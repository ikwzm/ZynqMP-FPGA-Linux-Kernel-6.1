diff --git a/Documentation/devicetree/bindings/perf/xilinx-apm.yaml b/Documentation/devicetree/bindings/perf/xilinx-apm.yaml
new file mode 100644
index 000000000..0b8ba96aa
--- /dev/null
+++ b/Documentation/devicetree/bindings/perf/xilinx-apm.yaml
@@ -0,0 +1,137 @@
+# SPDX-License-Identifier: GPL-2.0-or-later OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/perf/xilinx-apm.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Axi Performance Monitor device tree bindings
+
+maintainers:
+  - Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,axi-perf-monitor
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  xlnx,enable-profile:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1]
+    description:
+      Enables the profile mode.
+    maxItems: 1
+
+  xlnx,enable-trace:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1]
+    description:
+      Enables trace mode.
+    maxItems: 1
+
+  xlnx,num-monitor-slots:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - minimum: 1
+      - maximum: 8
+    description:
+      Number of monitor slots.
+
+  xlnx,enable-event-count:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1]
+    description:
+      Enable event count.
+
+  xlnx,enable-event-log:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1]
+    description:
+      Enable event log.
+
+  xlnx,have-sampled-metric-cnt:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Sampled metric counters enabled in APM.
+
+  xlnx,metric-count-width:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [32, 64]
+    description:
+      Metric Counter width.
+
+  xlnx,metric-count-scale:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [1, 2, 4, 8]
+    description:
+      Metric Counter scale factor.
+
+  xlnx,num-of-counters:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Number of counters in APM.
+
+  xlnx,metrics-sample-count-width:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [32, 64]
+    description:
+      Sampled metric counter width.
+
+  xlnx,global-count-width:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [32, 64]
+    description:
+      Global Clock counter width.
+
+  xlnx,id-filter-32bit:
+    description: APM is in 32-bit mode.
+    type: boolean
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - interrupts
+
+additionalProperties: false
+
+examples:
+  - |
+    apm@44a00000 {
+        compatible = "xlnx,axi-perf-monitor";
+        interrupt-parent = <&axi_intc_1>;
+        interrupts = <1 2>;
+        reg = <0x44a00000 0x1000>;
+        clocks = <&clkc 15>;
+        xlnx,enable-profile = <0>;
+        xlnx,enable-trace = <0>;
+        xlnx,num-monitor-slots = <4>;
+        xlnx,enable-event-count = <1>;
+        xlnx,enable-event-log = <1>;
+        xlnx,have-sampled-metric-cnt = <1>;
+        xlnx,num-of-counters = <8>;
+        xlnx,metric-count-width = <32>;
+        xlnx,metrics-sample-count-width = <32>;
+        xlnx,global-count-width = <32>;
+        xlnx,metric-count-scale = <1>;
+        xlnx,id-filter-32bit;
+    };
diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 2e16c5338..9f87046f6 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -2,6 +2,7 @@
 menuconfig UIO
 	tristate "Userspace I/O drivers"
 	depends on MMU
+	select DMA_SHARED_BUFFER
 	help
 	  Enable this to allow the userspace driver core code to be
 	  built.  This code allows userspace programs easy access to
@@ -166,6 +167,28 @@ config UIO_HV_GENERIC
 
 	  If you compile this as a module, it will be called uio_hv_generic.
 
+config UIO_XILINX_APM
+	tristate "Xilinx AXI Performance Monitor driver"
+	depends on MICROBLAZE || ARCH_ZYNQ || ARCH_ZYNQMP
+	help
+	  This driver is developed for AXI Performance Monitor IP, designed to
+	  monitor AXI4 traffic for performance analysis of AXI bus in the
+	  system. Driver maps HW registers and parameters to userspace.
+
+	  To compile this driver as a module, choose M here; the module
+	  will be called uio_xilinx_apm.
+
+config UIO_XILINX_AI_ENGINE
+	tristate "Xilinx AI Engine driver"
+	select IRQ_SIM
+	select UIO_DMEM_GENIRQ
+	select UIO_PDRV_GENIRQ
+	help
+	  The driver for Xilinx AI Engine that utilizes the uio_dmem_genirq.
+	  The userspace library will use this to interact with the AI Engine
+	  hardware, as well as for the memory allocation.
+	  Say 'y' only for platforms with the AI Engine IP.
+
 config UIO_DFL
 	tristate "Generic driver for DFL (Device Feature List) bus"
 	depends on FPGA_DFL
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index f2f416a14..af82e514b 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -1,4 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
+uio-y := uio_core.o uio_dmabuf.o
+
 obj-$(CONFIG_UIO)	+= uio.o
 obj-$(CONFIG_UIO_CIF)	+= uio_cif.o
 obj-$(CONFIG_UIO_PDRV_GENIRQ)	+= uio_pdrv_genirq.o
@@ -9,6 +11,8 @@ obj-$(CONFIG_UIO_PCI_GENERIC)	+= uio_pci_generic.o
 obj-$(CONFIG_UIO_NETX)	+= uio_netx.o
 obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
 obj-$(CONFIG_UIO_MF624)         += uio_mf624.o
+obj-$(CONFIG_UIO_XILINX_APM)	+= uio_xilinx_apm.o
 obj-$(CONFIG_UIO_FSL_ELBC_GPCM)	+= uio_fsl_elbc_gpcm.o
 obj-$(CONFIG_UIO_HV_GENERIC)	+= uio_hv_generic.o
+obj-$(CONFIG_UIO_XILINX_AI_ENGINE) += uio_xilinx_ai_engine.o
 obj-$(CONFIG_UIO_DFL)	+= uio_dfl.o
diff --git a/drivers/uio/uio.c b/drivers/uio/uio_core.c
similarity index 95%
rename from drivers/uio/uio.c
rename to drivers/uio/uio_core.c
index 43afbb7c5..e51a7e987 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio_core.c
@@ -24,6 +24,12 @@
 #include <linux/kobject.h>
 #include <linux/cdev.h>
 #include <linux/uio_driver.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+
+#include <uapi/linux/uio/uio.h>
+
+#include "uio_dmabuf.h"
 
 #define UIO_MAX_DEVICES		(1U << MINORBITS)
 
@@ -456,6 +462,8 @@ static irqreturn_t uio_interrupt(int irq, void *dev_id)
 struct uio_listener {
 	struct uio_device *dev;
 	s32 event_count;
+	struct list_head dbufs;
+	struct mutex dbufs_lock; /* protect @dbufs */
 };
 
 static int uio_open(struct inode *inode, struct file *filep)
@@ -502,6 +510,9 @@ static int uio_open(struct inode *inode, struct file *filep)
 	if (ret)
 		goto err_infoopen;
 
+	INIT_LIST_HEAD(&listener->dbufs);
+	mutex_init(&listener->dbufs_lock);
+
 	return 0;
 
 err_infoopen:
@@ -531,6 +542,10 @@ static int uio_release(struct inode *inode, struct file *filep)
 	struct uio_listener *listener = filep->private_data;
 	struct uio_device *idev = listener->dev;
 
+	ret = uio_dmabuf_cleanup(idev, &listener->dbufs, &listener->dbufs_lock);
+	if (ret)
+		dev_err(&idev->dev, "failed to clean up the dma bufs\n");
+
 	mutex_lock(&idev->info_lock);
 	if (idev->info && idev->info->release)
 		ret = idev->info->release(idev->info, inode);
@@ -654,6 +669,33 @@ static ssize_t uio_write(struct file *filep, const char __user *buf,
 	return retval ? retval : sizeof(s32);
 }
 
+static long uio_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
+{
+	struct uio_listener *listener = filep->private_data;
+	struct uio_device *idev = listener->dev;
+	long ret;
+
+	if (!idev->info)
+		return -EIO;
+
+	switch (cmd) {
+	case UIO_IOC_MAP_DMABUF:
+		ret = uio_dmabuf_map(idev, &listener->dbufs,
+				     &listener->dbufs_lock, (void __user *)arg);
+		break;
+	case UIO_IOC_UNMAP_DMABUF:
+		ret = uio_dmabuf_unmap(idev, &listener->dbufs,
+				       &listener->dbufs_lock,
+				       (void __user *)arg);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
 static int uio_find_mem_index(struct vm_area_struct *vma)
 {
 	struct uio_device *idev = vma->vm_private_data;
@@ -823,6 +865,7 @@ static const struct file_operations uio_fops = {
 	.write		= uio_write,
 	.mmap		= uio_mmap,
 	.poll		= uio_poll,
+	.unlocked_ioctl	= uio_ioctl,
 	.fasync		= uio_fasync,
 	.llseek		= noop_llseek,
 };
diff --git a/drivers/uio/uio_dmabuf.c b/drivers/uio/uio_dmabuf.c
new file mode 100644
index 000000000..b18f1469f
--- /dev/null
+++ b/drivers/uio/uio_dmabuf.c
@@ -0,0 +1,210 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Xilinx, Inc.
+ *
+ * Author: Hyun Woo Kwon <hyun.kwon@xilinx.com>
+ *
+ * DMA buf support for UIO device
+ *
+ */
+
+#include <linux/dma-buf.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/uio_driver.h>
+#include <linux/slab.h>
+
+#include <uapi/linux/uio/uio.h>
+
+#include "uio_dmabuf.h"
+
+struct uio_dmabuf_mem {
+	int dbuf_fd;
+	struct dma_buf *dbuf;
+	struct dma_buf_attachment *dbuf_attach;
+	struct sg_table *sgt;
+	enum dma_data_direction dir;
+	struct list_head list;
+};
+
+long uio_dmabuf_map(struct uio_device *dev, struct list_head *dbufs,
+		    struct mutex *dbufs_lock, void __user *user_args)
+{
+	struct uio_dmabuf_args args;
+	struct uio_dmabuf_mem *dbuf_mem;
+	struct dma_buf *dbuf;
+	struct dma_buf_attachment *dbuf_attach;
+	enum dma_data_direction dir;
+	struct sg_table *sgt;
+	long ret;
+
+	if (copy_from_user(&args, user_args, sizeof(args))) {
+		ret = -EFAULT;
+		dev_err(dev->dev.parent, "failed to copy from user\n");
+		goto err;
+	}
+
+	dbuf = dma_buf_get(args.dbuf_fd);
+	if (IS_ERR(dbuf)) {
+		dev_err(dev->dev.parent, "failed to get dmabuf\n");
+		return PTR_ERR(dbuf);
+	}
+
+	dbuf_attach = dma_buf_attach(dbuf, dev->dev.parent);
+	if (IS_ERR(dbuf_attach)) {
+		dev_err(dev->dev.parent, "failed to attach dmabuf\n");
+		ret = PTR_ERR(dbuf_attach);
+		goto err_put;
+	}
+
+	switch (args.dir) {
+	case UIO_DMABUF_DIR_BIDIR:
+		dir = DMA_BIDIRECTIONAL;
+		break;
+	case UIO_DMABUF_DIR_TO_DEV:
+		dir = DMA_TO_DEVICE;
+		break;
+	case UIO_DMABUF_DIR_FROM_DEV:
+		dir = DMA_FROM_DEVICE;
+		break;
+	default:
+		/* Not needed with check. Just here for any future change  */
+		dev_err(dev->dev.parent, "invalid direction\n");
+		ret = -EINVAL;
+		goto err_detach;
+	}
+
+	sgt = dma_buf_map_attachment(dbuf_attach, dir);
+	if (IS_ERR(sgt)) {
+		dev_err(dev->dev.parent, "failed to get dmabuf scatterlist\n");
+		ret = PTR_ERR(sgt);
+		goto err_detach;
+	}
+
+	/* Accept only contiguous one */
+	if (sgt->nents != 1) {
+		dma_addr_t next_addr = sg_dma_address(sgt->sgl);
+		struct scatterlist *s;
+		unsigned int i;
+
+		for_each_sg(sgt->sgl, s, sgt->nents, i) {
+			if (!sg_dma_len(s))
+				continue;
+
+			if (sg_dma_address(s) != next_addr) {
+				dev_err(dev->dev.parent,
+					"dmabuf not contiguous\n");
+				ret = -EINVAL;
+				goto err_unmap;
+			}
+
+			next_addr = sg_dma_address(s) + sg_dma_len(s);
+		}
+	}
+
+	dbuf_mem = kzalloc(sizeof(*dbuf_mem), GFP_KERNEL);
+	if (!dbuf_mem) {
+		ret = -ENOMEM;
+		goto err_unmap;
+	}
+
+	dbuf_mem->dbuf_fd = args.dbuf_fd;
+	dbuf_mem->dbuf = dbuf;
+	dbuf_mem->dbuf_attach = dbuf_attach;
+	dbuf_mem->sgt = sgt;
+	dbuf_mem->dir = dir;
+	args.dma_addr = sg_dma_address(sgt->sgl);
+	args.size = dbuf->size;
+
+	if (copy_to_user(user_args, &args, sizeof(args))) {
+		ret = -EFAULT;
+		dev_err(dev->dev.parent, "failed to copy to user\n");
+		goto err_free;
+	}
+
+	mutex_lock(dbufs_lock);
+	list_add(&dbuf_mem->list, dbufs);
+	mutex_unlock(dbufs_lock);
+
+	return 0;
+
+err_free:
+	kfree(dbuf_mem);
+err_unmap:
+	dma_buf_unmap_attachment(dbuf_attach, sgt, dir);
+err_detach:
+	dma_buf_detach(dbuf, dbuf_attach);
+err_put:
+	dma_buf_put(dbuf);
+err:
+	return ret;
+}
+
+long uio_dmabuf_unmap(struct uio_device *dev, struct list_head *dbufs,
+		      struct mutex *dbufs_lock, void __user *user_args)
+
+{
+	struct uio_dmabuf_args args;
+	struct uio_dmabuf_mem *dbuf_mem;
+	long ret;
+
+	if (copy_from_user(&args, user_args, sizeof(args))) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	mutex_lock(dbufs_lock);
+	list_for_each_entry(dbuf_mem, dbufs, list) {
+		if (dbuf_mem->dbuf_fd == args.dbuf_fd)
+			break;
+	}
+
+	if (dbuf_mem->dbuf_fd != args.dbuf_fd) {
+		dev_err(dev->dev.parent, "failed to find the dmabuf (%d)\n",
+			args.dbuf_fd);
+		ret = -EINVAL;
+		goto err_unlock;
+	}
+	list_del(&dbuf_mem->list);
+	mutex_unlock(dbufs_lock);
+
+	dma_buf_unmap_attachment(dbuf_mem->dbuf_attach, dbuf_mem->sgt,
+				 dbuf_mem->dir);
+	dma_buf_detach(dbuf_mem->dbuf, dbuf_mem->dbuf_attach);
+	dma_buf_put(dbuf_mem->dbuf);
+	kfree(dbuf_mem);
+
+	memset(&args, 0x0, sizeof(args));
+
+	if (copy_to_user(user_args, &args, sizeof(args))) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	return 0;
+
+err_unlock:
+	mutex_unlock(dbufs_lock);
+err:
+	return ret;
+}
+
+int uio_dmabuf_cleanup(struct uio_device *dev, struct list_head *dbufs,
+		       struct mutex *dbufs_lock)
+{
+	struct uio_dmabuf_mem *dbuf_mem, *next;
+
+	mutex_lock(dbufs_lock);
+	list_for_each_entry_safe(dbuf_mem, next, dbufs, list) {
+		list_del(&dbuf_mem->list);
+		dma_buf_unmap_attachment(dbuf_mem->dbuf_attach, dbuf_mem->sgt,
+					 dbuf_mem->dir);
+		dma_buf_detach(dbuf_mem->dbuf, dbuf_mem->dbuf_attach);
+		dma_buf_put(dbuf_mem->dbuf);
+		kfree(dbuf_mem);
+	}
+	mutex_unlock(dbufs_lock);
+
+	return 0;
+}
diff --git a/drivers/uio/uio_dmabuf.h b/drivers/uio/uio_dmabuf.h
new file mode 100644
index 000000000..30200306d
--- /dev/null
+++ b/drivers/uio/uio_dmabuf.h
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 Xilinx, Inc.
+ *
+ * Author: Hyun Woo Kwon <hyun.kwon@xilinx.com>
+ *
+ * DMA buf support for UIO device
+ *
+ */
+
+#ifndef _UIO_DMABUF_H_
+#define _UIO_DMABUF_H_
+
+struct uio_device;
+struct list_head;
+struct mutex;
+
+long uio_dmabuf_map(struct uio_device *dev, struct list_head *dbufs,
+		    struct mutex *dbufs_lock, void __user *user_args);
+long uio_dmabuf_unmap(struct uio_device *dev, struct list_head *dbufs,
+		      struct mutex *dbufs_lock, void __user *user_args);
+
+int uio_dmabuf_cleanup(struct uio_device *dev, struct list_head *dbufs,
+		       struct mutex *dbufs_lock);
+
+#endif
diff --git a/drivers/uio/uio_xilinx_ai_engine.c b/drivers/uio/uio_xilinx_ai_engine.c
new file mode 100644
index 000000000..8af59abb0
--- /dev/null
+++ b/drivers/uio/uio_xilinx_ai_engine.c
@@ -0,0 +1,302 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx UIO driver for AI Engine
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Author: Hyun Woo Kwon <hyun.kwon@xilinx.com>
+ */
+
+#include <linux/debugfs.h>
+#include <linux/irq_sim.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_data/uio_dmem_genirq.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+
+#define DRIVER_NAME "xilinx-aiengine"
+#define XILINX_AI_ENGINE_MAX_IRQ	4
+
+static uint xilinx_ai_engine_mem_cnt = 1;
+module_param_named(mem_cnt, xilinx_ai_engine_mem_cnt, uint, 0444);
+MODULE_PARM_DESC(mem_cnt, "Dynamic memory allocation count (default: 1)");
+
+static uint xilinx_ai_engine_mem_size = 32 * 1024 * 1024;
+module_param_named(mem_size, xilinx_ai_engine_mem_size, uint, 0444);
+MODULE_PARM_DESC(mem_size,
+		 "Dynamic memory allocation size in bytes (default: 32 MB)");
+
+#ifdef CONFIG_DEBUG_FS
+
+static ssize_t xilinx_ai_engine_debugfs_write(struct file *f,
+					      const char __user *buf,
+					      size_t size, loff_t *pos)
+{
+	struct irq_domain *irq_sim_domain = file_inode(f)->i_private;
+	int irq, ret;
+
+	irq = irq_find_mapping(irq_sim_domain, 1);
+	ret = irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true);
+	if (ret)
+		return ret;
+
+	return size;
+}
+
+static const struct file_operations debugfs_ops = {
+	.owner = THIS_MODULE,
+	.write = xilinx_ai_engine_debugfs_write,
+};
+
+/**
+ * xilinx_ai_engine_debugfs_init - Initialize the debugfs for irq sim
+ * @pdev: platform device to simulate irq for
+ * @irq_sim_domain: simualated irq
+ *
+ * Initialize the debugfs for irq simulation. This allows to generate
+ * the simulated interrupt from user.
+ *
+ * Return: 0 for success, error code otherwise.
+ */
+static int xilinx_ai_engine_debugfs_init(struct platform_device *pdev,
+					 struct irq_domain *irq_sim_domain)
+{
+	int ret;
+	struct dentry *debugfs_dir, *debugfs_file;
+
+	debugfs_dir = debugfs_create_dir("xilinx-ai-engine", NULL);
+	if (!debugfs_dir)
+		return -ENODEV;
+
+	debugfs_file = debugfs_create_file(dev_name(&pdev->dev), 0644,
+					   debugfs_dir, irq_sim_domain,
+					   &debugfs_ops);
+	if (!debugfs_file) {
+		ret = -ENODEV;
+		goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	debugfs_remove_recursive(debugfs_dir);
+	return ret;
+}
+
+/**
+ * xilinx_ai_engine_simulate_irq - Simulate the irq
+ * @pdev: platform device to simulate irq for
+ *
+ * Simulate the irq so the irq can be generated from user. This is only for
+ * debugging purpose.
+ *
+ * Return: irq number for success, negative for error code.
+ */
+static int xilinx_ai_engine_simulate_irq(struct platform_device *pdev)
+{
+	struct irq_domain *irq_sim_domain;
+	int ret;
+
+	/*
+	 * Sometimes, the returned base value is 0, so allocate 2 irqs, and
+	 * always use the 2nd one.
+	 */
+	irq_sim_domain = devm_irq_domain_create_sim(&pdev->dev, NULL, 2);
+	if (IS_ERR(irq_sim_domain)) {
+		ret = PTR_ERR(irq_sim_domain);
+		dev_err(&pdev->dev, "failed to create irq simulation domain");
+		return ret;
+	}
+
+	ret = xilinx_ai_engine_debugfs_init(pdev, irq_sim_domain);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed create debugfs for sim irq");
+
+		return  ret;
+	}
+
+	/* always use second interrupt */
+	return irq_create_mapping(irq_sim_domain, 1);
+}
+
+#else
+
+static int xilinx_ai_engine_simulate_irq(struct platform_device *pdev)
+{
+	return -ENODEV;
+}
+
+#endif
+
+static int xilinx_ai_engine_mem_index(struct uio_info *info,
+				      struct vm_area_struct *vma)
+{
+	if (vma->vm_pgoff < MAX_UIO_MAPS) {
+		if (info->mem[vma->vm_pgoff].size == 0)
+			return -1;
+		return (int)vma->vm_pgoff;
+	}
+	return -1;
+}
+
+static const struct vm_operations_struct xilinx_ai_engine_vm_ops = {
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+	.access = generic_access_phys,
+#endif
+};
+
+static int xilinx_ai_engine_mmap(struct uio_info *info,
+				 struct vm_area_struct *vma)
+{
+	int mi = xilinx_ai_engine_mem_index(info, vma);
+	struct uio_mem *mem;
+
+	if (mi < 0)
+		return -EINVAL;
+	mem = info->mem + mi;
+
+	if (mem->addr & ~PAGE_MASK)
+		return -ENODEV;
+	if (vma->vm_end - vma->vm_start > mem->size)
+		return -EINVAL;
+
+	vma->vm_ops = &xilinx_ai_engine_vm_ops;
+	/*
+	 * Make the dynamic memory mapping as write-combined. Only first one
+	 * will be the mmio region, which will be mapped as noncached.
+	 */
+	if (mi < 1)
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	else
+		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	/*
+	 * We cannot use the vm_iomap_memory() helper here,
+	 * because vma->vm_pgoff is the map index we looked
+	 * up above in uio_find_mem_index(), rather than an
+	 * actual page offset into the mmap.
+	 *
+	 * So we just do the physical mmap without a page
+	 * offset.
+	 */
+	return remap_pfn_range(vma,
+			       vma->vm_start,
+			       mem->addr >> PAGE_SHIFT,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot);
+}
+
+static int xilinx_ai_engine_probe(struct platform_device *pdev)
+{
+	struct platform_device *uio;
+	struct uio_dmem_genirq_pdata *pdata;
+	unsigned int i;
+	static const char * const interrupt_names[] = { "interrupt0",
+							"interrupt1",
+							"interrupt2",
+							"interrupt3" };
+	int ret;
+
+	uio = platform_device_alloc(DRIVER_NAME, PLATFORM_DEVID_NONE);
+	if (!uio)
+		return -ENOMEM;
+	uio->driver_override = "uio_dmem_genirq";
+	uio->dev.parent = &pdev->dev;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		ret = -ENOMEM;
+		goto err_out;
+	}
+
+	pdata->num_dynamic_regions = xilinx_ai_engine_mem_cnt;
+	pdata->dynamic_region_sizes = &xilinx_ai_engine_mem_size;
+	pdata->uioinfo.name = DRIVER_NAME;
+	pdata->uioinfo.version = "devicetree";
+	pdata->uioinfo.mmap = xilinx_ai_engine_mmap;
+	/* Set the offset value as it's map index for each memory */
+	for (i = 0; i < MAX_UIO_MAPS; i++)
+		pdata->uioinfo.mem[i].offs = i << PAGE_SHIFT;
+
+	/* TODO: Only one interrupt is supported out of 4 */
+	for (i  = 0; i < XILINX_AI_ENGINE_MAX_IRQ; i++) {
+		ret = platform_get_irq_byname(pdev, interrupt_names[i]);
+		if (ret >= 0) {
+			dev_info(&pdev->dev, "%s is used", interrupt_names[i]);
+			break;
+		}
+	}
+
+	/* Interrupt is optional */
+	if (ret < 0) {
+		ret = xilinx_ai_engine_simulate_irq(pdev);
+		if (ret < 0)
+			ret = UIO_IRQ_CUSTOM;
+	}
+	pdata->uioinfo.irq = ret;
+
+	ret = platform_device_add_data(uio, pdata, sizeof(*pdata));
+	if (ret)
+		goto err_out;
+
+	/* Mirror the parent device resource to uio device */
+	ret = platform_device_add_resources(uio, pdev->resource,
+					    pdev->num_resources);
+	if (ret)
+		goto err_out;
+
+	/* Configure the dma for uio device using the parent of_node */
+	uio->dev.bus = &platform_bus_type;
+	ret = of_dma_configure(&uio->dev, of_node_get(pdev->dev.of_node), true);
+	of_node_put(pdev->dev.of_node);
+	if (ret)
+		goto err_out;
+
+	ret = platform_device_add(uio);
+	if (ret)
+		goto err_out;
+	platform_set_drvdata(uio, pdata);
+	platform_set_drvdata(pdev, uio);
+
+	dev_info(&pdev->dev, "Xilinx AI Engine UIO driver probed");
+	return 0;
+
+err_out:
+	platform_device_put(uio);
+	dev_err(&pdev->dev,
+		"failed to probe Xilinx AI Engine UIO driver");
+	return ret;
+}
+
+static int xilinx_ai_engine_remove(struct platform_device *pdev)
+{
+	struct platform_device *uio = platform_get_drvdata(pdev);
+
+	platform_device_unregister(uio);
+	of_node_put(pdev->dev.of_node);
+
+	return 0;
+}
+
+static const struct of_device_id xilinx_ai_engine_of_match[] = {
+	{ .compatible = "xlnx,ai_engine", },
+	{ /* end of table */ },
+};
+MODULE_DEVICE_TABLE(of, xilinx_ai_engine_of_match);
+
+static struct platform_driver xilinx_ai_engine_driver = {
+	.probe			= xilinx_ai_engine_probe,
+	.remove			= xilinx_ai_engine_remove,
+	.driver			= {
+		.name		= DRIVER_NAME,
+		.of_match_table	= xilinx_ai_engine_of_match,
+	},
+};
+
+module_platform_driver(xilinx_ai_engine_driver);
+
+MODULE_AUTHOR("Xilinx, Inc.");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/uio/uio_xilinx_apm.c b/drivers/uio/uio_xilinx_apm.c
new file mode 100644
index 000000000..e8d289fd2
--- /dev/null
+++ b/drivers/uio/uio_xilinx_apm.c
@@ -0,0 +1,358 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx AXI Performance Monitor
+ *
+ * Copyright (C) 2013 - 2019 Xilinx, Inc. All rights reserved.
+ *
+ * Description:
+ * This driver is developed for AXI Performance Monitor IP,
+ * designed to monitor AXI4 traffic for performance analysis
+ * of AXI bus in the system. Driver maps HW registers and parameters
+ * to userspace. Userspace need not clear the interrupt of IP since
+ * driver clears the interrupt.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/uio_driver.h>
+
+#define XAPM_IS_OFFSET		0x0038  /* Interrupt Status Register */
+#define DRV_NAME		"xilinxapm_uio"
+#define DRV_VERSION		"1.0"
+#define UIO_DUMMY_MEMSIZE	4096
+#define XAPM_MODE_ADVANCED	1
+#define XAPM_MODE_PROFILE	2
+#define XAPM_MODE_TRACE		3
+
+/**
+ * struct xapm_param - HW parameters structure
+ * @mode: Mode in which APM is working
+ * @maxslots: Maximum number of Slots in APM
+ * @eventcnt: Event counting enabled in APM
+ * @eventlog: Event logging enabled in APM
+ * @sampledcnt: Sampled metric counters enabled in APM
+ * @numcounters: Number of counters in APM
+ * @metricwidth: Metric Counter width (32/64)
+ * @sampledwidth: Sampled metric counter width
+ * @globalcntwidth: Global Clock counter width
+ * @scalefactor: Scaling factor
+ * @isr: Interrupts info shared to userspace
+ * @is_32bit_filter: Flags for 32bit filter
+ * @clk: Clock handle
+ */
+struct xapm_param {
+	u32 mode;
+	u32 maxslots;
+	u32 eventcnt;
+	u32 eventlog;
+	u32 sampledcnt;
+	u32 numcounters;
+	u32 metricwidth;
+	u32 sampledwidth;
+	u32 globalcntwidth;
+	u32 scalefactor;
+	u32 isr;
+	bool is_32bit_filter;
+	struct clk *clk;
+};
+
+/**
+ * struct xapm_dev - Global driver structure
+ * @info: uio_info structure
+ * @param: xapm_param structure
+ * @regs: IOmapped base address
+ */
+struct xapm_dev {
+	struct uio_info info;
+	struct xapm_param param;
+	void __iomem *regs;
+};
+
+/**
+ * xapm_handler - Interrupt handler for APM
+ * @irq: IRQ number
+ * @info: Pointer to uio_info structure
+ *
+ * Return: Always returns IRQ_HANDLED
+ */
+static irqreturn_t xapm_handler(int irq, struct uio_info *info)
+{
+	struct xapm_dev *xapm = (struct xapm_dev *)info->priv;
+	void *ptr;
+
+	ptr = (unsigned long *)xapm->info.mem[1].addr;
+	/* Clear the interrupt and copy the ISR value to userspace */
+	xapm->param.isr = readl(xapm->regs + XAPM_IS_OFFSET);
+	writel(xapm->param.isr, xapm->regs + XAPM_IS_OFFSET);
+	memcpy(ptr, &xapm->param, sizeof(struct xapm_param));
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xapm_getprop - Retrieves dts properties to param structure
+ * @pdev: Pointer to platform device
+ * @param: Pointer to param structure
+ *
+ * Returns: '0' on success and failure value on error
+ */
+static int xapm_getprop(struct platform_device *pdev, struct xapm_param *param)
+{
+	u32 mode = 0;
+	int ret;
+	struct device_node *node;
+
+	node = pdev->dev.of_node;
+
+	/* Retrieve required dts properties and fill param structure */
+	ret = of_property_read_u32(node, "xlnx,enable-profile", &mode);
+	if (ret < 0)
+		dev_info(&pdev->dev, "no property xlnx,enable-profile\n");
+	else if (mode)
+		param->mode = XAPM_MODE_PROFILE;
+
+	ret = of_property_read_u32(node, "xlnx,enable-trace", &mode);
+	if (ret < 0)
+		dev_info(&pdev->dev, "no property xlnx,enable-trace\n");
+	else if (mode)
+		param->mode = XAPM_MODE_TRACE;
+
+	ret = of_property_read_u32(node, "xlnx,num-monitor-slots",
+				   &param->maxslots);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,num-monitor-slots");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,enable-event-count",
+				   &param->eventcnt);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,enable-event-count");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,enable-event-log",
+				   &param->eventlog);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,enable-event-log");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,have-sampled-metric-cnt",
+				   &param->sampledcnt);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,have-sampled-metric-cnt");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,num-of-counters",
+				   &param->numcounters);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,num-of-counters");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,metric-count-width",
+				   &param->metricwidth);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,metric-count-width");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,metrics-sample-count-width",
+				   &param->sampledwidth);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property metrics-sample-count-width");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,global-count-width",
+				   &param->globalcntwidth);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,global-count-width");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,metric-count-scale",
+				   &param->scalefactor);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "no property xlnx,metric-count-scale");
+		return ret;
+	}
+
+	param->is_32bit_filter = of_property_read_bool(node,
+						"xlnx,id-filter-32bit");
+
+	return 0;
+}
+
+/**
+ * xapm_probe - Driver probe function
+ * @pdev: Pointer to the platform_device structure
+ *
+ * Returns: '0' on success and failure value on error
+ */
+
+static int xapm_probe(struct platform_device *pdev)
+{
+	struct xapm_dev *xapm;
+	struct resource *res;
+	int irq;
+	int ret;
+	void *ptr;
+
+	xapm = devm_kzalloc(&pdev->dev, (sizeof(struct xapm_dev)), GFP_KERNEL);
+	if (!xapm)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xapm->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(xapm->regs)) {
+		dev_err(&pdev->dev, "unable to iomap registers\n");
+		return PTR_ERR(xapm->regs);
+	}
+
+	xapm->param.clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(xapm->param.clk)) {
+		if (PTR_ERR(xapm->param.clk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "axi clock error\n");
+		return PTR_ERR(xapm->param.clk);
+	}
+
+	ret = clk_prepare_enable(xapm->param.clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to enable clock.\n");
+		return ret;
+	}
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	/* Initialize mode as Advanced so that if no mode in dts, default
+	 * is Advanced
+	 */
+	xapm->param.mode = XAPM_MODE_ADVANCED;
+	ret = xapm_getprop(pdev, &xapm->param);
+	if (ret < 0)
+		goto err_clk_dis;
+
+	xapm->info.mem[0].name = "xilinx_apm";
+	xapm->info.mem[0].addr = res->start;
+	xapm->info.mem[0].size = resource_size(res);
+	xapm->info.mem[0].memtype = UIO_MEM_PHYS;
+
+	xapm->info.mem[1].addr = (unsigned long)kzalloc(UIO_DUMMY_MEMSIZE,
+							GFP_KERNEL);
+	ptr = (unsigned long *)xapm->info.mem[1].addr;
+	xapm->info.mem[1].size = UIO_DUMMY_MEMSIZE;
+	xapm->info.mem[1].memtype = UIO_MEM_LOGICAL;
+
+	xapm->info.name = "axi-pmon";
+	xapm->info.version = DRV_VERSION;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "unable to get irq\n");
+		ret = irq;
+		goto err_clk_dis;
+	}
+
+	xapm->info.irq = irq;
+	xapm->info.handler = xapm_handler;
+	xapm->info.priv = xapm;
+	xapm->info.irq_flags = IRQF_SHARED;
+
+	memcpy(ptr, &xapm->param, sizeof(struct xapm_param));
+
+	ret = uio_register_device(&pdev->dev, &xapm->info);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to register to UIO\n");
+		goto err_clk_dis;
+	}
+
+	platform_set_drvdata(pdev, xapm);
+
+	dev_info(&pdev->dev, "Probed Xilinx APM\n");
+
+	return 0;
+
+err_clk_dis:
+	clk_disable_unprepare(xapm->param.clk);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	return ret;
+}
+
+/**
+ * xapm_remove - Driver remove function
+ * @pdev: Pointer to the platform_device structure
+ *
+ * Return: Always returns '0'
+ */
+static int xapm_remove(struct platform_device *pdev)
+{
+	struct xapm_dev *xapm = platform_get_drvdata(pdev);
+
+	uio_unregister_device(&xapm->info);
+	clk_disable_unprepare(xapm->param.clk);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+
+	return 0;
+}
+
+static int __maybe_unused xapm_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xapm_dev *xapm = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(xapm->param.clk);
+	return 0;
+};
+
+static int __maybe_unused xapm_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xapm_dev *xapm = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = clk_prepare_enable(xapm->param.clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to enable clock.\n");
+		return ret;
+	}
+	return 0;
+};
+
+static const struct dev_pm_ops xapm_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xapm_runtime_suspend, xapm_runtime_resume)
+	SET_RUNTIME_PM_OPS(xapm_runtime_suspend,
+			   xapm_runtime_resume, NULL)
+};
+
+static const struct of_device_id xapm_of_match[] = {
+	{ .compatible = "xlnx,axi-perf-monitor", },
+	{ /* end of table*/ }
+};
+
+MODULE_DEVICE_TABLE(of, xapm_of_match);
+
+static struct platform_driver xapm_driver = {
+	.driver = {
+		.name = "xilinx-axipmon",
+		.of_match_table = xapm_of_match,
+		.pm = &xapm_dev_pm_ops,
+	},
+	.probe = xapm_probe,
+	.remove = xapm_remove,
+};
+
+module_platform_driver(xapm_driver);
+
+MODULE_AUTHOR("Xilinx Inc.");
+MODULE_DESCRIPTION("Xilinx AXI Performance Monitor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/uapi/linux/uio/uio.h b/include/uapi/linux/uio/uio.h
new file mode 100644
index 000000000..db92d311c
--- /dev/null
+++ b/include/uapi/linux/uio/uio.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * The header for UIO driver
+ *
+ * Copyright (C) 2019 Xilinx, Inc.
+ *
+ * Author: Hyun Woo Kwon <hyun.kwon@xilinx.com>
+ */
+
+#ifndef _UAPI_UIO_UIO_H_
+#define _UAPI_UIO_UIO_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/**
+ * enum uio_dmabuf_dir - list of dma directions for mapping management
+ * @UIO_DMABUF_DIR_BIDIR: Bidirectional DMA. To and from device
+ * @UIO_DMABUF_DIR_TO_DEV: DMA to device
+ * @UIO_DMABUF_DIR_FROM_DEV: DMA from device
+ * @UIO_DMABUF_DIR_NONE: Direction not specified
+ */
+enum uio_dmabuf_dir {
+	UIO_DMABUF_DIR_BIDIR	= 1,
+	UIO_DMABUF_DIR_TO_DEV	= 2,
+	UIO_DMABUF_DIR_FROM_DEV	= 3,
+	UIO_DMABUF_DIR_NONE	= 4,
+};
+
+/**
+ * struct uio_dmabuf_args - arguments from userspace to map / unmap dmabuf
+ * @dbuf_fd: The fd or dma buf
+ * @dma_addr: The dma address of dmabuf @dbuf_fd
+ * @size: The size of dmabuf @dbuf_fd
+ * @dir: direction of dma transfer of dmabuf @dbuf_fd
+ */
+struct uio_dmabuf_args {
+	__s32	dbuf_fd;
+	__u64	dma_addr;
+	__u64	size;
+	__u8	dir;
+};
+
+#define UIO_IOC_BASE		'U'
+
+/**
+ * DOC: UIO_IOC_MAP_DMABUF - Map the dma buf to userspace uio application
+ *
+ * This takes uio_dmabuf_args, and maps the given dmabuf @dbuf_fd and returns
+ * information to userspace.
+ * FIXME: This is experimental and may change at any time. Don't consider this
+ * as stable ABI.
+ */
+#define	UIO_IOC_MAP_DMABUF	_IOWR(UIO_IOC_BASE, 0x1, struct uio_dmabuf_args)
+
+/**
+ * DOC: UIO_IOC_UNMAP_DMABUF - Unmap the dma buf
+ *
+ * This takes uio_dmabuf_args, and unmaps the previous mapped dmabuf @dbuf_fd.
+ * FIXME: This is experimental and may change at any time. Don't consider this
+ * as stable ABI.
+ */
+#define	UIO_IOC_UNMAP_DMABUF	_IOWR(UIO_IOC_BASE, 0x2, struct uio_dmabuf_args)
+
+#endif
