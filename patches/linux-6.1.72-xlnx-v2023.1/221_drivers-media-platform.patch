diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,axis-broadcaster.yaml b/Documentation/devicetree/bindings/media/xilinx/xlnx,axis-broadcaster.yaml
new file mode 100644
index 000000000..08731ce6c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,axis-broadcaster.yaml
@@ -0,0 +1,179 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/xilinx/xlnx,axis-broadcaster.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx AXI4-Stream Broadcaster
+
+maintainers:
+  - Ronak Shah <ronak.shah@xilinx.com>
+
+description: |
+  The AXI4-Stream Broadcaster provides a solution for replicating a single
+  inbound AXI4-Stream interface into multiple outbound AXI4-Stream interfaces.
+  Support for up to 16 outbound AXI4-Stream interfaces is provided.
+  For more details, Please refer to PG085 AXI4-Stream Infrastructure IP Suite.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,axis-broadcaster-1.1
+
+  # See ./video-interfaces.txt for details
+  ports:
+    type: object
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: |
+          Input/sink port node, describing module connected to the
+          input of AXI4-Stream Broadcaster.
+
+        properties:
+          reg:
+            description: |
+              Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    patternProperties:
+      "^port@([1-9]|1[0-6])$":
+        type: object
+        description: |
+          Output/source port node, describing module connected to the
+          output of AXI4-Stream Broadcaster.
+
+        properties:
+          reg:
+            description: |
+              Output/source port number. It can have min 2 ports and
+              max 16 ports, numbered from 1 to 16.
+            items:
+              minimum: 1
+              maximum: 16
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+      - port@2
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    axis_broadcaster_0 {
+        compatible = "xlnx,axis-broadcaster-1.1";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                axis_broad_0_in: endpoint {
+                    remote-endpoint = <&v_proc_ss_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                axis_broad_0_out1: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_0_in>;
+                };
+            };
+            port@2 {
+                /* Source port */
+                reg = <2>;
+                axis_broad_0_out2: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_1_in>;
+                };
+            };
+            port@3 {
+                /* Source port */
+                reg = <3>;
+                axis_broad_0_out3: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_2_in>;
+                };
+            };
+            port@4 {
+                /* Source port */
+                reg = <4>;
+                axis_broad_0_out4: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_3_in>;
+                };
+            };
+            port@5 {
+                /* Source port */
+                reg = <5>;
+                axis_broad_0_out5: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_4_in>;
+                };
+            };
+            port@6 {
+                /* Source port */
+                reg = <6>;
+                axis_broad_0_out6: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_5_in>;
+                };
+            };
+            port@7 {
+                /* Source port */
+                reg = <7>;
+                axis_broad_0_out7: endpoint {
+                    remote-endpoint = <&v_frmbuf_wr_6_in>;
+                };
+            };
+        };
+    };
+...
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,axis-subsetconv.yaml b/Documentation/devicetree/bindings/media/xilinx/xlnx,axis-subsetconv.yaml
new file mode 100644
index 000000000..3373a4626
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,axis-subsetconv.yaml
@@ -0,0 +1,133 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/xilinx/xlnx,axis-subsetconv.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Subset Converter
+
+maintainers:
+  - Anil Kumar Mamidala <anil.mamidala@xilinx.com>
+  - Karthikeyan T <karthikeyan.thangavel@xilinx.com>
+
+description: |
+    This subset converter driver is for the Xilinx subset converter
+    IP which is a non-memory mapped IP used for converting formats.
+    The format conversion of source pad and sink pad in the pipeline
+    done by subset converter IP will be mapped in this driver.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,axis-subsetconv-1.1
+
+  # See ./video-interfaces.txt for details
+  ports:
+    type: object
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: |
+          Input/sink port node, describing module connected to the
+          input of AXI4-Stream Subset Converter.
+
+        properties:
+          reg:
+            description: |
+              Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    patternProperties:
+      "port@1":
+        type: object
+        description: |
+          Output/source port node, describing module connected to the
+          output.
+
+        properties:
+          reg:
+            description: |
+              Output/source port number.
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+   axis_subsetconv_0 {
+        compatible = "xlnx,axis-subsetconv-1.1";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                subset_conv_in: endpoint {
+                    remote-endpoint = <&isp_csiss_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                subset_conv_out: endpoint {
+                    remote-endpoint = <&isp_vcap_csi_in>;
+                };
+            };
+        };
+    };
+...
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,csi2rxss.yaml b/Documentation/devicetree/bindings/media/xilinx/xlnx,csi2rxss.yaml
index 7d77823db..bad38fd68 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,csi2rxss.yaml
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,csi2rxss.yaml
@@ -50,6 +50,7 @@ properties:
       Packets other than this data type (except for RAW8 and
       User defined data types) will be filtered out.
       Possible values are as below -
+      0x18 - YUV4208B
       0x1e - YUV4228B
       0x1f - YUV42210B
       0x20 - RGB444
@@ -67,6 +68,7 @@ properties:
       0x2f - RAW20
     $ref: /schemas/types.yaml#/definitions/uint32
     oneOf:
+      - const: 0x18
       - minimum: 0x1e
         maximum: 0x24
       - minimum: 0x28
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,isppipeline.yaml b/Documentation/devicetree/bindings/media/xilinx/xlnx,isppipeline.yaml
new file mode 100644
index 000000000..de662be01
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,isppipeline.yaml
@@ -0,0 +1,202 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/xilinx/xlnx,isppipeline.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Video ISP Pipeline IP
+
+maintainers:
+  - Kaushal Kumar <kaushal.kumar@amd.com>
+  - Venkat Praveen Kancharlapalli <venkat.praveen.kancharlapalli@amd.com>
+
+description: |
+    The Xilinx Video ISP pipeline IP is used to interface to a bayer video source.
+    It is a pipeline of image processing functions, such as black level correction, bad pixel correction,
+    gain control, auto-white balance, gamma correction etc., processing the raw video from the sensor.
+    Gamma_lut array values are computed using compute_gamma function whose link is mentioned below:
+    https://github.com/Xilinx/Vitis_Libraries/blob/de67b58ca9c7f4a76411103c0ecf9d467731b476/vision/L1/examples/isppipeline/xf_isp_tb.cpp#L313
+    Link to product guide for ISP pipeline is mentioned below:
+    https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/overview.html_3_8
+
+properties:
+  compatible:
+    const: xlnx,isppipeline-1.0
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+    description: Reference to the AXI Streaming clock.
+
+  clock-names:
+    items:
+      - const: ap_clk
+
+  xlnx,max-height:
+    $ref: /schemas/types.yaml#/definitions/uint16
+    description: Maximum number of lines.
+    minimum: 64
+    maximum: 4320
+
+  xlnx,max-width:
+    $ref: /schemas/types.yaml#/definitions/uint16
+    description: Maximum number of pixels in a line.
+    minimum: 64
+    maximum: 8192
+
+  xlnx,rgain:
+    $ref: /schemas/types.yaml#/definitions/uint16
+    description: To configure gain value for the red channel.
+    minimum: 0
+    maximum: 65535
+
+  xlnx,bgain:
+    $ref: /schemas/types.yaml#/definitions/uint16
+    description: To configure gain value for the blue channel.
+    minimum: 0
+    maximum: 65535
+
+  xlnx,pawb:
+    $ref: /schemas/types.yaml#/definitions/uint16
+    description: |
+        It is used in calculating the threshold value, which is used in gray world
+        white balance method to compute average pixel values below the threshold value.
+    minimum: 0
+    maximum: 65535
+
+  xlnx,mode-reg:
+    type: boolean
+    description: Flag to enable/disable AWB algorithm
+
+  reset-gpios:
+    maxItems: 1
+    description: Specifier for GPIO that asserts ISP pipeline IP. Use GPIO_ACTIVE_LOW on ap_rst_n.
+
+  ports:
+    type: object
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: |
+          Input/sink port node, describing module connected to the
+          input of ISP pipeline IP.
+
+        properties:
+          reg:
+            description: |
+              Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+      "port@1":
+        type: object
+        description: |
+          Output/source port node, describing module connected to the
+          output.
+
+        properties:
+          reg:
+            description: |
+              Output/source port number.
+            const: 1
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - reset-gpios
+  - xlnx,max-width
+  - xlnx,max-height
+  - xlnx,rgain
+  - xlnx,bgain
+  - xlnx,pawb
+  - xlnx,mode-reg
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+   ISPPipeline: ISPPipeline@a40f0000 {
+        compatible = "xlnx,isppipeline-1.0";
+        reg = <0xa40f0000 0x10000>;
+        clocks = <&misc_clk_0>;
+        clock-names = "ap_clk";
+        reset-gpios = <&gpio 87 1>;
+        xlnx,max-width = /bits/ 16 <3840>;
+        xlnx,max-height = /bits/ 16 <2160>;
+        xlnx,rgain = /bits/ 16 <128>;
+        xlnx,bgain = /bits/ 16 <210>;
+        xlnx,pawb = /bits/ 16 <350>;
+        xlnx,mode-reg;
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                isppipeline_in: endpoint {
+                    remote-endpoint = <&isp_csiss_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                isppipeline_out: endpoint {
+                    remote-endpoint = <&isp_vcap_csi_in>;
+                };
+            };
+        };
+    };
+...
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,mem2mem.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,mem2mem.txt
new file mode 100644
index 000000000..73af77fae
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,mem2mem.txt
@@ -0,0 +1,25 @@
+Xilinx Video IP MEM2MEM Pipeline (XVIM2M)
+----------------------------------------
+
+Xilinx video IP mem2mem pipeline processes DMA transfers to achieve memory
+copy from one physical memory to other. The data is copied by employing two
+DMA transfers memory to device and device to memory transactions one after
+the other. The DT node of the XVIM2M represents as a top level node of the
+pipeline and defines mappings between DMAs.
+
+Required properties:
+
+- compatible: Must be "xlnx,mem2mem".
+
+- dmas, dma-names: List of two DMA specifier and identifier strings (as
+  defined in Documentation/devicetree/bindings/dma/dma.txt) per port.
+  Identifier string of one DMA channel should be "tx" and other should be
+  "rx".
+
+Example:
+
+	video_m2m {
+		compatible = "xlnx,mem2mem";
+		dmas = <&dma_1 0>, <&dma_2 0>;
+		dma-names = "tx", "rx";
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,sdirxss.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,sdirxss.txt
new file mode 100644
index 000000000..0a93f29fd
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,sdirxss.txt
@@ -0,0 +1,77 @@
+
+Xilinx SDI Receiver Subsystem
+------------------------------
+
+The Xilinx SDI Rx Subsystem is used to capture SDI Video in upto 12G mode.
+It outputs the video as an AXI4 Stream video data in YUV 422 10bpc mode.
+The subsystem consists of the SDI Rx IP whose SDI native output is connected
+to a SDI to Native conversion Bridge. The output of the Native bridge is
+connected to a Native to AXI4S Bridge which generates the AXI4 Stream of
+YUV422 or YUV420 10 bpc in dual pixel per clock.
+
+Required properties:
+
+- compatible: Must contain "xlnx,v-smpte-uhdsdi-rx-ss"
+
+- reg: Physical base address and length of the registers set for the device.
+
+- interrupts: Contains the interrupt line number.
+
+- interrupt-parent: phandle to interrupt controller.
+
+- xlnx,include-edh: Whether the EDH processor is enabled in design or not.
+
+- xlnx,line-rate: The maximum mode supported by the design.
+
+- clocks: Input clock specifier. Refer to common clock bindings.
+
+- clock-names: List of input clocks.
+  Required elements: "s_axi_aclk", "sdi_rx_clk", "video_out_clk"
+
+- port: Video port, using the DT bindings defined in ../video-interfaces.txt.
+  The SDI Rx subsystem has one port configured as output port.
+
+- xlnx,video-format, xlnx,video-width: Video format and width, as defined in
+  video.txt. Please note that the video format is fixed to either YUV422 or YUV420
+  and the video-width is 10.
+
+Optional properties:
+
+- reset_gt-gpios: contains GPIO reset phandle for FMC init done pin in GT.
+  This pin is active low.
+- picxo_reset-gpios: contains GPIO reset phandle for PICXO done pin for PICXO module.
+  This pin is active high.
+- xlnx,bpp: This denotes the bit depth as 10 or 12 based on IP configuration.
+  The default value is 10 for backward compatibility.
+
+Example:
+		v_smpte_uhdsdi_rx_ss: v_smpte_uhdsdi_rx_ss@80000000 {
+			compatible = "xlnx,v-smpte-uhdsdi-rx-ss";
+			interrupt-parent = <&gic>;
+			interrupts = <0 89 4>;
+			reg = <0x0 0x80000000 0x0 0x10000>;
+			xlnx,include-axilite = "true";
+			xlnx,include-edh = "true";
+			xlnx,include-vid-over-axi = "true";
+			xlnx,line-rate = "12G_SDI_8DS";
+			clocks = <&clk_1>, <&si570_1>, <&clk_2>;
+			clock-names = "s_axi_aclk", "sdi_rx_clk", "video_out_clk";
+			reset_gt-gpios = <&axi_gpio_0 0 0 GPIO_ACTIVE_LOW>;
+			picxo_reset-gpios = <&axi_gpio_0 2 0 GPIO_ACTIVE_HIGH>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+
+					xlnx,video-format = <XVIP_VF_YUV_422>;
+					xlnx,video-width = <10>;
+
+					sdirx_out: endpoint {
+						remote-endpoint = <&vcap_sdirx_in>;
+					};
+				};
+			};
+		};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-axi4s-switch.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-axi4s-switch.txt
new file mode 100644
index 000000000..fb5ed47d9
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-axi4s-switch.txt
@@ -0,0 +1,141 @@
+Xilinx AXI4-Stream Switch
+-------------------------------
+
+The AXI4-Stream Switch provides configurable routing between masters and slaves.
+It supports up to 16 masters/sources and 16 slaves/sinks and two routing options.
+There is atleast one slave/sink port and two master/source ports.
+
+The two routing options available are TDEST routing and control register routing.
+The TDEST based routing uses design parameters and hence there no software control.
+Each port is mapped as a pad and has its own format specified.
+
+Control register routing introduces an AXI4-Lite interface to configure the
+routing table. There is one register for each of the master interfaces to
+control each of the selectors. This routing mode requires that there is
+precisely only one path between master and slave. When attempting to map the
+same slave interface to multiple master interfaces, only the lowest master
+interface is able to access the slave interface.
+Here only the slave/sink ports have formats as master/source ports will inherit
+the corresponding slave ports formats. A routing table is maintained in this case.
+
+Please refer to PG085 AXI4-Stream Infrastructure IP Suite v2.2 for more details.
+
+Required properties:
+
+ - compatible: Must be "xlnx,axis-switch-1.1".
+ - xlnx,routing-mode: Can be 0 (TDEST routing) or 1 (Control reg routing)
+ - xlnx,num-si-slots: Number of slave / input ports. Min 1 Max 16 .
+ - xlnx,num-mi-slots: Number of master / output ports. Min 1 Max 16.
+ - ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+ - clocks: Reference to the AXI Streaming clock feeding the ACLK and
+   AXI4 Lite control interface clock when control routing is enabled.
+ - clock-names: Must have "aclk".
+
+Optional properties:
+ - reg: Physical base address and length of the registers set for the device.
+	This is required only if xlnx,routing-mode is 1.
+ - clocks: Reference to AXI4 Lite control interface clock when routing-mode is 1.
+ - clock-names: "s_axi_ctl_clk" clock for AXI4 Lite interface when routing-mode is 1.
+
+Example:
+
+For TDEST routing, from 1 slave port to 4 master ports
+
+	axis_switch_0: axis_switch@0 {
+		compatible = "xlnx,axis-switch-1.1";
+		xlnx,routing-mode = <0x0>;
+		xlnx,num-si-slots = <0x1>;
+		xlnx,num-mi-slots = <0x4>;
+		clocks = <&vid_stream_clk>;
+		clock-names = "aclk";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				switch_in0: endpoint {
+					remote-endpoint = <&csirxss_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+				switch_out0: endpoint {
+					remote-endpoint = <&vcap_csirxss0_in>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+				switch_out1: endpoint {
+					remote-endpoint = <&vcap_csirxss1_in>;
+				};
+			};
+			port@3 {
+				reg = <3>;
+				switch_out2: endpoint {
+					remote-endpoint = <&vcap_csirxss2_in>;
+				};
+			};
+			port@4 {
+				reg = <4>;
+				switch_out3: endpoint {
+					remote-endpoint = <&vcap_csirxss3_in>;
+				};
+			};
+		};
+
+	};
+
+For Control reg based routing, from 2 slave ports to 4 master ports
+
+	axis_switch_0: axis_switch@a0050000 {
+		compatible = "xlnx,axis-switch-1.1";
+		reg = <0x0 0xa0050000 0x0 0x1000>;
+		xlnx,routing-mode = <0x1>;
+		xlnx,num-si-slots = <0x2>;
+		xlnx,num-mi-slots = <0x4>;
+		clocks = <&vid_stream_clk>, <&misc_clk_0>;
+		clock-names = "aclk", "s_axi_ctl_clk;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				switch_in0: endpoint {
+					remote-endpoint = <&csirxss_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+				switch_in1: endpoint {
+					remote-endpoint = <&tpg_out>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+				switch_out0: endpoint {
+					remote-endpoint = <&vcap_csirxss0_in>;
+				};
+			};
+			port@3 {
+				reg = <3>;
+				switch_out1: endpoint {
+					remote-endpoint = <&vcap_csirxss1_in>;
+				};
+			};
+			port@4 {
+				reg = <4>;
+				switch_out2: endpoint {
+					remote-endpoint = <&vcap_csirxss2_in>;
+				};
+			};
+			port@5 {
+				reg = <5>;
+				switch_out3: endpoint {
+					remote-endpoint = <&vcap_csirxss3_in>;
+				};
+			};
+		};
+
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt
new file mode 100644
index 000000000..cdb0886cf
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt
@@ -0,0 +1,58 @@
+Xilinx Color Filter Array (CFA)
+-------------------------------
+
+Required properties:
+
+- compatible: Must be "xlnx,v-cfa-7.0".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the video core clock.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The cfa has an input port (0) and an output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Must be SENSOR_MONO for the input port (0), and RBG for
+  the output port (1).
+
+- xlnx,video-width: Video width as defined in video.txt
+
+- xlnx, cfa-pattern: Must be one of "rggb", "grbg", "gbrg", and "bggr" for the
+  input port (0). Must not be specified for the output port (1).
+
+Example:
+
+	cfa_0: cfa@400b0000 {
+		compatible = "xlnx,v-cfa-7.0";
+		reg = <0x400b0000 0x10000>;
+		clocks = <&clkc 15>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_SENSOR_MONO>;
+				xlnx,video-width = <8>;
+				xlnx,cfa-pattern = "rggb";
+
+				cfa0_in: endpoint {
+					remote-endpoint = <&spc0_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
+
+				cfa0_out: endpoint {
+					remote-endpoint = <&ccm0_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt
new file mode 100644
index 000000000..f404ee301
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt
@@ -0,0 +1,54 @@
+Xilinx Chroma Resampler (CRESAMPLE)
+-----------------------------------
+
+Required properties:
+
+- compatible: Must be "xlnx,v-cresample-4.0".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the video core clock.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The cresample as han input port (0) and an output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Must be one of YUV_444, YUV_422 or YUV_420 for the input
+  port (0), and one of YUV_422 or YUV_420 for the output port (1).
+
+- xlnx,video-width: Video width as defined in video.txt
+
+Example:
+
+	cresample_0: cresample@40120000 {
+		compatible = "xlnx,v-cresample-4.0";
+		reg = <0x40120000 0x10000>;
+		clocks = <&clkc 15>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_YUV_444>;
+				xlnx,video-width = <8>;
+
+				cresample0_in: endpoint {
+					remote-endpoint = <&rgb2yuv0_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				cresample0_out: endpoint {
+					remote-endpoint = <&scaler0_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-demosaic.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-demosaic.txt
new file mode 100644
index 000000000..9b3aff413
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-demosaic.txt
@@ -0,0 +1,62 @@
+Xilinx Video Demosaic IP
+-----------------------------
+The Xilinx Video Demosaic IP is used to interface to a Bayer video source.
+
+The driver set default Sink Pad media bus format to RGGB.
+The IP and driver only support RGB as its Source Pad media format.
+
+Required properties:
+
+- compatible: Must be "xlnx,v-demosaic".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the AXI Streaming clock feeding the Demosaic ap_clk.
+
+- xlnx,max-height: Maximum number of lines. Valid range is 64 to 4320.
+
+- xlnx,max-width: Maximum number of pixels in a line. Valid range is 64 to 8192.
+
+- reset-gpios: Specifier for GPIO that asserts Demosaic IP (AP_RST_N) reset.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+
+Required port properties:
+
+- reg: This value represents the media pad of the V4L2 sub-device.
+  A Sink Pad is represented by reg = <0>
+  A Source Pad is represented by reg = <1>
+
+- xlnx,video-width: Video width as defined in video.txt
+
+Example:
+	demosaic_1: demosaic@a00b0000 {
+		compatible = "xlnx,v-demosaic";
+		reg = <0x0 0xa00b0000 0x0 0x10000>;
+		clocks = <&vid_stream_clk>;
+		reset-gpios = <&gpio 87 1>;
+		xlnx,max-width = <3840>;
+		xlnx,max-height = <2160>;
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				xlnx,video-width = <8>;
+
+				demosaic_in: endpoint {
+					remote-endpoint = <&tpg_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				xlnx,video-width = <8>;
+
+				demosaic_out: endpoint {
+					remote-endpoint = <&gamma_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-dprxss.yaml b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-dprxss.yaml
new file mode 100644
index 000000000..3e462611c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-dprxss.yaml
@@ -0,0 +1,189 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/xilinx/xlnx,v-dprxss.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx DisplayPort Receiver Subsystem
+
+maintainers:
+  - Rajesh Gugulothu <gugulothu.rajesh@xilinx.com>
+
+description: |
+  The DisplayPort subsystem is a full feature, hierarchically packaged
+  subsystem with a DisplayPort sink(RX). DP RX subsystem can capture
+  video data in different formats at different resolutions.
+  For more details, please refer to PG233 at
+  https://www.xilinx.com/support/documentation/ip_documentation/dp_rx_subsystem/v2_1/pg233-displayport-rx-subsystem.pdf
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,v-dprxss-3.0
+
+  reg:
+    minItems: 1
+    items:
+      - description: DisplayPort Receiver Subsystem registers
+      - description: EDID IP block registers
+
+  reg-names:
+    items:
+      - const: dp_base
+      - const: edid_base
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    description: List of clock specifiers
+    items:
+      - description: AXI Lite clock
+      - description: Link clock
+      - description: Video clock
+
+  clock-names:
+    items:
+      - const: s_axi_aclk
+      - const: rx_lnk_clk
+      - const: rx_vid_clk
+
+  phys:
+    description: This denotes phandles for phy lanes registered for DP
+                 protocol. Number of phy lanes registered are depends on
+                 the xlnx,lane-count property.
+
+  phy-names:
+    items:
+      - const: dp-phy0
+      - const: dp-phy1
+      - const: dp-phy2
+      - const: dp-phy3
+
+  xlnx,link-rate:
+    description: |
+      Max link rate that IP configured with.Possible values are as below -
+      0x6  - 1.62 Gb/s
+      0xa  - 2.7 Gb/s
+      0x14 - 5.4 Gb/s
+      0x1e - 8.1 Gb/s
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0x6, 0xa, 0x14, 0x1e]
+
+  xlnx,lane-count:
+    description: Max number of lanes that IP configured with.
+                 Possible values are 1, 2, 4.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [1, 2, 4]
+
+  xlnx,bpc:
+    description: |
+      Max BPC value that IP configured with. For example if IP is
+      configured
+      with 10 BPC means it supports (6, 8, 10) up to 10bpc.
+      Possible values are 6, 8, 10, 12, 16.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [6, 8, 10, 12, 16]
+
+  xlnx,audio-channels:
+    description: |
+      This denotes number of audio channels enabled in the IP
+      configuration. Possible values are 2, 3, 4, 5, 6, 7, 8.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [2, 3, 4, 5, 6, 7, 8]
+
+  xlnx,hdcp1x-keymgmt:
+    description:
+      A phandle to a syscon device, used to access
+      hdcp1x keymgmt registers.
+    $ref: /schemas/types.yaml#/definitions/phandle
+
+  ports:
+    type: object
+
+    properties:
+      port@0:
+        type: object
+        description: |
+          Output / source port node, endpoint describing modules
+          connected the DisplayPort receiver
+
+        properties:
+          reg:
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        additionalProperties: false
+
+required:
+  - clock-names
+  - clocks
+  - compatible
+  - interrupts
+  - reg
+  - reg-names
+  - link-rate
+  - bpc
+  - lane-count
+  - phy-names
+  - phys
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+   v_dp_rxss1@a0040000 {
+       clock-names = "s_axi_aclk", "rx_lnk_clk", "rx_vid_clk" ;
+       clocks = <&zynqmp_clk 71>, <&zynqmp_clk 72>;
+       compatible = "xlnx,v-dp-rxss-3.0";
+       interrupt-names = "dprxss_dp_irq";
+       interrupt-parent = <&gic>;
+       interrupts = <0 89 4>;
+       reg = <0xa0040000 0x40000>, <0xa0010000 0x1000>;
+       reg-names = "dp_base", "edid_base";
+       xlnx,link-rate = <0x1e>;
+       xlnx,audio-enable;
+       xlnx,audio-channels = <2>;
+       xlnx,bpc = <10>;
+       xlnx,hdcp22-enable;
+       xlnx,hdcp-enable;
+       xlnx,hdcp1x-keymgmt = <&hdcp_keymngmt_blk_0>;
+       xlnx,lane-count = <4>;
+       phy-names = "dp-phy0", "dp-phy1", "dp-phy2", "dp-phy3";
+       phys = <&vphy_lane0 0 1 1 0>, <&vphy_lane1 0 1 1 0>,
+              <&vphy_lane2 0 1 1 0>, <&vphy_lane3 0 1 1 0>;
+
+       ports {
+           #address-cells = <1>;
+           #size-cells = <0>;
+
+           port@0 {
+               reg = <0>;
+               dp_rxss_out: endpoint {
+                   remote-endpoint = <&remap0_in>;
+               };
+           };
+       };
+   };
+   hdcp_keymngmt_blk_0: hdcp_keymngmt_blk@a00c0000 {
+       compatible = "xlnx,hdcp-keymngmt-blk-1.0", "syscon";
+       reg = <0xa00c0000 0x10000>;
+   };
+...
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-gamma-lut.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-gamma-lut.txt
new file mode 100644
index 000000000..7bd750f00
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-gamma-lut.txt
@@ -0,0 +1,63 @@
+Xilinx Video Gamma Correction IP
+-----------------------------------
+The Xilinx Video Gamma Correction IP is used to provide RGB gamma correction.
+The IP provides a look up table for each R,G and B components.
+
+Required properties:
+
+- compatible: Must be "xlnx,v-gamma-lut".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the clock that drives the ap_clk
+	  signal of Video Gamma Lookup.
+
+- xlnx,max-height: Maximum number of lines. Valid range is 64 to 4320.
+
+- xlnx,max-width: Maximum number of pixels in a line. Valid range is 64 to 8192.
+
+- reset-gpios: Specifier for a GPIO that asserts Gamma IP (AP_RST_N) reset
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The Gamma LUT IP has an input port (0) and an output port (1).
+
+
+Required port properties:
+- reg: This value represents the media pad of the V4L2 sub-device.
+  A Sink Pad is represented by reg = <0>
+  A Source Pad is represented by reg = <1>
+
+- xlnx,video-width: Video width as defined in video.txt. Can be either 8 or 10.
+
+Example:
+
+	gamma_lut_1: gamma_lut_1@0xa0080000 {
+		compatible = "xlnx,v-gamma-lut";
+		reg = <0x0 0xa0080000 0x0 0x10000>;
+		clocks = <&vid_stream_clk>;
+		reset-gpios = <&gpio 83 1>;
+		xlnx,max-height = <2160>;
+		xlnx,max-width = <3840>;
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				xlnx,video-width = <8>;
+
+				gamma_in: endpoint {
+					remote-endpoint = <&demosaic_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				xlnx,video-width = <8>;
+
+				gamma_out: endpoint {
+					remote-endpoint = <&csc_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hdmi-rxss1.yaml b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hdmi-rxss1.yaml
new file mode 100644
index 000000000..9e37b02c9
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hdmi-rxss1.yaml
@@ -0,0 +1,202 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/xilinx/xlnx,v-hdmi-rxss1.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx HDMI 2.1 Receiver Subsystem
+
+maintainers:
+  - Vishal Sagar <vishal.sagar@xilinx.com>
+
+description: |
+  The Xilinx HDMI 2.1 Receiver Subsystem is a feature rich soft IP incorporating
+  all the necesssary logic to properly interface with PHY layer and provides HDMI
+  decoding functionality. The subsystem is a hierarchical IP that bundles a
+  collection of HDMI 2.1 Rx-related IP sub-cores and outputs them as a  single IP.
+  The subsystem receives the captured TMDS data from the PHY layer. It then
+  extracts the video and audio streams from the HDMI stream and converts it to
+  video and audio streams.
+  For more details refer to PG 351 Xilinx HDMI 2.1 Rx Subsystem.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,v-hdmi-rxss1-1.1
+          - xlnx,v-hdmi-rxss1-1.2
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: Clock for AXI4-Lite control interface
+      - description: Fixed FRL Link clock
+      - description: AXI4-Stream clock
+
+  clock-names:
+    items:
+      - const: s_axi_cpu_aclk
+      - const: frl_clk
+      - const: s_axis_video_aclk
+
+  xlnx,edid-ram-size:
+    description: |
+      This is size of EDID in BRAM.
+      The possible values are 256, 512, 1024 or 4096.
+      This property has to be specified as '/bits/ 16' value.
+    $ref: /schemas/types.yaml#/definitions/uint16
+    enum: [ 256, 512, 1024, 4096 ]
+
+  xlnx,input-pixels-per-clock:
+    description: |
+      Number of pixels per clock on Video Interface.
+      This property has to be specified as '/bits/ 8' value.
+    $ref: /schemas/types.yaml#/definitions/uint8
+    enum: [ 4, 8 ]
+
+  xlnx,max-bits-per-component:
+    description: |
+      Maximum bits per component.
+      This property has to be specified as '/bits/ 8' value.
+    $ref: /schemas/types.yaml#/definitions/uint8
+    enum: [ 8, 10, 12, 16 ]
+
+  xlnx,max-frl-rate:
+    description: |
+      Maximum FRL rate.
+      This property has to be specified as '/bits/ 8' value.
+    $ref: /schemas/types.yaml#/definitions/uint8
+    enum: [ 4, 5, 6 ]
+
+  xlnx,frl-clk-freq-khz:
+    description: |
+      FRL clock frequency in KHz
+    $ref: /schemas/types.yaml#/definitions/uint32
+
+  xlnx,vid-clk-freq-khz:
+    description: |
+      Video clock frequency in KHz
+    $ref: /schemas/types.yaml#/definitions/uint32
+
+  phys:
+    description: |
+      This denotes phandles for phy lanes registered for HDMI protocol.
+
+  phy-names:
+    items:
+      - const: hdmi-phy0
+      - const: hdmi-phy1
+      - const: hdmi-phy2
+      - const: hdmi-phy3
+
+  ports:
+    type: object
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: |
+          Sink port node with one endpoint connected to a hdmi-connector node.
+        properties:
+          reg:
+            const: 0
+          endpoint:
+            type: object
+            properties:
+              remote-endpoint: true
+            required:
+              - remote-endpoint
+            additionalProperties: false
+        additionalProperties: false
+
+      port@1:
+        type: object
+        description: |
+          Source port node with one endpoint.
+        properties:
+          reg:
+            const: 1
+          endpoint:
+            type: object
+            properties:
+              remote-endpoint: true
+            required:
+              - remote-endpoint
+            additionalProperties: false
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - xlnx,edid-ram-size
+  - xlnx,max-bits-per-component
+  - xlnx,max-frl-rate
+  - xlnx,frl-clk-freq-khz
+  - xlnx,vid-clk-freq-khz
+  - xlnx,input-pixels-per-clock
+  - phys
+  - phy-names
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    v_hdmi_rxss1: v_hdmi_rxss1@80000000 {
+      compatible = "xlnx,v-hdmi-rxss1-1.1";
+      reg = <0x80000000 0x10000>;
+      clock-names = "s_axi_cpu_aclk", "frl_clk", "s_axis_video_aclk";
+      clocks = <&zynqmp_clk 71>, <&misc_clk_4>, <&misc_clk_5>;
+      interrupt-parent = <&gic>;
+      interrupts = <0 90 4>;
+      xlnx,edid-ram-size = /bits/ 16 <0x100>;
+      xlnx,input-pixels-per-clock = /bits/ 8 <0x8>;
+      xlnx,max-bits-per-component = /bits/ 8 <0xa>;
+      xlnx,max-frl-rate = /bits/ 8 <0x6>;
+      xlnx,frl-clk-freq-khz = <449955>;
+      xlnx,vid-clk-freq-khz = <400000>;
+      phy-names = "hdmi-phy0", "hdmi-phy1", "hdmi-phy2", "hdmi-phy3";
+      phys = <&hdmiphy1_lane0 0 1 1 0>,
+             <&hdmiphy1_lane1 0 1 1 0>,
+             <&hdmiphy1_lane2 0 1 1 0>,
+             <&hdmiphy1_lane3 0 1 1 0>;
+      ports {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        port@0 {
+           reg = <0>;
+           hdmi_rx_in: endpoint {
+             remote-endpoint = <&hdmi_connector_out>;
+           };
+        };
+        port@1 {
+           reg = <1>;
+           hdmi_rx_out: endpoint {
+             remote-endpoint = <&vpss_in>;
+           };
+        };
+      };
+    };
+...
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
new file mode 100644
index 000000000..a6db30405
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
@@ -0,0 +1,64 @@
+Xilinx High-Level Synthesis Core (HLS)
+--------------------------------------
+
+High-Level Synthesis cores are synthesized from a high-level function
+description developed by the user. As such their functions vary widely, but
+they all share a set of common characteristics that allow them to be described
+by common bindings.
+
+
+Required properties:
+
+- compatible: This property must contain "xlnx,v-hls" to indicate that the
+  core is compatible with the generic Xilinx HLS DT bindings. It can also
+  contain a more specific string to identify the HLS core implementation. The
+  value of those implementation-specific strings is out of scope for these DT
+  bindings.
+
+- reg: Physical base address and length of the registers sets for the device.
+  The HLS core has two registers sets, the first one contains the core
+  standard registers and the second one contains the custom user registers.
+
+- clocks: Reference to the video core clock.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The HLS core has one input port (0) and one output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Video format as defined in video.txt.
+- xlnx,video-width: Video width as defined in video.txt.
+
+Example:
+
+	hls_0: hls@43c00000 {
+		compatible = "xlnx,v-hls-sobel", "xlnx,v-hls";
+		reg = <0x43c00000 0x24>, <0x43c00024 0xa0>;
+		clocks = <&clkc 15>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				hls0_in: endpoint {
+					remote-endpoint = <&vdma_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				hls0_out: endpoint {
+					remote-endpoint = <&vdma_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-multi-scaler.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-multi-scaler.txt
new file mode 100644
index 000000000..3aea1f36a
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-multi-scaler.txt
@@ -0,0 +1,95 @@
+Xilinx mem2mem Multi Video Scaler (XM2MSC)
+-----------------------------------------
+
+Required propertie(s):
+- compatible		: Should be "xlnx,v-multi-scaler-v1.0"
+- clocks		: Input clock specifier. Refer to common clk bindings.
+- interrupt-parent	: Interrupt controller the interrupt is routed through
+- interrupts		: Should contain MultiScaler interrupt
+- reset-gpios		: Should contain GPIO reset phandle
+- reg			: Physical base address and
+			  length of the registers set for the device.
+- xlnx,max-chan		: Maximum number of supported scaling channels (1 - 8)
+- xlnx,max-width	: Maximum number of supported column/width (64 - 3840)
+- xlnx,max-height	: Maximum number of supported row/height (64 - 2160)
+- xlnx,dma-addr-width	: dma address width (either 32 or 64)
+- xlnx,pixels-per-clock	: pixels per clock set in IP (1, 2 or 4)
+- xlnx,vid-formats	: A list of strings indicating what video memory
+			  formats the IP has been configured to support.
+			  See VIDEO FORMATS table below and examples.
+- xlnx,num-taps		: The number of filter taps for scaling (6, 8, 10, 12)
+
+VIDEO FORMATS
+The following table describes the legal string values to be used for
+the xlnx,vid-formats property. To the left is the string value and the
+column to the right describes the format.
+
+IP FORMAT	DTS String	Description
+-------------|----------------|---------------------
+RGB8		bgr888		Packed RGB, 8 bits per component.
+				Every RGB pixel in memory is represented with
+				24 bits.
+RGBX8		xbgr8888	Packed RGB, 8 bits per component. Every RGB
+				pixel in memory is represented with 32 bits.
+				Bits[31:24] do not contain pixel information.
+BGRX8		xrgb8888	Packed BGR, 8 bits per component. Every BGR
+				pixel in memory is represented with 32 bits.
+				Bits[31:24] do not contain pixel information.
+RGBX10		xbgr2101010	Packed RGB, 10 bits per component. Every RGB
+				pixel is represented with 32 bits. Bits[31:30]
+				do not contain any pixel information.
+YUV8		vuy888		Packed YUV 4:4:4, 8 bits per component. Every
+				YUV 4:4:4 pixel in memory is represented with
+				24 bits.
+YUVX8		xvuy8888	Packed YUV 4:4:4, 8 bits per component.
+				Every YUV 4:4:4 pixel in memory is represented
+				with 32 bits. Bits[31:24] do not contain pixel
+				information.
+YUYV8		yuyv		Packed YUV 4:2:2, 8 bits per component. Every
+				two YUV 4:2:2 pixels in memory are represented
+				with 32 bits.
+UYVY8		uyvy		Packed YUV 4:2:2, 8 bits per component.
+				Every two YUV 4:2:2 pixels in memory are
+				represented with 32 bits.
+YUVX10		yuvx2101010	Packed YUV 4:4:4, 10 bits per component.
+				Every YUV 4:4:4 pixel is represented with 32 bits.
+				Bits[31:30] do not contain any pixel information.
+Y8		y8		Packed Luma-Only, 8 bits per component. Every
+				luma-only pixel in memory is represented with
+				8 bits. Y8 is presented as YUV 4:4:4 on the
+				AXI4-Stream interface.
+Y10		y10		Packed Luma-Only, 10 bits per component. Every
+				three luma-only pixels in memory is represented
+				with 32 bits. Y10 is presented as YUV 4:4:4 on
+				the AXI4-Stream interface.
+Y_UV8		nv16		Semi-planar YUV 4:2:2 with 8 bits per component.
+				Y and UV stored in separate planes.
+Y_UV8_420	nv12		Semi-planar YUV 4:2:0 with 8 bits per component.
+				Y and UV stored in separate planes.
+Y_UV10		xv20		Semi-planar YUV 4:2:2 with 10 bits per component.
+				Every 3 pixels is represented with 32 bits.
+				Bits[31:30] do not contain any pixel information.
+				Y and UV stored in separate planes.
+Y_UV10_420	xv15		Semi-planar YUV 4:2:0 with 10 bits per component.
+				Every 3 pixels is represented with 32 bits.
+				Bits[31:30] do not contain any pixel information.
+				Y and UV stored in separate planes.
+
+Example
+
+v_multi_scaler_0: v_multi_scaler@a0000000 {\
+	clocks = <&clk 71>;
+	compatible = "xlnx,v-multi-scaler-v1.0";
+	interrupt-names = "interrupt";
+	interrupt-parent = <&gic>;
+	interrupts = <0 89 4>;
+	reg = <0x0 0xa0000000 0x0 0x10000>;
+	xlnx,vid-formats = "bgr888","vuy888";
+	reset-gpios = <&gpio 78 1>;
+	xlnx,max-chan = <0x01>;
+	xlnx,dma-addr-width = <0x20>;
+	xlnx,pixels-per-clock = /bits/ 8 <2>;
+	xlnx,max-width = <3840>;
+	xlnx,max-height = <2160>;
+	xlnx,num-taps = <6>;
+};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-remapper.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-remapper.txt
new file mode 100644
index 000000000..cda02cb97
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-remapper.txt
@@ -0,0 +1,61 @@
+Xilinx Video Remapper
+---------------------
+
+The IP core remaps input pixel components to produce an output pixel with
+less, more or the same number of components as the input pixel.
+
+Required properties:
+
+- compatible: Must be "xlnx,v-remapper".
+
+- clocks: Reference to the video core clock.
+
+- xlnx,video-width: Video pixel component width, as defined in video.txt.
+
+- #xlnx,s-components: Number of components per pixel at the input port
+  (between 1 and 4 inclusive).
+
+- #xlnx,m-components: Number of components per pixel at the output port
+  (between 1 and 4 inclusive).
+
+- xlnx,component-maps: Remapping configuration represented as an array of
+  integers. The array contains one entry per output component, in the low to
+  high order. Each entry corresponds to the zero-based position of the
+  corresponding input component, or the value 4 to drive a constant value on
+  the output component. For example, to remap RGB to BGR use <2 1 0>, and to
+  remap RBG to xRGB use <1 0 2 4>.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The remapper as an input port (0) and and output port (1).
+
+Example: RBG to xRGB remapper
+
+	remapper_0: remapper {
+		compatible = "xlnx,v-remapper";
+
+		clocks = <&clkc 15>;
+
+		xlnx,video-width = <8>;
+
+		#xlnx,s-components = <3>;
+		#xlnx,m-components = <4>;
+		xlnx,component-maps = <1 0 2 4>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				remap0_in: endpoint {
+					remote-endpoint = <&tpg0_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+				remap0_out: endpoint {
+					remote-endpoint = <&sobel0_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt
new file mode 100644
index 000000000..ecd10fb31
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt
@@ -0,0 +1,54 @@
+Xilinx RGB to YUV (RGB2YUV)
+---------------------------
+
+Required properties:
+
+- compatible: Must be "xlnx,v-rgb2yuv-7.1".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the video core clock.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The rgb2yuv has an input port (0) and an output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Must be RBG for the input port (0) and YUV_444 for the
+  output port (1).
+
+- xlnx,video-width: Video width as defined in video.txt
+
+Example:
+
+	rgb2yuv_0: rgb2yuv@40100000 {
+		compatible = "xlnx,v-rgb2yuv-7.1";
+		reg = <0x40100000 0x10000>;
+		clocks = <&clkc 15>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
+
+				rgb2yuv0_in: endpoint {
+					remote-endpoint = <&gamma0_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_444>;
+				xlnx,video-width = <8>;
+
+				rgb2yuv0_out: endpoint {
+					remote-endpoint = <&cresample0_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt
new file mode 100644
index 000000000..0bb9c405f
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt
@@ -0,0 +1,75 @@
+Xilinx Scaler (SCALER)
+------------------------------------
+
+Required properties:
+
+- compatible: Must be "xlnx,v-scaler-8.1".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the video core clock.
+
+- xlnx,num-hori-taps, xlnx,num-vert-taps: The number of horizontal and vertical
+  taps for scaling filter(range: 2 - 12).
+
+- xlnx,max-num-phases: The maximum number of phases for scaling filter
+  (range: 2 - 64).
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The scaler has an input port (0) and an output port (1).
+
+Optional properties:
+
+- xlnx,separate-yc-coef: When set, this boolean property specifies that
+  the hardware uses separate coefficients for the luma and chroma filters.
+  Otherwise a single set of coefficients is shared for both.
+
+- xlnx,separate-hv-coef: When set, this boolean property specifies that
+  the hardware uses separate coefficients for the horizontal and vertical
+  filters. Otherwise a single set of coefficients is shared for both.
+
+Required port properties:
+
+- xlnx,video-format: Must be one of RBG, YUV_422, YUV_422 or YUV_420 for
+  both input port (0) and output port (1). The two formats must be identical.
+
+- xlnx,video-width: Video width as defined in video.txt
+
+Example:
+
+	scaler_0: scaler@43c30000 {
+		compatible = "xlnx,v-scaler-8.1";
+		reg = <0x43c30000 0x10000>;
+		clocks = <&clkc 15>;
+
+		xlnx,num-hori-taps = <12>;
+		xlnx,num-vert-taps = <12>;
+		xlnx,max-num-phases = <4>;
+		xlnx,separate-hv-coef;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				scaler0_in: endpoint {
+					remote-endpoint = <&cresample0_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				scaler0_out: endpoint {
+					remote-endpoint = <&vcap0_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scd.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scd.txt
new file mode 100644
index 000000000..a05e9712c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scd.txt
@@ -0,0 +1,164 @@
+Xilinx Scene Change Detection IP (SCD)
+--------------------------------------
+
+The Xilinx Scene Change Detection IP contains two blocks: one IP block is used
+for reading video frame data from memory to the device and the other IP block
+is used for determining whether there is a scene change between current and the
+previous frame. The IP supports YUV planar and semi-planar formats. IP only
+needs luma frame to determine the scene change event. The IP supports memory
+based model, which means that it will accept a dma buffer address and perform
+MEM2DEV transfer followed by statistical based image processing and give the
+data back to application if scene change detection is present or not.
+
+Another version of scene change detection IP which supports streaming model,
+which means that IP can be inserted in a capture pipeline. For example,
+"hdmirx -> streaming-scd -> fb_wr" is a typical capture pipeline where
+streaming SCD can be embedded. The IP accespts the AXI video data and perform
+histogram based statistical analysis to detect scene change. The IP supports
+single channel.
+
+Required properties:
+
+- compatible: Should be "xlnx,v-scd"
+
+- reg: Physical base address and length of the registers set for the device
+
+- clocks: Reference to the video core clock.
+
+- reset-gpios: Specifier for a GPIO that assert SCD (AP_RST_N) reset.
+
+- xlnx,memory-based: This is to differentiate between memory based and
+  streaming based IP. The value is 1 for memory based and 0 for streaming
+  based IPs.
+
+- xlnx,numstreams: Maximum active streams IP can support is 8 and this is based
+  on the design.
+
+- xlnx,addrwidth: Size of dma address pointer in IP (either 32 or 64)
+
+- subdev: Each channel will have its own subdev node. Each subdev will have its
+  sink port.
+
+- port: Video port, using the DT bindings defined in ../video-interfaces.txt.
+
+Example:
+
+1. Memory based device tree
+
+The following example shows how the device tree would look like for a memory
+based design where 8 streams are enabled.
+
+	scd: scenechange@a0100000 {
+		compatible = "xlnx,v-scd";
+		reg = <0x0 0xa0100000 0x0 0x1fff>;
+		clocks = <&misc_clk_0>;
+		interrupt-parent = <&gic>;
+		interrupts = <0 90 4>;
+		reset-gpios = <&gpio 94 1>;
+
+		xlnx,memory-based;
+		xlnx,numstreams = <8>;
+		xlnx,addrwidth = <0x20>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+		#dma-cells = <1>;
+
+		subdev@0 {
+			port@0 {
+				reg = <0>;
+				scd_in0: endpoint {
+					remote-endpoint = <&vcap0_out0>;
+				};
+			};
+		};
+		subdev@1 {
+			port@0 {
+				reg = <0>;
+				scd_in1: endpoint {
+					remote-endpoint = <&vcap0_out1>;
+				};
+			};
+		};
+		subdev@2 {
+			port@0 {
+				reg = <0>;
+				scd_in2: endpoint {
+					remote-endpoint = <&vcap0_out2>;
+				};
+			};
+		};
+		subdev@3 {
+			port@0 {
+				reg = <0>;
+				scd_in3: endpoint {
+					remote-endpoint = <&vcap0_out3>;
+				};
+			};
+		};
+		subdev@4 {
+			port@0 {
+				reg = <0>;
+				scd_in4: endpoint {
+					remote-endpoint = <&vcap0_out4>;
+				};
+			};
+		};
+		subdev@5 {
+			port@0 {
+				reg = <0>;
+				scd_in5: endpoint {
+					remote-endpoint = <&vcap0_out5>;
+				};
+			};
+		};
+		subdev@6 {
+			port@0 {
+				reg = <0>;
+				scd_in6: endpoint {
+					remote-endpoint = <&vcap0_out6>;
+				};
+			};
+		};
+		subdev@7 {
+			port@0 {
+				reg = <0>;
+			scd_in7: endpoint {
+					remote-endpoint = <&vcap0_out7>;
+				};
+			};
+		};
+	};
+
+2. Streaming based device tree
+
+The following example shows how the device tree would look like for a streaming
+based design.
+
+	scd: scenechange@a0280000 {
+		compatible = "xlnx,v-scd";
+		reg = <0x0 0xa0280000 0x0 0x1fff>;
+		clocks = <&clk 72>;
+		interrupt-parent = <&gic>;
+		interrupts = <0 111 4>;
+		reset-gpios = <&gpio 100 1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		xlnx,numstreams = <1>;
+
+		scd {
+			port@0 {
+				reg = <0x0>;
+				scd_in0: endpoint {
+					remote-endpoint = <&vpss_scaler_out>;
+				};
+			};
+
+			port@1 {
+				reg = <0x1>;
+				scd_out0: endpoint {
+					remote-endpoint = <&vcap_hdmi_in_1>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt
new file mode 100644
index 000000000..91dc3af4a
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt
@@ -0,0 +1,55 @@
+Xilinx Video Switch
+-------------------
+
+Required properties:
+
+  - compatible: Must be "xlnx,v-switch-1.0".
+
+  - reg: Physical base address and length of the registers set for the device.
+
+  - clocks: Reference to the video core clock.
+
+  - #xlnx,inputs: Number of input ports
+  - #xlnx,outputs: Number of outputs ports
+
+  - ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+
+Example:
+
+	switch: switch@43c10000 {
+		compatible = "xlnx,v-switch-1.0";
+		reg = <0x43c10000 0x10000>;
+		clocks = <&clkc 15>;
+
+		#xlnx,inputs = <2>;
+		#xlnx,outputs = <2>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				switch_in0: endpoint {
+					remote-endpoint = <&tpg_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+				switch_in1: endpoint {
+					remote-endpoint = <&cresample0_out>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+				switch_out0: endpoint {
+					remote-endpoint = <&scaler0_in>;
+				};
+			};
+			port@3 {
+				reg = <3>;
+				switch_out1: endpoint {
+					remote-endpoint = <&vcap0_in1>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
index 439351ab2..4b2126a78 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
@@ -6,7 +6,8 @@ Required properties:
 - compatible: Must contain at least one of
 
     "xlnx,v-tpg-5.0" (TPG version 5.0)
-    "xlnx,v-tpg-6.0" (TPG version 6.0)
+    "xlnx,v-tpg-7.0" (TPG version 7.0)
+    "xlnx,v-tpg-8.0" (TPG version 8.0)
 
   TPG versions backward-compatible with previous versions should list all
   compatible versions in the newer to older order.
@@ -23,6 +24,8 @@ Required properties:
 
 Optional properties:
 
+- xlnx,ppc: Pixels per clock. Valid values are 1, 2, 4 or 8.
+
 - xlnx,vtc: A phandle referencing the Video Timing Controller that generates
   video timings for the TPG test patterns.
 
@@ -30,16 +33,26 @@ Optional properties:
   input. The GPIO active level corresponds to the selection of VTC-generated
   video timings.
 
+- reset-gpios: Specifier for a GPIO that assert TPG (AP_RST_N) reset.
+  This property is mandatory for TPG v7.0 and above.
+
+- xlnx,max-height: Maximum number of lines.
+  This property is mandatory for TPG v8.0. Value ranges from 64 to 7760.
+
+- xlnx,max-width: Maximum number of pixels in a line.
+  This property is mandatory for TPG v8.0. Value ranges from 64 to 10328.
+
 The xlnx,vtc and timing-gpios properties are mandatory when the TPG is
 synthesized with two ports and forbidden when synthesized with one port.
 
 Example:
 
 	tpg_0: tpg@40050000 {
-		compatible = "xlnx,v-tpg-6.0", "xlnx,v-tpg-5.0";
+		compatible = "xlnx,v-tpg-5.0";
 		reg = <0x40050000 0x10000>;
 		clocks = <&clkc 15>;
 
+		xlnx,ppc = <2>;
 		xlnx,vtc = <&vtc_3>;
 		timing-gpios = <&ps7_gpio_0 55 GPIO_ACTIVE_LOW>;
 
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-vpss-csc.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-vpss-csc.txt
new file mode 100644
index 000000000..d2bad8744
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-vpss-csc.txt
@@ -0,0 +1,67 @@
+Xilinx VPSS Color Space Converter (CSC)
+-----------------------------------------
+The Xilinx VPSS Color Space Converter (CSC) is a Video IP that supports
+color space conversion from RGB or YUV(444, 422, 420)input to RGB or
+YUV(444, 422, 420) output.
+
+Required properties:
+
+- compatible: Must be "xlnx,v-vpss-csc".
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the clock that drives the ap_clk signal.
+
+- xlnx,max-height: Maximum number of lines.
+  Valid range from 64 to 4320.
+
+- xlnx,max-width: Maximum number of pixels in a line.
+  Valid range from 64 to 8192.
+
+- reset-gpios: Specifier for a GPIO that assert VPSS CSC (AP_RST_N) reset.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The scaler has an input port (0) and an output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Must be XVIP_VF_RBG, XVIP_VF_YUV_444 or XVIP_VF_YUV_422
+  for input port (0) and XVIP_VF_RBG, XVIP_VF_YUV_444 or XVIP_VF_YUV_422
+  for output port (1). See <dt-bindings/media/xilinx-vip.h> for more details.
+
+- xlnx,video-width: Video width as defined in video.txt. Must be either 8 or 10.
+
+Example:
+	csc_1:csc@a0040000 {
+		compatible = "xlnx,v-vpss-csc";
+		reg = <0x0 0xa0040000 0x0 0x10000>;
+		clocks = <&vid_stream_clk>;
+		reset-gpios = <&gpio 84 1>;
+		xlnx,max-width = <3840>;
+		xlnx,max-height = <2160>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			/* Sink Pad */
+			port@0 {
+				reg = <0>;
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
+
+				csc_in: endpoint {
+					remote-endpoint = <&gamma_out>;
+				};
+			};
+			/* Source Pad */
+			port@1 {
+				reg = <1>;
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
+
+				csc_out: endpoint {
+					remote-endpoint = <&scalar_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-vpss-scaler.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-vpss-scaler.txt
new file mode 100644
index 000000000..05ca0cb33
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-vpss-scaler.txt
@@ -0,0 +1,93 @@
+  Xilinx VPSS Scaler
+------------------------
+
+Required properties:
+
+- compatible: Must be "xlnx,v-vpss-scaler-2.2" or "xlnx,v-vpss-scaler-1.0".
+  The older string "xlnx,v-vpss-scaler" will be deprecated.
+
+- reg: Physical base address and length of the registers set for the device.
+
+- clocks: Reference to the AXI Streaming clock feeding the VPSS Scaler AP_CLK
+  and AXI4 Lite control interface clock.
+
+- clock-names: Must contain "aclk_axis" and "aclk_ctrl" in the same order as
+  clocks listed in clocks property.
+
+- xlnx,num-hori-taps, xlnx,num-vert-taps: The number of horizontal and vertical
+  taps for scaling filter(range: 2,4,6,8,10,12).
+
+  A value of 2 represents bilinear filters. A value of 4 represents bicubic.
+  Values 6,8,10,12 represent polyphase filters.
+
+- xlnx,pix-per-clk : The pixels per clock property of the IP
+
+- reset-gpios: Specifier for a GPIO that assert for VPSS Scaler reset.
+  This property is mandatory for the Scaler
+
+- xlnx,max-height: Maximum number of lines.
+  Valid range from 64 to 4320.
+
+- xlnx,max-width: Maximum number of pixels in a line.
+  Valid range from 64 to 8192.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The scaler has an input port (0) and an output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Must be one of XVIP_VF_RBG or XVIP_VF_YUV_422 for
+  input port (0) and must be XVIP_VF_RBG or XVIP_VF_YUV_422 or for
+  the output port (1).
+  See <dt-bindings/media/xilinx-vip.h> for more details.
+
+- reg: This value represents the media pad of the V4L2 sub-device.
+  A Sink Pad is represented by reg = <0>
+  A Source Pad is represented by reg = <1>
+
+- xlnx,video-width: Video width as defined in video.txt
+
+Example:
+
+	scaler_1:scaler@a0000000 {
+		compatible = "xlnx,v-vpss-scaler-1.0";
+		reg = <0x0 0xa0000000 0x0 0x40000>;
+		clocks = <&vid_stream_clk>, <&misc_clk_2>;
+		clock-names = "aclk_axis", "aclk_ctrl";
+		xlnx,num-hori-taps = <8>;
+		xlnx,num-vert-taps = <8>;
+		xlnx,pix-per-clk = <2>;
+		reset-gpios = <&gpio 87 1>;
+		xlnx,max-width = <3840>;
+		xlnx,max-height = <2160>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				/* Sink Pad */
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
+
+				scaler_in: endpoint {
+					remote-endpoint = <&csc_out>;
+				};
+			};
+
+			port@1 {
+				/* Source Pad */
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				scaler_out: endpoint {
+					remote-endpoint = <&vcap_tpg_in>;
+				};
+			};
+		};
+
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,video.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,video.txt
index 5a0227023..8f80b38e1 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,video.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,video.txt
@@ -21,6 +21,18 @@ Required properties:
 
 - ports: Video port, using the DT bindings defined in ../video-interfaces.txt.
 
+Optional properties:
+- memory-region : phandle to /reserved-memory node.
+  If memory is reserved for special use by DMAs then this node
+  can be used to refer and use from this reserved memory region.
+
+- xlnx,atomic_streamon: This property is useful for the scenario where some of
+  the upstream entities are being shared with multiple video devices (dma
+  engines) in the same media pipeline. When set, all entities belonging to
+  the media pipeline will get enabled even when any one of the dma engine
+  present in the media  pipeline start streaming, otherwise the entities
+  get enabled only when all dma engines start streaming.
+
 Required port properties:
 
 - direction: should be either "input" or "output" depending on the direction
@@ -53,3 +65,46 @@ Example:
 			};
 		};
 	};
+
+Example using reserved memory:
+Reserving from 32bit Shared CMA pool of 512MiB using System RAM:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+/ {
+	reserved-memory {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		ranges;
+		psmem_multimedia: multimedia_cma_mem_region {
+			compatible = "shared-dma-pool";
+			reg = <0x00 0x40000000 0x00 0x20000000>;
+			reusable;
+		};
+	};
+};
+...
+	video_cap {
+		/* ... */
+		memory-region = <&psmem_multimedia>;
+	};
+
+
+Reserving from 64bit Shared DMA pool of 1792 MiB using external PL based
+DDR memory:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+/ {
+	reserved-memory {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		ranges;
+		plmem_multimedia: multimedia_dma_mem_region {
+			compatible = "shared-dma-pool";
+			no-map;
+			reg = <0x48 0x0 0x0 0x70000000>;
+		};
+	};
+};
+...
+	video_cap {
+		/* ... */
+		memory-region = <&plmem_multimedia>;
+	}
diff --git a/Documentation/devicetree/bindings/xlnx,ctrl-fb.txt b/Documentation/devicetree/bindings/xlnx,ctrl-fb.txt
new file mode 100644
index 000000000..8abc053df
--- /dev/null
+++ b/Documentation/devicetree/bindings/xlnx,ctrl-fb.txt
@@ -0,0 +1,22 @@
+The Xilinx framebuffer DMA engine supports two soft IP blocks: one IP
+block is used for reading video frame data from memory (FB Read) to the device
+and the other IP block is used for writing video frame data from the device
+to memory (FB Write).  Both the FB Read/Write IP blocks are aware of the
+format of the data being written to or read from memory including RGB and
+YUV in packed, planar, and semi-planar formats.  Because the FB Read/Write
+is format aware, only one buffer pointer is needed by the IP blocks even
+when planar or semi-planar format are used.
+
+Required properties:
+ - compatible: Should be "xlnx,ctrl-fbwr-1.0" for framebuffer Write OR
+	       "xlnx,ctrl-fbrd-1.0" for framebuffer Read.
+ - reg: Base address and size of the IP core.
+ - reset-gpios: gpio to reset the framebuffer IP
+
+Example:
+
+        fbwr@0xa0000000 {
+                compatible = "xlnx,ctrl-fbwr-1.0";
+                reg = <0x0 0xa0000000 0x0 0x10000>;
+                reset-gpios = <&gpio 82 1>;
+        };
diff --git a/Documentation/devicetree/bindings/xlnx,ctrl-vpss.txt b/Documentation/devicetree/bindings/xlnx,ctrl-vpss.txt
new file mode 100644
index 000000000..04e6426f4
--- /dev/null
+++ b/Documentation/devicetree/bindings/xlnx,ctrl-vpss.txt
@@ -0,0 +1,21 @@
+The Xilinx VPSS Scaler is a Video IP that supports up scaling, down scaling and
+no scaling functionailty along with color space conversion. This supports custom
+resolution values between 0 to 4096.
+
+Required properties:
+
+- compatible: Must be "xlnx,ctrl-xvpss-1.0".
+- reg: Base address and size of the IP core.
+- reset-gpios: gpio to reset the framebuffer IP
+- xlnx,vpss-taps: number of taps
+- xlnx,vpss-ppc: pixels per clock
+
+Example:
+
+        ctrlvpss: vpss@0xa0200000 {
+                compatible = "xlnx,ctrl-xvpss-1.0";
+                reg = <0x0 0xa0200000 0x0 0x30000>;
+                reset-gpios = <&gpio 80 1>;
+                xlnx,vpss-taps = <6>;
+                xlnx,vpss-ppc = <2>;
+        };
diff --git a/drivers/media/platform/xilinx/Kconfig b/drivers/media/platform/xilinx/Kconfig
index 93ef78bf6..c0609c925 100644
--- a/drivers/media/platform/xilinx/Kconfig
+++ b/drivers/media/platform/xilinx/Kconfig
@@ -6,9 +6,11 @@ config VIDEO_XILINX
 	tristate "Xilinx Video IP (EXPERIMENTAL)"
 	depends on V4L_PLATFORM_DRIVERS
 	depends on VIDEO_DEV  && OF && HAS_DMA
+	depends on DMADEVICES
 	select MEDIA_CONTROLLER
 	select VIDEO_V4L2_SUBDEV_API
 	select VIDEOBUF2_DMA_CONTIG
+	select XILINX_FRMBUF
 	select V4L2_FWNODE
 	help
 	  Driver for Xilinx Video IP Pipelines
@@ -21,15 +23,209 @@ config VIDEO_XILINX_CSI2RXSS
 	  based driver that takes input from CSI-2 Tx source and converts
 	  it into an AXI4-Stream.
 
+config VIDEO_XILINX_AXI4S_SWITCH
+	tristate "Xilinx AXI4-Stream Video Switch"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx AXI4-Stream Video Switch. This is a
+	  V4L sub device based driver. It supports fixed (TDEST based)
+	  as well as dynamic (control register based) routing.
+	  Say M to modularize. Say N if unsure.
+
+config VIDEO_XILINX_CFA
+	tristate "Xilinx Video Color Filter Array"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Color Filter Array
+
+config VIDEO_XILINX_CRESAMPLE
+	tristate "Xilinx Video Chroma Resampler"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Chroma Resampler
+
+config VIDEO_XILINX_DEMOSAIC
+	tristate "Xilinx Video Demosaic IP"
+	depends on VIDEO_XILINX
+	help
+	  Driver for Xilinx Video Demosaic IP. This is a V4L sub-device
+	  based driver for the Demosaic IP that takes input a Bayer video
+	  stream format as input and generates an RGB video output.
+	  Say M to modularize. Say N if unsure.
+
+config VIDEO_XILINX_GAMMA
+	tristate "Xilinx Gamma Correction LUT"
+	depends on VIDEO_XILINX
+	help
+	  Driver for Xilinx Gamma Correction LUT IP. This is a V4L sub-device
+	  based driver that exposes V4L controls to adjust Red, Blue and Green
+	  Gamma Correction.
+
+	  Say M to modularize. Say N if unsure.
+
+config VIDEO_XILINX_HDCP1X_RX
+	bool
+	select XLNX_HDCP1X_CIPHER
+	help
+	  Functionality of HDCP1X Rx for DP and HDMI. It handles the hdcp1x rx
+	  authentication. Choose this config in a platform where the DP/HDMI Rx
+	  subsystem enabled with HDCP1X.
+
+config VIDEO_XILINX_HDCP2X_RX
+	bool
+	select XILINX_HDCP_COMMON
+	help
+	  Functionality of HDCP2X Rx for DP and HDMI. It handles the hdcp2x rx
+	  authentication. Choose this config in a platform where the DP/HDMI Rx
+	  subsystem enabled with HDCP2X.
+
+
+config VIDEO_XILINX_HDMI21RXSS
+	tristate "Xilinx HDMI 2.1 Rx Subsystem"
+	depends on VIDEO_XILINX
+	select VIDEO_XILINX_HDCP1X_RX
+	help
+	  Driver for the Xilinx HDMI 2.1 Rx subsystem to capture HDMI streams.
+	  This is a V4L2 subdev driver which used to get the stream properties
+	  like timing, color format and depth, frame rate.
+
+	  Say M to modularize. Say N if unsure.
+
+config VIDEO_XILINX_HLS
+	tristate "Xilinx Video HLS Core"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Video HLS Cores
+
+config VIDEO_XILINX_ISP
+	tristate "Xilinx Video ISP pipeline"
+	depends on VIDEO_XILINX
+	help
+	  Driver for Xilinx Video ISP pipeline. This is a V4L sub-device
+	  based driver for Video ISP pipeline that takes a bayer video
+	  stream format as input and generates an RGB video output.
+	  Say M to modularize. Say N if unsure.
+
+config VIDEO_XILINX_REMAPPER
+	tristate "Xilinx Video Remapper"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Video Remapper
+
+config VIDEO_XILINX_RGB2YUV
+	tristate "Xilinx Video RGB to YUV Converter"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Video RGB to YUV Converter
+
+config VIDEO_XILINX_SCALER
+	tristate "Xilinx Video Scaler"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Video Scaler
+
+config VIDEO_XILINX_MULTISCALER
+	tristate "Xilinx Video Multiscaler"
+	depends on VIDEO_XILINX
+	depends on VIDEO_DEV
+	select V4L2_MEM2MEM_DEV
+	select VIDEOBUF2_DMA_CONTIG
+	help
+	  Driver for the Xilinx Video Multi Scaler. This is a V4L2 memory to
+	  memory based driver. Multi-Scaler has max 8 channels which can be
+	  programed for different scaling ratio.
+
+config VIDEO_XILINX_SDIRXSS
+	tristate "Xilinx SDI Rx Subsystem"
+	depends on VIDEO_XILINX
+	help
+	  Driver for Xilinx SDI Rx Subsystem
+
+config VIDEO_XILINX_SWITCH
+	tristate "Xilinx Video Switch"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Video Switch
+
 config VIDEO_XILINX_TPG
 	tristate "Xilinx Video Test Pattern Generator"
 	depends on VIDEO_XILINX
 	select VIDEO_XILINX_VTC
 	help
-	   Driver for the Xilinx Video Test Pattern Generator
+	  Driver for the Xilinx Video Test Pattern Generator
+
+config VIDEO_XILINX_VPSS_CSC
+	tristate "Xilinx VPSS CSC"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx Video Processing Sub-System (VPSS)
+	  Color Space Conversion. The driver provides RGB to YUV444
+	  conversion and provides video controls like Brightness,
+	  Contrast, Color Gains that can be applied to video.
+	  Say N if unsure. Say M to modularize.
+
+config VIDEO_XILINX_VPSS_SCALER
+	tristate "Xilinx Video VPSS Scaler"
+	depends on VIDEO_XILINX
+	help
+	  Driver for Xilinx Video Processing Sub-System(VPSS) Scaler.
+	  It allows upscaling and downscaling of video. It also supports
+	  limited Color Space Conversion.
+	  Say N if unsure.
 
 config VIDEO_XILINX_VTC
 	tristate "Xilinx Video Timing Controller"
 	depends on VIDEO_XILINX
 	help
-	   Driver for the Xilinx Video Timing Controller
+	  Driver for the Xilinx Video Timing Controller
+
+config VIDEO_XILINX_DPRXSS
+	tristate "Xilinx DP Rx Subsystem"
+	depends on VIDEO_XILINX
+	select VIDEO_XILINX_HDCP1X_RX
+	select VIDEO_XILINX_HDCP2X_RX
+	select DRM_DISPLAY_HELPER
+	select DRM_DISPLAY_DP_HELPER
+	help
+	  Driver for Xilinx DisplayPort Rx Subsystem. This is a V4L sub-device
+	  based driver for the DisplayPort receiver subsystem IP. It captures
+	  AXI-Stream video data and output to video IPs. Choose this driver
+	  in a platform where the DisplayPort rx subsystem can be instantiated.
+
+config VIDEO_XILINX_SCD
+	tristate "Xilinx Scene Change Detect"
+	depends on VIDEO_XILINX
+	help
+	  Driver for Xilinx Scene Change Detection Controller.
+	  The driver allows applications to pass video buffers and
+	  provides if scene change detection is present between
+	  adjacent frames.
+
+config VIDEO_XILINX_M2M
+	tristate "Xilinx Video mem2mem"
+	depends on VIDEO_XILINX
+	select V4L2_MEM2MEM_DEV
+	help
+	  Driver for Xilinx V4L2 mem2mem pipeline operation to achieve memory
+	  copy between two different physical memories using DMA transfers.
+
+config VIDEO_XILINX_AXI4S_BROADCASTER
+	tristate "Xilinx AXI4-Stream Video Broadcaster"
+	depends on VIDEO_XILINX
+	help
+	  Driver for the Xilinx AXI4-Stream Video Broadcaster. This is a
+	  V4L sub device based driver. It replicates a single input AXI4-Stream
+	  into multiple output AXI4-Stream.
+	  Say M to modularize. Say N if unsure.
+
+config VIDEO_XILINX_AXI4S_SUBSETCONV
+	tristate "Xilinx AXI4-Stream Subset Converter"
+	depends on VIDEO_XILINX
+	help
+	  This subset converter driver is for configuring the Xilinx
+	  subset converter IP which is a non-memory mapped IP used for
+	  converting formats. The format conversion of source pad and
+	  sink pad in the pipeline done by subset conveter IP will be
+	  mapped in this driver.
+	  To compile this driver as a module, choose M here.
+	  If unsure, choose N
diff --git a/drivers/media/platform/xilinx/Makefile b/drivers/media/platform/xilinx/Makefile
index 6119a34f3..108af1e5f 100644
--- a/drivers/media/platform/xilinx/Makefile
+++ b/drivers/media/platform/xilinx/Makefile
@@ -1,8 +1,34 @@
 # SPDX-License-Identifier: GPL-2.0
 
+xilinx-scd-objs += xilinx-scenechange.o xilinx-scenechange-channel.o \
+		   xilinx-scenechange-dma.o
 xilinx-video-objs += xilinx-dma.o xilinx-vip.o xilinx-vipp.o
 
 obj-$(CONFIG_VIDEO_XILINX) += xilinx-video.o
+obj-$(CONFIG_VIDEO_XILINX_AXI4S_BROADCASTER) += xilinx-axis-broadcaster.o
+obj-$(CONFIG_VIDEO_XILINX_AXI4S_SUBSETCONV) += xilinx-axis-subsetconv.o
+obj-$(CONFIG_VIDEO_XILINX_AXI4S_SWITCH) += xilinx-axis-switch.o
+obj-$(CONFIG_VIDEO_XILINX_CFA) += xilinx-cfa.o
+obj-$(CONFIG_VIDEO_XILINX_CRESAMPLE) += xilinx-cresample.o
 obj-$(CONFIG_VIDEO_XILINX_CSI2RXSS) += xilinx-csi2rxss.o
+obj-$(CONFIG_VIDEO_XILINX_DEMOSAIC) += xilinx-demosaic.o
+obj-$(CONFIG_VIDEO_XILINX_DPRXSS) += xilinx-dprxss.o
+obj-$(CONFIG_VIDEO_XILINX_GAMMA) += xilinx-gamma.o
+obj-$(CONFIG_VIDEO_XILINX_HDCP1X_RX) += xilinx-hdcp1x-rx.o
+obj-$(CONFIG_VIDEO_XILINX_HDCP2X_RX) += xilinx-hdcp2x-rx.o \
+					xilinx-hdcp2x-rx-crypt.o
+obj-$(CONFIG_VIDEO_XILINX_HDMI21RXSS) += xilinx-hdmirxss.o
+obj-$(CONFIG_VIDEO_XILINX_HLS) += xilinx-hls.o
+obj-$(CONFIG_VIDEO_XILINX_ISP) += xilinx-isppipeline.o
+obj-$(CONFIG_VIDEO_XILINX_M2M) += xilinx-m2m.o
+obj-$(CONFIG_VIDEO_XILINX_MULTISCALER) += xilinx-multi-scaler.o
+obj-$(CONFIG_VIDEO_XILINX_REMAPPER) += xilinx-remapper.o
+obj-$(CONFIG_VIDEO_XILINX_RGB2YUV) += xilinx-rgb2yuv.o
+obj-$(CONFIG_VIDEO_XILINX_SCALER) += xilinx-scaler.o
+obj-$(CONFIG_VIDEO_XILINX_SCD) += xilinx-scd.o
+obj-$(CONFIG_VIDEO_XILINX_SDIRXSS) += xilinx-sdirxss.o
+obj-$(CONFIG_VIDEO_XILINX_SWITCH) += xilinx-switch.o
 obj-$(CONFIG_VIDEO_XILINX_TPG) += xilinx-tpg.o
+obj-$(CONFIG_VIDEO_XILINX_VPSS_CSC) += xilinx-vpss-csc.o
+obj-$(CONFIG_VIDEO_XILINX_VPSS_SCALER) += xilinx-vpss-scaler.o
 obj-$(CONFIG_VIDEO_XILINX_VTC) += xilinx-vtc.o
diff --git a/drivers/media/platform/xilinx/xilinx-axis-broadcaster.c b/drivers/media/platform/xilinx/xilinx-axis-broadcaster.c
new file mode 100644
index 000000000..4ad9bd213
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-axis-broadcaster.c
@@ -0,0 +1,288 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx AXI4-Stream Video Broadcaster
+ *
+ * Copyright (C) 2021 Xilinx, Inc.
+ *
+ * Author: Ronak Shah <ronak.shah@xilinx.com>
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/media-device.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define MAX_VBR_SINKS			1
+#define MIN_VBR_SRCS			2
+#define MAX_VBR_SRCS			16
+
+/**
+ * struct xvbroadcaster_device - AXI4-Stream Broadcaster device structure
+ * @dev: Platform structure
+ * @subdev: The v4l2 subdev structure
+ * @pads: media pads
+ * @formats: active V4L2 media bus formats on each pad
+ * @npads: number of pads
+ */
+struct xvbroadcaster_device {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	struct media_pad *pads;
+	struct v4l2_mbus_framefmt formats;
+	u32 npads;
+};
+
+static inline struct xvbroadcaster_device *to_xvbr(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xvbroadcaster_device, subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xvbr_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+xvbr_get_pad_format(struct xvbroadcaster_device *xvbr,
+		    struct v4l2_subdev_state *sd_state,
+		    unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&xvbr->subdev, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &xvbr->formats;
+	default:
+		return NULL;
+	}
+}
+
+static int xvbr_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xvbroadcaster_device *xvbr = to_xvbr(subdev);
+
+	fmt->format = *xvbr_get_pad_format(xvbr, sd_state, fmt->pad, fmt->which);
+
+	return 0;
+}
+
+static int xvbr_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xvbroadcaster_device *xvbr = to_xvbr(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = xvbr_get_pad_format(xvbr, sd_state, fmt->pad, fmt->which);
+
+	*format = fmt->format;
+
+	xvip_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xvbr_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xvbroadcaster_device *xvbr = to_xvbr(subdev);
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+
+	for (i = 0; i < xvbr->npads; ++i) {
+		format = v4l2_subdev_get_try_format(subdev, fh->state, i);
+		*format = xvbr->formats;
+	}
+
+	return 0;
+}
+
+static int xvbr_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops xvbr_video_ops = {
+	.s_stream = xvbr_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xvbr_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xvbr_get_format,
+	.set_fmt = xvbr_set_format,
+};
+
+static struct v4l2_subdev_ops xvbr_ops = {
+	.video = &xvbr_video_ops,
+	.pad = &xvbr_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xvbr_internal_ops = {
+	.open = xvbr_open,
+	.close = xvbr_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xvbr_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xvbr_parse_of(struct xvbroadcaster_device *xvbr)
+{
+	struct device_node *node = xvbr->dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		endpoint = of_get_next_child(port, NULL);
+		if (!endpoint) {
+			dev_err(xvbr->dev, "No port at\n");
+			return -EINVAL;
+		}
+
+		/* Count the number of ports. */
+		xvbr->npads++;
+	}
+
+	/* validate number of ports */
+	if ((xvbr->npads > (MAX_VBR_SINKS + MAX_VBR_SRCS)) ||
+	    (xvbr->npads < (MAX_VBR_SINKS + MIN_VBR_SRCS))) {
+		dev_err(xvbr->dev, "invalid number of ports %u\n", xvbr->npads);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xvbr_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xvbroadcaster_device *xvbr;
+	unsigned int i;
+	int ret;
+
+	xvbr = devm_kzalloc(&pdev->dev, sizeof(*xvbr), GFP_KERNEL);
+	if (!xvbr)
+		return -ENOMEM;
+
+	xvbr->dev = &pdev->dev;
+
+	ret = xvbr_parse_of(xvbr);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Initialize V4L2 subdevice and media entity
+	 */
+	xvbr->pads = devm_kzalloc(&pdev->dev, xvbr->npads * sizeof(*xvbr->pads),
+				  GFP_KERNEL);
+	if (!xvbr->pads)
+		return -ENOMEM;
+
+	xvbr->pads[0].flags = MEDIA_PAD_FL_SINK;
+
+	for (i = 1; i < xvbr->npads; ++i)
+		xvbr->pads[i].flags = MEDIA_PAD_FL_SOURCE;
+
+	xvbr->formats.code = MEDIA_BUS_FMT_RGB888_1X24;
+	xvbr->formats.field = V4L2_FIELD_NONE;
+	xvbr->formats.colorspace = V4L2_COLORSPACE_SRGB;
+	xvbr->formats.width = XVIP_MAX_WIDTH;
+	xvbr->formats.height = XVIP_MAX_HEIGHT;
+
+	subdev = &xvbr->subdev;
+	v4l2_subdev_init(subdev, &xvbr_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xvbr_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xvbr);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	subdev->entity.ops = &xvbr_media_ops;
+
+	ret = media_entity_pads_init(&subdev->entity, xvbr->npads, xvbr->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xvbr);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(xvbr->dev, "Xilinx AXI4-Stream Broadcaster found!\n");
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+
+	return ret;
+}
+
+static int xvbr_remove(struct platform_device *pdev)
+{
+	struct xvbroadcaster_device *xvbr = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xvbr->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id xvbr_of_id_table[] = {
+	{ .compatible = "xlnx,axis-broadcaster-1.1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xvbr_of_id_table);
+
+static struct platform_driver xvbr_driver = {
+	.driver = {
+		.name		= "xilinx-axis-broadcaster",
+		.of_match_table	= xvbr_of_id_table,
+	},
+	.probe			= xvbr_probe,
+	.remove			= xvbr_remove,
+};
+
+module_platform_driver(xvbr_driver);
+
+MODULE_AUTHOR("Ronak Shah <ronak.shah@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx AXI4-Stream Broadcaster Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-axis-subsetconv.c b/drivers/media/platform/xilinx/xilinx-axis-subsetconv.c
new file mode 100644
index 000000000..c0f42505b
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-axis-subsetconv.c
@@ -0,0 +1,355 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Axis Subset Converter Driver
+ *
+ * Copyright (C) 2022 Xilinx, Inc.
+ *
+ * Authors: Anil Kumar M <anil.mamidal@xilinx.com>
+ *          Karthikeyan T <karthikeyan.thangavel@xilinx.com>
+ *
+ * This converter driver is for matching the format of source pad
+ * and sink pad in the media pipeline. The format of a source does
+ * not match the sink pad if it is converted by a non-memory mapped
+ * hardware IP. This subset converter driver is for non-memory mapped
+ * axi stream subset converter which converts the format of the stream.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/v4l2-subdev.h>
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+#include "xilinx-vip.h"
+
+/* Number of media pads */
+#define XSUBSETCONV_MEDIA_PADS		(2)
+
+#define XSUBSETCONV_DEFAULT_WIDTH	(1920)
+#define XSUBSETCONV_DEFAULT_HEIGHT	(1080)
+
+/**
+ * struct xsubsetconv_state - SW format converter device structure
+ * @dev: Core structure for SW format converter
+ * @subdev: The v4l2 subdev structure
+ * @formats: Active V4L2 formats on each pad
+ * @lock: mutex for serializing operations
+ * @pads: media pads
+ *
+ * This structure contains the device driver related parameters
+ */
+struct xsubsetconv_state {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	struct v4l2_mbus_framefmt formats[2];
+	struct mutex lock; /* mutex lock for serializing operations */
+	struct media_pad pads[XSUBSETCONV_MEDIA_PADS];
+};
+
+static const struct of_device_id xsubsetconv_of_id_table[] = {
+	{ .compatible = "xlnx,axis-subsetconv-1.1"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xsubsetconv_of_id_table);
+
+static inline struct xsubsetconv_state *
+to_xsubsetconvstate(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xsubsetconv_state, subdev);
+}
+
+static struct v4l2_mbus_framefmt *
+xsubsetconv_get_pad_format(struct xsubsetconv_state *xsubsetconv,
+			   struct v4l2_subdev_state *state,
+			   unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xsubsetconv->subdev, state, pad);
+		break;
+
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format =  &xsubsetconv->formats[pad];
+		break;
+
+	default:
+		format = NULL;
+	}
+
+	return format;
+}
+
+/**
+ * xsubsetconv_get_format - Get the pad format
+ * @sd: pointer to v4l2 sub device structure
+ * @state: pointer to sub device pad information structure
+ * @fmt: pointer to pad level media bus format
+ *
+ * This function is used to get the pad format information.
+ *
+ * Return: -EINVAL or 0 on success
+ */
+static int xsubsetconv_get_format(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xsubsetconv_state *xsubsetconv = to_xsubsetconvstate(sd);
+	struct v4l2_mbus_framefmt *get_fmt;
+	int ret = 0;
+
+	mutex_lock(&xsubsetconv->lock);
+	get_fmt = xsubsetconv_get_pad_format(xsubsetconv, state,
+					     fmt->pad, fmt->which);
+
+	if (!get_fmt) {
+		ret = -EINVAL;
+		goto unlock_get_format;
+	}
+	fmt->format = *get_fmt;
+
+unlock_get_format:
+	mutex_unlock(&xsubsetconv->lock);
+
+	return ret;
+}
+
+/**
+ * xsubsetconv_set_format - This is used to set the pad format
+ * @sd: Pointer to V4L2 Sub device structure
+ * @state: Pointer to sub device pad information structure
+ * @fmt: Pointer to pad level media bus format
+ *
+ * This function is used to set the pad format.
+ * Since the pad format is converted in hardware which is not
+ * memory based IP, this driver will convert the source pad format
+ * to the hardware outputting sink pad format. It actually cannot
+ * convert any format.
+ *
+ * Return: -EINVAL or 0 on success
+ */
+static int xsubsetconv_set_format(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *format;
+	struct xsubsetconv_state *xsubsetconv = to_xsubsetconvstate(sd);
+	unsigned int src_code;
+	int ret = 0;
+
+	mutex_lock(&xsubsetconv->lock);
+
+	format = xsubsetconv_get_pad_format(xsubsetconv, state,
+					    fmt->pad, fmt->which);
+	if (!format) {
+		dev_err(xsubsetconv->dev, "get pad format error\n");
+		ret = -EINVAL;
+		goto unlock_set_fmt;
+	}
+
+	/* Restore the original pad format code */
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		struct v4l2_mbus_framefmt *sink_fmt;
+
+		sink_fmt = xsubsetconv_get_pad_format(xsubsetconv, state,
+						      XVIP_PAD_SINK, fmt->which);
+		if (!sink_fmt) {
+			dev_err(xsubsetconv->dev, "get sink pad format error\n");
+			ret = -EINVAL;
+			goto unlock_set_fmt;
+		}
+		/*
+		 * TODO: Need to add a check to compare sink format and possible
+		 *		 src format supported by subset converter
+		 */
+		*format = *sink_fmt;
+		format->code = fmt->format.code;
+
+	} else {
+		struct v4l2_mbus_framefmt *src_fmt;
+
+		src_fmt = xsubsetconv_get_pad_format(xsubsetconv, state,
+						     XVIP_PAD_SOURCE, fmt->which);
+		if (!src_fmt) {
+			dev_err(xsubsetconv->dev, "get source pad format error\n");
+			ret = -EINVAL;
+			goto unlock_set_fmt;
+		}
+
+		*format = fmt->format;
+		src_code = src_fmt->code;
+		*src_fmt = *format;
+		src_fmt->code = src_code;
+	}
+
+unlock_set_fmt:
+	mutex_unlock(&xsubsetconv->lock);
+
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xsubsetconv_media_ops = {
+	.link_validate = v4l2_subdev_link_validate
+};
+
+static struct v4l2_subdev_pad_ops xsubsetconv_pad_ops = {
+	.get_fmt = xsubsetconv_get_format,
+	.set_fmt = xsubsetconv_set_format,
+};
+
+static struct v4l2_subdev_ops xsubsetconv_ops = {
+	.pad = &xsubsetconv_pad_ops
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xsubsetconv_parse_of(struct xsubsetconv_state *xsubsetconv)
+{
+	struct device_node *node = xsubsetconv->dev->of_node;
+	struct device_node *ports = NULL;
+	struct device_node *port = NULL;
+	unsigned int nports = 0;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		endpoint = of_get_next_child(port, NULL);
+		if (!endpoint) {
+			dev_err(xsubsetconv->dev, "No port at\n");
+			return -EINVAL;
+		}
+
+		dev_dbg(xsubsetconv->dev, "%s : port %d\n", __func__, nports);
+
+		/* Count the number of ports. */
+		nports++;
+	}
+
+	if (nports != XSUBSETCONV_MEDIA_PADS) {
+		dev_err(xsubsetconv->dev, "invalid number of ports %u\n", nports);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xsubsetconv_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xsubsetconv_state *xsubsetconv;
+	int ret;
+
+	xsubsetconv = devm_kzalloc(&pdev->dev, sizeof(*xsubsetconv), GFP_KERNEL);
+	if (!xsubsetconv)
+		return -ENOMEM;
+
+	xsubsetconv->dev = &pdev->dev;
+
+	ret = xsubsetconv_parse_of(xsubsetconv);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "xsubsetconv_parse_of ret = %d\n", ret);
+		return ret;
+	}
+
+	mutex_init(&xsubsetconv->lock);
+
+	/* Initialize V4L2 subdevice and media entity */
+	xsubsetconv->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xsubsetconv->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize the sink format */
+	memset(&xsubsetconv->formats[XVIP_PAD_SINK], 0,
+	       sizeof(xsubsetconv->formats[0]));
+	xsubsetconv->formats[XVIP_PAD_SINK].code = MEDIA_BUS_FMT_RGB888_1X24;
+	xsubsetconv->formats[XVIP_PAD_SINK].field = V4L2_FIELD_NONE;
+	xsubsetconv->formats[XVIP_PAD_SINK].colorspace = V4L2_COLORSPACE_SRGB;
+	xsubsetconv->formats[XVIP_PAD_SINK].width = XSUBSETCONV_DEFAULT_WIDTH;
+	xsubsetconv->formats[XVIP_PAD_SINK].height = XSUBSETCONV_DEFAULT_HEIGHT;
+
+	xsubsetconv->formats[XVIP_PAD_SOURCE] = xsubsetconv->formats[XVIP_PAD_SINK];
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xsubsetconv->subdev;
+
+	v4l2_subdev_init(subdev, &xsubsetconv_ops);
+
+	subdev->dev = &pdev->dev;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	subdev->entity.ops = &xsubsetconv_media_ops;
+
+	v4l2_set_subdevdata(subdev, xsubsetconv);
+
+	ret = media_entity_pads_init(&subdev->entity, XSUBSETCONV_MEDIA_PADS,
+				     xsubsetconv->pads);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "media pad init failed = %d\n", ret);
+		mutex_destroy(&xsubsetconv->lock);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, xsubsetconv);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(&pdev->dev, "Xilinx AXI4-Stream Subset Converter found!\n");
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	mutex_destroy(&xsubsetconv->lock);
+
+	return ret;
+}
+
+static int xsubsetconv_remove(struct platform_device *pdev)
+{
+	struct xsubsetconv_state *xsubsetconv = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xsubsetconv->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	mutex_destroy(&xsubsetconv->lock);
+
+	return 0;
+}
+
+static struct platform_driver xsubsetconv_driver = {
+	.driver = {
+		.name		= "xlnx,axis-subsetconv-1.1",
+		.of_match_table	= xsubsetconv_of_id_table,
+	},
+	.probe			= xsubsetconv_probe,
+	.remove			= xsubsetconv_remove,
+};
+
+module_platform_driver(xsubsetconv_driver);
+
+MODULE_AUTHOR("Anil Kumar M <anil.mamidal@xilinx.com>");
+MODULE_AUTHOR("Karthikeyan T <karthikeyan.thangavel@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx AXI4-Stream Subset Converter Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-axis-switch.c b/drivers/media/platform/xilinx/xilinx-axis-switch.c
new file mode 100644
index 000000000..97391171a
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-axis-switch.c
@@ -0,0 +1,630 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx AXI4-Stream Video Switch
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Author: Vishal Sagar <vishal.sagar@xilinx.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/media-device.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XVSW_CTRL_REG			0x00
+#define XVSW_CTRL_REG_UPDATE_MASK	BIT(1)
+
+#define XVSW_MI_MUX_REG_BASE		0x40
+#define XVSW_MI_MUX_VAL_MASK		0xF
+#define XVSW_MI_MUX_DISABLE_MASK	BIT(31)
+
+#define MIN_VSW_SINKS			1
+#define MAX_VSW_SINKS			16
+#define MIN_VSW_SRCS			1
+#define MAX_VSW_SRCS			16
+
+/**
+ * struct xvswitch_device - Xilinx AXI4-Stream Switch device structure
+ * @dev: Platform structure
+ * @iomem: Base address of IP
+ * @subdev: The v4l2 subdev structure
+ * @pads: media pads
+ * @routing: sink pad connected to each source pad (-1 if none)
+ * @formats: active V4L2 media bus formats on sink pads
+ * @nsinks: number of sink pads (1 to 8)
+ * @nsources: number of source pads (2 to 8)
+ * @tdest_routing: Whether TDEST routing is enabled
+ * @aclk: Video clock
+ * @saxi_ctlclk: AXI-Lite control clock
+ */
+struct xvswitch_device {
+	struct device *dev;
+	void __iomem *iomem;
+	struct v4l2_subdev subdev;
+	struct media_pad *pads;
+	int routing[MAX_VSW_SRCS];
+	struct v4l2_mbus_framefmt *formats;
+	u32 nsinks;
+	u32 nsources;
+	bool tdest_routing;
+	struct clk *aclk;
+	struct clk *saxi_ctlclk;
+};
+
+static inline struct xvswitch_device *to_xvsw(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xvswitch_device, subdev);
+}
+
+static inline u32 xvswitch_read(struct xvswitch_device *xvsw, u32 addr)
+{
+	return ioread32(xvsw->iomem + addr);
+}
+
+static inline void xvswitch_write(struct xvswitch_device *xvsw, u32 addr,
+				  u32 value)
+{
+	iowrite32(value, xvsw->iomem + addr);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xvsw_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xvswitch_device *xvsw = to_xvsw(subdev);
+	unsigned int i;
+
+	/* Nothing to be done in case of TDEST routing */
+	if (xvsw->tdest_routing)
+		return 0;
+
+	if (!enable) {
+		/* In control reg routing, disable all master ports */
+		for (i = 0; i < xvsw->nsources; i++) {
+			xvswitch_write(xvsw, XVSW_MI_MUX_REG_BASE + (i * 4),
+				       XVSW_MI_MUX_DISABLE_MASK);
+		}
+		xvswitch_write(xvsw, XVSW_CTRL_REG, XVSW_CTRL_REG_UPDATE_MASK);
+		return 0;
+	}
+
+	/*
+	 * In case of control reg routing,
+	 * from routing table write the values into respective reg
+	 * and enable
+	 */
+	for (i = 0; i < MAX_VSW_SRCS; i++) {
+		u32 val;
+
+		if (xvsw->routing[i] != -1)
+			val = xvsw->routing[i];
+		else
+			val = XVSW_MI_MUX_DISABLE_MASK;
+
+		xvswitch_write(xvsw, XVSW_MI_MUX_REG_BASE + (i * 4),
+			       val);
+	}
+
+	xvswitch_write(xvsw, XVSW_CTRL_REG, XVSW_CTRL_REG_UPDATE_MASK);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+xvsw_get_pad_format(struct xvswitch_device *xvsw,
+		    struct v4l2_subdev_state *sd_state,
+		    unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *get_fmt;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		get_fmt = v4l2_subdev_get_try_format(&xvsw->subdev, sd_state,
+						     pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		get_fmt = &xvsw->formats[pad];
+		break;
+	default:
+		get_fmt = NULL;
+		break;
+	}
+
+	return get_fmt;
+}
+
+static int xvsw_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xvswitch_device *xvsw = to_xvsw(subdev);
+	int pad = fmt->pad;
+	struct v4l2_mbus_framefmt *get_fmt;
+
+	/*
+	 * If control reg routing and pad is source pad then
+	 * get corresponding sink pad. if no sink pad then
+	 * clear the format and return
+	 */
+
+	if (!xvsw->tdest_routing && pad >= xvsw->nsinks) {
+		pad = xvsw->routing[pad - xvsw->nsinks];
+		if (pad < 0) {
+			memset(&fmt->format, 0, sizeof(fmt->format));
+			return 0;
+		}
+	}
+
+	get_fmt = xvsw_get_pad_format(xvsw, sd_state, pad, fmt->which);
+	if (!get_fmt)
+		return -EINVAL;
+
+	fmt->format = *get_fmt;
+
+	return 0;
+}
+
+static int xvsw_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xvswitch_device *xvsw = to_xvsw(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	if (!xvsw->tdest_routing && fmt->pad >= xvsw->nsinks) {
+		/*
+		 * In case of control reg routing,
+		 * get the corresponding sink pad to source pad passed.
+		 *
+		 * The source pad format is always identical to the
+		 * sink pad format and can't be modified.
+		 *
+		 * If sink pad found then get_format for that pad
+		 * else clear the fmt->format as the source pad
+		 * isn't connected and return.
+		 */
+		return xvsw_get_format(subdev, sd_state, fmt);
+	}
+
+	if (xvsw->nsinks == 1 && fmt->pad != 0) {
+		struct v4l2_mbus_framefmt *sinkformat;
+
+		/*
+		 * in tdest routing if there is only one sink then all the
+		 * source pads will have same property as sink pad, assuming
+		 * streams going to each source pad will have same
+		 * properties.
+		 */
+
+		/* get sink pad format */
+		sinkformat = xvsw_get_pad_format(xvsw, sd_state, 0, fmt->which);
+		if (!sinkformat)
+			return -EINVAL;
+
+		fmt->format = *sinkformat;
+
+		/* set sink pad format on source pad */
+		format = xvsw_get_pad_format(xvsw, sd_state, fmt->pad, fmt->which);
+		if (!format)
+			return -EINVAL;
+
+		*format = *sinkformat;
+
+		return 0;
+	}
+
+	/*
+	 * In TDEST routing mode, one can set any format on the pad as
+	 * it can't be checked which pad's data will travel to
+	 * which pad. E.g. In a system with 2 slaves and 4 masters,
+	 * S0 or S1 data can reach M0 thru M3 based on TDEST
+	 * S0 may have RBG and S1 may have YUV. M0, M1 stream RBG
+	 * and M2, M3 stream YUV based on TDEST.
+	 *
+	 * In Control reg routing mode, set format only for sink pads.
+	 */
+	format = xvsw_get_pad_format(xvsw, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	format->code = fmt->format.code;
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xvsw_get_routing(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_routing *route)
+{
+	struct xvswitch_device *xvsw = to_xvsw(subdev);
+	unsigned int i;
+	u32 min;
+
+	/* In case of tdest routing, we can't get routing */
+	if (xvsw->tdest_routing)
+		return -EINVAL;
+
+	mutex_lock(&subdev->entity.graph_obj.mdev->graph_mutex);
+
+	if (xvsw->nsources < route->num_routes)
+		min = xvsw->nsources;
+	else
+		min = route->num_routes;
+
+	for (i = 0; i < min; ++i) {
+		route->routes[i].sink = xvsw->routing[i];
+		route->routes[i].source = i;
+	}
+
+	route->num_routes = xvsw->nsources;
+
+	mutex_unlock(&subdev->entity.graph_obj.mdev->graph_mutex);
+
+	return 0;
+}
+
+static int xvsw_set_routing(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_routing *route)
+{
+	struct xvswitch_device *xvsw = to_xvsw(subdev);
+	unsigned int i;
+	int ret = 0;
+
+	/* In case of tdest routing, we can't set routing */
+	if (xvsw->tdest_routing)
+		return -EINVAL;
+
+	mutex_lock(&subdev->entity.graph_obj.mdev->graph_mutex);
+
+	if (media_entity_pipeline(&subdev->entity)) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	for (i = 0; i < xvsw->nsources; ++i)
+		xvsw->routing[i] = -1;
+
+	for (i = 0; i < route->num_routes; ++i)
+		xvsw->routing[route->routes[i].source - xvsw->nsinks] =
+			route->routes[i].sink;
+
+done:
+	mutex_unlock(&subdev->entity.graph_obj.mdev->graph_mutex);
+	return ret;
+}
+
+static int xvsw_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static int xvsw_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops xvsw_video_ops = {
+	.s_stream = xvsw_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xvsw_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xvsw_get_format,
+	.set_fmt = xvsw_set_format,
+	.get_routing = xvsw_get_routing,
+	.set_routing = xvsw_set_routing,
+};
+
+static struct v4l2_subdev_ops xvsw_ops = {
+	.video = &xvsw_video_ops,
+	.pad = &xvsw_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xvsw_internal_ops = {
+	.open = xvsw_open,
+	.close = xvsw_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static bool xvsw_has_route(struct media_entity *entity, unsigned int pad0,
+			   unsigned int pad1)
+{
+	struct xvswitch_device *xvsw =
+		container_of(entity, struct xvswitch_device, subdev.entity);
+	unsigned int sink0, sink1;
+
+	/* Two sinks are never connected together. */
+	if (pad0 < xvsw->nsinks && pad1 < xvsw->nsinks)
+		return false;
+
+	/* In TDEST routing, assume all sinks and sources are connected */
+	if (xvsw->tdest_routing)
+		return true;
+
+	sink0 = pad0 < xvsw->nsinks ? pad0 : xvsw->routing[pad0 - xvsw->nsinks];
+	sink1 = pad1 < xvsw->nsinks ? pad1 : xvsw->routing[pad1 - xvsw->nsinks];
+
+	return sink0 == sink1;
+}
+
+static const struct media_entity_operations xvsw_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+	.has_route = xvsw_has_route,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xvsw_parse_of(struct xvswitch_device *xvsw)
+{
+	struct device_node *node = xvsw->dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	unsigned int nports = 0;
+	u32 routing_mode = 0;
+	int ret;
+
+	ret = of_property_read_u32(node, "xlnx,num-si-slots", &xvsw->nsinks);
+	if (ret < 0 || xvsw->nsinks < MIN_VSW_SINKS ||
+	    xvsw->nsinks > MAX_VSW_SINKS) {
+		dev_err(xvsw->dev, "missing or invalid xlnx,num-si-slots property\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,num-mi-slots", &xvsw->nsources);
+	if (ret < 0 || xvsw->nsources < MIN_VSW_SRCS ||
+	    xvsw->nsources > MAX_VSW_SRCS) {
+		dev_err(xvsw->dev, "missing or invalid xlnx,num-mi-slots property\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,routing-mode", &routing_mode);
+	if (ret < 0 || routing_mode > 1) {
+		dev_err(xvsw->dev, "missing or invalid xlnx,routing property\n");
+		return ret;
+	}
+
+	if (!routing_mode)
+		xvsw->tdest_routing = true;
+
+	xvsw->aclk = devm_clk_get(xvsw->dev, "aclk");
+	if (IS_ERR(xvsw->aclk)) {
+		ret = PTR_ERR(xvsw->aclk);
+		dev_err(xvsw->dev, "failed to get ap_clk (%d)\n", ret);
+		return ret;
+	}
+
+	if (!xvsw->tdest_routing) {
+		xvsw->saxi_ctlclk = devm_clk_get(xvsw->dev,
+						 "s_axi_ctl_clk");
+		if (IS_ERR(xvsw->saxi_ctlclk)) {
+			ret = PTR_ERR(xvsw->saxi_ctlclk);
+			dev_err(xvsw->dev,
+				"failed to get s_axi_ctl_clk (%d)\n",
+				ret);
+			return ret;
+		}
+	}
+
+	if (xvsw->tdest_routing && xvsw->nsinks > 1) {
+		dev_err(xvsw->dev, "sinks = %d. Driver Limitation max 1 sink in TDEST routing mode\n",
+			xvsw->nsinks);
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		endpoint = of_get_next_child(port, NULL);
+		if (!endpoint) {
+			dev_err(xvsw->dev, "No port at\n");
+			return -EINVAL;
+		}
+
+		/* Count the number of ports. */
+		nports++;
+	}
+
+	/* validate number of ports */
+	if (nports != (xvsw->nsinks + xvsw->nsources)) {
+		dev_err(xvsw->dev, "invalid number of ports %u\n", nports);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xvsw_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xvswitch_device *xvsw;
+	struct resource *res;
+	unsigned int npads;
+	unsigned int i, padcount;
+	int ret;
+
+	xvsw = devm_kzalloc(&pdev->dev, sizeof(*xvsw), GFP_KERNEL);
+	if (!xvsw)
+		return -ENOMEM;
+
+	xvsw->dev = &pdev->dev;
+
+	ret = xvsw_parse_of(xvsw);
+	if (ret < 0)
+		return ret;
+
+	/* ioremap only if control reg based routing */
+	if (!xvsw->tdest_routing) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		xvsw->iomem = devm_ioremap_resource(xvsw->dev, res);
+		if (IS_ERR(xvsw->iomem))
+			return PTR_ERR(xvsw->iomem);
+	}
+
+	/*
+	 * Initialize V4L2 subdevice and media entity. Pad numbers depend on the
+	 * number of pads.
+	 */
+	npads = xvsw->nsinks + xvsw->nsources;
+	xvsw->pads = devm_kzalloc(&pdev->dev, npads * sizeof(*xvsw->pads),
+				  GFP_KERNEL);
+	if (!xvsw->pads)
+		return -ENOMEM;
+
+	for (i = 0; i < xvsw->nsinks; ++i)
+		xvsw->pads[i].flags = MEDIA_PAD_FL_SINK;
+
+	for (; i < npads; ++i)
+		xvsw->pads[i].flags = MEDIA_PAD_FL_SOURCE;
+
+	padcount = xvsw->tdest_routing ? npads : xvsw->nsinks;
+
+	/*
+	 * In case of tdest routing, allocate format per pad.
+	 * source pad format has to match one of the sink pads in tdest routing.
+	 *
+	 * Otherwise only allocate for sinks as sources will
+	 * get the same pad format and corresponding sink.
+	 * set format on src pad will return corresponding sinks data.
+	 */
+	xvsw->formats = devm_kzalloc(&pdev->dev,
+				     padcount * sizeof(*xvsw->formats),
+				     GFP_KERNEL);
+	if (!xvsw->formats) {
+		dev_err(xvsw->dev, "No memory to allocate formats!\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < padcount; i++) {
+		xvsw->formats[i].code = MEDIA_BUS_FMT_RGB888_1X24;
+		xvsw->formats[i].field = V4L2_FIELD_NONE;
+		xvsw->formats[i].colorspace = V4L2_COLORSPACE_SRGB;
+		xvsw->formats[i].width = XVIP_MAX_WIDTH;
+		xvsw->formats[i].height = XVIP_MAX_HEIGHT;
+	}
+
+	/*
+	 * Initialize the routing table if none are connected.
+	 * Routing table is valid only incase routing is not TDEST based.
+	 */
+	for (i = 0; i < MAX_VSW_SRCS; ++i)
+		xvsw->routing[i] = -1;
+
+	ret = clk_prepare_enable(xvsw->aclk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable aclk (%d)\n",
+			ret);
+		return ret;
+	}
+
+	if (!xvsw->tdest_routing) {
+		ret = clk_prepare_enable(xvsw->saxi_ctlclk);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to enable s_axi_ctl_clk (%d)\n",
+				ret);
+			clk_disable_unprepare(xvsw->aclk);
+			return ret;
+		}
+	}
+
+	subdev = &xvsw->subdev;
+	v4l2_subdev_init(subdev, &xvsw_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xvsw_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xvsw);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	subdev->entity.ops = &xvsw_media_ops;
+
+	ret = media_entity_pads_init(&subdev->entity, npads, xvsw->pads);
+	if (ret < 0)
+		goto clk_error;
+
+	platform_set_drvdata(pdev, xvsw);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(xvsw->dev, "Xilinx AXI4-Stream Switch found!\n");
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+clk_error:
+	if (!xvsw->tdest_routing)
+		clk_disable_unprepare(xvsw->saxi_ctlclk);
+	clk_disable_unprepare(xvsw->aclk);
+	return ret;
+}
+
+static int xvsw_remove(struct platform_device *pdev)
+{
+	struct xvswitch_device *xvsw = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xvsw->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	if (!xvsw->tdest_routing)
+		clk_disable_unprepare(xvsw->saxi_ctlclk);
+	clk_disable_unprepare(xvsw->aclk);
+	return 0;
+}
+
+static const struct of_device_id xvsw_of_id_table[] = {
+	{ .compatible = "xlnx,axis-switch-1.1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xvsw_of_id_table);
+
+static struct platform_driver xvsw_driver = {
+	.driver = {
+		.name		= "xilinx-axis-switch",
+		.of_match_table	= xvsw_of_id_table,
+	},
+	.probe			= xvsw_probe,
+	.remove			= xvsw_remove,
+};
+
+module_platform_driver(xvsw_driver);
+
+MODULE_AUTHOR("Vishal Sagar <vishal.sagar@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx AXI4-Stream Switch Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-cfa.c b/drivers/media/platform/xilinx/xilinx-cfa.c
new file mode 100644
index 000000000..0ae19bb50
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-cfa.c
@@ -0,0 +1,410 @@
+/*
+ * Xilinx Color Filter Array
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XCFA_BAYER_PHASE	0x100
+#define XCFA_BAYER_PHASE_RGGB	0
+#define XCFA_BAYER_PHASE_GRBG	1
+#define XCFA_BAYER_PHASE_GBRG	2
+#define XCFA_BAYER_PHASE_BGGR	3
+
+/**
+ * struct xcfa_device - Xilinx CFA device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: Xilinx Video IP formats
+ */
+struct xcfa_device {
+	struct xvip_device xvip;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+};
+
+static inline struct xcfa_device *to_cfa(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xcfa_device, xvip.subdev);
+}
+
+/*
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xcfa_get_bayer_phase(const unsigned int code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return XCFA_BAYER_PHASE_RGGB;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		return XCFA_BAYER_PHASE_GRBG;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+		return XCFA_BAYER_PHASE_GBRG;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		return XCFA_BAYER_PHASE_BGGR;
+	}
+
+	return -EINVAL;
+}
+
+static int xcfa_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xcfa_device *xcfa = to_cfa(subdev);
+	const unsigned int code = xcfa->formats[XVIP_PAD_SINK].code;
+	u32 bayer_phase;
+
+	if (!enable) {
+		xvip_stop(&xcfa->xvip);
+		return 0;
+	}
+
+	/* This always returns the valid bayer phase value */
+	bayer_phase = xcfa_get_bayer_phase(code);
+
+	xvip_write(&xcfa->xvip, XCFA_BAYER_PHASE, bayer_phase);
+
+	xvip_set_frame_size(&xcfa->xvip, &xcfa->formats[XVIP_PAD_SINK]);
+
+	xvip_start(&xcfa->xvip);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+__xcfa_get_pad_format(struct xcfa_device *xcfa,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xcfa->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xcfa->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xcfa_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xcfa_device *xcfa = to_cfa(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xcfa_get_pad_format(xcfa, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xcfa_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xcfa_device *xcfa = to_cfa(subdev);
+	struct v4l2_mbus_framefmt *format;
+	int bayer_phase;
+
+	format = __xcfa_get_pad_format(xcfa, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	bayer_phase = xcfa_get_bayer_phase(fmt->format.code);
+	if (bayer_phase >= 0) {
+		xcfa->vip_formats[XVIP_PAD_SINK] =
+			xvip_get_format_by_code(fmt->format.code);
+		format->code = fmt->format.code;
+	}
+
+	xvip_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad */
+	format = __xcfa_get_pad_format(xcfa, sd_state, XVIP_PAD_SOURCE,
+				       fmt->which);
+
+	xvip_set_format_size(format, fmt);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Operations
+ */
+
+static int xcfa_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xcfa_device *xcfa = to_cfa(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xcfa->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SOURCE);
+	*format = xcfa->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xcfa_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops xcfa_video_ops = {
+	.s_stream = xcfa_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xcfa_pad_ops = {
+	.enum_mbus_code		= xvip_enum_mbus_code,
+	.enum_frame_size	= xvip_enum_frame_size,
+	.get_fmt		= xcfa_get_format,
+	.set_fmt		= xcfa_set_format,
+};
+
+static struct v4l2_subdev_ops xcfa_ops = {
+	.video  = &xcfa_video_ops,
+	.pad    = &xcfa_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xcfa_internal_ops = {
+	.open	= xcfa_open,
+	.close	= xcfa_close,
+};
+
+/*
+ * Media Operations
+ */
+
+static const struct media_entity_operations xcfa_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/*
+ * Power Management
+ */
+
+static int __maybe_unused xcfa_pm_suspend(struct device *dev)
+{
+	struct xcfa_device *xcfa = dev_get_drvdata(dev);
+
+	xvip_suspend(&xcfa->xvip);
+
+	return 0;
+}
+
+static int __maybe_unused xcfa_pm_resume(struct device *dev)
+{
+	struct xcfa_device *xcfa = dev_get_drvdata(dev);
+
+	xvip_resume(&xcfa->xvip);
+
+	return 0;
+}
+
+/*
+ * Platform Device Driver
+ */
+
+static int xcfa_parse_of(struct xcfa_device *xcfa)
+{
+	struct device *dev = xcfa->xvip.dev;
+	struct device_node *node = xcfa->xvip.dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id;
+	int ret;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct xvip_video_format *vip_format;
+
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "no reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "invalid reg in DT");
+				return -EINVAL;
+			}
+
+			xcfa->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	return 0;
+}
+
+static int xcfa_probe(struct platform_device *pdev)
+{
+	struct xcfa_device *xcfa;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	int ret;
+
+	xcfa = devm_kzalloc(&pdev->dev, sizeof(*xcfa), GFP_KERNEL);
+	if (!xcfa)
+		return -ENOMEM;
+
+	xcfa->xvip.dev = &pdev->dev;
+
+	ret = xcfa_parse_of(xcfa);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xcfa->xvip);
+	if (ret < 0)
+		return ret;
+
+	/* Reset and initialize the core */
+	xvip_reset(&xcfa->xvip);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xcfa->xvip.subdev;
+	v4l2_subdev_init(subdev, &xcfa_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xcfa_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xcfa);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &xcfa->default_formats[XVIP_PAD_SINK];
+	default_format->code = xcfa->vip_formats[XVIP_PAD_SINK]->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	xvip_get_frame_size(&xcfa->xvip, default_format);
+
+	xcfa->formats[XVIP_PAD_SINK] = *default_format;
+
+	default_format = &xcfa->default_formats[XVIP_PAD_SOURCE];
+	*default_format = xcfa->default_formats[XVIP_PAD_SINK];
+	default_format->code = xcfa->vip_formats[XVIP_PAD_SOURCE]->code;
+
+	xcfa->formats[XVIP_PAD_SOURCE] = *default_format;
+
+	xcfa->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xcfa->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xcfa_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, xcfa->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xcfa);
+
+	xvip_print_version(&xcfa->xvip);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xcfa->xvip);
+	return ret;
+}
+
+static int xcfa_remove(struct platform_device *pdev)
+{
+	struct xcfa_device *xcfa = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xcfa->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xcfa->xvip);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(xcfa_pm_ops, xcfa_pm_suspend, xcfa_pm_resume);
+
+static const struct of_device_id xcfa_of_id_table[] = {
+	{ .compatible = "xlnx,v-cfa-7.0" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xcfa_of_id_table);
+
+static struct platform_driver xcfa_driver = {
+	.driver			= {
+		.name		= "xilinx-cfa",
+		.pm		= &xcfa_pm_ops,
+		.of_match_table	= xcfa_of_id_table,
+	},
+	.probe			= xcfa_probe,
+	.remove			= xcfa_remove,
+};
+
+module_platform_driver(xcfa_driver);
+
+MODULE_DESCRIPTION("Xilinx Color Filter Array Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-cresample.c b/drivers/media/platform/xilinx/xilinx-cresample.c
new file mode 100644
index 000000000..5204b5e5c
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-cresample.c
@@ -0,0 +1,461 @@
+/*
+ * Xilinx Chroma Resampler
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XCRESAMPLE_ENCODING			0x100
+#define XCRESAMPLE_ENCODING_FIELD		(1 << 7)
+#define XCRESAMPLE_ENCODING_CHROMA		(1 << 8)
+
+/**
+ * struct xcresample_device - Xilinx CRESAMPLE device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: Xilinx Video IP formats
+ * @ctrl_handler: control handler
+ */
+struct xcresample_device {
+	struct xvip_device xvip;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+};
+
+static inline struct xcresample_device *to_cresample(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xcresample_device, xvip.subdev);
+}
+
+/*
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xcresample_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xcresample_device *xcresample = to_cresample(subdev);
+
+	if (!enable) {
+		xvip_stop(&xcresample->xvip);
+		return 0;
+	}
+
+	xvip_set_frame_size(&xcresample->xvip,
+			    &xcresample->formats[XVIP_PAD_SINK]);
+
+	xvip_start(&xcresample->xvip);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+__xcresample_get_pad_format(struct xcresample_device *xcresample,
+			    struct v4l2_subdev_state *sd_state,
+			    unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xcresample->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xcresample->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xcresample_get_format(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct xcresample_device *xcresample = to_cresample(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xcresample_get_pad_format(xcresample, sd_state, fmt->pad,
+					     fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xcresample_set_format(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct xcresample_device *xcresample = to_cresample(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xcresample_get_pad_format(xcresample, sd_state, fmt->pad,
+					     fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	xvip_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad. */
+	format = __xcresample_get_pad_format(xcresample, sd_state,
+					     XVIP_PAD_SOURCE, fmt->which);
+
+	xvip_set_format_size(format, fmt);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Operations
+ */
+
+static int xcresample_open(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_fh *fh)
+{
+	struct xcresample_device *xcresample = to_cresample(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xcresample->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SOURCE);
+	*format = xcresample->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xcresample_close(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static int xcresample_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct xcresample_device *xcresample =
+		container_of(ctrl->handler, struct xcresample_device,
+			     ctrl_handler);
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_CRESAMPLE_FIELD_PARITY:
+		xvip_clr_or_set(&xcresample->xvip, XCRESAMPLE_ENCODING,
+				XCRESAMPLE_ENCODING_FIELD, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_CRESAMPLE_CHROMA_PARITY:
+		xvip_clr_or_set(&xcresample->xvip, XCRESAMPLE_ENCODING,
+				XCRESAMPLE_ENCODING_CHROMA, ctrl->val);
+		return 0;
+	}
+
+	return -EINVAL;
+
+}
+
+static const struct v4l2_ctrl_ops xcresample_ctrl_ops = {
+	.s_ctrl	= xcresample_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops xcresample_video_ops = {
+	.s_stream = xcresample_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xcresample_pad_ops = {
+	.enum_mbus_code		= xvip_enum_mbus_code,
+	.enum_frame_size	= xvip_enum_frame_size,
+	.get_fmt		= xcresample_get_format,
+	.set_fmt		= xcresample_set_format,
+};
+
+static struct v4l2_subdev_ops xcresample_ops = {
+	.video  = &xcresample_video_ops,
+	.pad    = &xcresample_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xcresample_internal_ops = {
+	.open	= xcresample_open,
+	.close	= xcresample_close,
+};
+
+/*
+ * Control Configs
+ */
+
+static const char *const xcresample_parity_string[] = {
+	"Even",
+	"Odd",
+};
+
+static struct v4l2_ctrl_config xcresample_field = {
+	.ops	= &xcresample_ctrl_ops,
+	.id	= V4L2_CID_XILINX_CRESAMPLE_FIELD_PARITY,
+	.name	= "Chroma Resampler: Encoding Field Parity",
+	.type	= V4L2_CTRL_TYPE_MENU,
+	.min	= 0,
+	.max	= 1,
+	.qmenu	= xcresample_parity_string,
+};
+
+static struct v4l2_ctrl_config xcresample_chroma = {
+	.ops	= &xcresample_ctrl_ops,
+	.id	= V4L2_CID_XILINX_CRESAMPLE_CHROMA_PARITY,
+	.name	= "Chroma Resampler: Encoding Chroma Parity",
+	.type	= V4L2_CTRL_TYPE_MENU,
+	.min	= 0,
+	.max	= 1,
+	.qmenu	= xcresample_parity_string,
+};
+
+/*
+ * Media Operations
+ */
+
+static const struct media_entity_operations xcresample_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/*
+ * Power Management
+ */
+
+static int __maybe_unused xcresample_pm_suspend(struct device *dev)
+{
+	struct xcresample_device *xcresample = dev_get_drvdata(dev);
+
+	xvip_suspend(&xcresample->xvip);
+
+	return 0;
+}
+
+static int __maybe_unused xcresample_pm_resume(struct device *dev)
+{
+	struct xcresample_device *xcresample = dev_get_drvdata(dev);
+
+	xvip_resume(&xcresample->xvip);
+
+	return 0;
+}
+
+/*
+ * Platform Device Driver
+ */
+
+static int xcresample_parse_of(struct xcresample_device *xcresample)
+{
+	struct device *dev = xcresample->xvip.dev;
+	struct device_node *node = xcresample->xvip.dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id;
+	int ret;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct xvip_video_format *vip_format;
+
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "no reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "invalid reg in DT");
+				return -EINVAL;
+			}
+
+			xcresample->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	return 0;
+}
+
+static int xcresample_probe(struct platform_device *pdev)
+{
+	struct xcresample_device *xcresample;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	int ret;
+
+	xcresample = devm_kzalloc(&pdev->dev, sizeof(*xcresample), GFP_KERNEL);
+	if (!xcresample)
+		return -ENOMEM;
+
+	xcresample->xvip.dev = &pdev->dev;
+
+	ret = xcresample_parse_of(xcresample);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xcresample->xvip);
+	if (ret < 0)
+		return ret;
+
+	/* Reset and initialize the core */
+	xvip_reset(&xcresample->xvip);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xcresample->xvip.subdev;
+	v4l2_subdev_init(subdev, &xcresample_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xcresample_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xcresample);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &xcresample->default_formats[XVIP_PAD_SINK];
+	default_format->code = xcresample->vip_formats[XVIP_PAD_SINK]->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	xvip_get_frame_size(&xcresample->xvip, default_format);
+
+	xcresample->formats[XVIP_PAD_SINK] = *default_format;
+
+	default_format = &xcresample->default_formats[XVIP_PAD_SOURCE];
+	*default_format = xcresample->default_formats[XVIP_PAD_SINK];
+	default_format->code = xcresample->vip_formats[XVIP_PAD_SOURCE]->code;
+
+	xcresample->formats[XVIP_PAD_SOURCE] = *default_format;
+
+	xcresample->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xcresample->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xcresample_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, xcresample->pads);
+	if (ret < 0)
+		goto error;
+
+	v4l2_ctrl_handler_init(&xcresample->ctrl_handler, 2);
+	xcresample_field.def =
+		(xvip_read(&xcresample->xvip, XCRESAMPLE_ENCODING) &
+		 XCRESAMPLE_ENCODING_FIELD) ? 1 : 0;
+	v4l2_ctrl_new_custom(&xcresample->ctrl_handler, &xcresample_field,
+			     NULL);
+	xcresample_chroma.def =
+		(xvip_read(&xcresample->xvip, XCRESAMPLE_ENCODING) &
+		 XCRESAMPLE_ENCODING_CHROMA) ? 1 : 0;
+	v4l2_ctrl_new_custom(&xcresample->ctrl_handler, &xcresample_chroma,
+			     NULL);
+	if (xcresample->ctrl_handler.error) {
+		dev_err(&pdev->dev, "failed to add controls\n");
+		ret = xcresample->ctrl_handler.error;
+		goto error;
+	}
+	subdev->ctrl_handler = &xcresample->ctrl_handler;
+
+	platform_set_drvdata(pdev, xcresample);
+
+	xvip_print_version(&xcresample->xvip);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&xcresample->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xcresample->xvip);
+	return ret;
+}
+
+static int xcresample_remove(struct platform_device *pdev)
+{
+	struct xcresample_device *xcresample = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xcresample->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xcresample->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xcresample->xvip);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(xcresample_pm_ops, xcresample_pm_suspend,
+			 xcresample_pm_resume);
+
+static const struct of_device_id xcresample_of_id_table[] = {
+	{ .compatible = "xlnx,v-cresample-4.0" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xcresample_of_id_table);
+
+static struct platform_driver xcresample_driver = {
+	.driver			= {
+		.name		= "xilinx-cresample",
+		.pm		= &xcresample_pm_ops,
+		.of_match_table	= xcresample_of_id_table,
+	},
+	.probe			= xcresample_probe,
+	.remove			= xcresample_remove,
+};
+
+module_platform_driver(xcresample_driver);
+
+MODULE_DESCRIPTION("Xilinx Chroma Resampler Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-csi2rxss.c b/drivers/media/platform/xilinx/xilinx-csi2rxss.c
index 29b53febc..2434a1dc5 100644
--- a/drivers/media/platform/xilinx/xilinx-csi2rxss.c
+++ b/drivers/media/platform/xilinx/xilinx-csi2rxss.c
@@ -49,6 +49,7 @@
 
 #define XCSI_ISR_FR		BIT(31)
 #define XCSI_ISR_VCXFE		BIT(30)
+#define XCSI_ISR_YUV420		BIT(28)
 #define XCSI_ISR_WCC		BIT(22)
 #define XCSI_ISR_ILC		BIT(21)
 #define XCSI_ISR_SPFIFOF	BIT(20)
@@ -70,7 +71,7 @@
 #define XCSI_ISR_VC0FSYNCERR	BIT(1)
 #define XCSI_ISR_VC0FLVLERR	BIT(0)
 
-#define XCSI_ISR_ALLINTR_MASK	(0xc07e3fff)
+#define XCSI_ISR_ALLINTR_MASK	(0xd07e3fff)
 
 /*
  * Removed VCXFE mask as it doesn't exist in IER
@@ -138,6 +139,7 @@ struct xcsi2rxss_event {
 static const struct xcsi2rxss_event xcsi2rxss_events[] = {
 	{ XCSI_ISR_FR, "Frame Received" },
 	{ XCSI_ISR_VCXFE, "VCX Frame Errors" },
+	{ XCSI_ISR_YUV420, "YUV 420 Word Count Errors" },
 	{ XCSI_ISR_WCC, "Word Count Errors" },
 	{ XCSI_ISR_ILC, "Invalid Lane Count Error" },
 	{ XCSI_ISR_SPFIFOF, "Short Packet FIFO OverFlow Error" },
@@ -167,6 +169,7 @@ static const struct xcsi2rxss_event xcsi2rxss_events[] = {
  * and media bus formats
  */
 static const u32 xcsi2dt_mbus_lut[][2] = {
+	{ MIPI_CSI2_DT_YUV420_8B, MEDIA_BUS_FMT_VYYUYY8_1X24 },
 	{ MIPI_CSI2_DT_YUV422_8B, MEDIA_BUS_FMT_UYVY8_1X16 },
 	{ MIPI_CSI2_DT_YUV422_10B, MEDIA_BUS_FMT_UYVY10_1X20 },
 	{ MIPI_CSI2_DT_RGB444, 0 },
@@ -474,12 +477,15 @@ static int xcsi2rxss_log_status(struct v4l2_subdev *sd)
 static struct v4l2_subdev *xcsi2rxss_get_remote_subdev(struct media_pad *local)
 {
 	struct media_pad *remote;
+	struct v4l2_subdev *sd;
 
 	remote = media_pad_remote_pad_first(local);
 	if (!remote || !is_media_entity_v4l2_subdev(remote->entity))
-		return NULL;
+		sd = NULL;
+	else
+		sd = media_entity_to_v4l2_subdev(remote->entity);
 
-	return media_entity_to_v4l2_subdev(remote->entity);
+	return sd;
 }
 
 static int xcsi2rxss_start_stream(struct xcsi2rxss_state *state)
@@ -505,7 +511,14 @@ static int xcsi2rxss_start_stream(struct xcsi2rxss_state *state)
 	state->rsubdev =
 		xcsi2rxss_get_remote_subdev(&state->pads[XVIP_PAD_SINK]);
 
+	if (!state->rsubdev) {
+		ret = -ENODEV;
+		goto exit_start_stream;
+	}
+
 	ret = v4l2_subdev_call(state->rsubdev, video, s_stream, 1);
+
+exit_start_stream:
 	if (ret) {
 		/* disable interrupts */
 		xcsi2rxss_clr(state, XCSI_IER_OFFSET, XCSI_IER_INTR_MASK);
@@ -580,8 +593,11 @@ static irqreturn_t xcsi2rxss_irq_handler(int irq, void *data)
 	 * Stream line buffer full
 	 * This means there is a backpressure from downstream IP
 	 */
-	if (status & XCSI_ISR_SLBF) {
-		dev_alert_ratelimited(dev, "Stream Line Buffer Full!\n");
+	if (status & (XCSI_ISR_SLBF | XCSI_ISR_YUV420)) {
+		if (status & XCSI_ISR_SLBF)
+			dev_alert_ratelimited(dev, "Stream Line Buffer Full!\n");
+		if (status & XCSI_ISR_YUV420)
+			dev_alert_ratelimited(dev, "YUV 420 Word count error!\n");
 
 		/* disable interrupts */
 		xcsi2rxss_clr(state, XCSI_IER_OFFSET, XCSI_IER_INTR_MASK);
@@ -669,21 +685,28 @@ __xcsi2rxss_get_pad_format(struct xcsi2rxss_state *xcsi2rxss,
 			   struct v4l2_subdev_state *sd_state,
 			   unsigned int pad, u32 which)
 {
+	struct v4l2_mbus_framefmt *get_fmt;
+
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(&xcsi2rxss->subdev,
-						  sd_state, pad);
+		get_fmt = v4l2_subdev_get_try_format(&xcsi2rxss->subdev,
+						     sd_state, pad);
+		break;
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &xcsi2rxss->format;
+		get_fmt = &xcsi2rxss->format;
+		break;
 	default:
-		return NULL;
+		get_fmt = NULL;
+		break;
 	}
+
+	return get_fmt;
 }
 
 /**
  * xcsi2rxss_init_cfg - Initialise the pad format config to default
  * @sd: Pointer to V4L2 Sub device structure
- * @sd_state: Pointer to sub device state structure
+ * @cfg: Pointer to sub device pad information structure
  *
  * This function is used to initialize the pad format with the default
  * values.
@@ -710,7 +733,7 @@ static int xcsi2rxss_init_cfg(struct v4l2_subdev *sd,
 /**
  * xcsi2rxss_get_format - Get the pad format
  * @sd: Pointer to V4L2 Sub device structure
- * @sd_state: Pointer to sub device state structure
+ * @cfg: Pointer to sub device pad information structure
  * @fmt: Pointer to pad level media bus format
  *
  * This function is used to get the pad format information.
@@ -722,20 +745,30 @@ static int xcsi2rxss_get_format(struct v4l2_subdev *sd,
 				struct v4l2_subdev_format *fmt)
 {
 	struct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);
+	struct v4l2_mbus_framefmt *get_fmt;
+	int ret = 0;
 
 	mutex_lock(&xcsi2rxss->lock);
-	fmt->format = *__xcsi2rxss_get_pad_format(xcsi2rxss, sd_state,
-						  fmt->pad,
-						  fmt->which);
+
+	get_fmt = __xcsi2rxss_get_pad_format(xcsi2rxss, sd_state, fmt->pad,
+					     fmt->which);
+	if (!get_fmt) {
+		ret = -EINVAL;
+		goto unlock_get_format;
+	}
+
+	fmt->format = *get_fmt;
+
+unlock_get_format:
 	mutex_unlock(&xcsi2rxss->lock);
 
-	return 0;
+	return ret;
 }
 
 /**
  * xcsi2rxss_set_format - This is used to set the pad format
  * @sd: Pointer to V4L2 Sub device structure
- * @sd_state: Pointer to sub device state structure
+ * @cfg: Pointer to sub device pad information structure
  * @fmt: Pointer to pad level media bus format
  *
  * This function is used to set the pad format. Since the pad format is fixed
@@ -752,6 +785,7 @@ static int xcsi2rxss_set_format(struct v4l2_subdev *sd,
 	struct xcsi2rxss_state *xcsi2rxss = to_xcsi2rxssstate(sd);
 	struct v4l2_mbus_framefmt *__format;
 	u32 dt;
+	int ret = 0;
 
 	mutex_lock(&xcsi2rxss->lock);
 
@@ -762,12 +796,15 @@ static int xcsi2rxss_set_format(struct v4l2_subdev *sd,
 	 */
 	__format = __xcsi2rxss_get_pad_format(xcsi2rxss, sd_state,
 					      fmt->pad, fmt->which);
+	if (!__format) {
+		ret = -EINVAL;
+		goto unlock_set_format;
+	}
 
 	/* only sink pad format can be updated */
 	if (fmt->pad == XVIP_PAD_SOURCE) {
 		fmt->format = *__format;
-		mutex_unlock(&xcsi2rxss->lock);
-		return 0;
+		goto unlock_set_format;
 	}
 
 	/*
@@ -784,9 +821,11 @@ static int xcsi2rxss_set_format(struct v4l2_subdev *sd,
 	}
 
 	*__format = fmt->format;
+
+unlock_set_format:
 	mutex_unlock(&xcsi2rxss->lock);
 
-	return 0;
+	return ret;
 }
 
 /*
@@ -880,6 +919,7 @@ static int xcsi2rxss_parse_of(struct xcsi2rxss_state *xcsi2rxss)
 	}
 
 	switch (xcsi2rxss->datatype) {
+	case MIPI_CSI2_DT_YUV420_8B:
 	case MIPI_CSI2_DT_YUV422_8B:
 	case MIPI_CSI2_DT_RGB444:
 	case MIPI_CSI2_DT_RGB555:
diff --git a/drivers/media/platform/xilinx/xilinx-demosaic.c b/drivers/media/platform/xilinx/xilinx-demosaic.c
new file mode 100644
index 000000000..33b461294
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-demosaic.c
@@ -0,0 +1,436 @@
+/*
+ * Xilinx Video Demosaic IP
+ *
+ * Copyright (C) 2017 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XDEMOSAIC_AP_CTRL			(0x00)
+#define XDEMOSAIC_WIDTH				(0x10)
+#define XDEMOSAIC_HEIGHT			(0x18)
+#define XDEMOSAIC_INPUT_BAYER_FORMAT		(0x28)
+
+#define XDEMOSAIC_MIN_HEIGHT	(64)
+#define XDEMOSAIC_MAX_HEIGHT	(4320)
+#define XDEMOSAIC_DEF_HEIGHT	(720)
+#define XDEMOSAIC_MIN_WIDTH	(64)
+#define XDEMOSAIC_MAX_WIDTH	(8192)
+#define XDEMOSAIC_DEF_WIDTH	(1280)
+
+#define XDEMOSAIC_RESET_DEASSERT	(0)
+#define XDEMOSAIC_RESET_ASSERT		(1)
+#define XDEMOSAIC_START			BIT(0)
+#define XDEMOSAIC_AUTO_RESTART		BIT(7)
+#define XDEMOSAIC_STREAM_ON	(XDEMOSAIC_AUTO_RESTART | XDEMOSAIC_START)
+
+enum xdmsc_bayer_format {
+	XDEMOSAIC_RGGB = 0,
+	XDEMOSAIC_GRBG,
+	XDEMOSAIC_GBRG,
+	XDEMOSAIC_BGGR,
+};
+
+struct xdmsc_dev {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+
+	enum xdmsc_bayer_format bayer_fmt;
+	struct gpio_desc *rst_gpio;
+	u32 max_width;
+	u32 max_height;
+};
+
+static inline u32 xdmsc_read(struct xdmsc_dev *xdmsc, u32 reg)
+{
+	u32 data;
+
+	data = xvip_read(&xdmsc->xvip, reg);
+	dev_dbg(xdmsc->xvip.dev,
+		"Reading 0x%x from reg offset 0x%x", data, reg);
+	return data;
+}
+
+static inline void xdmsc_write(struct xdmsc_dev *xdmsc, u32 reg, u32 data)
+{
+	xvip_write(&xdmsc->xvip, reg, data);
+	dev_dbg(xdmsc->xvip.dev,
+		"Writing 0x%x to reg offset 0x%x", data, reg);
+#ifdef DEBUG
+	if (xdmsc_read(xdmsc, reg) != data)
+		dev_err(xdmsc->xvip.dev,
+			"Wrote 0x%x does not match read back", data);
+#endif
+}
+
+static inline struct xdmsc_dev *to_xdmsc(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xdmsc_dev, xvip.subdev);
+}
+
+static struct v4l2_mbus_framefmt
+*__xdmsc_get_pad_format(struct xdmsc_dev *xdmsc,
+			struct v4l2_subdev_state *sd_state,
+			unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *get_fmt;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		get_fmt = v4l2_subdev_get_try_format(&xdmsc->xvip.subdev,
+						     sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		get_fmt = &xdmsc->formats[pad];
+		break;
+	default:
+		get_fmt = NULL;
+		break;
+	}
+
+	return get_fmt;
+}
+
+static int xdmsc_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xdmsc_dev *xdmsc = to_xdmsc(subdev);
+
+	if (!enable) {
+		dev_dbg(xdmsc->xvip.dev, "%s : Off", __func__);
+		gpiod_set_value_cansleep(xdmsc->rst_gpio,
+					 XDEMOSAIC_RESET_ASSERT);
+		gpiod_set_value_cansleep(xdmsc->rst_gpio,
+					 XDEMOSAIC_RESET_DEASSERT);
+		return 0;
+	}
+
+	xdmsc_write(xdmsc, XDEMOSAIC_WIDTH,
+		    xdmsc->formats[XVIP_PAD_SINK].width);
+	xdmsc_write(xdmsc, XDEMOSAIC_HEIGHT,
+		    xdmsc->formats[XVIP_PAD_SINK].height);
+	xdmsc_write(xdmsc, XDEMOSAIC_INPUT_BAYER_FORMAT, xdmsc->bayer_fmt);
+
+	/* Start Demosaic Video IP */
+	xdmsc_write(xdmsc, XDEMOSAIC_AP_CTRL, XDEMOSAIC_STREAM_ON);
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops xdmsc_video_ops = {
+	.s_stream = xdmsc_s_stream,
+};
+
+static int xdmsc_get_format(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct xdmsc_dev *xdmsc = to_xdmsc(subdev);
+	struct v4l2_mbus_framefmt *get_fmt;
+
+	get_fmt = __xdmsc_get_pad_format(xdmsc, sd_state, fmt->pad, fmt->which);
+	if (!get_fmt)
+		return -EINVAL;
+
+	fmt->format = *get_fmt;
+
+	return 0;
+}
+
+static bool
+xdmsc_is_format_bayer(struct xdmsc_dev *xdmsc, u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SRGGB16_1X16:
+		xdmsc->bayer_fmt = XDEMOSAIC_RGGB;
+		break;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG16_1X16:
+		xdmsc->bayer_fmt = XDEMOSAIC_GRBG;
+		break;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGBRG16_1X16:
+		xdmsc->bayer_fmt = XDEMOSAIC_GBRG;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SBGGR16_1X16:
+		xdmsc->bayer_fmt = XDEMOSAIC_BGGR;
+		break;
+	default:
+		dev_dbg(xdmsc->xvip.dev, "Unsupported format for Sink Pad");
+		return false;
+	}
+	return true;
+}
+
+static int xdmsc_set_format(struct v4l2_subdev *subdev,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_format *fmt)
+{
+	struct xdmsc_dev *xdmsc = to_xdmsc(subdev);
+	struct v4l2_mbus_framefmt *__format;
+
+	__format = __xdmsc_get_pad_format(xdmsc, sd_state, fmt->pad, fmt->which);
+	if (!__format)
+		return -EINVAL;
+
+	*__format = fmt->format;
+
+	__format->width = clamp_t(unsigned int, fmt->format.width,
+				  XDEMOSAIC_MIN_WIDTH, xdmsc->max_width);
+	__format->height = clamp_t(unsigned int, fmt->format.height,
+				   XDEMOSAIC_MIN_HEIGHT, xdmsc->max_height);
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		if (__format->code != MEDIA_BUS_FMT_RBG888_1X24 &&
+		    __format->code != MEDIA_BUS_FMT_RBG101010_1X30 &&
+		    __format->code != MEDIA_BUS_FMT_RBG121212_1X36 &&
+		    __format->code != MEDIA_BUS_FMT_RBG161616_1X48) {
+			dev_dbg(xdmsc->xvip.dev,
+				"%s : Unsupported source media bus code format",
+				__func__);
+			__format->code = MEDIA_BUS_FMT_RBG888_1X24;
+		}
+	}
+
+	if (fmt->pad == XVIP_PAD_SINK) {
+		if (!xdmsc_is_format_bayer(xdmsc, __format->code)) {
+			dev_dbg(xdmsc->xvip.dev,
+				"Unsupported Sink Pad Media format, defaulting to RGGB");
+			__format->code = MEDIA_BUS_FMT_SRGGB8_1X8;
+		}
+	}
+
+	fmt->format = *__format;
+	return 0;
+}
+
+static int xdmsc_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xdmsc_dev *xdmsc = to_xdmsc(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xdmsc->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SOURCE);
+	*format = xdmsc->default_formats[XVIP_PAD_SOURCE];
+	return 0;
+}
+
+static int xdmsc_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops xdmsc_internal_ops = {
+	.open = xdmsc_open,
+	.close = xdmsc_close,
+};
+
+static const struct v4l2_subdev_pad_ops xdmsc_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xdmsc_get_format,
+	.set_fmt = xdmsc_set_format,
+};
+
+static const struct v4l2_subdev_ops xdmsc_ops = {
+	.video = &xdmsc_video_ops,
+	.pad = &xdmsc_pad_ops,
+};
+
+static const struct media_entity_operations xdmsc_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int xdmsc_parse_of(struct xdmsc_dev *xdmsc)
+{
+	struct device *dev = xdmsc->xvip.dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id = 0;
+	int rval;
+
+	rval = of_property_read_u32(node, "xlnx,max-height",
+				    &xdmsc->max_height);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,max-height property!");
+		return -EINVAL;
+	} else if (xdmsc->max_height > XDEMOSAIC_MAX_HEIGHT ||
+		 xdmsc->max_height < XDEMOSAIC_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u32(node, "xlnx,max-width",
+				    &xdmsc->max_width);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,max-width property!");
+		return -EINVAL;
+	} else if (xdmsc->max_width > XDEMOSAIC_MAX_WIDTH ||
+		 xdmsc->max_width < XDEMOSAIC_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			rval = of_property_read_u32(port, "reg", &port_id);
+			if (rval < 0) {
+				dev_err(dev, "No reg in DT");
+				return rval;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "Invalid reg in DT");
+				return -EINVAL;
+			}
+		}
+	}
+
+	xdmsc->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(xdmsc->rst_gpio)) {
+		if (PTR_ERR(xdmsc->rst_gpio) != -EPROBE_DEFER)
+			dev_err(dev, "Reset GPIO not setup in DT");
+		return PTR_ERR(xdmsc->rst_gpio);
+	}
+	return 0;
+}
+
+static int xdmsc_probe(struct platform_device *pdev)
+{
+	struct xdmsc_dev *xdmsc;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *def_fmt;
+	int rval;
+
+	xdmsc = devm_kzalloc(&pdev->dev, sizeof(*xdmsc), GFP_KERNEL);
+	if (!xdmsc)
+		return -ENOMEM;
+	xdmsc->xvip.dev = &pdev->dev;
+	rval = xdmsc_parse_of(xdmsc);
+	if (rval < 0)
+		return rval;
+	rval = xvip_init_resources(&xdmsc->xvip);
+	if (rval)
+		return -EIO;
+
+	/* Reset Demosaic IP */
+	gpiod_set_value_cansleep(xdmsc->rst_gpio,
+				 XDEMOSAIC_RESET_DEASSERT);
+
+	/* Init V4L2 subdev */
+	subdev = &xdmsc->xvip.subdev;
+	v4l2_subdev_init(subdev, &xdmsc_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xdmsc_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Default Formats Initialization */
+	def_fmt = &xdmsc->default_formats[XVIP_PAD_SINK];
+	def_fmt->field = V4L2_FIELD_NONE;
+	def_fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	def_fmt->width = XDEMOSAIC_DEF_WIDTH;
+	def_fmt->height = XDEMOSAIC_DEF_HEIGHT;
+
+	/*
+	 * Sink Pad can be any Bayer format.
+	 * Default Sink Pad format is RGGB.
+	 */
+	def_fmt->code = MEDIA_BUS_FMT_SRGGB8_1X8;
+	xdmsc->formats[XVIP_PAD_SINK] = *def_fmt;
+
+	def_fmt = &xdmsc->default_formats[XVIP_PAD_SOURCE];
+	*def_fmt = xdmsc->default_formats[XVIP_PAD_SINK];
+
+	/* Source Pad has a fixed media bus format of RGB */
+	def_fmt->code = MEDIA_BUS_FMT_RBG888_1X24;
+	xdmsc->formats[XVIP_PAD_SOURCE] = *def_fmt;
+
+	xdmsc->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xdmsc->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Init Media Entity */
+	subdev->entity.ops = &xdmsc_media_ops;
+	rval = media_entity_pads_init(&subdev->entity, 2, xdmsc->pads);
+	if (rval < 0)
+		goto media_error;
+
+	platform_set_drvdata(pdev, xdmsc);
+	rval = v4l2_async_register_subdev(subdev);
+	if (rval < 0) {
+		dev_err(&pdev->dev, "failed to register subdev");
+		goto v4l2_subdev_error;
+	}
+	dev_info(&pdev->dev,
+		 "Xilinx Video Demosaic Probe Successful");
+	return 0;
+
+v4l2_subdev_error:
+	media_entity_cleanup(&subdev->entity);
+media_error:
+	xvip_cleanup_resources(&xdmsc->xvip);
+	return rval;
+}
+
+static int xdmsc_remove(struct platform_device *pdev)
+{
+	struct xdmsc_dev *xdmsc = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xdmsc->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xdmsc->xvip);
+	return 0;
+}
+
+static const struct of_device_id xdmsc_of_id_table[] = {
+	{.compatible = "xlnx,v-demosaic"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xdmsc_of_id_table);
+
+static struct platform_driver xdmsc_driver = {
+	.driver = {
+		.name = "xilinx-demosaic",
+		.of_match_table = xdmsc_of_id_table,
+	},
+	.probe = xdmsc_probe,
+	.remove = xdmsc_remove,
+
+};
+
+module_platform_driver(xdmsc_driver);
+MODULE_DESCRIPTION("Xilinx Demosaic IP Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index 0a7fd8642..169f05efb 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -10,11 +10,13 @@
  */
 
 #include <linux/dma/xilinx_dma.h>
+#include <linux/dma/xilinx_frmbuf.h>
 #include <linux/lcm.h>
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/slab.h>
+#include <linux/xilinx-v4l2-controls.h>
 
 #include <media/v4l2-dev.h>
 #include <media/v4l2-fh.h>
@@ -26,9 +28,10 @@
 #include "xilinx-vip.h"
 #include "xilinx-vipp.h"
 
+#define XVIP_DMA_DEF_FORMAT		V4L2_PIX_FMT_YUYV
 #define XVIP_DMA_DEF_WIDTH		1920
 #define XVIP_DMA_DEF_HEIGHT		1080
-
+#define XVIP_DMA_DEF_WIDTH_ALIGN	2
 /* Minimum and maximum widths are expressed in bytes */
 #define XVIP_DMA_MIN_WIDTH		1U
 #define XVIP_DMA_MAX_WIDTH		65535U
@@ -61,7 +64,7 @@ static int xvip_dma_verify_format(struct xvip_dma *dma)
 	int ret;
 
 	subdev = xvip_dma_remote_subdev(&dma->pad, &fmt.pad);
-	if (subdev == NULL)
+	if (!subdev)
 		return -EPIPE;
 
 	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
@@ -69,10 +72,15 @@ static int xvip_dma_verify_format(struct xvip_dma *dma)
 	if (ret < 0)
 		return ret == -ENOIOCTLCMD ? -EINVAL : ret;
 
-	if (dma->fmtinfo->code != fmt.format.code ||
-	    dma->format.height != fmt.format.height ||
-	    dma->format.width != fmt.format.width ||
-	    dma->format.colorspace != fmt.format.colorspace)
+	if (dma->fmtinfo->code != fmt.format.code)
+		return -EINVAL;
+
+	/*
+	 * Crop rectangle contains format resolution by default, and crop
+	 * rectangle if s_selection is executed.
+	 */
+	if (dma->r.width != fmt.format.width ||
+	    dma->r.height != fmt.format.height)
 		return -EINVAL;
 
 	return 0;
@@ -82,46 +90,6 @@ static int xvip_dma_verify_format(struct xvip_dma *dma)
  * Pipeline Stream Management
  */
 
-/**
- * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
- * @pipe: The pipeline
- * @start: Start (when true) or stop (when false) the pipeline
- *
- * Walk the entities chain starting at the pipeline output video node and start
- * or stop all of them.
- *
- * Return: 0 if successful, or the return value of the failed video::s_stream
- * operation otherwise.
- */
-static int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)
-{
-	struct xvip_dma *dma = pipe->output;
-	struct media_entity *entity;
-	struct media_pad *pad;
-	struct v4l2_subdev *subdev;
-	int ret;
-
-	entity = &dma->video.entity;
-	while (1) {
-		pad = &entity->pads[0];
-		if (!(pad->flags & MEDIA_PAD_FL_SINK))
-			break;
-
-		pad = media_pad_remote_pad_first(pad);
-		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
-			break;
-
-		entity = pad->entity;
-		subdev = media_entity_to_v4l2_subdev(entity);
-
-		ret = v4l2_subdev_call(subdev, video, s_stream, start);
-		if (start && ret < 0 && ret != -ENOIOCTLCMD)
-			return ret;
-	}
-
-	return 0;
-}
-
 /**
  * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
  * @pipe: The pipeline
@@ -132,7 +100,8 @@ static int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)
  * independently, pipelines have a shared stream state that enable or disable
  * all entities in the pipeline. For this reason the pipeline uses a streaming
  * counter that tracks the number of DMA engines that have requested the stream
- * to be enabled.
+ * to be enabled. This will walk the graph starting from each DMA and enable or
+ * disable the entities in the path.
  *
  * When called with the @on argument set to true, this function will increment
  * the pipeline streaming count. If the streaming count reaches the number of
@@ -149,20 +118,22 @@ static int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)
  */
 static int xvip_pipeline_set_stream(struct xvip_pipeline *pipe, bool on)
 {
+	struct xvip_composite_device *xdev;
 	int ret = 0;
 
 	mutex_lock(&pipe->lock);
+	xdev = pipe->xdev;
 
 	if (on) {
-		if (pipe->stream_count == pipe->num_dmas - 1) {
-			ret = xvip_pipeline_start_stop(pipe, true);
+		if (pipe->stream_count == pipe->num_dmas - 1 || xdev->atomic_streamon) {
+			ret = xvip_graph_pipeline_start_stop(xdev, pipe, true);
 			if (ret < 0)
 				goto done;
 		}
 		pipe->stream_count++;
 	} else {
 		if (--pipe->stream_count == 0)
-			xvip_pipeline_start_stop(pipe, false);
+			xvip_graph_pipeline_start_stop(xdev, pipe, false);
 	}
 
 done:
@@ -199,23 +170,22 @@ static int xvip_pipeline_validate(struct xvip_pipeline *pipe,
 
 		dma = to_xvip_dma(media_entity_to_video_device(entity));
 
-		if (dma->pad.flags & MEDIA_PAD_FL_SINK) {
-			pipe->output = dma;
+		if (dma->pad.flags & MEDIA_PAD_FL_SINK)
 			num_outputs++;
-		} else {
+		else
 			num_inputs++;
-		}
 	}
 
 	mutex_unlock(&mdev->graph_mutex);
 
 	media_graph_walk_cleanup(&graph);
 
-	/* We need exactly one output and zero or one input. */
-	if (num_outputs != 1 || num_inputs > 1)
+	/* We need at least one DMA to proceed */
+	if (num_outputs == 0 && num_inputs == 0)
 		return -EPIPE;
 
 	pipe->num_dmas = num_inputs + num_outputs;
+	pipe->xdev = start->xdev;
 
 	return 0;
 }
@@ -223,7 +193,6 @@ static int xvip_pipeline_validate(struct xvip_pipeline *pipe,
 static void __xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
 {
 	pipe->num_dmas = 0;
-	pipe->output = NULL;
 }
 
 /**
@@ -286,11 +255,13 @@ static int xvip_pipeline_prepare(struct xvip_pipeline *pipe,
  * @buf: vb2 buffer base object
  * @queue: buffer list entry in the DMA engine queued buffers list
  * @dma: DMA channel that uses the buffer
+ * @desc: Descriptor associated with this structure
  */
 struct xvip_dma_buffer {
 	struct vb2_v4l2_buffer buf;
 	struct list_head queue;
 	struct xvip_dma *dma;
+	struct dma_async_tx_descriptor *desc;
 };
 
 #define to_xvip_dma_buffer(vb)	container_of(vb, struct xvip_dma_buffer, buf)
@@ -299,6 +270,9 @@ static void xvip_dma_complete(void *param)
 {
 	struct xvip_dma_buffer *buf = param;
 	struct xvip_dma *dma = buf->dma;
+	int i, sizeimage;
+	u32 fid = 0;
+	int status;
 
 	spin_lock(&dma->queued_lock);
 	list_del(&buf->queue);
@@ -307,7 +281,38 @@ static void xvip_dma_complete(void *param)
 	buf->buf.field = V4L2_FIELD_NONE;
 	buf->buf.sequence = dma->sequence++;
 	buf->buf.vb2_buf.timestamp = ktime_get_ns();
-	vb2_set_plane_payload(&buf->buf.vb2_buf, 0, dma->format.sizeimage);
+
+	status = xilinx_xdma_get_fid(dma->dma, buf->desc, &fid);
+	if (!status) {
+		if (((V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) &&
+		     dma->format.fmt.pix_mp.field == V4L2_FIELD_ALTERNATE) ||
+		     dma->format.fmt.pix.field == V4L2_FIELD_ALTERNATE) {
+			/*
+			 * fid = 1 is odd field i.e. V4L2_FIELD_TOP.
+			 * fid = 0 is even field i.e. V4L2_FIELD_BOTTOM.
+			 */
+			buf->buf.field = fid ?
+					 V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;
+
+			if (fid == dma->prev_fid)
+				buf->buf.sequence = dma->sequence++;
+
+			buf->buf.sequence >>= 1;
+			dma->prev_fid = fid;
+		}
+	}
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		for (i = 0; i < dma->fmtinfo->buffers; i++) {
+			sizeimage =
+				dma->format.fmt.pix_mp.plane_fmt[i].sizeimage;
+			vb2_set_plane_payload(&buf->buf.vb2_buf, i, sizeimage);
+		}
+	} else {
+		sizeimage = dma->format.fmt.pix.sizeimage;
+		vb2_set_plane_payload(&buf->buf.vb2_buf, 0, sizeimage);
+	}
+
 	vb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);
 }
 
@@ -317,13 +322,39 @@ xvip_dma_queue_setup(struct vb2_queue *vq,
 		     unsigned int sizes[], struct device *alloc_devs[])
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
+	unsigned int i;
+	int sizeimage;
+
+	/* Multi planar case: Make sure the image size is large enough */
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		if (*nplanes) {
+			if (*nplanes != dma->format.fmt.pix_mp.num_planes)
+				return -EINVAL;
+
+			for (i = 0; i < *nplanes; i++) {
+				sizeimage =
+				  dma->format.fmt.pix_mp.plane_fmt[i].sizeimage;
+				if (sizes[i] < sizeimage)
+					return -EINVAL;
+			}
+		} else {
+			*nplanes = dma->fmtinfo->buffers;
+			for (i = 0; i < dma->fmtinfo->buffers; i++) {
+				sizeimage =
+				  dma->format.fmt.pix_mp.plane_fmt[i].sizeimage;
+				sizes[i] = sizeimage;
+			}
+		}
+		return 0;
+	}
 
-	/* Make sure the image size is large enough. */
-	if (*nplanes)
-		return sizes[0] < dma->format.sizeimage ? -EINVAL : 0;
+	/* Single planar case: Make sure the image size is large enough */
+	sizeimage = dma->format.fmt.pix.sizeimage;
+	if (*nplanes == 1)
+		return sizes[0] < sizeimage ? -EINVAL : 0;
 
 	*nplanes = 1;
-	sizes[0] = dma->format.sizeimage;
+	sizes[0] = sizeimage;
 
 	return 0;
 }
@@ -346,15 +377,21 @@ static void xvip_dma_buffer_queue(struct vb2_buffer *vb)
 	struct xvip_dma_buffer *buf = to_xvip_dma_buffer(vbuf);
 	struct dma_async_tx_descriptor *desc;
 	dma_addr_t addr = vb2_dma_contig_plane_dma_addr(vb, 0);
-	u32 flags;
-
-	if (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+	u32 flags = 0;
+	u32 luma_size;
+	u32 padding_factor_nume, padding_factor_deno, bpl_nume, bpl_deno;
+	u32 fid = ~0;
+	u32 bpl;
+
+	if (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||
+	    dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
 		flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
 		dma->xt.dir = DMA_DEV_TO_MEM;
 		dma->xt.src_sgl = false;
 		dma->xt.dst_sgl = true;
 		dma->xt.dst_start = addr;
-	} else {
+	} else if (dma->queue.type == V4L2_BUF_TYPE_VIDEO_OUTPUT ||
+		   dma->queue.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
 		dma->xt.dir = DMA_MEM_TO_DEV;
 		dma->xt.src_sgl = true;
@@ -362,10 +399,89 @@ static void xvip_dma_buffer_queue(struct vb2_buffer *vb)
 		dma->xt.src_start = addr;
 	}
 
-	dma->xt.frame_size = 1;
-	dma->sgl[0].size = dma->format.width * dma->fmtinfo->bpp;
-	dma->sgl[0].icg = dma->format.bytesperline - dma->sgl[0].size;
-	dma->xt.numf = dma->format.height;
+	/*
+	 * DMA IP supports only 2 planes, so one datachunk is sufficient
+	 * to get start address of 2nd plane
+	 */
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		struct v4l2_pix_format_mplane *pix_mp;
+		size_t size;
+
+		pix_mp = &dma->format.fmt.pix_mp;
+		bpl = pix_mp->plane_fmt[0].bytesperline;
+
+		xilinx_xdma_v4l2_config(dma->dma, pix_mp->pixelformat);
+		xvip_width_padding_factor(pix_mp->pixelformat,
+					  &padding_factor_nume,
+					  &padding_factor_deno);
+		xvip_bpl_scaling_factor(pix_mp->pixelformat, &bpl_nume,
+					&bpl_deno);
+		dma->xt.frame_size = dma->fmtinfo->num_planes;
+
+		size = ((size_t)dma->r.width * dma->fmtinfo->bpl_factor *
+			padding_factor_nume * bpl_nume) /
+			((size_t)padding_factor_deno * bpl_deno);
+		dma->sgl[0].size = size;
+
+		dma->sgl[0].icg = bpl - dma->sgl[0].size;
+		dma->xt.numf = dma->r.height;
+
+		/*
+		 * dst_icg is the number of bytes to jump after last luma addr
+		 * and before first chroma addr
+		 */
+
+		/* Handling contiguous data with mplanes */
+		if (dma->fmtinfo->buffers == 1) {
+			dma->sgl[0].dst_icg = (size_t)bpl *
+					      (pix_mp->height - dma->r.height);
+		} else {
+			/* Handling non-contiguous data with mplanes */
+			if (dma->fmtinfo->buffers == 2 || dma->fmtinfo->buffers == 3) {
+				dma_addr_t chroma_addr =
+					vb2_dma_contig_plane_dma_addr(vb, 1);
+				luma_size = bpl * dma->xt.numf;
+				if (chroma_addr > addr)
+					dma->sgl[0].dst_icg = chroma_addr -
+						addr - luma_size;
+			}
+			/* Handle the 3rd plane for Y_U_V8 */
+			if (dma->fmtinfo->buffers == 3) {
+				dma_addr_t chroma_addr =
+					vb2_dma_contig_plane_dma_addr(vb, 1);
+				dma_addr_t third_plane_addr =
+					vb2_dma_contig_plane_dma_addr(vb, 2);
+				u32 chroma_size = bpl * dma->xt.numf;
+
+				if (third_plane_addr > chroma_addr)
+					dma->sgl[0].dst_icg = third_plane_addr -
+						chroma_addr - chroma_size;
+			}
+		}
+	} else {
+		struct v4l2_pix_format *pix;
+		size_t size;
+		size_t dst_icg;
+
+		pix = &dma->format.fmt.pix;
+		bpl = pix->bytesperline;
+		xilinx_xdma_v4l2_config(dma->dma, pix->pixelformat);
+		xvip_width_padding_factor(pix->pixelformat,
+					  &padding_factor_nume,
+					  &padding_factor_deno);
+		xvip_bpl_scaling_factor(pix->pixelformat, &bpl_nume,
+					&bpl_deno);
+		dma->xt.frame_size = dma->fmtinfo->num_planes;
+		size = ((size_t)dma->r.width * dma->fmtinfo->bpl_factor *
+			padding_factor_nume * bpl_nume) /
+			((size_t)padding_factor_deno * bpl_deno);
+		dma->sgl[0].size = size;
+		dma->sgl[0].icg = bpl - dma->sgl[0].size;
+		dma->xt.numf = dma->r.height;
+		dma->sgl[0].dst_icg = 0;
+		dst_icg = (size_t)bpl * (pix->height - dma->r.height);
+		dma->sgl[0].dst_icg = dst_icg;
+	}
 
 	desc = dmaengine_prep_interleaved_dma(dma->dma, &dma->xt, flags);
 	if (!desc) {
@@ -375,11 +491,28 @@ static void xvip_dma_buffer_queue(struct vb2_buffer *vb)
 	}
 	desc->callback = xvip_dma_complete;
 	desc->callback_param = buf;
+	buf->desc = desc;
+
+	if (buf->buf.field == V4L2_FIELD_TOP)
+		fid = 1;
+	else if (buf->buf.field == V4L2_FIELD_BOTTOM)
+		fid = 0;
+	else if (buf->buf.field == V4L2_FIELD_NONE)
+		fid = 0;
+
+	xilinx_xdma_set_fid(dma->dma, desc, fid);
 
 	spin_lock_irq(&dma->queued_lock);
 	list_add_tail(&buf->queue, &dma->queued_bufs);
 	spin_unlock_irq(&dma->queued_lock);
 
+	/*
+	 * Low latency capture: Give descriptor callback at start of
+	 * processing the descriptor
+	 */
+	if (dma->low_latency_cap)
+		xilinx_xdma_set_earlycb(dma->dma, desc,
+					EARLY_CALLBACK_START_DESC);
 	dmaengine_submit(desc);
 
 	if (vb2_is_streaming(&dma->queue))
@@ -394,6 +527,7 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 	int ret;
 
 	dma->sequence = 0;
+	dma->prev_fid = ~0;
 
 	/*
 	 * Start streaming on the pipeline. No link touching an entity in the
@@ -402,9 +536,11 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 	 * Use the pipeline object embedded in the first DMA object that starts
 	 * streaming.
 	 */
+	mutex_lock(&dma->xdev->lock);
 	pipe = to_xvip_pipeline(&dma->video) ? : &dma->pipe;
 
 	ret = video_device_pipeline_start(&dma->video, &pipe->pipe);
+	mutex_unlock(&dma->xdev->lock);
 	if (ret < 0)
 		goto error;
 
@@ -421,11 +557,25 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 
 	/* Start the DMA engine. This must be done before starting the blocks
 	 * in the pipeline to avoid DMA synchronization issues.
+	 * We dont't want to start DMA in case of low latency capture mode,
+	 * applications will start DMA using S_CTRL at later point of time.
 	 */
-	dma_async_issue_pending(dma->dma);
+	if (!dma->low_latency_cap) {
+		dma_async_issue_pending(dma->dma);
 
-	/* Start the pipeline. */
-	xvip_pipeline_set_stream(pipe, true);
+		/* Start the pipeline. */
+		ret = xvip_pipeline_set_stream(pipe, true);
+		if (ret < 0)
+			goto error_stop;
+	} else {
+		/* For low latency capture, return the first buffer early
+		 * so that consumer can initialize until we start DMA.
+		 */
+		buf = list_first_entry(&dma->queued_bufs,
+				       struct xvip_dma_buffer, queue);
+		xvip_dma_complete(buf);
+		buf->desc->callback = NULL;
+	}
 
 	return 0;
 
@@ -433,6 +583,7 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 	video_device_pipeline_stop(&dma->video);
 
 error:
+	dmaengine_terminate_all(dma->dma);
 	/* Give back all queued buffers to videobuf2. */
 	spin_lock_irq(&dma->queued_lock);
 	list_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {
@@ -492,10 +643,104 @@ xvip_dma_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 	cap->capabilities = dma->xdev->v4l2_caps | V4L2_CAP_STREAMING |
 			    V4L2_CAP_DEVICE_CAPS;
 
-	strscpy(cap->driver, "xilinx-vipp", sizeof(cap->driver));
-	strscpy(cap->card, dma->video.name, sizeof(cap->card));
-	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%pOFn:%u",
-		 dma->xdev->dev->of_node, dma->port);
+	strscpy((char *)cap->driver, "xilinx-vipp", sizeof(cap->driver));
+	strscpy((char *)cap->card, (char *)dma->video.name, sizeof(cap->card));
+	snprintf((char *)cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%pOFn:%u", dma->xdev->dev->of_node, dma->port);
+
+	return 0;
+}
+
+static int xvip_xdma_enum_fmt(struct xvip_dma *dma, struct v4l2_fmtdesc *f,
+			      struct v4l2_subdev_format *v4l_fmt)
+{
+	const struct xvip_video_format *fmt;
+	int ret;
+	u32 i, fmt_cnt = 0, *fmts = NULL;
+
+	ret = xilinx_xdma_get_v4l2_vid_fmts(dma->dma, &fmt_cnt, &fmts);
+	if (ret)
+		return ret;
+
+	/* Has media pad value changed? */
+	if (v4l_fmt->format.code != dma->remote_subdev_med_bus ||
+	    !dma->remote_subdev_med_bus) {
+		/* Re-generate legal list of fourcc codes */
+		dma->poss_v4l2_fmt_cnt = 0;
+		dma->remote_subdev_med_bus = v4l_fmt->format.code;
+
+		if (!dma->poss_v4l2_fmts) {
+			dma->poss_v4l2_fmts =
+				devm_kzalloc(&dma->video.dev,
+					     sizeof(u32) * fmt_cnt,
+					     GFP_KERNEL);
+			if (!dma->poss_v4l2_fmts)
+				return -ENOMEM;
+		}
+
+		for (i = 0; i < fmt_cnt; i++) {
+			fmt = xvip_get_format_by_fourcc(fmts[i]);
+			if (IS_ERR(fmt))
+				return PTR_ERR(fmt);
+
+			if (fmt->code != dma->remote_subdev_med_bus)
+				continue;
+
+			dma->poss_v4l2_fmts[dma->poss_v4l2_fmt_cnt++] =	fmts[i];
+		}
+	}
+
+	/* Return err if index is greater than count of legal values */
+	if (f->index >= dma->poss_v4l2_fmt_cnt)
+		return -EINVAL;
+
+	/* Else return pix format in table */
+	fmt = xvip_get_format_by_fourcc(dma->poss_v4l2_fmts[f->index]);
+	if (IS_ERR(fmt))
+		return PTR_ERR(fmt);
+
+	f->pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int
+xvip_dma_enum_input(struct file *file, void *priv, struct v4l2_input *i)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	struct v4l2_subdev *subdev;
+
+	if (i->index > 0)
+		return -EINVAL;
+
+	subdev = xvip_dma_remote_subdev(&dma->pad, NULL);
+	if (!subdev)
+		return -EPIPE;
+
+	/*
+	 * FIXME: right now only camera input type is handled.
+	 * There should be mechanism to distinguish other types of
+	 * input like V4L2_INPUT_TYPE_TUNER and V4L2_INPUT_TYPE_TOUCH.
+	 */
+	i->type = V4L2_INPUT_TYPE_CAMERA;
+	strlcpy((char *)i->name, (char *)subdev->name, sizeof(i->name));
+
+	return 0;
+}
+
+static int
+xvip_dma_get_input(struct file *file, void *fh, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int
+xvip_dma_set_input(struct file *file, void *fh, unsigned int i)
+{
+	if (i > 0)
+		return -EINVAL;
 
 	return 0;
 }
@@ -510,11 +755,43 @@ xvip_dma_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)
 {
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	struct v4l2_subdev *subdev;
+	struct v4l2_subdev_format v4l_fmt;
+	const struct xvip_video_format *fmt;
+	int err, ret;
 
+	/* Establish media pad format */
+	subdev = xvip_dma_remote_subdev(&dma->pad, &v4l_fmt.pad);
+	if (!subdev)
+		return -EPIPE;
+
+	v4l_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &v4l_fmt);
+	if (ret < 0)
+		return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+	/*
+	 * In case of frmbuf DMA, this will invoke frambuf driver specific APIs
+	 * to enumerate formats otherwise return the pix format corresponding
+	 * to subdev's media bus format. This kind of separation would be
+	 * helpful for clean up and upstreaming.
+	 */
+	err = xvip_xdma_enum_fmt(dma, f, &v4l_fmt);
+	if (!err)
+		return err;
+
+	/*
+	 * This logic will just return one pix format based on subdev's
+	 * media bus format
+	 */
 	if (f->index > 0)
 		return -EINVAL;
 
-	f->pixelformat = dma->format.pixelformat;
+	fmt = xvip_get_format_by_code(v4l_fmt.format.code);
+	if (IS_ERR(fmt))
+		return PTR_ERR(fmt);
+
+	f->pixelformat = fmt->fourcc;
 
 	return 0;
 }
@@ -525,13 +802,17 @@ xvip_dma_get_format(struct file *file, void *fh, struct v4l2_format *format)
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
 
-	format->fmt.pix = dma->format;
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type))
+		format->fmt.pix_mp = dma->format.fmt.pix_mp;
+	else
+		format->fmt.pix = dma->format.fmt.pix;
 
 	return 0;
 }
 
 static void
-__xvip_dma_try_format(struct xvip_dma *dma, struct v4l2_pix_format *pix,
+__xvip_dma_try_format(struct xvip_dma *dma,
+		      struct v4l2_format *format,
 		      const struct xvip_video_format **fmtinfo)
 {
 	const struct xvip_video_format *info;
@@ -540,40 +821,146 @@ __xvip_dma_try_format(struct xvip_dma *dma, struct v4l2_pix_format *pix,
 	unsigned int min_bpl;
 	unsigned int max_bpl;
 	unsigned int width;
-	unsigned int align;
 	unsigned int bpl;
+	unsigned int i, hsub, vsub, plane_width, plane_height;
+	unsigned int fourcc;
+	unsigned int padding_factor_nume, padding_factor_deno;
+	unsigned int bpl_nume, bpl_deno;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	subdev = xvip_dma_remote_subdev(&dma->pad, &fmt.pad);
+	if (!subdev)
+		return;
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+	if (ret < 0)
+		return;
+
+	if (fmt.format.field == V4L2_FIELD_ALTERNATE) {
+		if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type))
+			dma->format.fmt.pix_mp.field = V4L2_FIELD_ALTERNATE;
+		else
+			dma->format.fmt.pix.field = V4L2_FIELD_ALTERNATE;
+	} else {
+		if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type))
+			dma->format.fmt.pix_mp.field = V4L2_FIELD_NONE;
+		else
+			dma->format.fmt.pix.field = V4L2_FIELD_NONE;
+	}
 
 	/* Retrieve format information and select the default format if the
 	 * requested format isn't supported.
 	 */
-	info = xvip_get_format_by_fourcc(pix->pixelformat);
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type))
+		fourcc = format->fmt.pix_mp.pixelformat;
+	else
+		fourcc = format->fmt.pix.pixelformat;
 
-	pix->pixelformat = info->fourcc;
-	pix->field = V4L2_FIELD_NONE;
+	info = xvip_get_format_by_fourcc(fourcc);
+
+	if (IS_ERR(info))
+		info = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);
+
+	xvip_width_padding_factor(info->fourcc, &padding_factor_nume,
+				  &padding_factor_deno);
+	xvip_bpl_scaling_factor(info->fourcc, &bpl_nume, &bpl_deno);
 
 	/* The transfer alignment requirements are expressed in bytes. Compute
 	 * the minimum and maximum values, clamp the requested width and convert
 	 * it back to pixels.
 	 */
-	align = lcm(dma->align, info->bpp);
-	min_width = roundup(XVIP_DMA_MIN_WIDTH, align);
-	max_width = rounddown(XVIP_DMA_MAX_WIDTH, align);
-	width = rounddown(pix->width * info->bpp, align);
-
-	pix->width = clamp(width, min_width, max_width) / info->bpp;
-	pix->height = clamp(pix->height, XVIP_DMA_MIN_HEIGHT,
-			    XVIP_DMA_MAX_HEIGHT);
-
-	/* Clamp the requested bytes per line value. If the maximum bytes per
-	 * line value is zero, the module doesn't support user configurable line
-	 * sizes. Override the requested value with the minimum in that case.
-	 */
-	min_bpl = pix->width * info->bpp;
-	max_bpl = rounddown(XVIP_DMA_MAX_WIDTH, dma->align);
-	bpl = rounddown(pix->bytesperline, dma->align);
-
-	pix->bytesperline = clamp(bpl, min_bpl, max_bpl);
-	pix->sizeimage = pix->bytesperline * pix->height;
+	min_width = roundup(XVIP_DMA_MIN_WIDTH, dma->width_align);
+	max_width = rounddown(XVIP_DMA_MAX_WIDTH, dma->width_align);
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		struct v4l2_pix_format_mplane *pix_mp;
+		struct v4l2_plane_pix_format *plane_fmt;
+
+		pix_mp = &format->fmt.pix_mp;
+		plane_fmt = pix_mp->plane_fmt;
+		pix_mp->field = dma->format.fmt.pix_mp.field;
+		width = rounddown(pix_mp->width * info->bpl_factor,
+				  dma->width_align);
+		pix_mp->width = clamp(width, min_width, max_width) /
+				info->bpl_factor;
+		pix_mp->height = clamp(pix_mp->height, XVIP_DMA_MIN_HEIGHT,
+				       XVIP_DMA_MAX_HEIGHT);
+
+		/*
+		 * Clamp the requested bytes per line value. If the maximum
+		 * bytes per line value is zero, the module doesn't support
+		 * user configurable line sizes. Override the requested value
+		 * with the minimum in that case.
+		 */
+
+		max_bpl = rounddown(XVIP_DMA_MAX_WIDTH, dma->align);
+
+		/* Handling contiguous data with mplanes */
+		if (info->buffers == 1) {
+			min_bpl = (pix_mp->width * info->bpl_factor *
+				   padding_factor_nume * bpl_nume) /
+				   (padding_factor_deno * bpl_deno);
+			min_bpl = roundup(min_bpl, dma->align);
+			bpl = roundup(plane_fmt[0].bytesperline, dma->align);
+			plane_fmt[0].bytesperline = clamp(bpl, min_bpl,
+							  max_bpl);
+
+			if (info->num_planes == 1) {
+				/* Single plane formats */
+				plane_fmt[0].sizeimage =
+						plane_fmt[0].bytesperline *
+						pix_mp->height;
+			} else {
+				/* Multi plane formats */
+				plane_fmt[0].sizeimage =
+					DIV_ROUND_UP(plane_fmt[0].bytesperline *
+						     pix_mp->height *
+						     info->bpp, 8);
+			}
+		} else {
+			/* Handling non-contiguous data with mplanes */
+			hsub = info->hsub;
+			vsub = info->vsub;
+			for (i = 0; i < info->num_planes; i++) {
+				plane_width = pix_mp->width / (i ? hsub : 1);
+				plane_height = pix_mp->height / (i ? vsub : 1);
+				min_bpl = (plane_width * info->bpl_factor *
+					   padding_factor_nume * bpl_nume) /
+					   (padding_factor_deno * bpl_deno);
+				min_bpl = roundup(min_bpl, dma->align);
+				bpl = rounddown(plane_fmt[i].bytesperline,
+						dma->align);
+				plane_fmt[i].bytesperline =
+						clamp(bpl, min_bpl, max_bpl);
+				plane_fmt[i].sizeimage =
+						plane_fmt[i].bytesperline *
+						plane_height;
+			}
+		}
+	} else {
+		struct v4l2_pix_format *pix;
+
+		pix = &format->fmt.pix;
+		pix->field = dma->format.fmt.pix.field;
+		width = rounddown(pix->width * info->bpl_factor,
+				  dma->width_align);
+		pix->width = clamp(width, min_width, max_width) /
+			     info->bpl_factor;
+		pix->height = clamp(pix->height, XVIP_DMA_MIN_HEIGHT,
+				    XVIP_DMA_MAX_HEIGHT);
+
+		min_bpl = (pix->width * info->bpl_factor *
+			  padding_factor_nume * bpl_nume) /
+			  (padding_factor_deno * bpl_deno);
+		min_bpl = roundup(min_bpl, dma->align);
+		max_bpl = rounddown(XVIP_DMA_MAX_WIDTH, dma->align);
+		bpl = rounddown(pix->bytesperline, dma->align);
+		pix->bytesperline = clamp(bpl, min_bpl, max_bpl);
+		pix->sizeimage = pix->width * pix->height * info->bpp / 8;
+	}
 
 	if (fmtinfo)
 		*fmtinfo = info;
@@ -585,7 +972,7 @@ xvip_dma_try_format(struct file *file, void *fh, struct v4l2_format *format)
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
 
-	__xvip_dma_try_format(dma, &format->fmt.pix, NULL);
+	__xvip_dma_try_format(dma, format, NULL);
 	return 0;
 }
 
@@ -594,28 +981,151 @@ xvip_dma_set_format(struct file *file, void *fh, struct v4l2_format *format)
 {
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
-	const struct xvip_video_format *info;
+	const struct xvip_video_format *info = NULL;
 
-	__xvip_dma_try_format(dma, &format->fmt.pix, &info);
+	__xvip_dma_try_format(dma, format, &info);
 
 	if (vb2_is_busy(&dma->queue))
 		return -EBUSY;
 
-	dma->format = format->fmt.pix;
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		dma->format.fmt.pix_mp = format->fmt.pix_mp;
+
+		/*
+		 * Save format resolution in crop rectangle. This will be
+		 * updated when s_slection is called.
+		 */
+		dma->r.width = format->fmt.pix_mp.width;
+		dma->r.height = format->fmt.pix_mp.height;
+	} else {
+		dma->format.fmt.pix = format->fmt.pix;
+		dma->r.width = format->fmt.pix.width;
+		dma->r.height = format->fmt.pix.height;
+	}
+
 	dma->fmtinfo = info;
 
 	return 0;
 }
 
+static int
+xvip_dma_g_selection(struct file *file, void *fh, struct v4l2_selection *sel)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	u32 width, height;
+	bool crop_frame = false;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_COMPOSE:
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			return -EINVAL;
+
+		crop_frame = true;
+		break;
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			return -EINVAL;
+		break;
+	case V4L2_SEL_TGT_CROP:
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+
+		crop_frame = true;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	sel->r.left = 0;
+	sel->r.top = 0;
+
+	if (crop_frame) {
+		sel->r.width = dma->r.width;
+		sel->r.height = dma->r.height;
+	} else {
+		if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+			width = dma->format.fmt.pix_mp.width;
+			height = dma->format.fmt.pix_mp.height;
+		} else {
+			width = dma->format.fmt.pix.width;
+			height = dma->format.fmt.pix.height;
+		}
+
+		sel->r.width = width;
+		sel->r.height = height;
+	}
+
+	return 0;
+}
+
+static int
+xvip_dma_s_selection(struct file *file, void *fh, struct v4l2_selection *sel)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	u32 width, height;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_COMPOSE:
+		/* COMPOSE target is only valid for capture buftype */
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			return -EINVAL;
+		break;
+	case V4L2_SEL_TGT_CROP:
+		/* CROP target is only valid for output buftype */
+		if (sel->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->format.type)) {
+		width = dma->format.fmt.pix_mp.width;
+		height = dma->format.fmt.pix_mp.height;
+	} else {
+		width = dma->format.fmt.pix.width;
+		height = dma->format.fmt.pix.height;
+	}
+
+	if (sel->r.width > width || sel->r.height > height ||
+	    sel->r.top != 0 || sel->r.left != 0)
+		return -EINVAL;
+
+	sel->r.width = rounddown(max(XVIP_DMA_MIN_WIDTH, sel->r.width),
+				 dma->width_align);
+	sel->r.height = max(XVIP_DMA_MIN_HEIGHT, sel->r.height);
+	dma->r.width = sel->r.width;
+	dma->r.height = sel->r.height;
+
+	return 0;
+}
+
 static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 	.vidioc_querycap		= xvip_dma_querycap,
 	.vidioc_enum_fmt_vid_cap	= xvip_dma_enum_format,
+	.vidioc_enum_fmt_vid_out	= xvip_dma_enum_format,
 	.vidioc_g_fmt_vid_cap		= xvip_dma_get_format,
+	.vidioc_g_fmt_vid_cap_mplane	= xvip_dma_get_format,
 	.vidioc_g_fmt_vid_out		= xvip_dma_get_format,
+	.vidioc_g_fmt_vid_out_mplane	= xvip_dma_get_format,
 	.vidioc_s_fmt_vid_cap		= xvip_dma_set_format,
+	.vidioc_s_fmt_vid_cap_mplane	= xvip_dma_set_format,
 	.vidioc_s_fmt_vid_out		= xvip_dma_set_format,
+	.vidioc_s_fmt_vid_out_mplane	= xvip_dma_set_format,
 	.vidioc_try_fmt_vid_cap		= xvip_dma_try_format,
+	.vidioc_try_fmt_vid_cap_mplane	= xvip_dma_try_format,
 	.vidioc_try_fmt_vid_out		= xvip_dma_try_format,
+	.vidioc_try_fmt_vid_out_mplane	= xvip_dma_try_format,
+	.vidioc_s_selection		= xvip_dma_s_selection,
+	.vidioc_g_selection		= xvip_dma_g_selection,
 	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
 	.vidioc_querybuf		= vb2_ioctl_querybuf,
 	.vidioc_qbuf			= vb2_ioctl_qbuf,
@@ -624,6 +1134,121 @@ static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 	.vidioc_expbuf			= vb2_ioctl_expbuf,
 	.vidioc_streamon		= vb2_ioctl_streamon,
 	.vidioc_streamoff		= vb2_ioctl_streamoff,
+	.vidioc_enum_input	= &xvip_dma_enum_input,
+	.vidioc_g_input		= &xvip_dma_get_input,
+	.vidioc_s_input		= &xvip_dma_set_input,
+};
+
+/* -----------------------------------------------------------------------------
+ * V4L2 controls
+ */
+
+static int xvip_dma_s_ctrl(struct v4l2_ctrl *ctl)
+{
+	struct xvip_dma *dma = container_of(ctl->handler, struct xvip_dma,
+					    ctrl_handler);
+	int ret = 0;
+	struct xvip_pipeline *pipe = media_entity_pipeline(&dma->video.entity) ?
+		to_xvip_pipeline(&dma->video) : &dma->pipe;
+	struct xvip_dma_buffer *buf, *nbuf;
+
+	switch (ctl->id)  {
+	case V4L2_CID_XILINX_LOW_LATENCY:
+		if (ctl->val == XVIP_LOW_LATENCY_ENABLE) {
+			if (vb2_is_busy(&dma->queue))
+				return -EBUSY;
+
+			dma->low_latency_cap = true;
+			/*
+			 * Don't use auto-restart for low latency
+			 * to avoid extra one frame delay between
+			 * programming and actual writing of data
+			 */
+			xilinx_xdma_set_mode(dma->dma, DEFAULT);
+		} else if (ctl->val == XVIP_LOW_LATENCY_DISABLE) {
+			if (vb2_is_busy(&dma->queue))
+				return -EBUSY;
+
+			dma->low_latency_cap = false;
+			xilinx_xdma_set_mode(dma->dma, AUTO_RESTART);
+		} else if (ctl->val == XVIP_START_DMA) {
+			if (dma->low_latency_cap &&
+			    vb2_is_streaming(&dma->queue)) {
+				/*
+				 * In low latency capture, the driver allows application
+				 * to start dma when queue has buffers. That's why we
+				 * don't check for vb2_is_busy().
+				 */
+				dma_async_issue_pending(dma->dma);
+
+				/* Start the pipeline. */
+				ret = xvip_pipeline_set_stream(pipe, true);
+				if (ret < 0) {
+					dev_err(dma->xdev->dev, "Failed to set stream\n");
+					media_pipeline_stop(dma->video.entity.pads);
+					dmaengine_terminate_all(dma->dma);
+
+					/* Give back all queued buffers to videobuf2. */
+					spin_lock_irq(&dma->queued_lock);
+					list_for_each_entry_safe(buf, nbuf,
+								 &dma->queued_bufs, queue) {
+						vb2_buffer_done(&buf->buf.vb2_buf,
+								VB2_BUF_STATE_QUEUED);
+						list_del(&buf->queue);
+					}
+					spin_unlock_irq(&dma->queued_lock);
+				}
+			} else {
+				ret = -EINVAL;
+			}
+		} else {
+			ret = -EINVAL;
+		}
+
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int xvip_dma_open(struct file *file)
+{
+	int ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		return ret;
+
+	/* Disable the low latency mode as default */
+	if (v4l2_fh_is_singular_file(file)) {
+		struct xvip_dma *dma = video_drvdata(file);
+
+		mutex_lock(&dma->lock);
+		dma->low_latency_cap = false;
+		xilinx_xdma_set_mode(dma->dma, AUTO_RESTART);
+		mutex_unlock(&dma->lock);
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops xvip_dma_ctrl_ops = {
+	.s_ctrl = xvip_dma_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config xvip_dma_ctrls[] = {
+	{
+		.ops = &xvip_dma_ctrl_ops,
+		.id = V4L2_CID_XILINX_LOW_LATENCY,
+		.name = "Low Latency Controls",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = XVIP_LOW_LATENCY_ENABLE,
+		.max = XVIP_START_DMA,
+		.step = 1,
+		.def = XVIP_LOW_LATENCY_DISABLE,
+	}
 };
 
 /* -----------------------------------------------------------------------------
@@ -633,7 +1258,7 @@ static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 static const struct v4l2_file_operations xvip_dma_fops = {
 	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= video_ioctl2,
-	.open		= v4l2_fh_open,
+	.open		= xvip_dma_open,
 	.release	= vb2_fop_release,
 	.poll		= vb2_fop_poll,
 	.mmap		= vb2_fop_mmap,
@@ -648,6 +1273,7 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 {
 	char name[16];
 	int ret;
+	u32 i, hsub, vsub, width, height;
 
 	dma->xdev = xdev;
 	dma->port = port;
@@ -656,42 +1282,132 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 	INIT_LIST_HEAD(&dma->queued_bufs);
 	spin_lock_init(&dma->queued_lock);
 
-	dma->fmtinfo = xvip_get_format_by_fourcc(V4L2_PIX_FMT_YUYV);
-	dma->format.pixelformat = dma->fmtinfo->fourcc;
-	dma->format.colorspace = V4L2_COLORSPACE_SRGB;
-	dma->format.field = V4L2_FIELD_NONE;
-	dma->format.width = XVIP_DMA_DEF_WIDTH;
-	dma->format.height = XVIP_DMA_DEF_HEIGHT;
-	dma->format.bytesperline = dma->format.width * dma->fmtinfo->bpp;
-	dma->format.sizeimage = dma->format.bytesperline * dma->format.height;
+	dma->fmtinfo = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);
+	dma->format.type = type;
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {
+		struct v4l2_pix_format_mplane *pix_mp;
+
+		pix_mp = &dma->format.fmt.pix_mp;
+		pix_mp->pixelformat = dma->fmtinfo->fourcc;
+		pix_mp->colorspace = V4L2_COLORSPACE_SRGB;
+		pix_mp->field = V4L2_FIELD_NONE;
+		pix_mp->width = XVIP_DMA_DEF_WIDTH;
+
+		/* Handling contiguous data with mplanes */
+		if (dma->fmtinfo->buffers == 1) {
+			pix_mp->plane_fmt[0].bytesperline =
+				pix_mp->width * dma->fmtinfo->bpl_factor;
+			pix_mp->plane_fmt[0].sizeimage =
+					pix_mp->width * pix_mp->height *
+					dma->fmtinfo->bpp / 8;
+		} else {
+		    /* Handling non-contiguous data with mplanes */
+			hsub = dma->fmtinfo->hsub;
+			vsub = dma->fmtinfo->vsub;
+			for (i = 0; i < dma->fmtinfo->buffers; i++) {
+				width = pix_mp->width / (i ? hsub : 1);
+				height = pix_mp->height / (i ? vsub : 1);
+				pix_mp->plane_fmt[i].bytesperline =
+					width *	dma->fmtinfo->bpl_factor;
+				pix_mp->plane_fmt[i].sizeimage = width * height;
+			}
+		}
+	} else {
+		struct v4l2_pix_format *pix;
+
+		pix = &dma->format.fmt.pix;
+		pix->pixelformat = dma->fmtinfo->fourcc;
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		pix->field = V4L2_FIELD_NONE;
+		pix->width = XVIP_DMA_DEF_WIDTH;
+		pix->height = XVIP_DMA_DEF_HEIGHT;
+		pix->bytesperline = pix->width * dma->fmtinfo->bpl_factor;
+		pix->sizeimage =
+			pix->width * pix->height * dma->fmtinfo->bpp / 8;
+	}
 
 	/* Initialize the media entity... */
-	dma->pad.flags = type == V4L2_BUF_TYPE_VIDEO_CAPTURE
-		       ? MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
+	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||
+	    type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		dma->pad.flags = MEDIA_PAD_FL_SINK;
+	else
+		dma->pad.flags = MEDIA_PAD_FL_SOURCE;
 
 	ret = media_entity_pads_init(&dma->video.entity, 1, &dma->pad);
 	if (ret < 0)
 		goto error;
 
+	ret = v4l2_ctrl_handler_init(&dma->ctrl_handler,
+				     ARRAY_SIZE(xvip_dma_ctrls));
+	if (ret < 0) {
+		dev_err(dma->xdev->dev, "failed to initialize V4L2 ctrl\n");
+		goto error;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xvip_dma_ctrls); i++) {
+		struct v4l2_ctrl *ctrl;
+
+		dev_dbg(dma->xdev->dev, "%d ctrl = 0x%x\n", i,
+			xvip_dma_ctrls[i].id);
+		ctrl = v4l2_ctrl_new_custom(&dma->ctrl_handler,
+					    &xvip_dma_ctrls[i], NULL);
+		if (!ctrl) {
+			dev_err(dma->xdev->dev, "Failed for %s ctrl\n",
+				xvip_dma_ctrls[i].name);
+			goto error;
+		}
+	}
+
+	if (dma->ctrl_handler.error) {
+		dev_err(dma->xdev->dev, "failed to add controls\n");
+		ret = dma->ctrl_handler.error;
+		goto error;
+	}
+
+	ret = v4l2_ctrl_handler_setup(&dma->ctrl_handler);
+	if (ret < 0) {
+		dev_err(dma->xdev->dev, "failed to set controls\n");
+		goto error;
+	}
+
 	/* ... and the video node... */
 	dma->video.fops = &xvip_dma_fops;
 	dma->video.v4l2_dev = &xdev->v4l2_dev;
+	dma->video.v4l2_dev->ctrl_handler = &dma->ctrl_handler;
 	dma->video.queue = &dma->queue;
 	snprintf(dma->video.name, sizeof(dma->video.name), "%pOFn %s %u",
 		 xdev->dev->of_node,
-		 type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "output" : "input",
+		 (type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||
+		  type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+					? "output" : "input",
 		 port);
+
 	dma->video.vfl_type = VFL_TYPE_VIDEO;
-	dma->video.vfl_dir = type == V4L2_BUF_TYPE_VIDEO_CAPTURE
-			   ? VFL_DIR_RX : VFL_DIR_TX;
+	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||
+	    type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		dma->video.vfl_dir = VFL_DIR_RX;
+	else
+		dma->video.vfl_dir = VFL_DIR_TX;
+
 	dma->video.release = video_device_release_empty;
 	dma->video.ioctl_ops = &xvip_dma_ioctl_ops;
 	dma->video.lock = &dma->lock;
 	dma->video.device_caps = V4L2_CAP_STREAMING;
-	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	switch (dma->format.type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		dma->video.device_caps |= V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		dma->video.device_caps |= V4L2_CAP_VIDEO_CAPTURE;
-	else
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+		dma->video.device_caps |= V4L2_CAP_VIDEO_OUTPUT_MPLANE;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		dma->video.device_caps |= V4L2_CAP_VIDEO_OUTPUT;
+		break;
+	}
 
 	video_set_drvdata(&dma->video, dma);
 
@@ -729,6 +1445,13 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 		goto error;
 	}
 
+	xilinx_xdma_get_width_align(dma->dma, &dma->width_align);
+	if (!dma->width_align) {
+		dev_dbg(dma->xdev->dev,
+			"Using width align %d\n", XVIP_DMA_DEF_WIDTH_ALIGN);
+		dma->width_align = XVIP_DMA_DEF_WIDTH_ALIGN;
+	}
+
 	dma->align = 1 << dma->dma->device->copy_align;
 
 	ret = video_register_device(&dma->video, VFL_TYPE_VIDEO, -1);
@@ -752,6 +1475,7 @@ void xvip_dma_cleanup(struct xvip_dma *dma)
 	if (!IS_ERR_OR_NULL(dma->dma))
 		dma_release_channel(dma->dma);
 
+	v4l2_ctrl_handler_free(&dma->ctrl_handler);
 	media_entity_cleanup(&dma->video.entity);
 
 	mutex_destroy(&dma->lock);
diff --git a/drivers/media/platform/xilinx/xilinx-dma.h b/drivers/media/platform/xilinx/xilinx-dma.h
index 9c6d4c18d..a698a36a6 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.h
+++ b/drivers/media/platform/xilinx/xilinx-dma.h
@@ -18,6 +18,7 @@
 #include <linux/videodev2.h>
 
 #include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
 #include <media/v4l2-dev.h>
 #include <media/videobuf2-v4l2.h>
 
@@ -32,7 +33,7 @@ struct xvip_video_format;
  * @use_count: number of DMA engines using the pipeline
  * @stream_count: number of DMA engines currently streaming
  * @num_dmas: number of DMA engines in the pipeline
- * @output: DMA engine at the output of the pipeline
+ * @xdev: Composite device the pipe belongs to
  */
 struct xvip_pipeline {
 	struct media_pipeline pipe;
@@ -42,7 +43,7 @@ struct xvip_pipeline {
 	unsigned int stream_count;
 
 	unsigned int num_dmas;
-	struct xvip_dma *output;
+	struct xvip_composite_device *xdev;
 };
 
 static inline struct xvip_pipeline *to_xvip_pipeline(struct video_device *vdev)
@@ -60,33 +61,47 @@ static inline struct xvip_pipeline *to_xvip_pipeline(struct video_device *vdev)
  * @list: list entry in a composite device dmas list
  * @video: V4L2 video device associated with the DMA channel
  * @pad: media pad for the video device entity
+ * @remote_subdev_med_bus: media bus format of sub-device
+ * @ctrl_handler: V4L2 ctrl_handler for inheritance ctrls from subdev
  * @xdev: composite device the DMA channel belongs to
  * @pipe: pipeline belonging to the DMA channel
  * @port: composite device DT node port number for the DMA channel
  * @lock: protects the @format, @fmtinfo and @queue fields
  * @format: active V4L2 pixel format
+ * @r: crop rectangle parameters
  * @fmtinfo: format information corresponding to the active @format
+ * @poss_v4l2_fmts: All possible v4l formats supported
+ * @poss_v4l2_fmt_cnt: number of supported v4l formats
  * @queue: vb2 buffers queue
  * @sequence: V4L2 buffers sequence number
  * @queued_bufs: list of queued buffers
  * @queued_lock: protects the buf_queued list
  * @dma: DMA engine channel
  * @align: transfer alignment required by the DMA channel (in bytes)
+ * @width_align: width alignment required by the DMA channel (in bytes)
  * @xt: dma interleaved template for dma configuration
  * @sgl: data chunk structure for dma_interleaved_template
+ * @prev_fid: Previous Field ID
+ * @low_latency_cap: Low latency capture mode
  */
 struct xvip_dma {
 	struct list_head list;
 	struct video_device video;
 	struct media_pad pad;
+	u32 remote_subdev_med_bus;
+
+	struct v4l2_ctrl_handler ctrl_handler;
 
 	struct xvip_composite_device *xdev;
 	struct xvip_pipeline pipe;
 	unsigned int port;
 
 	struct mutex lock;
-	struct v4l2_pix_format format;
+	struct v4l2_format format;
+	struct v4l2_rect r;
 	const struct xvip_video_format *fmtinfo;
+	u32 *poss_v4l2_fmts;
+	u32 poss_v4l2_fmt_cnt;
 
 	struct vb2_queue queue;
 	unsigned int sequence;
@@ -96,8 +111,12 @@ struct xvip_dma {
 
 	struct dma_chan *dma;
 	unsigned int align;
+	unsigned int width_align;
 	struct dma_interleaved_template xt;
 	struct data_chunk sgl[1];
+
+	u32 prev_fid;
+	u32 low_latency_cap;
 };
 
 #define to_xvip_dma(vdev)	container_of(vdev, struct xvip_dma, video)
diff --git a/drivers/media/platform/xilinx/xilinx-dprxss.c b/drivers/media/platform/xilinx/xilinx-dprxss.c
new file mode 100644
index 000000000..fd00607e6
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-dprxss.c
@@ -0,0 +1,3215 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx DP Rx Subsystem
+ *
+ * Copyright (C) 2020 Xilinx, Inc.
+ *
+ * Author: Rajesh Gugulothu <gugulothu.rajesh@xilinx.com>
+ *
+ */
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/phy/phy-dp.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/v4l2-dv-timings.h>
+#include <linux/v4l2-subdev.h>
+#include <linux/xilinx-dprxss.h>
+
+#include <drm/display/drm_dp_helper.h>
+#include <dt-bindings/media/xilinx-vip.h>
+
+#include <media/hdr-ctrls.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-dv-timings.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-subdev.h>
+
+#include <sound/soc.h>
+
+#include <linux/xlnx/xlnx_hdcp_common.h>
+#include <linux/xlnx/xlnx_timer.h>
+#include "xilinx-hdcp1x-rx.h"
+#include "xilinx-hdcp2x-rx.h"
+#include "xilinx-vip.h"
+
+#define XV_AES_ENABLE			0x8
+#define XDP_AUDIO_DETECT_TIMEOUT	500 /* milliseconds */
+#define INFO_PCKT_SIZE_WORDS		8
+#define INFO_PCKT_SIZE			(INFO_PCKT_SIZE_WORDS * 4)
+#define INFO_PCKT_TYPE_AUDIO		0x84
+/* Refer section 2.2.5.1.2 in DP spec and table 42 in CTA-861-G spec */
+#define INFO_PCKT_TYPE_DRM		0x87
+
+/* DP Rx subsysetm register map, bitmask, and offsets. */
+#define XDPRX_LINK_ENABLE_REG		0x000
+#define XDPRX_AUX_CLKDIV_REG		0x004
+#define XDPRX_AUX_DEFER_COUNT		6
+#define XDPRX_AUX_DEFER_SHIFT		24
+#define XDPRX_AUX_DEFER_MASK		GENMASK(27, 24)
+
+#define XDPRX_LINERST_DIS_REG		0x008
+#define XDPRX_DTG_REG			0x00c
+#define XDPRX_DTG_DIS_MASK		BIT(0)
+#define XDPRX_VSCEXT_VESA_SDP_SUPPORTED	BIT(2)
+
+#define XDPRX_PIXEL_WIDTH_REG		0x010
+#define XDPRX_INTR_MASK_REG		0x014
+#define XDPRX_INTR_POWER_MASK		BIT(1)
+#define XDPRX_INTR_NOVID_MASK		BIT(2)
+#define XDPRX_INTR_VBLANK_MASK		BIT(3)
+#define XDPRX_INTR_TRLOST_MASK		BIT(4)
+#define XDPRX_INTR_VID_MASK		BIT(6)
+#define XDPRX_INTR_AUDIO_MASK		BIT(8)
+#define XDPRX_INTR_TRDONE_MASK		BIT(14)
+#define XDPRX_INTR_BWCHANGE_MASK	BIT(15)
+#define XDPRX_INTR_TP1_MASK		BIT(16)
+#define XDPRX_INTR_TP2_MASK		BIT(17)
+#define XDPRX_INTR_TP3_MASK		BIT(18)
+#define XDPRX_INTR_HDCP1X_DBG_WRITE_MASK	BIT(19)
+#define XDPRX_INTR_HDCP1X_AKSV_WRITE_MASK	BIT(20)
+#define XDPRX_INTR_HDCP1X_AN_WRITE_MASK		BIT(21)
+#define XDPRX_INTR_HDCP1X_AINFO_WRITE_MASK	BIT(22)
+#define XDPRX_INTR_HDCP1X_RO_READ_MASK		BIT(23)
+#define XDPRX_INTR_HDCP1X_BINFO_READ_MASK	BIT(24)
+#define XDPRX_INTR_HDCP1X_MASK_ALL	(XDPRX_INTR_HDCP1X_DBG_WRITE_MASK | \
+					 XDPRX_INTR_HDCP1X_AKSV_WRITE_MASK | \
+					 XDPRX_INTR_HDCP1X_AN_WRITE_MASK | \
+					 XDPRX_INTR_HDCP1X_AINFO_WRITE_MASK | \
+					 XDPRX_INTR_HDCP1X_RO_READ_MASK | \
+					 XDPRX_INTR_HDCP1X_BINFO_READ_MASK)
+#define XDPRX_INTR_HDCP2X_AKE_INIT_MASK BIT(0)
+#define XDPRX_INTR_HDCP2X_AKE_NO_STORED_KM_MASK BIT(1)
+#define XDPRX_INTR_HDCP2X_AKE_STORED_KM_MASK BIT(2)
+#define XDPRX_INTR_HDCP2X_LC_INIT_MASK BIT(3)
+#define XDPRX_INTR_HDCP2X_SKE_SEND_EKS_MASK BIT(4)
+#define XDPRX_INTR_HDCP2X_DBG_WRITE_MASK BIT(5)
+#define XDPRX_INTR_HDCP2X_HPRIME_READ_DONE_MASK BIT(6)
+#define XDPRX_INTR_HDCP2X_PAIRING_INFO_READ_MASK BIT(7)
+#define XDPRX_INTR_HDCP2X_STREAM_TYPE_MASK BIT(8)
+#define XDPRX_INTR_HDCP2X_RPTR_RCVID_LIST_ACK_MASK BIT(9)
+#define XDPRX_INTR_HDCP2X_RPTR_STREAM_MANAGE_MASK BIT(10)
+#define XDPRX_INTR_HDCP2X_MASK_ALL (XDPRX_INTR_HDCP2X_AKE_INIT_MASK | \
+				XDPRX_INTR_HDCP2X_AKE_NO_STORED_KM_MASK | \
+				XDPRX_INTR_HDCP2X_AKE_STORED_KM_MASK | \
+				XDPRX_INTR_HDCP2X_LC_INIT_MASK | \
+				XDPRX_INTR_HDCP2X_SKE_SEND_EKS_MASK | \
+				XDPRX_INTR_HDCP2X_DBG_WRITE_MASK | \
+				XDPRX_INTR_HDCP2X_HPRIME_READ_DONE_MASK | \
+				XDPRX_INTR_HDCP2X_PAIRING_INFO_READ_MASK | \
+				XDPRX_INTR_HDCP2X_STREAM_TYPE_MASK | \
+				XDPRX_INTR_HDCP2X_RPTR_RCVID_LIST_ACK_MASK | \
+				XDPRX_INTR_HDCP2X_RPTR_STREAM_MANAGE_MASK)
+#define XDPRX_HDCP2X_REG_OFFSET		0x8000
+#define XDPRX_HDCP_TIMER_OFFSET		0x3000
+#define XDPRX_HDCP2X_TABLE		0x1000
+
+#define XDPRX_INTR_LINKQUAL_MASK	BIT(29)
+#define XDPRX_INTR_UNPLUG_MASK		BIT(31)
+#define XDPRX_INTR_CRCTST_MASK		BIT(30)
+#define XDPRX_INTR_TRNG_MASK		(XDPRX_INTR_TP1_MASK | \
+					 XDPRX_INTR_TP2_MASK |\
+					 XDPRX_INTR_TP3_MASK | \
+					 XDPRX_INTR_POWER_MASK |\
+					 XDPRX_INTR_CRCTST_MASK |\
+					 XDPRX_INTR_BWCHANGE_MASK)
+#define XDPRX_INTR_ACCESS_LANE_SET_MASK		BIT(30)
+#define XDPRX_INTR_TP4_MASK			BIT(31)
+#define XDPRX_INTR_ACCESS_LINK_QUAL_MASK	BIT(29)
+#define XDPRX_INTR_ACCESS_ERR_CNT_MASK		BIT(28)
+#define XDPRX_INTR_TRNG_MASK_1		(XDPRX_INTR_TP4_MASK | \
+					 XDPRX_INTR_ACCESS_LANE_SET_MASK | \
+					 XDPRX_INTR_ACCESS_LINK_QUAL_MASK | \
+					 XDPRX_INTR_ACCESS_ERR_CNT_MASK)
+#define XDPRX_INTR_ALL_MASK		0xffffffff
+#define XDPRX_INTR_ALL_MASK_1		0xffffffff
+
+#define XDPRX_SOFT_RST_REG		0x01c
+#define XDPRX_SOFT_RST_REG_HDCP2X_MASK	0x200
+#define XDPRX_SOFT_VIDRST_MASK		BIT(0)
+#define XDPRX_SOFT_AUXRST_MASK		BIT(7)
+
+#define XDPRX_HPD_INTR_REG		0x02c
+#define XDPRX_HPD_INTR_MASK		BIT(0)
+#define XDPRX_HPD_PULSE_MASK		GENMASK(31, 16)
+
+#define XDPRX_INTR_CAUSE_REG		0x040
+#define XDPRX_INTR_MASK_1_REG		0x044
+#define XDPRX_INTR_CAUSE_1_REG		0x048
+#define XDPRX_INTR_CAUSE_2_REG		0x070
+#define XDPRX_INTR_MASK_2_REG		0x005c
+#define XDPRX_CRC_CONFIG_REG		0x074
+#define XDPRX_CRC_EN_MASK		BIT(5)
+
+#define XDPRX_LOCAL_EDID_REG		0x084
+#define XDPRX_DEVICE_SERVICE_IRQ	0x090
+#define XDPRX_DEVICE_SERVICE_IRQ_CP_IRQ_MASK	BIT(3)
+#define XDPRX_VIDEO_UNSUPPORTED_REG	0x094
+#define XDPRX_VRD_BWSET_REG		0x09c
+#define XDPRX_LANE_CNT_REG		0x0a0
+#define XDPRX_EFRAME_CAP_MASK		BIT(7)
+#define XDPRX_LNCNT_TPS3_MASK		BIT(6)
+
+#define XDPRX_TP_SET_REG		0x0a4
+#define XDPRX_AUX_RDINT_SHIFT		8
+#define XDPRX_AUX_RDINT_16MS		4
+#define XDPRX_AUX_READINTRVL_REG	BIT(15)
+
+#define XDPRX_CTRL_DPCD_REG		0x0b8
+#define XDPRX_MST_CAP_REG		0x0d0
+#define XDPRX_SINK_COUNT_REG		0x0d4
+
+#define XDPRX_PHY_REG			0x200
+#define XDPRX_PHY_GTPLLRST_MASK		BIT(0)
+#define XDPRX_PHY_GTRXRST_MASK		BIT(1)
+#define XDPRX_PHYRST_TRITER_MASK	BIT(23)
+#define XDPRX_PHYRST_RATECHANGE_MASK	BIT(24)
+#define XDPRX_PHYRST_TP1START_MASK	BIT(25)
+#define XDPRX_PHYRST_ENBL_MASK		0x0
+#define XDPRX_PHY_INIT_MASK		GENMASK(29, 27)
+
+#define XDPRX_PHYSTATUS_REG			0x208
+#define XDPRX_PHYSTATUS_ALL_LANES_GOOD_MASK	GENMASK(6, 0)
+#define XDPRX_PHYSTATUS_READ_COUNT	100
+
+#define XDPRX_MINVOLT_SWING_REG		0x214
+#define XDPRX_VS_PE_SHIFT		12
+#define XDPRX_VS_SWEEP_CNTSHIFT		4
+#define XDPRX_VS_CROPT_SHIFT		2
+#define XDPRX_VS_CROPT_INC4CNT		1
+#define XDPRX_MIN_VS_MASK		(1 | (XDPRX_VS_CROPT_INC4CNT << \
+					 XDPRX_VS_CROPT_SHIFT) | \
+					 (4 << XDPRX_VS_SWEEP_CNTSHIFT) | \
+					 (1 << XDPRX_VS_PE_SHIFT))
+
+#define XDPRX_CDRCTRL_CFG_REG		0x21c
+/* default CDR tDLOCK calibration value */
+#define XDPRX_CDRCTRL_TDLOCK_VAL	0x1388
+#define XDPRX_CDRCTRL_TDLOCK_MASK	GENMASK(19, 0)
+#define XDPRX_CDRCTRL_DIS_TIMEOUT	BIT(30)
+
+#define XDPRX_BSIDLE_TIME_REG		0x220
+#define XDPRX_BSIDLE_TMOUT_VAL		0x047868C0
+
+#define XDPRX_AUDIO_CONTROL		0x300
+#define XDPRX_AUDIO_EN_MASK		BIT(0)
+#define XDPRX_AUDIO_INFO_DATA		0x304
+#define XDPRX_AUDIO_MAUD		0x324
+#define XDPRX_AUDIO_NAUD		0x328
+#define XDPRX_AUDIO_STATUS		0x32C
+
+#define XDPRX_LINK_BW_REG		0x400
+#define XDPRX_LANE_COUNT_REG		0x404
+#define XDPRX_DPCD_TRAINING_PATTERN_SET	0x40c
+#define XDPRX_DPCD_LANE01_STATUS	0x43c
+#define XDPRX_LANE01_PEVS_MASK		GENMASK(15, 8)
+#define XDPRX_DPC_LINK_QUAL_CONFIG	0x454
+#define XDPRX_DPCD_LINK_QUAL_PRBS_MASK	GENMASK(1, 0)
+#define XDPRX_LINK_QUAL_PRBS_MODE_MASK	GENMASK(2, 0)
+#define XDPRX_MSA_HRES_REG		0x500
+#define XDPRX_MSA_HSPOL_REG		0x504
+#define XDPRX_MSA_HSPOL_MASK		BIT(0)
+#define XDPRX_MSA_HSWIDTH_REG		0x508
+#define XDPRX_MSA_HSTART_REG		0x50c
+#define XDPRX_MSA_VHEIGHT_REG		0x514
+#define XDPRX_MSA_HTOTAL_REG		0x510
+#define XDPRX_MSA_VSPOL_REG		0x518
+#define XDPRX_MSA_VSPOL_MASK		BIT(0)
+#define XDPRX_MSA_VSWIDTH_REG		0x51c
+#define XDPRX_MSA_VSTART_REG		0x520
+#define XDPRX_MSA_VTOTAL_REG		0x524
+#define XDPRX_MSA_MISC0_REG		0x528
+#define XDPRX_MSA_FMT_MASK		GENMASK(2, 1)
+#define XDPRX_MSA_BPC_MASK		GENMASK(7, 5)
+#define XDPRX_COLOR_DEPTH_SHIFT		5
+#define XDPRX_COLOR_FMT_SHIFT		1
+
+#define XDPRX_MSA_MISC1_REG		0x52c
+#define XDPRX_INTERLACE_MASK		BIT(0)
+#define XDPRX_DPCD_MSA_TIMING_IGNORE_MASK	BIT(6)
+#define XDPRX_MSA_MVID_REG		0x530
+#define XDPRX_MSA_NVID_REG		0x534
+#define XDPRX_INTR_ERRORCNT_MASK	BIT(28)
+#define XDPRX_INTR_LANESET_MASK		BIT(30)
+#define XDPRX_SDP_PAYLOAD_STREAM1	0x644
+#define XDPRX_VSC_SDP_FMT_MASK		GENMASK(7, 4)
+#define XDPRX_VSC_SDP_BPC_MASK		GENMASK(11, 8)
+#define XDPRX_EXT_VRD_BWSET_REG		0x7f0
+
+#define XDPRX_COLOR_FORMAT_RGB		0x0
+#define XDPRX_COLOR_FORMAT_422		0x1
+#define XDPRX_COLOR_FORMAT_444		0x2
+#define XDPRX_COLOR_FORMAT_420		0x3
+#define MHZ				1000000
+#define XDPRX_MAX_LANE_COUNT		4
+
+#define XDPRX_EDID_NUM_BLOCKS		3
+#define XDPRX_EDID_BLOCK_SIZE		128
+#define XDPRX_EDID_LENGTH		(XDPRX_EDID_BLOCK_SIZE * \
+					 XDPRX_EDID_NUM_BLOCKS * 4)
+/*
+ * IRQ_HPD pulse for upstream device is 5ms as per
+ * the VESA standard
+ */
+#define XDPRX_HPD_PULSE_5000		5000
+/*
+ * low going IRQ_HPD generated for upstream device
+ * as per the VESA standard
+ */
+#define XDPRX_HPD_PULSE_750		750
+
+/* GtCtrl Registers */
+#define XDPRX_GTCTL_REG			0x4C
+#define XDPRX_GTCTL_EN			BIT(0)
+#define XDPRX_GTCTL_VSWING_MASK		GENMASK(12, 8)
+#define XDPRX_GTCTL_VSWING_INIT_VAL	0x05
+#define XDPRX_GTCTL_LINE_RATE_MASK	GENMASK(2, 1)
+#define XDPRX_GTCTL_LINE_RATE_810G	3
+#define XDPRX_GTCTL_LINE_RATE_540G	2
+#define XDPRX_GTCTL_LINE_RATE_270G	1
+#define XDPRX_GTCTL_LINE_RATE_162G	0
+
+#define DP_LINK_BW_1_62G	1620
+#define DP_LINK_BW_2_7G		2700
+#define DP_LINK_BW_5_4G		5400    /* 1.2 */
+#define DP_LINK_BW_8_1G		8100    /* 1.4 */
+
+#define XDPRXSS_MMCM_OFFSET		0x5000
+
+/* Clock Wizard registers */
+#define XDPRX_MMCM_SWRST_OFFSET		0x00000000
+#define XDPRX_MMCM_SWRST_VAL		0xA
+#define XDPRX_MMCM_STATUS_OFFSET	0x00000004
+#define XDPRX_MMCM_ISR_OFFSET		0x0000000C
+#define XDPRX_MMCM_IER_OFFSET		0x00000010
+#define XDPRX_MMCM_RECONFIG_OFFSET	0x00000014
+#define XDPRX_MMCM_REG1_OFFSET		0x00000330
+#define XDPRX_MMCM_REG2_OFFSET		0x00000334
+#define XDPRX_MMCM_REG3_OFFSET		0x00000338
+#define XDPRX_MMCM_REG4_OFFSET		0x0000033C
+#define XDPRX_MMCM_REG12_OFFSET		0x00000380
+#define XDPRX_MMCM_REG13_OFFSET		0x00000384
+#define XDPRX_MMCM_REG11_OFFSET		0x00000378
+#define XDPRX_MMCM_REG11_VAL		0x2e
+#define XDPRX_MMCM_REG14_OFFSET		0x00000398
+#define XDPRX_MMCM_REG14_VAL		0xe80
+#define XDPRX_MMCM_REG15_OFFSET		0x0000039C
+#define XDPRX_MMCM_REG15_VAL		0x4271
+#define XDPRX_MMCM_REG16_OFFSET		0x000003A0
+#define XDPRX_MMCM_REG16_VAL		0x43e9
+#define XDPRX_MMCM_REG17_OFFSET		0x000003A8
+#define XDPRX_MMCM_REG17_VAL		0x1c
+#define XDPRX_MMCM_REG19_OFFSET		0x000003CC
+#define XDPRX_MMCM_REG25_OFFSET		0x000003F0
+#define XDPRX_MMCM_REG26_OFFSET		0x000003FC
+#define XDPRX_MMCM_REG26_VAL		1
+
+#define XDPRX_MMCM_LOCK			BIT(0)
+#define XDPRX_MMCM_REG3_PREDIV2		BIT(11)
+#define XDPRX_MMCM_REG3_USED		BIT(12)
+#define XDPRX_MMCM_REG3_MX		BIT(9)
+#define XDPRX_MMCM_REG1_PREDIV2		BIT(12)
+#define XDPRX_MMCM_REG1_EN		BIT(9)
+#define XDPRX_MMCM_REG1_MX		BIT(10)
+#define XDPRX_MMCM_RECONFIG_LOAD	BIT(0)
+#define XDPRX_MMCM_RECONFIG_SADDR	BIT(1)
+#define XDPRX_MMCM_REG1_EDGE_MASK	BIT(8)
+
+#define XDPRX_MMCM_CLKOUT0_PREDIV2_SHIFT	11
+#define XDPRX_MMCM_CLKOUT0_MX_SHIFT		9
+#define XDPRX_MMCM_CLKOUT0_P5EN_SHIFT		13
+#define XDPRX_MMCM_CLKOUT0_P5FEDGE_SHIFT	15
+#define XDPRX_MMCM_REG12_EDGE_SHIFT		10
+
+#define XDPRX_MMCM_M_VAL_405		28
+#define XDPRX_MMCM_M_VAL_270		44
+#define XDPRX_MMCM_M_VAL_135		88
+#define XDPRX_MMCM_M_VAL_81		148
+#define XDPRX_MMCM_D_VAL		5
+#define XDPRX_MMCM_M_O_VAL_RATIO	4
+#define XDPRX_MMCM_STATUS_RETRY		10000
+
+#define MMCM_O_VAL_FEDGE_DIVIDER	2
+#define MMCM_O_VAL_HIGHTIME_DIVIDER	4
+#define MMCM_O_VAL_EDGE_DIVIDER		4
+#define MMCM_D_VAL_EDGE_DIVIDER		2
+#define MMCM_D_VAL_HIGHTIME_DIVIDER	2
+#define MMCM_M_VAL_EDGE_DIVIDER		2
+#define MMCM_M_VAL_HIGHTIME_DIVIDER	2
+#define MMCM_MDO_VAL_HIGHTIME_SHIFT	8
+
+#define XDPRX_HDCP1X_REG_OFFSET			0x4000
+#define BYTES_PER_RDWR				4
+#define ALIGN_FOR_RDWR				0x3
+
+#define XDPRX_DPCD_HDCP1X_PORT_REG_LENGTH	0x100
+#define XDPRX_DPCD_HDCP1X_PORT_OFST		0x900
+#define XDPRX_DPCD_HDCP1X_PORT_KSVFIFO		0x02c
+
+#define HDCP1X_KEYMGMT_REG_VERSION		0x0000
+#define HDCP1X_KEYMGMT_REG_TYPE			0x0004
+#define HDCP1X_KEYMGMT_REG_SCRATCH		0x0008
+#define HDCP1X_KEYMGMT_REG_CTRL			0x000C
+#define HDCP1X_KEYMGMT_REG_STATUS		0x0010
+#define HDCP1X_KEYMGMT_REG_TBL_CTRL		0x0020
+#define HDCP1X_KEYMGMT_REG_TBL_STATUS		0x0024
+#define HDCP1X_KEYMGMT_REG_TBL_ADDR		0x0028
+#define HDCP1X_KEYMGMT_REG_TBL_DAT_H		0x002C
+#define HDCP1X_KEYMGMT_REG_TBL_DAT_L		0x0030
+#define HDCP1X_KEYMGMT_REG_MAX			0x0040
+
+#define HDCP1X_KEYMGMT_REG_CTRL_RST_MASK	BIT(31)
+#define HDCP1X_KEYMGMT_REG_CTRL_DISABLE_MASK	GENMASK(31, 1)
+#define HDCP1X_KEYMGMT_REG_CTRL_ENABLE_MASK	BIT(0)
+#define HDCP1X_KEYMGMT_REG_TBL_STATUS_RETRY	0x400
+#define HDCP1X_KEYMGMT_TBLID_0			0
+#define HDCP1X_KEYS_SIZE			336
+#define HDCP2X_LC128_SIZE			16
+#define HDCP2X_PRIVATE_SIZE			996
+#define HDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK	BIT(0)
+#define HDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK	BIT(1)
+#define HDCP1X_KEYMGMT_REG_TBL_CTRL_EN_MASK	BIT(31)
+#define HDCP1X_KEYMGMT_REG_TBL_STATUS_DONE_MASK	BIT(0)
+#define HDCP1X_KEYMGMT_MAX_TBLS			8
+#define HDCP1X_KEYMGMT_MAX_ROWS_PER_TBL		41
+#define XDPRX_LINK_ENABLE_DELAY_MS		20
+
+#define xdprxss_generate_hpd_intr(state, duration) \
+		xdprxss_write(state, XDPRX_HPD_INTR_REG, \
+			      FIELD_PREP(XDPRX_HPD_PULSE_MASK, duration) |\
+			      XDPRX_HPD_INTR_MASK)
+#define xdprxss_disable_unplug_intr(state) \
+		xdprxss_set(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_UNPLUG_MASK)
+#define xdprxss_disable_audio(state) \
+		xdprxss_clr(state, XDPRX_AUDIO_CONTROL, XDPRX_AUDIO_EN_MASK)
+#define xdprxss_enable_audio(state) \
+		xdprxss_set(state, XDPRX_AUDIO_CONTROL, XDPRX_AUDIO_EN_MASK)
+#define xdprxss_dtg_enable(state)	xdprxss_set(state, XDPRX_DTG_REG, 1)
+#define xdprxss_update_ext_rcv_cap(xdprxss, max_linkrate) \
+		xdprxss_write(xdprxss, \
+			      XDPRX_EXT_VRD_BWSET_REG, max_linkrate)
+#define xdprxss_set_clk_data_recovery_timeout_val(xdprxss, value) \
+		xdprxss_write(xdprxss, XDPRX_CDRCTRL_CFG_REG, \
+				FIELD_PREP(XDPRX_CDRCTRL_TDLOCK_MASK, value))
+#define xdprxss_enable_training_timeout(xdprxss) \
+		xdprxss_clr(xdprxss, XDPRX_CDRCTRL_CFG_REG, \
+			    XDPRX_CDRCTRL_DIS_TIMEOUT)
+#define xdprxss_enable_training_intr(xdprxss) \
+		xdprxss_clr(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_TRNG_MASK)
+#define xdprxss_enable_training_intr_1(state) \
+		xdprxss_clr(state, XDPRX_INTR_MASK_1_REG, XDPRX_INTR_TRNG_MASK_1)
+#define xdprxss_disable_allintr(state) \
+		xdprxss_set(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_ALL_MASK)
+#define xdprxss_disable_allintr_1(state) \
+		xdprxss_set(state, XDPRX_INTR_MASK_1_REG, XDPRX_INTR_ALL_MASK_1)
+#define xdprxss_enable_audio_intr(state) \
+		xdprxss_clr(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_AUDIO_MASK)
+#define xdprxss_enable_hdcp1x_interrupts(state) \
+		xdprxss_clr(state, XDPRX_INTR_MASK_REG, \
+				XDPRX_INTR_HDCP1X_MASK_ALL)
+#define xdprxss_enable_hdcp2x_interrupts(state) \
+	xdprxss_set(state, XDPRX_INTR_MASK_2_REG, \
+			XDPRX_INTR_HDCP2X_MASK_ALL)
+#define XDP_RX_HPD_INTERRUPT_ASSERT_MASK 0x01
+#define ntohll(x) be64_to_cpu(x)
+
+union xdprxss_iframe_header {
+	u32 data;
+	u8 byte[4];
+};
+
+union xdprxss_iframe_payload {
+	u32 data[8];
+	u8 byte[32];
+};
+
+struct xdprxss_infoframe {
+	union xdprxss_iframe_header header;
+	union xdprxss_iframe_payload payload;
+};
+
+/**
+ * struct xlnx_dprx_audio_data - DP Rx Subsystem audio data structure
+ * @infoframe: Audio infoframe that is received
+ * @audio_detected: To indicate audio detection
+ * @audio_update_q: wait queue for audio detection
+ */
+struct xlnx_dprx_audio_data {
+	u32 infoframe[8];
+	bool audio_detected;
+	wait_queue_head_t audio_update_q;
+};
+
+/**
+ * struct retimer_cfg - Retimer configuration structure
+ * @retimer_access_laneset: Function pointer to retimer access laneset function
+ * @retimer_rst_cr_path: Function pointer to retimer reset cr path function
+ * @retimer_rst_dp_path: Function pointer to retimer reset dp path function
+ * @retimer_prbs_mode: Function pointer to prbs mode enable/disable function
+ */
+struct retimer_cfg {
+	void (*retimer_access_laneset)(void);
+	void (*retimer_rst_cr_path)(void);
+	void (*retimer_rst_dp_path)(void);
+	void (*retimer_prbs_mode)(u8 enable);
+};
+
+/**
+ * struct vidphy_cfg - Video phy configuration structure
+ * @vidphy_prbs_mode: Function pointer to prbs mode enable/disable function
+ */
+struct vidphy_cfg {
+	void (*vidphy_prbs_mode)(u8 enable);
+};
+
+/**
+ * struct xdprxss_state - DP Rx Subsystem device structure
+ * @dev: Platform structure
+ * @subdev: The v4l2 subdev structure
+ * @ctrl_handler: control handler
+ * @drm_infoframe: DRM infoframe data
+ * @infoframe: IP infoframe data
+ * @event: Holds the video unlock event
+ * @detected_timings: Detected Video timings
+ * @phy: pointer to phy instance
+ * @pad: media pad
+ * @axi_clk: Axi lite interface clock
+ * @rx_lnk_clk: DP Rx GT clock
+ * @rx_vid_clk: DP RX Video clock
+ * @rx_dec_clk: DP Rx Decode clock
+ * @tmr_config: Pointer for timer core
+ * @dp_base: Base address of DP Rx Subsystem
+ * @edid_base: Bare Address of EDID block
+ * @hdcp1x_keymgmt_base: regmap of HDCP1X Key Management block
+ * @prvdata: Pointer to device private data
+ * @hdcp1x: Pointer to hdcp1x data
+ * @hdcp2x: Pointer to hdcp2x data
+ * @hdcp1x_key: Pointer to hdcp1x key data
+ * @hdcp2x_lc128: Pointer to hdcp2x lc128 key
+ * @hdcp2x_private: Pointer to hdcp2x Private key
+ * @retimer_prvdata: Pointer to retimer private data structure
+ * @vidphy_prvdata: Pointer to video phy private data structure
+ * @tp1_work: training pattern 1 worker
+ * @unplug_work: Unplug worker
+ * @lane_set_work: lane set worker
+ * @link_qual_work: link qual worker
+ * @lock: Lock is used for width, height, framerate variables
+ * @format: Active V4L2 format on each pad
+ * @frame_interval: Captures the frame rate
+ * @max_linkrate: Maximum supported link rate
+ * @max_lanecount: Maximux supported lane count
+ * @bpc: Bits per component
+ * @ce_req_val: Variable for storing channel status
+ * @hdcp1x_key_available: flag to indicate hdcp1x key availability
+ * @hdcp2x_key_available: flag to indicate hdcp2x key availability
+ * @versal_gt_present: flag to indicate versal-gt property in device tree
+ * @hdcp_enable: To indicate HDCP enabled or not
+ * @hdcp22_enable: To indicate HDCP22 enabled or not
+ * @audio_enable: To indicate audio enabled or not
+ * @audio_init: flag to indicate audio is initialized
+ * @rx_audio_data: audio data
+ * @valid_stream: To indicate valid video
+ * @streaming: Flag for storing streaming state
+ * @ltstate: Flag for storing link training state
+ * @hdcp2x_timer_irq: HDCP2X timer IRQ variable
+ * This structure contains the device driver related parameters
+ */
+struct xdprxss_state {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_hdr10_payload drm_infoframe;
+	struct xdprxss_infoframe infoframe;
+	struct v4l2_event event;
+	struct v4l2_dv_timings detected_timings;
+	struct phy *phy[XDPRX_MAX_LANE_COUNT];
+	struct media_pad pad;
+	struct clk *axi_clk;
+	struct clk *rx_lnk_clk;
+	struct clk *rx_vid_clk;
+	struct regmap *hdcp1x_keymgmt_base;
+	void *tmr_config;
+	void __iomem *dp_base;
+	void __iomem *edid_base;
+	void *prvdata;
+	void *hdcp1x;
+	void *hdcp2x;
+	u8 *hdcp1x_key;
+	u8 *hdcp2x_lc128;
+	u8 *hdcp2x_private;
+	struct retimer_cfg *retimer_prvdata;
+	struct vidphy_cfg *vidphy_prvdata;
+	struct delayed_work tp1_work;
+	struct delayed_work unplug_work;
+	struct work_struct lane_set_work;
+	struct work_struct link_qual_work;
+	/* protects width, height, framerate variables */
+	spinlock_t lock;
+	struct v4l2_mbus_framefmt format;
+	unsigned int frame_interval;
+	u32 max_linkrate;
+	u32 max_lanecount;
+	u32 bpc;
+	u32 ce_req_val;
+	bool hdcp1x_key_available;
+	bool hdcp2x_key_available;
+	bool versal_gt_present;
+	bool hdcp_enable;
+	bool hdcp22_enable;
+	bool audio_enable;
+	bool audio_init;
+	struct xlnx_dprx_audio_data *rx_audio_data;
+	unsigned int valid_stream : 1;
+	unsigned int streaming : 1;
+	unsigned int ltstate : 2;
+	int hdcp2x_timer_irq;
+};
+
+union hdcp1x_key_table {
+	u8 data_u8[HDCP1X_KEYS_SIZE];
+	u64 data_u64[HDCP1X_KEYS_SIZE / (sizeof(u64))];
+};
+
+/*
+ * This is a default EDID data loaded to EDID memory. It allows the source
+ * to get edid before application start on DP Rx.User can load their
+ * custom EDID data using set_edid functions call
+ */
+static u8 xilinx_edid[384] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x10, 0xac, 0x47, 0x41,
+	0x4c, 0x35, 0x37, 0x30, 0x20, 0x1b, 0x01, 0x04, 0xb5, 0x46, 0x27, 0x78,
+	0x3a, 0x76, 0x45, 0xae, 0x51, 0x33, 0xba, 0x26, 0x0d, 0x50, 0x54, 0xa5,
+	0x4b, 0x00, 0x81, 0x00, 0xb3, 0x00, 0xd1, 0x00, 0xa9, 0x40, 0x81, 0x80,
+	0xd1, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x4d, 0xd0, 0x00, 0xa0, 0xf0, 0x70,
+	0x3e, 0x80, 0x30, 0x20, 0x35, 0x00, 0xba, 0x89, 0x21, 0x00, 0x00, 0x1a,
+	0x00, 0x00, 0x00, 0xff, 0x00, 0x46, 0x46, 0x4e, 0x58, 0x4d, 0x37, 0x38,
+	0x37, 0x30, 0x37, 0x35, 0x4c, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x44,
+	0x45, 0x4c, 0x4c, 0x20, 0x55, 0x50, 0x33, 0x32, 0x31, 0x38, 0x4b, 0x0a,
+	0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x4b, 0x1e, 0xb4, 0x6c, 0x01, 0x0a,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x02, 0x70, 0x02, 0x03, 0x1d, 0xf1,
+	0x50, 0x10, 0x1f, 0x20, 0x05, 0x14, 0x04, 0x13, 0x12, 0x11, 0x03, 0x02,
+	0x16, 0x15, 0x07, 0x06, 0x01, 0x23, 0x09, 0x1f, 0x07, 0x83, 0x01, 0x00,
+	0x00, 0xa3, 0x66, 0x00, 0xa0, 0xf0, 0x70, 0x1f, 0x80, 0x30, 0x20, 0x35,
+	0x00, 0xba, 0x89, 0x21, 0x00, 0x00, 0x1a, 0x56, 0x5e, 0x00, 0xa0, 0xa0,
+	0xa0, 0x29, 0x50, 0x30, 0x20, 0x35, 0x00, 0xba, 0x89, 0x21, 0x00, 0x00,
+	0x1a, 0x7c, 0x39, 0x00, 0xA0, 0x80, 0x38, 0x1f, 0x40, 0x30, 0x20, 0x3a,
+	0x00, 0xba, 0x89, 0x21, 0x00, 0x00, 0x1a, 0xa8, 0x16, 0x00, 0xa0, 0x80,
+	0x38, 0x13, 0x40, 0x30, 0x20, 0x3a, 0x00, 0xba, 0x89, 0x21, 0x00, 0x00,
+	0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x47, 0x70, 0x12, 0x79, 0x00, 0x00, 0x12, 0x00, 0x16,
+	0x82, 0x10, 0x10, 0x00, 0xff, 0x0e, 0xdf, 0x10, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x44, 0x45, 0x4c, 0x47, 0x41, 0x4c, 0x35, 0x37, 0x30, 0x03, 0x01,
+	0x50, 0x70, 0x92, 0x01, 0x84, 0xff, 0x1d, 0xc7, 0x00, 0x1d, 0x80, 0x09,
+	0x00, 0xdf, 0x10, 0x2f, 0x00, 0x02, 0x00, 0x04, 0x00, 0xc1, 0x42, 0x01,
+	0x84, 0xff, 0x1d, 0xc7, 0x00, 0x2f, 0x80, 0x1f, 0x00, 0xdf, 0x10, 0x30,
+	0x00, 0x02, 0x00, 0x04, 0x00, 0xa8, 0x4e, 0x01, 0x04, 0xff, 0x0e, 0xc7,
+	0x00, 0x2f, 0x80, 0x1f, 0x00, 0xdf, 0x10, 0x61, 0x00, 0x02, 0x00, 0x09,
+	0x00, 0x97, 0x9d, 0x01, 0x04, 0xff, 0x0e, 0xc7, 0x00, 0x2f, 0x80, 0x1f,
+	0x00, 0xdf, 0x10, 0x2f, 0x00, 0x02, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x90,
+};
+
+static const u32 xdprxss_supported_mbus_fmts[] = {
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_VUY8_1X24,
+	MEDIA_BUS_FMT_RBG888_1X24,
+	MEDIA_BUS_FMT_UYVY10_1X20,
+	MEDIA_BUS_FMT_VUY10_1X30,
+	MEDIA_BUS_FMT_RBG101010_1X30,
+};
+
+#define XLNX_V4L2_DV_BT_2048X1080P60 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 88, 44, 20, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_CEA861) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080I50 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 1, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 274, 44, 274, 2, 5, 15, 3, 5, 15, \
+		V4L2_DV_BT_STD_CEA861) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080I60 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 1, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 66, 20, 66, 2, 5, 15, 3, 5, 15, \
+		V4L2_DV_BT_STD_CEA861) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P50 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 400, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_CEA861) \
+}
+
+#define XLNX_V4L2_DV_BT_7680X4320P25 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(7680, 4320, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 2552, 176, 592, 16, 20, 44, 0, 0, 0, \
+		V4L2_DV_BT_STD_CEA861) \
+}
+
+#define XLNX_V4L2_DV_BT_7680X4320P30 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(7680, 4320, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 552, 176, 592, 16, 20, 44, 0, 0, 0, \
+		V4L2_DV_BT_STD_CEA861) \
+}
+
+static const struct v4l2_dv_timings fmt_cap[] = {
+	V4L2_DV_BT_CEA_1280X720P25,
+	V4L2_DV_BT_CEA_1280X720P30,
+	V4L2_DV_BT_CEA_1280X720P50,
+	V4L2_DV_BT_CEA_1280X720P60,
+	V4L2_DV_BT_CEA_1920X1080P25,
+	V4L2_DV_BT_CEA_1920X1080P30,
+	V4L2_DV_BT_CEA_1920X1080P50,
+	V4L2_DV_BT_CEA_1920X1080P60,
+	V4L2_DV_BT_CEA_1920X1080I50,
+	V4L2_DV_BT_CEA_1920X1080I60,
+	V4L2_DV_BT_CEA_3840X2160P30,
+	V4L2_DV_BT_CEA_3840X2160P50,
+	V4L2_DV_BT_CEA_3840X2160P60,
+	V4L2_DV_BT_CEA_4096X2160P25,
+	V4L2_DV_BT_CEA_4096X2160P30,
+	V4L2_DV_BT_CEA_4096X2160P50,
+	V4L2_DV_BT_CEA_4096X2160P60,
+
+	XLNX_V4L2_DV_BT_2048X1080I50,
+	XLNX_V4L2_DV_BT_2048X1080I60,
+	XLNX_V4L2_DV_BT_2048X1080P50,
+	XLNX_V4L2_DV_BT_2048X1080P60,
+	XLNX_V4L2_DV_BT_7680X4320P30,
+};
+
+static inline struct xdprxss_state *
+to_xdprxssstate(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xdprxss_state, subdev);
+}
+
+/* Register related operations */
+static inline void xdprxss_hdcp1x_keymgmt_reset(struct xdprxss_state *state)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_CTRL, &data))
+		return;
+	data |= HDCP1X_KEYMGMT_REG_CTRL_RST_MASK;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_CTRL, data))
+		return;
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_CTRL, &data))
+		return;
+	data &= ~HDCP1X_KEYMGMT_REG_CTRL_RST_MASK;
+	regmap_write(state->hdcp1x_keymgmt_base, HDCP1X_KEYMGMT_REG_CTRL, data);
+}
+
+static inline void xdprxss_hdcp1x_keymgmt_enable(struct xdprxss_state *state)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_CTRL, &data))
+		return;
+	data |= HDCP1X_KEYMGMT_REG_CTRL_ENABLE_MASK;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_CTRL, data))
+		return;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TBL_CTRL, &data))
+		return;
+	data |= HDCP1X_KEYMGMT_REG_TBL_CTRL_EN_MASK;
+	regmap_write(state->hdcp1x_keymgmt_base, HDCP1X_KEYMGMT_REG_TBL_CTRL, data);
+}
+
+static inline void xdprxss_hdcp1x_keymgmt_disable(struct xdprxss_state *state)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_CTRL, &data))
+		return;
+	data &= HDCP1X_KEYMGMT_REG_CTRL_DISABLE_MASK;
+	regmap_write(state->hdcp1x_keymgmt_base, HDCP1X_KEYMGMT_REG_CTRL, data);
+}
+
+static inline u32 xdprxss_mmcm_read(struct xdprxss_state *xdprxss, u32 addr)
+{
+	return ioread32(xdprxss->dp_base + XDPRXSS_MMCM_OFFSET + addr);
+}
+
+static inline void xdprxss_mmcm_write(struct xdprxss_state *xdprxss, u32 addr,
+				      u32 value)
+{
+	iowrite32(value, xdprxss->dp_base + XDPRXSS_MMCM_OFFSET + addr);
+}
+
+static inline u32 xdprxss_read(struct xdprxss_state *xdprxss, u32 addr)
+{
+	return ioread32(xdprxss->dp_base + addr);
+}
+
+static inline void xdprxss_write(struct xdprxss_state *xdprxss, u32 addr,
+				 u32 value)
+{
+	iowrite32(value, xdprxss->dp_base + addr);
+}
+
+static inline void xdprxss_clr(struct xdprxss_state *xdprxss, u32 addr,
+			       u32 clr)
+{
+	xdprxss_write(xdprxss, addr, xdprxss_read(xdprxss, addr) & ~clr);
+}
+
+static inline void xdprxss_set(struct xdprxss_state *xdprxss, u32 addr,
+			       u32 set)
+{
+	xdprxss_write(xdprxss, addr, xdprxss_read(xdprxss, addr) | set);
+}
+
+static void xdprxss_clrset(struct xdprxss_state *dp, u32 addr,
+			   u32 clr_mask, u32 set_data)
+{
+	u32 regval;
+
+	regval = xdprxss_read(dp, addr);
+	regval &= ~clr_mask;
+	regval |= set_data << __bf_shf(clr_mask);
+	xdprxss_write(dp, addr, regval);
+}
+
+static inline void xdprxss_dpcd_update_start(struct xdprxss_state *xdprxss)
+{
+	iowrite32(0x1, xdprxss->dp_base + XDPRX_CTRL_DPCD_REG);
+}
+
+static inline void xdprxss_dpcd_update_end(struct xdprxss_state *xdprxss)
+{
+	iowrite32(0x0, xdprxss->dp_base + XDPRX_CTRL_DPCD_REG);
+}
+
+static inline int xdprxss_get_lane01_reqval(struct xdprxss_state *xdprxss)
+{
+	return xdprxss_read(xdprxss, XDPRX_DPCD_LANE01_STATUS) &
+			    XDPRX_LANE01_PEVS_MASK;
+}
+
+/**
+ * xdprxss_dpcd_update - Update the DPCD registers
+ * @xdprxss: pointer to driver state
+ * @addr: DPCD register address
+ * @val: Value to be override
+ * This function is used to override the DPCD registers set.
+ * DPCD register set is ranges from 0x084-0x0f0.
+ * Register 0x0B8(direct_dpcd_access) must be set to 1 to
+ * override DPCD values
+ */
+static inline void xdprxss_dpcd_update(struct xdprxss_state *xdprxss,
+				       u32 addr, u32 val)
+{
+	xdprxss_write(xdprxss, addr, val);
+}
+
+static inline void xdprxss_soft_video_reset(struct xdprxss_state *xdprxss)
+{
+	xdprxss_write(xdprxss, XDPRX_SOFT_RST_REG, XDPRX_SOFT_VIDRST_MASK);
+	xdprxss_write(xdprxss, XDPRX_SOFT_RST_REG, 0x0);
+}
+
+/**
+ * xlnx_dp_phy_ready - check if PHY is ready
+ * @dp: DisplayPort IP core structure
+ *
+ * check if PHY is ready. If PHY is not ready, wait 1ms to check for 100 times.
+ * This amount of delay was suggested by IP designer.
+ *
+ * Return: 0 if PHY is ready, or -ENODEV if PHY is not ready.
+ */
+static int xlnx_dp_phy_ready(struct xdprxss_state *dp)
+{
+	u32 i, reg, ready;
+
+	ready = XDPRX_PHYSTATUS_ALL_LANES_GOOD_MASK;
+
+	/* Wait for 100ms. This should be enough time for PHY to be ready */
+	for (i = 0; i < XDPRX_PHYSTATUS_READ_COUNT; i++) {
+		reg = xdprxss_read(dp, XDPRX_PHYSTATUS_REG);
+		if ((reg & ready) == ready)
+			break;
+
+		usleep_range(1000, 1100);
+	}
+
+	if (i == XDPRX_PHYSTATUS_READ_COUNT) {
+		dev_err(dp->dev, "PHY isn't ready\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void config_rx_dec_clk(struct xdprxss_state *dp, int bw_code)
+{
+	u8 p5_fedge_en, o_val, d_val, m_val;
+	u16 hightime, div_edge;
+	u32 reg;
+
+	/*
+	 * Configuring MMCM to give a /20 clock output for /16 clk input.
+	 *
+	 * GT ch0outclk (/16) --> MMCM --> /20 clock
+	 *
+	 * Thus:
+	 * 8.1G  : Input MMCM clock is 506.25, output is 405
+	 * 5.4G  : Input MMCM clock is 337.5, output is 270
+	 * 2.7G  : Input MMCM clock is 168.75, output is 135
+	 * 1.62G : Input MMCM clock is 101.25, output is 81
+	 */
+	switch (bw_code) {
+	case DP_LINK_BW_8_1:
+		m_val = XDPRX_MMCM_M_VAL_405;
+		break;
+	case DP_LINK_BW_5_4:
+		m_val = XDPRX_MMCM_M_VAL_270;
+		break;
+	case DP_LINK_BW_2_7:
+		m_val = XDPRX_MMCM_M_VAL_135;
+		break;
+	default:
+		m_val = XDPRX_MMCM_M_VAL_81;
+	}
+	d_val = XDPRX_MMCM_D_VAL;
+	o_val = m_val / XDPRX_MMCM_M_O_VAL_RATIO;
+
+	/*
+	 * MMCM is dynamically programmed for the respective rate
+	 * using the M, D, Div values
+	 */
+	hightime = o_val / MMCM_O_VAL_HIGHTIME_DIVIDER;
+	reg = XDPRX_MMCM_REG3_PREDIV2 | XDPRX_MMCM_REG3_USED | XDPRX_MMCM_REG3_MX;
+	if (o_val % MMCM_O_VAL_EDGE_DIVIDER > 1)
+		reg |= BIT(8);
+
+	p5_fedge_en = o_val % MMCM_O_VAL_FEDGE_DIVIDER;
+	reg |= p5_fedge_en << XDPRX_MMCM_CLKOUT0_P5EN_SHIFT |
+		p5_fedge_en << XDPRX_MMCM_CLKOUT0_P5FEDGE_SHIFT;
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG3_OFFSET, reg);
+	reg = hightime | hightime << MMCM_MDO_VAL_HIGHTIME_SHIFT;
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG4_OFFSET, reg);
+
+	/* Implement D */
+	reg = 0;
+	div_edge = d_val % MMCM_D_VAL_EDGE_DIVIDER;
+	hightime = d_val / MMCM_D_VAL_HIGHTIME_DIVIDER;
+	reg = reg | div_edge << XDPRX_MMCM_REG12_EDGE_SHIFT;
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG12_OFFSET, reg);
+	reg = hightime | hightime << MMCM_MDO_VAL_HIGHTIME_SHIFT;
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG13_OFFSET, reg);
+
+	/* Implement M */
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG25_OFFSET, 0);
+
+	div_edge = m_val % MMCM_M_VAL_EDGE_DIVIDER;
+	hightime = m_val / MMCM_M_VAL_HIGHTIME_DIVIDER;
+	reg = hightime | hightime << MMCM_MDO_VAL_HIGHTIME_SHIFT;
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG2_OFFSET, reg);
+	reg = XDPRX_MMCM_REG1_PREDIV2 | XDPRX_MMCM_REG1_EN | XDPRX_MMCM_REG1_MX;
+
+	if (div_edge)
+		reg = reg | XDPRX_MMCM_REG1_EDGE_MASK;
+	else
+		reg = reg & ~XDPRX_MMCM_REG1_EDGE_MASK;
+
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG1_OFFSET, reg);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG11_OFFSET, XDPRX_MMCM_REG11_VAL);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG14_OFFSET, XDPRX_MMCM_REG14_VAL);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG15_OFFSET, XDPRX_MMCM_REG15_VAL);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG16_OFFSET, XDPRX_MMCM_REG16_VAL);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG17_OFFSET, XDPRX_MMCM_REG17_VAL);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_REG26_OFFSET, XDPRX_MMCM_REG26_VAL);
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_RECONFIG_OFFSET,
+			   XDPRX_MMCM_RECONFIG_LOAD | XDPRX_MMCM_RECONFIG_SADDR);
+}
+
+static int get_rx_dec_clk_lock(struct xdprxss_state *dp)
+{
+	u32 retry = 0;
+
+	/* MMCM issued a reset */
+	xdprxss_mmcm_write(dp, XDPRX_MMCM_SWRST_OFFSET, XDPRX_MMCM_SWRST_VAL);
+	while (!(xdprxss_mmcm_read(dp, XDPRX_MMCM_STATUS_OFFSET) & BIT(0))) {
+		if (retry == XDPRX_MMCM_STATUS_RETRY)
+			return -ENODEV;
+
+		usleep_range(1000, 1100);
+		retry++;
+	}
+
+	return 0;
+}
+
+static int config_gt_control_linerate(struct xdprxss_state *dp, int bw_code)
+{
+	u32 data;
+
+	switch (bw_code) {
+	case DP_LINK_BW_1_62:
+		data = XDPRX_GTCTL_LINE_RATE_162G;
+		break;
+	case DP_LINK_BW_2_7:
+		data = XDPRX_GTCTL_LINE_RATE_270G;
+		break;
+	case DP_LINK_BW_5_4:
+		data = XDPRX_GTCTL_LINE_RATE_540G;
+		break;
+	case DP_LINK_BW_8_1:
+		data = XDPRX_GTCTL_LINE_RATE_810G;
+		break;
+	default:
+		data = XDPRX_GTCTL_LINE_RATE_810G;
+	}
+
+	xdprxss_clrset(dp, XDPRX_GTCTL_REG, XDPRX_GTCTL_LINE_RATE_MASK, data);
+
+	return xlnx_dp_phy_ready(dp);
+}
+
+static int xlnx_dp_rx_gt_control_init(struct xdprxss_state *dp)
+{
+	int ret;
+
+	/* setting initial vswing */
+	xdprxss_clrset(dp, XDPRX_GTCTL_REG, XDPRX_GTCTL_VSWING_MASK,
+		       XDPRX_GTCTL_VSWING_INIT_VAL);
+
+	xdprxss_clr(dp, XDPRX_GTCTL_REG, XDPRX_GTCTL_EN);
+	ret = xlnx_dp_phy_ready(dp);
+	if (ret < 0)
+		return ret;
+
+	/* Setting initial link rate */
+	ret = config_gt_control_linerate(dp, DP_LINK_BW_8_1);
+	if (ret) {
+		dev_err(dp->dev, "Default Line Rate setting Failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void xdprxss_dtg_disable(struct xdprxss_state *state)
+{
+	xdprxss_clr(state, XDPRX_DTG_REG, XDPRX_DTG_DIS_MASK);
+	xdprxss_soft_video_reset(state);
+}
+
+/**
+ * xdprxss_get_stream_properties - Get DP Rx stream properties
+ * @state: pointer to driver state
+ * This function decodes the stream to get stream properties
+ * like width, height, format, picture type (interlaced/progressive),etc.
+ *
+ * Return: 0 for success else errors
+ */
+static int xdprxss_get_stream_properties(struct xdprxss_state *state)
+{
+	struct v4l2_mbus_framefmt *format = &state->format;
+	struct v4l2_dv_timings *dv_timings = &state->detected_timings;
+	u32 rxmsa_mvid, rxmsa_nvid, rxmsa_misc, recv_clk_freq, linkrate, data;
+	u16 vres_total, hres_total, framerate, lanecount;
+	u16 hact, vact, hsw, vsw, hstart, vstart;
+	u8 pixel_width, fmt;
+	u16 read_val;
+
+	rxmsa_mvid = xdprxss_read(state, XDPRX_MSA_MVID_REG);
+	rxmsa_nvid = xdprxss_read(state, XDPRX_MSA_NVID_REG);
+
+	hact = xdprxss_read(state, XDPRX_MSA_HRES_REG);
+
+	vact = xdprxss_read(state, XDPRX_MSA_VHEIGHT_REG);
+	rxmsa_misc = xdprxss_read(state, XDPRX_MSA_MISC0_REG);
+
+	vres_total = xdprxss_read(state, XDPRX_MSA_VTOTAL_REG);
+	hres_total = xdprxss_read(state, XDPRX_MSA_HTOTAL_REG);
+	linkrate = xdprxss_read(state, XDPRX_LINK_BW_REG);
+	lanecount = xdprxss_read(state, XDPRX_LANE_COUNT_REG);
+	hstart = xdprxss_read(state, XDPRX_MSA_HSTART_REG);
+	vstart = xdprxss_read(state, XDPRX_MSA_VSTART_REG);
+	hsw = xdprxss_read(state, XDPRX_MSA_HSWIDTH_REG);
+	vsw = xdprxss_read(state, XDPRX_MSA_VSWIDTH_REG);
+
+	recv_clk_freq = (linkrate * 27 * rxmsa_mvid) / rxmsa_nvid;
+
+	if (recv_clk_freq > 540 && lanecount == 4)
+		pixel_width = 0x4;
+	else if (recv_clk_freq > 270 && (lanecount != 1))
+		pixel_width = 0x2;
+	else
+		pixel_width = 0x1;
+
+	framerate = (recv_clk_freq * MHZ) / (hres_total * vres_total);
+	framerate = roundup(framerate, 5);
+	xdprxss_write(state, XDPRX_LINERST_DIS_REG, 0x1);
+	/* set pixel mode as per lane count and reset the DTG */
+	xdprxss_clr(state, XDPRX_DTG_REG, XDPRX_DTG_DIS_MASK);
+	xdprxss_write(state, XDPRX_PIXEL_WIDTH_REG, pixel_width);
+	read_val = xdprxss_read(state, XDPRX_DTG_REG);
+	xdprxss_write(state, XDPRX_DTG_REG, (read_val | 0x1));
+	read_val = FIELD_GET(XDPRX_DPCD_MSA_TIMING_IGNORE_MASK,
+			     xdprxss_read(state, XDPRX_MSA_MISC1_REG));
+	if (read_val) {
+		dev_dbg(state->dev, "Read colorimetry info from SDP packet instead of MSA\n");
+		read_val = xdprxss_read(state, XDPRX_SDP_PAYLOAD_STREAM1);
+		/* Decoding Data byte 16 */
+		fmt = FIELD_GET(XDPRX_VSC_SDP_FMT_MASK, read_val);
+		state->bpc = FIELD_GET(XDPRX_VSC_SDP_BPC_MASK, read_val);
+	} else {
+		fmt = FIELD_GET(XDPRX_MSA_FMT_MASK, rxmsa_misc);
+		state->bpc = FIELD_GET(XDPRX_MSA_BPC_MASK, rxmsa_misc);
+	}
+
+	switch (fmt) {
+	case XDPRX_COLOR_FORMAT_420:
+		if (state->bpc == 10)
+			format->code = MEDIA_BUS_FMT_VYYUYY10_4X20;
+		else
+			format->code = MEDIA_BUS_FMT_VYYUYY8_1X24;
+		break;
+	case XDPRX_COLOR_FORMAT_422:
+		if (state->bpc == 10)
+			format->code = MEDIA_BUS_FMT_UYVY10_1X20;
+		else
+			format->code = MEDIA_BUS_FMT_UYVY8_1X16;
+		break;
+	case XDPRX_COLOR_FORMAT_444:
+		if (state->bpc == 10)
+			format->code = MEDIA_BUS_FMT_VUY10_1X30;
+		else
+			format->code = MEDIA_BUS_FMT_VUY8_1X24;
+		break;
+	case XDPRX_COLOR_FORMAT_RGB:
+		if (state->bpc == 10)
+			format->code = MEDIA_BUS_FMT_RBG101010_1X30;
+		else
+			format->code = MEDIA_BUS_FMT_RBG888_1X24;
+		break;
+	default:
+		dev_err(state->dev, "Unsupported color format\n");
+
+		return -EINVAL;
+	}
+
+	dv_timings->type = V4L2_DV_BT_656_1120;
+	/*
+	 * TODO : For now driver supports only progressive video.
+	 * In future, driver may add with other interlace support
+	 */
+	dv_timings->bt.interlaced = false;
+	dv_timings->bt.width = hact;
+	dv_timings->bt.height = vact;
+	dv_timings->bt.polarities = 0;
+
+	data = xdprxss_read(state, XDPRX_MSA_HSPOL_REG);
+	if (data & XDPRX_MSA_HSPOL_MASK)
+		dv_timings->bt.polarities = V4L2_DV_HSYNC_POS_POL;
+
+	data = xdprxss_read(state, XDPRX_MSA_VSPOL_REG);
+	if (data & XDPRX_MSA_VSPOL_MASK)
+		dv_timings->bt.polarities |= V4L2_DV_VSYNC_POS_POL;
+
+	dv_timings->bt.pixelclock = vres_total * hres_total * framerate;
+	dv_timings->bt.hsync = hsw;
+	dv_timings->bt.hfrontporch = (hres_total - (hact + hstart));
+	dv_timings->bt.hbackporch = hstart - hsw;
+	dv_timings->bt.vsync = vsw;
+	dv_timings->bt.vfrontporch = (vres_total - (vact + vstart));
+	dv_timings->bt.vbackporch = vstart - vsw;
+
+	spin_lock(&state->lock);
+	format->width = dv_timings->bt.width;
+	format->height = dv_timings->bt.height;
+	format->colorspace = V4L2_COLORSPACE_REC709;
+	format->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+	format->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
+	format->quantization = V4L2_QUANTIZATION_DEFAULT;
+	format->field = V4L2_FIELD_NONE;
+	state->frame_interval = framerate;
+	spin_unlock(&state->lock);
+
+	dev_dbg(state->dev, "detected properties : width %d height %d\n",
+		dv_timings->bt.width, dv_timings->bt.height);
+
+	return 0;
+}
+
+static void xdprxss_set_training_params(struct xdprxss_state *xdprxss)
+{
+	unsigned int offset;
+
+	/*
+	 * This register is used to set a minimum value which must be met
+	 * As per the Display Port protocol.The internal logic forces training
+	 * to fail until this value is met.Please refer to PG 300
+	 * https://www.xilinx.com/support/documentation/ip_documentation/dp_rx_subsystem/v2_1/pg233-displayport-rx-subsystem.pdf
+	 */
+	xdprxss_write(xdprxss, XDPRX_MINVOLT_SWING_REG, XDPRX_MIN_VS_MASK);
+	xdprxss_write(xdprxss, XDPRX_AUX_CLKDIV_REG,
+		      xdprxss_read(xdprxss, XDPRX_AUX_CLKDIV_REG) |
+		      FIELD_PREP(XDPRX_AUX_DEFER_MASK, XDPRX_AUX_DEFER_COUNT));
+
+	xdprxss_dpcd_update_start(xdprxss);
+	xdprxss_dpcd_update(xdprxss, XDPRX_TP_SET_REG,
+			    (XDPRX_AUX_RDINT_16MS << XDPRX_AUX_RDINT_SHIFT) |
+			    XDPRX_AUX_READINTRVL_REG);
+	xdprxss_dpcd_update_end(xdprxss);
+
+	xdprxss_clr(xdprxss, XDPRX_INTR_MASK_REG, XDPRX_INTR_ALL_MASK);
+
+	/* Load edid data to EDID memory block */
+	for (offset = 0; offset < XDPRX_EDID_LENGTH; offset = offset + 4) {
+		iowrite32((uint32_t)xilinx_edid[offset / 4],
+			  xdprxss->edid_base + offset);
+	}
+	xdprxss_write(xdprxss, XDPRX_LOCAL_EDID_REG, 0x1);
+	xdprxss_set(xdprxss, XDPRX_DTG_REG, XDPRX_VSCEXT_VESA_SDP_SUPPORTED);
+
+	/* Disable all the interrupts */
+	xdprxss_set(xdprxss, XDPRX_INTR_MASK_REG, XDPRX_INTR_ALL_MASK);
+	xdprxss_disable_allintr_1(xdprxss);
+
+	/* Enable trainng related interrupts */
+	xdprxss_clr(xdprxss, XDPRX_INTR_MASK_REG, XDPRX_INTR_TRNG_MASK);
+	xdprxss_enable_training_intr_1(xdprxss);
+
+	xdprxss_write(xdprxss, XDPRX_AUX_CLKDIV_REG,
+		      xdprxss_read(xdprxss, XDPRX_AUX_CLKDIV_REG) |
+		      FIELD_PREP(XDPRX_AUX_DEFER_MASK, XDPRX_AUX_DEFER_COUNT));
+	xdprxss_write(xdprxss, XDPRX_BSIDLE_TIME_REG, XDPRX_BSIDLE_TMOUT_VAL);
+	xdprxss_clr(xdprxss, XDPRX_CRC_CONFIG_REG, XDPRX_CRC_EN_MASK);
+	xdprxss_write(xdprxss, XDPRX_LINK_ENABLE_REG, 0x1);
+}
+
+static void xdprxss_core_init(struct xdprxss_state *xdprxss)
+{
+	unsigned long axi_clk;
+
+	u32 max_lanecount = xdprxss->max_lanecount;
+
+	xdprxss_dpcd_update_start(xdprxss);
+	xdprxss_dpcd_update(xdprxss,
+			    XDPRX_VRD_BWSET_REG, xdprxss->max_linkrate);
+	xdprxss_update_ext_rcv_cap(xdprxss, xdprxss->max_linkrate);
+	max_lanecount |= (XDPRX_EFRAME_CAP_MASK | XDPRX_LNCNT_TPS3_MASK);
+	xdprxss_dpcd_update(xdprxss, XDPRX_LANE_CNT_REG, max_lanecount);
+	xdprxss_dpcd_update_end(xdprxss);
+	xdprxss_write(xdprxss, XDPRX_LINK_ENABLE_REG, 0x0);
+	axi_clk = clk_get_rate(xdprxss->axi_clk);
+	xdprxss_write(xdprxss, XDPRX_AUX_CLKDIV_REG, axi_clk / MHZ);
+	/* Put both GT RX/TX and CPLL into reset */
+	xdprxss_write(xdprxss, XDPRX_PHY_REG, XDPRX_PHY_GTPLLRST_MASK |
+		      XDPRX_PHY_GTRXRST_MASK);
+	/* Release CPLL reset */
+	xdprxss_write(xdprxss, XDPRX_PHY_REG, XDPRX_PHY_GTRXRST_MASK);
+	xdprxss_set_clk_data_recovery_timeout_val(xdprxss,
+						  XDPRX_CDRCTRL_TDLOCK_VAL);
+	/*
+	 * Remove the reset from the PHY and configure to issue reset after
+	 * every training iteration, link rate change, and start of training
+	 * pattern
+	 */
+	xdprxss_write(xdprxss, XDPRX_PHY_REG,
+		      XDPRX_PHYRST_ENBL_MASK |
+		      XDPRX_PHYRST_TRITER_MASK |
+		      XDPRX_PHYRST_RATECHANGE_MASK |
+		      XDPRX_PHYRST_TP1START_MASK);
+	xdprxss_write(xdprxss, XDPRX_MST_CAP_REG, 0x0);
+	xdprxss_write(xdprxss, XDPRX_SINK_COUNT_REG, 1);
+	xdprxss_enable_training_timeout(xdprxss);
+	xdprxss_set_training_params(xdprxss);
+}
+
+static void xdprxss_irq_unplug(struct xdprxss_state *state)
+{
+	dev_dbg(state->dev, "Asserted cable unplug interrupt\n");
+	if (state->hdcp22_enable)
+		xhdcp2x_rx_disable(state->hdcp2x);
+	if (state->hdcp_enable)
+		xhdcp1x_rx_disable(state->hdcp1x);
+
+	xdprxss_set(state, XDPRX_SOFT_RST_REG, XDPRX_SOFT_VIDRST_MASK);
+	xdprxss_clr(state, XDPRX_SOFT_RST_REG, XDPRX_SOFT_VIDRST_MASK);
+
+	if (state->retimer_prvdata)
+		state->retimer_prvdata->retimer_rst_dp_path();
+
+	/*
+	 * Disable unplug interrupt so that no unplug event when RX is
+	 * disconnected
+	 */
+	xdprxss_disable_unplug_intr(state);
+	xdprxss_generate_hpd_intr(state, XDPRX_HPD_PULSE_750);
+
+	xdprxss_disable_allintr(state);
+	xdprxss_disable_allintr_1(state);
+
+	xdprxss_enable_training_intr(state);
+	xdprxss_enable_training_intr_1(state);
+	/*
+	 * In a scenario, where the cable is plugged-in but the training
+	 * is lost, the software is expected to assert a HPD upon the
+	 * occurrence of a TRAINING_LOST interrupt, so that the Source
+	 * can retrain the link.
+	 */
+	xdprxss_write(state, XDPRX_HPD_INTR_REG,
+		      FIELD_PREP(XDPRX_HPD_PULSE_MASK, XDPRX_HPD_PULSE_5000) |
+		      XDPRX_HPD_INTR_MASK);
+}
+
+static void xdprxss_irq_tp1(struct xdprxss_state *state)
+{
+	union phy_configure_opts phy_opts = { 0 };
+	struct phy_configure_opts_dp *phy_cfg = &phy_opts.dp;
+	u32 linkrate;
+	unsigned int i;
+
+	dev_dbg(state->dev, "Asserted traning pattern 1\n");
+
+	linkrate = xdprxss_read(state, XDPRX_LINK_BW_REG);
+
+	switch (linkrate) {
+	case DP_LINK_BW_1_62:
+	case DP_LINK_BW_2_7:
+	case DP_LINK_BW_5_4:
+	case DP_LINK_BW_8_1:
+		phy_cfg->link_rate = linkrate * 270;
+		break;
+	default:
+		dev_err(state->dev, "invalid link rate\n");
+		break;
+	}
+
+	if (state->retimer_prvdata) {
+		state->retimer_prvdata->retimer_rst_cr_path();
+		state->retimer_prvdata->retimer_access_laneset();
+	}
+
+	if (!state->versal_gt_present) {
+		phy_cfg->set_rate = 1;
+		for (i = 0; i < state->max_lanecount; i++)
+			phy_configure(state->phy[i], &phy_opts);
+		/* Initialize phy logic of DP-RX core */
+		xdprxss_write(state, XDPRX_PHY_REG, XDPRX_PHY_INIT_MASK);
+		phy_reset(state->phy[0]);
+	} else {
+		config_rx_dec_clk(state, linkrate);
+
+		config_gt_control_linerate(state, linkrate);
+
+		if (get_rx_dec_clk_lock(state))
+			dev_info(state->dev, "rx decryption clock failed to lock\n");
+
+		/* Initialize phy logic of DP-RX core */
+		xdprxss_write(state, XDPRX_PHY_REG, XDPRX_PHY_INIT_MASK);
+	}
+	state->ltstate = 1;
+	xdprxss_clr(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_ALL_MASK);
+}
+
+static void xdprxss_irq_tp2(struct xdprxss_state *state)
+{
+	dev_dbg(state->dev, "Asserted traning pattern 2\n");
+	state->ltstate = 2;
+}
+
+static void xdprxss_training_failure(struct xdprxss_state *state)
+{
+	dev_dbg(state->dev, "Traning Lost !!\n");
+	state->valid_stream = false;
+
+	if (state->hdcp_enable)
+		xhdcp1x_rx_disable(state->hdcp1x);
+	if (state->hdcp22_enable)
+		xhdcp2x_rx_disable(state->hdcp2x);
+
+	xdprxss_write(state, XDPRX_HPD_INTR_REG,
+		      FIELD_PREP(XDPRX_HPD_PULSE_MASK, XDPRX_HPD_PULSE_750) |
+		      XDPRX_HPD_INTR_MASK);
+
+	/* reset the aux logic */
+	xdprxss_set(state, XDPRX_SOFT_RST_REG, XDPRX_SOFT_AUXRST_MASK);
+	xdprxss_clr(state, XDPRX_SOFT_RST_REG, XDPRX_SOFT_AUXRST_MASK);
+	xdprxss_disable_audio(state);
+}
+
+static void xdprxss_irq_no_video(struct xdprxss_state *state)
+{
+	dev_dbg(state->dev, "No Valid video received !!\n");
+
+	xdprxss_write(state, XDPRX_VIDEO_UNSUPPORTED_REG, 0x1);
+	xdprxss_clr(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_VBLANK_MASK);
+	xdprxss_set(state, XDPRX_INTR_MASK_REG, XDPRX_INTR_NOVID_MASK);
+
+	xdprxss_dtg_disable(state);
+	xdprxss_dtg_enable(state);
+
+	xdprxss_enable_audio_intr(state);
+
+	/* notify source change event */
+	memset(&state->event, 0, sizeof(state->event));
+	state->event.type = V4L2_EVENT_SOURCE_CHANGE;
+	state->event.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION;
+	v4l2_subdev_notify_event(&state->subdev, &state->event);
+	state->valid_stream = false;
+}
+
+static void xdprxss_irq_valid_video(struct xdprxss_state *state)
+{
+	dev_dbg(state->dev, "Valid Video received !!\n");
+	xdprxss_write(state, XDPRX_VIDEO_UNSUPPORTED_REG, 0x0);
+
+	if (!xdprxss_get_stream_properties(state)) {
+		memset(&state->event, 0, sizeof(state->event));
+		state->event.type = V4L2_EVENT_SOURCE_CHANGE;
+		state->event.u.src_change.changes =
+				V4L2_EVENT_SRC_CH_RESOLUTION;
+		v4l2_subdev_notify_event(&state->subdev, &state->event);
+		state->valid_stream = true;
+	} else {
+		dev_err(state->dev, "Unable to get stream properties!\n");
+		state->valid_stream = false;
+	}
+
+	xdprxss_disable_audio(state);
+	xdprxss_enable_audio(state);
+}
+
+/**
+ * xdprxss_parse_drmif - Parse DRM infoframe from received infoframe packet
+ * @state: pointer to driver state
+ * @drm_infoframe: DRM infoframe structure member
+ * This function parses DRM(Dynamic Range and Mastering InfoFrame) infoframe
+ * from received infoframe packet. For more information please refer to the
+ * section 6.9 in CTA-861-G
+ *
+ */
+static void xdprxss_parse_drmif(struct xdprxss_state *state,
+				struct v4l2_hdr10_payload *drm_infoframe)
+{
+	struct xdprxss_infoframe *iframe = &state->infoframe;
+
+	drm_infoframe->eotf = iframe->payload.byte[2] & 0x7;
+	drm_infoframe->metadata_type = iframe->payload.byte[3] & 0x7;
+	drm_infoframe->display_primaries[0].x =
+					(iframe->payload.byte[4] & 0xFF) |
+					(iframe->payload.byte[5] << 8);
+	drm_infoframe->display_primaries[0].y =
+					(iframe->payload.byte[6] & 0xFF) |
+					(iframe->payload.byte[7] << 8);
+	drm_infoframe->display_primaries[1].x =
+					(iframe->payload.byte[8] & 0xFF) |
+					(iframe->payload.byte[9] << 8);
+	drm_infoframe->display_primaries[1].y =
+					(iframe->payload.byte[10] & 0xFF) |
+					(iframe->payload.byte[11] << 8);
+	drm_infoframe->display_primaries[2].x =
+					(iframe->payload.byte[12] & 0xFF) |
+					(iframe->payload.byte[13] << 8);
+	drm_infoframe->display_primaries[2].y =
+					(iframe->payload.byte[14] & 0xFF) |
+					(iframe->payload.byte[15] << 8);
+	drm_infoframe->white_point.x =
+				(iframe->payload.byte[16] & 0xFF) |
+				(iframe->payload.byte[17] << 8);
+	drm_infoframe->white_point.y =
+				(iframe->payload.byte[18] & 0xFF) |
+				(iframe->payload.byte[19] << 8);
+	drm_infoframe->max_mdl = (iframe->payload.byte[20] & 0xFF) |
+				(iframe->payload.byte[21] << 8);
+	drm_infoframe->min_mdl = (iframe->payload.byte[22] & 0xFF) |
+				(iframe->payload.byte[23] << 8);
+	drm_infoframe->max_cll = (iframe->payload.byte[24] & 0xFF) |
+				(iframe->payload.byte[25] << 8);
+	drm_infoframe->max_fall = (iframe->payload.byte[26] & 0xFF) |
+				(iframe->payload.byte[27] << 8);
+}
+
+static void xdprxss_irq_audio_detected(struct xdprxss_state *state)
+{
+	struct xdprxss_infoframe *iframe = &state->infoframe;
+	struct v4l2_hdr10_payload *drm_infoframe = &state->drm_infoframe;
+	u32 buff[INFO_PCKT_SIZE_WORDS];
+	u8 *buf_ptr;
+	int i;
+
+	iframe->header.data = xdprxss_read(state, XDPRX_AUDIO_INFO_DATA);
+	buff[0] = iframe->header.data;
+	for (i = 0; i < (INFO_PCKT_SIZE_WORDS - 1); i++) {
+		iframe->payload.data[i] = xdprxss_read(state,
+						       XDPRX_AUDIO_INFO_DATA);
+		buff[i + 1] = iframe->payload.data[i];
+	}
+
+	buf_ptr = (u8 *)buff;
+	memcpy(state->rx_audio_data->infoframe, buff, INFO_PCKT_SIZE);
+
+	if (buf_ptr[1] == INFO_PCKT_TYPE_AUDIO)
+		state->rx_audio_data->audio_detected = true;
+	if (iframe->header.byte[1] == INFO_PCKT_TYPE_DRM) {
+		memset((void *)drm_infoframe, 0,
+		       sizeof(struct v4l2_hdr10_payload));
+		xdprxss_parse_drmif(state, drm_infoframe);
+	}
+}
+
+static void xdprxss_irq_access_laneset(struct xdprxss_state *state)
+{
+	u32 read_val;
+	u8 training;
+
+	training = xdprxss_read(state, XDPRX_DPCD_TRAINING_PATTERN_SET);
+
+	if (state->ltstate == 2 && training != 1) {
+		read_val = xdprxss_get_lane01_reqval(state);
+
+		if (state->ce_req_val != read_val && state->retimer_prvdata)
+			state->retimer_prvdata->retimer_access_laneset();
+
+		/* Update the value to be used in next round */
+		state->ce_req_val = xdprxss_get_lane01_reqval(state);
+	}
+}
+
+static void xdprxss_irq_access_linkqual(struct xdprxss_state *state)
+{
+	u32 read_val;
+
+	read_val = xdprxss_read(state, XDPRX_DPC_LINK_QUAL_CONFIG);
+
+	if ((read_val & XDPRX_LINK_QUAL_PRBS_MODE_MASK) ==
+	    XDPRX_DPCD_LINK_QUAL_PRBS_MASK) {
+		/* enable PRBS mode in video phy */
+		state->vidphy_prvdata->vidphy_prbs_mode(1);
+		/* enable PRBS mode in retimer */
+		state->retimer_prvdata->retimer_prbs_mode(1);
+	} else {
+		/* disable PRBS mode in video phy */
+		state->vidphy_prvdata->vidphy_prbs_mode(0);
+		/* disable PRBS mode in retimer */
+		state->retimer_prvdata->retimer_prbs_mode(0);
+	}
+}
+
+static irqreturn_t xdprxss_irq_handler(int irq, void *dev_id)
+{
+	struct xdprxss_state *state = (struct xdprxss_state *)dev_id;
+	u32 status, status1, status2;
+	u32 lane_count;
+	u8 index;
+
+	status = xdprxss_read(state, XDPRX_INTR_CAUSE_REG);
+	status &= ~xdprxss_read(state, XDPRX_INTR_MASK_REG);
+
+	status1 = xdprxss_read(state, XDPRX_INTR_CAUSE_1_REG);
+	status1 &= ~xdprxss_read(state, XDPRX_INTR_MASK_1_REG);
+
+	status2 = xdprxss_read(state, XDPRX_INTR_CAUSE_2_REG);
+
+	if (!status && !status1 && !status2)
+		return IRQ_NONE;
+
+	if (status1 & XDPRX_INTR_ACCESS_LANE_SET_MASK)
+		schedule_work(&state->lane_set_work);
+	if (status1 & XDPRX_INTR_LINKQUAL_MASK)
+		schedule_work(&state->link_qual_work);
+	if (status & XDPRX_INTR_UNPLUG_MASK)
+		schedule_delayed_work(&state->unplug_work, 0);
+	if (status & XDPRX_INTR_TP1_MASK)
+		schedule_delayed_work(&state->tp1_work, 0);
+	if (status & XDPRX_INTR_TP2_MASK)
+		xdprxss_irq_tp2(state);
+	if (status & XDPRX_INTR_TRLOST_MASK)
+		xdprxss_training_failure(state);
+	if (status & XDPRX_INTR_NOVID_MASK)
+		xdprxss_irq_no_video(state);
+	if (status & XDPRX_INTR_VID_MASK)
+		xdprxss_irq_valid_video(state);
+	if (status & XDPRX_INTR_AUDIO_MASK)
+		xdprxss_irq_audio_detected(state);
+	if (status & XDPRX_INTR_TRDONE_MASK) {
+		lane_count = xdprxss_read(state, XDPRX_LANE_COUNT_REG);
+		if (state->hdcp22_enable && state->hdcp2x_key_available)
+			xhdcp2x_rx_enable(state->hdcp2x, lane_count);
+		if (state->hdcp_enable && state->hdcp1x_key_available)
+			xhdcp1x_rx_enable(state->hdcp1x, lane_count);
+		dev_dbg(state->dev, "DP Link training is done !!\n");
+	}
+	if (status & XDPRX_INTR_HDCP1X_AKSV_WRITE_MASK)
+		xhdcp1x_rx_push_events(state->hdcp1x, XHDCP1X_RX_AKSV_RCVD);
+	if (status & XDPRX_INTR_HDCP1X_RO_READ_MASK)
+		xhdcp1x_rx_push_events(state->hdcp1x,
+				       XHDCP1X_RX_RO_PRIME_READ_DONE);
+
+	if (status2 & XDPRX_INTR_HDCP2X_AKE_INIT_MASK) {
+		for (index = 0; index < 2; index++) {
+			xdprxss_write(state, XDPRX_SOFT_RST_REG_HDCP2X_MASK, XDPRX_SOFT_RST_REG);
+			xdprxss_write(state, XDPRX_SOFT_RST_REG_HDCP2X_MASK, 0);
+		}
+		xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_DPCD_AKE_INIT_RCVD);
+	}
+	if (status2 & XDPRX_INTR_HDCP2X_AKE_NO_STORED_KM_MASK)
+		xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_DPCD_AKE_NO_STORED_KM_RCVD);
+
+	if (status2 & XDPRX_INTR_HDCP2X_AKE_STORED_KM_MASK)
+		xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_DPCD_AKE_STORED_KM_RCVD);
+
+	if (status2 & XDPRX_INTR_HDCP2X_LC_INIT_MASK)
+		xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_DPCD_LC_INIT_RCVD);
+
+	if (status2 & XDPRX_INTR_HDCP2X_SKE_SEND_EKS_MASK)
+		xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_DPCD_SKE_SEND_EKS_RCVD);
+
+	if (status2 & XDPRX_INTR_HDCP2X_HPRIME_READ_DONE_MASK)
+		xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_DPCD_HPRIME_READ_DONE_RCVD);
+
+	if (status2 & XDPRX_INTR_HDCP2X_STREAM_TYPE_MASK)
+		xhdcp2x_rx_set_stream_type(state->hdcp2x);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xdprxss_subscribe_event - Subscribe to video source change event
+ * @sd: V4L2 Sub device
+ * @fh: V4L2 File Handle
+ * @sub: Subcribe event structure
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int xdprxss_subscribe_event(struct v4l2_subdev *sd,
+				   struct v4l2_fh *fh,
+				   struct v4l2_event_subscription *sub)
+{
+	int ret;
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+
+	dev_dbg(xdprxss->dev, "Event subscribed : 0x%08x\n", sub->type);
+
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		ret = v4l2_src_change_event_subscribe(fh, sub);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int xdprxss_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+
+	/* DP does not need to be enabled when we start streaming */
+	if (enable == xdprxss->streaming)
+		return 0;
+
+	if (enable && !xdprxss->valid_stream)
+		return -EINVAL;
+
+	xdprxss->streaming = enable;
+
+	return 0;
+}
+
+/**
+ * xdprxss_g_input_status - It is used to determine if the video signal
+ * is present / locked onto or not.
+ *
+ * @sd: V4L2 Sub device
+ * @status: status of signal locked
+ *
+ * This is used to determine if the valid video signal is present and
+ * locked onto by the DP Rx xdprxss or not .
+ *
+ * Return: zero on success
+ */
+static int xdprxss_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+
+	if (!xdprxss->valid_stream)
+		*status = V4L2_IN_ST_NO_SYNC | V4L2_IN_ST_NO_SIGNAL;
+	else
+		*status = 0;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__xdprxss_get_pad_format(struct xdprxss_state *xdprxss,
+			 struct v4l2_subdev_state *sd_state,
+			 unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xdprxss->subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xdprxss->format;
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+/**
+ * xdprxss_init_cfg - Initialise the pad format config to default
+ * @sd: Pointer to V4L2 Sub device structure
+ * @sd_state: Pointer to sub device pad information structure
+ *
+ * This function is used to initialize the pad format with the default
+ * values.
+ *
+ * Return: 0 on success
+ */
+static int xdprxss_init_cfg(struct v4l2_subdev *sd,
+			    struct v4l2_subdev_state *sd_state)
+{
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(sd, sd_state, 0);
+
+	if (!xdprxss->valid_stream)
+		*format = xdprxss->format;
+
+	return 0;
+}
+
+/**
+ * xdprxss_getset_format - This is used to set and get the pad format
+ * @sd: Pointer to V4L2 Sub device structure
+ * @sd_state: Pointer to sub device pad information structure
+ * @fmt: Pointer to pad level media bus format
+ *
+ * This function is used to set the pad format.
+ * Since the pad format is fixed in hardware, it can't be
+ * modified on run time.
+ *
+ * Return: 0 on success
+ */
+static int xdprxss_getset_format(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	if (!xdprxss->valid_stream) {
+		dev_err(xdprxss->dev, "Video not locked!\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(xdprxss->dev,
+		"set width %d height %d code %d field %d colorspace %d\n",
+		fmt->format.width, fmt->format.height,
+		fmt->format.code, fmt->format.field,
+		fmt->format.colorspace);
+	format = __xdprxss_get_pad_format(xdprxss, sd_state,
+					  fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+/**
+ * xdprxss_enum_mbus_code - Handle pixel format enumeration
+ * @sd: pointer to v4l2 subdev structure
+ * @sd_state: V4L2 subdev pad configuration
+ * @code: pointer to v4l2_subdev_mbus_code_enum structure
+ *
+ * Return: -EINVAL or zero on success
+ */
+static int xdprxss_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+	u32 index = code->index;
+	u32 base = 0;
+
+	if (xdprxss->bpc == 8)
+		base = 0;
+
+	if (xdprxss->bpc == 10)
+		base = 3;
+
+	if (code->pad || index >= 3)
+		return -EINVAL;
+
+	code->code = xdprxss_supported_mbus_fmts[base + index];
+
+	return 0;
+}
+
+/**
+ * xdprxss_enum_dv_timings - Enumerate all the supported DV timings
+ * @sd: pointer to v4l2 subdev structure
+ * @timings: DV timings structure to be returned.
+ *
+ * Return: -EINVAL incase of invalid index and pad or zero on success
+ */
+static int xdprxss_enum_dv_timings(struct v4l2_subdev *sd,
+				   struct v4l2_enum_dv_timings *timings)
+{
+	if (timings->index >= ARRAY_SIZE(fmt_cap))
+		return -EINVAL;
+
+	if (timings->pad != 0)
+		return -EINVAL;
+
+	timings->timings = fmt_cap[timings->index];
+
+	return 0;
+}
+
+/**
+ * xdprxss_get_dv_timings_cap - This is used to set the dv timing
+ * capabilities
+ * @subdev: Pointer to V4L2 Sub device structure
+ * @cap: Pointer to dv timing capability structure
+ *
+ * Return: -EINVAL incase of invalid pad or zero on success
+ */
+static int xdprxss_get_dv_timings_cap(struct v4l2_subdev *subdev,
+				      struct v4l2_dv_timings_cap *cap)
+{
+	struct v4l2_dv_timings_cap xdprxss_dv_timings_cap = {
+		.type = V4L2_DV_BT_656_1120,
+		.reserved = { 0 },
+		V4L2_INIT_BT_TIMINGS
+		(800, 7680,
+		600, 4320,
+		25000000, 297000000,
+		V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+		V4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,
+		V4L2_DV_BT_CAP_INTERLACED | V4L2_DV_BT_CAP_PROGRESSIVE |
+		V4L2_DV_BT_CAP_REDUCED_BLANKING |
+		V4L2_DV_BT_CAP_CUSTOM
+		)
+	};
+
+	if (cap->pad != 0)
+		return -EINVAL;
+
+	*cap = xdprxss_dv_timings_cap;
+
+	return 0;
+}
+
+static int xdprxss_query_dv_timings(struct v4l2_subdev *sd,
+				    struct v4l2_dv_timings *timings)
+{
+	struct xdprxss_state *state = to_xdprxssstate(sd);
+
+	if (!timings)
+		return -EINVAL;
+
+	if (!state->valid_stream)
+		return -ENOLCK;
+
+	*timings = state->detected_timings;
+
+	return 0;
+}
+
+static int xdprxss_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct xdprxss_state *state = container_of(ctrl->handler,
+						   struct xdprxss_state,
+						   ctrl_handler);
+	struct v4l2_metadata_hdr *hdr_ptr;
+
+	switch (ctrl->id) {
+	case V4L2_CID_METADATA_HDR:
+		if (!state->valid_stream) {
+			dev_err(state->dev, "Can't get values when video not locked!\n");
+			return -EINVAL;
+		}
+		hdr_ptr = (struct v4l2_metadata_hdr *)ctrl->p_new.p;
+		hdr_ptr->metadata_type = V4L2_HDR_TYPE_HDR10;
+		hdr_ptr->size = sizeof(struct v4l2_hdr10_payload);
+		memcpy(hdr_ptr->payload, &state->drm_infoframe,
+		       hdr_ptr->size);
+		break;
+	default:
+		dev_err(state->dev, "Get Invalid control id 0x%08x\n", ctrl->id);
+		ret = -EINVAL;
+	}
+
+	dev_dbg(state->dev, "Get ctrl id = 0x%08x val = 0x%08x\n",
+		ctrl->id, ctrl->val);
+	return ret;
+}
+
+/* ------------------------------------------------------------
+ * Media Operations
+ */
+static const struct v4l2_ctrl_ops xdprxss_ctrl_ops = {
+	.g_volatile_ctrl = xdprxss_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config xdprxss_ctrls[] = {
+	{
+		.ops = &xdprxss_ctrl_ops,
+		.id = V4L2_CID_METADATA_HDR,
+		.name = "HDR Controls",
+		.type = V4L2_CTRL_TYPE_HDR,
+		.min = 0x8000000000000000,
+		.max = 0x7FFFFFFFFFFFFFFF,
+		.step = 1,
+		.def = 0,
+		.elem_size = sizeof(struct v4l2_metadata_hdr),
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_HAS_PAYLOAD,
+	}
+};
+
+static const struct media_entity_operations xdprxss_media_ops = {
+	.link_validate = v4l2_subdev_link_validate
+};
+
+static int xdprxss_hdcp1x_keymgmt_is_table_config_done(struct xdprxss_state *state)
+{
+	int retry = HDCP1X_KEYMGMT_REG_TBL_STATUS_RETRY;
+	u32 data;
+
+	while (retry) {
+		if (regmap_read(state->hdcp1x_keymgmt_base,
+				HDCP1X_KEYMGMT_REG_TBL_STATUS, &data))
+			return 0;
+		if (!(data & HDCP1X_KEYMGMT_REG_TBL_STATUS_DONE_MASK))
+			break;
+		retry--;
+	}
+
+	return retry;
+}
+
+static int xdprxss_hdcp1x_keymgmt_table_read(struct xdprxss_state *state,
+					     u8 table_id, u8 row_id, u64 *read_val)
+{
+	u64 temp;
+	u32 addr, data;
+
+	addr = table_id;
+	addr <<= BITS_PER_BYTE;
+	addr |= row_id;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TBL_CTRL, &data))
+		return -EIO;
+	data &= ~HDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK;
+	data |= HDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_TBL_CTRL, data))
+		return -EIO;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_TBL_ADDR, addr))
+		return -EIO;
+	if (!xdprxss_hdcp1x_keymgmt_is_table_config_done(state))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TBL_DAT_H, &data))
+		return -EIO;
+	temp = data;
+	temp <<= BITS_PER_BYTE * sizeof(u32);
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TBL_DAT_L, &data))
+		return -EIO;
+	temp |= data;
+	*read_val = temp;
+
+	return 0;
+}
+
+static int xdprxss_hdcp1x_keymgmt_table_write(struct xdprxss_state *state,
+					      u8 table_id, u8 row_id, u64 write_val)
+{
+	u32 addr, data;
+
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_TBL_DAT_L,
+			 lower_32_bits(write_val)))
+		return -EIO;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_TBL_DAT_H,
+			 upper_32_bits(write_val)))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TBL_CTRL, &data))
+		return -EIO;
+	data &= ~HDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK;
+	data |= HDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_TBL_CTRL, data))
+		return -EIO;
+
+	addr = table_id;
+	addr <<= BITS_PER_BYTE;
+	addr |= row_id;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 HDCP1X_KEYMGMT_REG_TBL_ADDR, addr))
+		return -EIO;
+	if (!xdprxss_hdcp1x_keymgmt_is_table_config_done(state))
+		return -EIO;
+
+	return 0;
+}
+
+static void xdprxss_hdcp1x_keymgmt_get_num_of_tables_rows(struct xdprxss_state *state,
+							  u8 *num_tables,
+							  u8 *num_rows_per_table)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TYPE, &data))
+		return;
+
+	if (data) {
+		*num_tables = (data >> 8) & 0xFF;
+		*num_rows_per_table = data & 0xFF;
+	} else {
+		*num_tables = HDCP1X_KEYMGMT_MAX_TBLS;
+		*num_rows_per_table = HDCP1X_KEYMGMT_MAX_ROWS_PER_TBL;
+	}
+}
+
+static int xdprxss_hdcp1x_keymgmt_init_tables(struct xdprxss_state *state)
+{
+	int ret = 0;
+	u8 num_tables = 0, num_rows_per_table = 0, table_id, row_id;
+
+	xdprxss_hdcp1x_keymgmt_get_num_of_tables_rows(state, &num_tables,
+						      &num_rows_per_table);
+	for (table_id = 0; table_id < num_tables; table_id++)
+		for (row_id = 0; row_id < num_rows_per_table; row_id++)
+			if (xdprxss_hdcp1x_keymgmt_table_write(state, table_id,
+							       row_id, 0))
+				return -EIO;
+	return ret;
+}
+
+static int xdprxss_hdcp1x_keymgmt_load_keys(struct xdprxss_state *state,
+					    union hdcp1x_key_table *key_table,
+					    u32 key_table_size)
+{
+	int ret = 0;
+	u8 row_id;
+
+	for (row_id = 0; row_id < (key_table_size / sizeof(u64)); row_id++)
+		if (xdprxss_hdcp1x_keymgmt_table_write(state, HDCP1X_KEYMGMT_TBLID_0,
+						       row_id, key_table->data_u64[row_id]))
+			ret = -EIO;
+
+	return ret;
+}
+
+static int xdprxss_hdcp1x_keymgmt_verify_keys(struct xdprxss_state *state,
+					      union hdcp1x_key_table *key_table,
+					      u32 key_table_size)
+{
+	u64 data;
+	int ret = 0;
+	u8 row_id;
+
+	for (row_id = 0; row_id < (key_table_size / sizeof(u64)); row_id++) {
+		data = 0;
+		xdprxss_hdcp1x_keymgmt_table_read(state, HDCP1X_KEYMGMT_TBLID_0,
+						  row_id, &data);
+		if (data != key_table->data_u64[row_id])
+			ret = -EIO;
+	}
+
+	return ret;
+}
+
+static int xdprxss_hdcp1x_keymgmt_set_key(struct xdprxss_state *state)
+{
+	union hdcp1x_key_table key_table;
+	int ret;
+	u32 version, type;
+	u8 index;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_VERSION, &version))
+		return -EIO;
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			HDCP1X_KEYMGMT_REG_TYPE, &type))
+		return -EIO;
+	if (!version && !type) {
+		dev_err(state->dev, "hdcp1x keymgmt core is not present\n");
+		return -ENODEV;
+	}
+
+	xdprxss_hdcp1x_keymgmt_reset(state);
+	ret = xdprxss_hdcp1x_keymgmt_init_tables(state);
+	if (ret)
+		return ret;
+	xdprxss_hdcp1x_keymgmt_disable(state);
+	memcpy(key_table.data_u8, state->hdcp1x_key, HDCP1X_KEYS_SIZE);
+	/* adjust the endian-ness to host order */
+	for (index = 0; index < HDCP1X_KEYS_SIZE / sizeof(u64); index++)
+		key_table.data_u64[index] = ntohll(key_table.data_u64[index]);
+	ret = xdprxss_hdcp1x_keymgmt_load_keys(state, &key_table,
+					       HDCP1X_KEYS_SIZE);
+	if (ret)
+		return ret;
+	ret = xdprxss_hdcp1x_keymgmt_verify_keys(state, &key_table,
+						 HDCP1X_KEYS_SIZE);
+	if (ret)
+		return ret;
+	xdprxss_hdcp1x_keymgmt_enable(state);
+
+	return ret;
+}
+
+static int xdprxss_hdcp2x_key_write(struct xdprxss_state *xdprxss,
+				    struct xdprxss_hdcp2x_keys_ioctl *xhdcp22_keys)
+{
+	int ret = 0;
+
+	if (xhdcp22_keys->size_lc128 != HDCP2X_LC128_SIZE &&
+	    xhdcp22_keys->size_private != HDCP2X_PRIVATE_SIZE)
+		return -EINVAL;
+
+	if (copy_from_user(xdprxss->hdcp2x_lc128, xhdcp22_keys->key_lc128,
+			   xhdcp22_keys->size_lc128))
+		return -EFAULT;
+
+	if (copy_from_user(xdprxss->hdcp2x_private, xhdcp22_keys->key_private,
+			   xhdcp22_keys->size_private))
+		return -EFAULT;
+
+	xdprxss->hdcp2x_key_available = true;
+
+	ret = xhdcp2x_rx_set_key(xdprxss->hdcp2x, xdprxss->hdcp2x_lc128, xdprxss->hdcp2x_private);
+	if (ret < 0)
+		return ret;
+
+	/* give a HPD to let the upstream do a new link training */
+	xdprxss_generate_hpd_intr(xdprxss, XDPRX_HPD_PULSE_5000);
+	xdprxss_write(xdprxss, XDPRX_LINK_ENABLE_REG, 0x0);
+
+	/*
+	 * TODO: without below sleep the DP Rx IP is not giving the HPD to
+	 * upstream, this needs to be removed once the issue fixed in IP
+	 */
+	msleep(XDPRX_LINK_ENABLE_DELAY_MS);
+	xdprxss_write(xdprxss, XDPRX_LINK_ENABLE_REG, 0x1);
+
+	return ret;
+}
+
+static int xdprxss_hdcp1x_key_write(struct xdprxss_state *xdprxss,
+				    struct xdprxss_hdcp1x_keys_ioctl *hdcp_keys)
+{
+	int ret = 0;
+
+	if (hdcp_keys->size != HDCP1X_KEYS_SIZE)
+		return -EINVAL;
+
+	if (copy_from_user(xdprxss->hdcp1x_key, hdcp_keys->keys,
+			   hdcp_keys->size))
+		return -EFAULT;
+
+	xdprxss->hdcp1x_key_available = true;
+	ret = xdprxss_hdcp1x_keymgmt_set_key(xdprxss);
+	if (ret < 0)
+		return ret;
+
+	xhdcp1x_rx_set_keyselect(xdprxss->hdcp1x, 0);
+	xhdcp1x_rx_load_bksv(xdprxss->hdcp1x);
+
+	/* give a HPD to let the upstream do a new link training */
+	xdprxss_generate_hpd_intr(xdprxss, XDPRX_HPD_PULSE_5000);
+	xdprxss_write(xdprxss, XDPRX_LINK_ENABLE_REG, 0x0);
+
+	/*
+	 * TODO: without below sleep the DP Rx IP is not giving the HPD to
+	 * upstream, this needs to be removed once the issue fixed in IP
+	 */
+	msleep(XDPRX_LINK_ENABLE_DELAY_MS);
+	xdprxss_write(xdprxss, XDPRX_LINK_ENABLE_REG, 0x1);
+
+	return ret;
+}
+
+static long xdprxss_ioctl(struct v4l2_subdev *sd, u32 cmd, void *arg)
+{
+	struct xdprxss_state *xdprxss = to_xdprxssstate(sd);
+
+	if (!xdprxss->hdcp22_enable && cmd == XILINX_DPRXSS_HDCP2X_KEY_WRITE) {
+		dev_err(xdprxss->dev, "hdcp22 is not enabled in the system");
+		return -ENODEV;
+	}
+
+	if (!xdprxss->hdcp_enable && cmd == XILINX_DPRXSS_HDCP_KEY_WRITE) {
+		dev_err(xdprxss->dev, "hdcp is not enabled in the system");
+		return -ENODEV;
+	}
+
+	if (xdprxss->hdcp2x_key_available) {
+		dev_info(xdprxss->dev, "hdcp2x keys are already loaded");
+		return -EPERM;
+	}
+
+	if (xdprxss->hdcp1x_key_available) {
+		dev_info(xdprxss->dev, "hdcp1x keys are already loaded");
+		return -EPERM;
+	}
+
+	switch (cmd) {
+	case XILINX_DPRXSS_HDCP_KEY_WRITE:
+		return xdprxss_hdcp1x_key_write(xdprxss, arg);
+	case XILINX_DPRXSS_HDCP2X_KEY_WRITE:
+		return xdprxss_hdcp2x_key_write(xdprxss, arg);
+	default:
+		dev_info(xdprxss->dev, "hdcp keys not made available");
+	}
+
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_core_ops xdprxss_core_ops = {
+	.subscribe_event	= xdprxss_subscribe_event,
+	.unsubscribe_event	= v4l2_event_subdev_unsubscribe,
+	.ioctl			= xdprxss_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops xdprxss_video_ops = {
+	.query_dv_timings	= xdprxss_query_dv_timings,
+	.s_stream		= xdprxss_s_stream,
+	.g_input_status		= xdprxss_g_input_status,
+};
+
+static const struct v4l2_subdev_pad_ops xdprxss_pad_ops = {
+	.init_cfg		= xdprxss_init_cfg,
+	.enum_mbus_code		= xdprxss_enum_mbus_code,
+	.get_fmt		= xdprxss_getset_format,
+	.set_fmt		= xdprxss_getset_format,
+	.enum_dv_timings	= xdprxss_enum_dv_timings,
+	.dv_timings_cap         = xdprxss_get_dv_timings_cap,
+};
+
+static const struct v4l2_subdev_ops xdprxss_ops = {
+	.core	= &xdprxss_core_ops,
+	.video	= &xdprxss_video_ops,
+	.pad	= &xdprxss_pad_ops
+};
+
+/* ----------------------------------------------------------------
+ * DP audio operation
+ */
+/**
+ * xlnx_rx_pcm_startup - initialize audio during audio usecase
+ *
+ * @substream: Pointer to sound pcm substream structure
+ * @dai: Pointer to sound soc dai structure
+ *
+ * This function is called by ALSA framework before audio
+ * capture begins.
+ *
+ * Return: -EIO if no audio is detected or 0 on success
+ */
+static int xlnx_rx_pcm_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	int err;
+	struct xlnx_dprx_audio_data *adata;
+	unsigned long jiffies = msecs_to_jiffies(XDP_AUDIO_DETECT_TIMEOUT);
+	struct xdprxss_state *xdprxss = dev_get_drvdata(dai->dev);
+
+	adata = xdprxss->rx_audio_data;
+
+	xdprxss_clr(xdprxss, XDPRX_AUDIO_CONTROL, XDPRX_AUDIO_EN_MASK);
+	xdprxss_set(xdprxss, XDPRX_AUDIO_CONTROL, XDPRX_AUDIO_EN_MASK);
+
+	/*
+	 * TODO: Currently the audio infoframe packet interrupts are not
+	 * coming for the first time without the below msleep.
+	 * Need to find out the root cause and should remove this msleep
+	 */
+	msleep(50);
+
+	/* Enable DP Rx audio and interruts */
+	xdprxss_set(xdprxss, XDPRX_INTR_MASK_REG, XDPRX_INTR_AUDIO_MASK);
+
+	err = wait_event_interruptible_timeout(adata->audio_update_q,
+					       adata->audio_detected,
+					       jiffies);
+	if (!err) {
+		dev_err(dai->dev, "No audio detected in input stream\n");
+		return -EIO;
+	}
+
+	dev_info(dai->dev, "Detected audio, starting capture\n");
+
+	return 0;
+}
+
+/**
+ * xlnx_rx_pcm_shutdown - Deinitialze audio when audio usecase is stopped
+ *
+ * @substream: Pointer to sound pcm substream structure
+ * @dai: Pointer to sound soc dai structure
+ *
+ * This function is called by ALSA framework before audio capture usecase
+ * ends.
+ */
+static void xlnx_rx_pcm_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct xdprxss_state *xdprxss = dev_get_drvdata(dai->dev);
+
+	xdprxss_clr(xdprxss, XDPRX_AUDIO_CONTROL, XDPRX_AUDIO_EN_MASK);
+	xdprxss_clr(xdprxss, XDPRX_INTR_MASK_REG, XDPRX_INTR_AUDIO_MASK);
+}
+
+static const struct snd_soc_dai_ops xlnx_rx_dai_ops = {
+	.startup = xlnx_rx_pcm_startup,
+	.shutdown = xlnx_rx_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver xlnx_rx_audio_dai = {
+	.name = "xlnx_dp_rx",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+			 SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |
+			 SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |
+			 SNDRV_PCM_RATE_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &xlnx_rx_dai_ops,
+};
+
+static const struct snd_soc_component_driver xlnx_rx_dummy_codec_driver;
+
+/**
+ * dprx_register_aud_dev - register audio device
+ *
+ * @dev: Pointer to Platform structure
+ *
+ * This function registers codec DAI device as part of
+ * ALSA SoC framework.
+ *
+ * Return: 0 on success, error value otherwise
+ */
+static int dprx_register_aud_dev(struct device *dev)
+{
+	return snd_soc_register_component(dev, &xlnx_rx_dummy_codec_driver,
+			&xlnx_rx_audio_dai, 1);
+}
+
+/**
+ * dprx_unregister_aud_dev - register audio device
+ *
+ * @dev: Pointer to Platform structure
+ *
+ * This functions unregisters codec DAI device
+ */
+static void dprx_unregister_aud_dev(struct device *dev)
+{
+	snd_soc_unregister_component(dev);
+}
+
+/* ----------------------------------------------------------------
+ * Platform Device Driver
+ */
+static int xdprxss_parse_of(struct xdprxss_state *xdprxss)
+{
+	struct device_node *node = xdprxss->dev->of_node;
+	u32 val = 0;
+	int ret;
+
+	ret = of_property_read_u32(node, "xlnx,bpc", &xdprxss->bpc);
+	if (ret < 0) {
+		if (ret != -EINVAL) {
+			dev_err(xdprxss->dev, "failed to get xlnx,bpp\n");
+			return ret;
+		}
+	}
+	/*
+	 * TODO : For now driver supports only 8, 10 bpc.
+	 * In future, driver may add with other bpc support
+	 */
+	if (xdprxss->bpc != 8 && xdprxss->bpc != 10) {
+		dev_err(xdprxss->dev, "unsupported bpc = %u\n", xdprxss->bpc);
+		return -EINVAL;
+	}
+
+	xdprxss->hdcp22_enable = of_property_read_bool(node, "xlnx,hdcp22-enable");
+	if (!xdprxss->hdcp22_enable)
+		dev_info(xdprxss->dev, "hdcp2x is not enabled\n");
+
+	xdprxss->hdcp_enable = of_property_read_bool(node, "xlnx,hdcp-enable");
+	if (!xdprxss->hdcp_enable)
+		dev_info(xdprxss->dev, "hdcp is not enabled\n");
+
+	xdprxss->audio_enable = of_property_read_bool(node,
+						      "xlnx,audio-enable");
+	if (!xdprxss->audio_enable)
+		dev_info(xdprxss->dev, "audio not enabled\n");
+
+	xdprxss->versal_gt_present =
+		of_property_read_bool(node, "xlnx,versal-gt");
+
+	ret = of_property_read_u32(node, "xlnx,link-rate", &val);
+	if (ret < 0) {
+		dev_err(xdprxss->dev, "xlnx,link-rate property not found\n");
+		return ret;
+	}
+	if (!(val == DP_LINK_BW_1_62 ||
+	      val == DP_LINK_BW_2_7 ||
+	      val == DP_LINK_BW_5_4 ||
+	      val == DP_LINK_BW_8_1)) {
+		dev_err(xdprxss->dev, "invalid link rate\n");
+		return -EINVAL;
+	}
+	xdprxss->max_linkrate = val;
+
+	ret = of_property_read_u32(node, "xlnx,lane-count", &val);
+	if (ret < 0) {
+		dev_err(xdprxss->dev, "xlnx,lane-count property not found\n");
+		return ret;
+	}
+	if (val < 1 && val > 4) {
+		dev_err(xdprxss->dev, "invalid lane count\n");
+		return -EINVAL;
+	}
+	xdprxss->max_lanecount = val;
+
+	ret = of_property_read_u32(node, "xlnx,mode", &val);
+	if (ret < 0) {
+		dev_err(xdprxss->dev, "xlnx,mode property not found\n");
+		return ret;
+	}
+	if (val > 0) {
+		dev_err(xdprxss->dev, "driver does't support MST mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void xlnx_dp_laneset_work_func(struct work_struct *work)
+{
+	struct xdprxss_state *dp;
+
+	dp = container_of(work, struct xdprxss_state, lane_set_work);
+
+	xdprxss_irq_access_laneset(dp);
+}
+
+static void xlnx_dp_linkqual_work_func(struct work_struct *work)
+{
+	struct xdprxss_state *dp;
+
+	dp = container_of(work, struct xdprxss_state, link_qual_work);
+
+	xdprxss_irq_access_linkqual(dp);
+}
+
+static void xlnx_dp_tp1_work_func(struct work_struct *work)
+{
+	struct xdprxss_state *dp;
+
+	dp = container_of(work, struct xdprxss_state, tp1_work.work);
+
+	xdprxss_irq_tp1(dp);
+}
+
+static void xlnx_dp_unplug_work_func(struct work_struct *work)
+{
+	struct xdprxss_state *dp;
+
+	dp = container_of(work, struct xdprxss_state, unplug_work.work);
+
+	xdprxss_irq_unplug(dp);
+}
+
+static int xlnx_find_device(struct platform_device *pdev,
+			    struct xdprxss_state *xdprxss, const char *name)
+{
+	struct device_node *pnode = pdev->dev.of_node;
+	struct device_node *fnode;
+	struct platform_device *iface_pdev;
+
+	fnode = of_parse_phandle(pnode, name, 0);
+	if (!fnode) {
+		dev_err(&pdev->dev, "platform node %s not found\n", name);
+		of_node_put(fnode);
+	} else {
+		iface_pdev = of_find_device_by_node(fnode);
+		if (!iface_pdev) {
+			of_node_put(pnode);
+			return -ENODEV;
+		}
+
+		xdprxss->prvdata = dev_get_drvdata(&iface_pdev->dev);
+		if (!xdprxss->prvdata) {
+			dev_info(&pdev->dev,
+				 "platform device(%s) not found -EPROBE_DEFER\n", name);
+			of_node_put(fnode);
+			return -EPROBE_DEFER;
+		}
+		of_node_put(fnode);
+	}
+
+	return 0;
+}
+
+static int dprx_hdcp2x_dpcd_rd_handler(void *ref, u32 offset, u8 *buff, u32 buff_size)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+	u32 value, alignment, num_this_time, idx, reg_offset, num_read = 0;
+	u8 *read_buf = buff;
+
+	reg_offset = XDPRX_HDCP2X_TABLE;
+	reg_offset += offset;
+
+	/* Iterate through the reads */
+	do {
+		alignment = reg_offset & ALIGN_FOR_RDWR;
+		num_this_time = BYTES_PER_RDWR;
+
+		if (alignment)
+			num_this_time = BYTES_PER_RDWR - alignment;
+		if (num_this_time > buff_size)
+			num_this_time = buff_size;
+
+		value = xdprxss_read(xdprxss, (reg_offset & ~ALIGN_FOR_RDWR));
+		if (alignment)
+			value >>= (BITS_PER_BYTE * alignment);
+
+		for (idx = 0; idx < num_this_time; idx++) {
+			read_buf[idx] = (u8)(value & 0xFF);
+			value >>= BITS_PER_BYTE;
+		}
+
+		read_buf += num_this_time;
+		buff_size -= num_this_time;
+		reg_offset += num_this_time;
+		num_read += num_this_time;
+
+	} while (buff_size > 0);
+
+	return num_read;
+}
+
+static int dprx_hdcp2x_dpcd_wr_handler(void *ref, u32 offset, u8 *buff,
+				       u32 buff_size)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+	u32 mask, temp, reg_offset, value, alignment, num_written = 0;
+	int num_this_time, idx = 0;
+	u8 *write_buf = buff;
+
+	reg_offset = XDPRX_HDCP2X_TABLE;
+	reg_offset += offset;
+
+	/* Iterate through the writes */
+	do {
+		alignment = reg_offset & ALIGN_FOR_RDWR;
+		num_this_time = BYTES_PER_RDWR;
+		if (alignment)
+			num_this_time = BYTES_PER_RDWR - alignment;
+
+		if (num_this_time > (int)buff_size)
+			num_this_time = buff_size;
+
+		/* Check for simple case */
+		if (num_this_time == BYTES_PER_RDWR) {
+			for (idx = ALIGN_FOR_RDWR; idx >= 0; idx--) {
+				value <<= BITS_PER_BYTE;
+				value |= write_buf[idx];
+			}
+		} else {
+			mask = 0xFF;
+			if (alignment)
+				mask <<= (BITS_PER_BYTE * alignment);
+
+			value = xdprxss_read(xdprxss, (reg_offset & ~ALIGN_FOR_RDWR));
+
+			for (idx = 0; idx < num_this_time; idx++) {
+				temp = write_buf[idx];
+				temp <<= (BITS_PER_BYTE * (alignment + idx));
+				value &= ~mask;
+				value |= temp;
+				mask <<= BITS_PER_BYTE;
+			}
+		}
+		xdprxss_write(xdprxss, (reg_offset & ~0x03ul), value);
+
+		write_buf += num_this_time;
+		buff_size -= num_this_time;
+		reg_offset += num_this_time;
+		num_written += num_this_time;
+
+	} while (buff_size > 0);
+
+	return num_written;
+}
+
+static void dprx_hdcp2x_cp_irq_set_handler(void *ref)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+
+	xdprxss_write(xdprxss, XDPRX_HPD_INTR_REG, 0);
+	xdprxss_write(xdprxss, XDPRX_DEVICE_SERVICE_IRQ, XDPRX_DEVICE_SERVICE_IRQ_CP_IRQ_MASK);
+}
+
+static void dprx_hdcp2x_notification_handler(void *ref, u8 notification)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+
+	switch (notification) {
+	case XHDCP2X_RX_NOTIFY_UN_AUTHENTICATED:
+		dev_info(xdprxss->dev, "DP RX HDCP2X Un-Authenticated\n");
+		break;
+	case XHDCP2X_RX_NOTIFY_RE_AUTHENTICATE:
+		dev_info(xdprxss->dev, "DP RX HDCP2X Re-Authentication requested\n");
+		break;
+	case XHDCP2X_RX_NOTIFY_SKE_SEND_EKS:
+		dev_info(xdprxss->dev, "DP RX HDCP2X SKE send EKS message processed\n");
+		break;
+	case XHDCP2X_RX_NOTIFY_AUTHENTICATED:
+		dev_info(xdprxss->dev, "DP RX HDCP2X Authenticated\n");
+		break;
+	case XHDCP2X_RX_NOTIFY_ENCRYPTION_DONE:
+		dev_info(xdprxss->dev, "DP RX HDCP2X Encrypted\n");
+		break;
+	}
+}
+
+static irqreturn_t xlnx_timer_irq_handler (int irq, void *dev_id)
+{
+	struct xdprxss_state *state = (struct xdprxss_state *)dev_id;
+
+	xlnx_hdcp_tmrcntr_interrupt_handler(state->tmr_config);
+
+	return IRQ_HANDLED;
+}
+
+static void xlnx_hdcp2x_rx_timer_handler(void *ref, u8 tmrcntr_number)
+{
+	struct xdprxss_state *state = (struct xdprxss_state *)ref;
+
+	xhdcp2x_rx_timer_handler((void *)state->hdcp2x, tmrcntr_number);
+	xhdcp2x_rx_push_events(state->hdcp2x, XHDCP2X_RX_TIMER_EVENT);
+}
+
+static int dprx_register_hdcp2x_dev(struct xdprxss_state *xdprxss, struct platform_device *pdev)
+{
+	int ret;
+	int lane_count = xdprxss_read(xdprxss, XDPRX_LANE_COUNT_REG);
+
+	xdprxss->hdcp2x = xhdcp2x_rx_init(xdprxss->dev, xdprxss,
+					  xdprxss->dp_base + XDPRX_HDCP2X_REG_OFFSET,
+					  XHDCP2X_RX_DP, 0, lane_count);
+	if (IS_ERR(xdprxss->hdcp2x)) {
+		dev_err(xdprxss->dev, "failed to initialize hdcp2x\n");
+		return PTR_ERR(xdprxss->hdcp2x);
+	}
+
+	xdprxss->hdcp2x_lc128 = devm_kzalloc(xdprxss->dev, HDCP2X_LC128_SIZE, GFP_KERNEL);
+	if (!xdprxss->hdcp2x_lc128)
+		return -ENOMEM;
+
+	xdprxss->hdcp2x_private = devm_kzalloc(xdprxss->dev, HDCP2X_PRIVATE_SIZE, GFP_KERNEL);
+	if (!xdprxss->hdcp2x_private)
+		return -ENOMEM;
+
+	xdprxss->tmr_config = xhdcp2x_timer_init(&pdev->dev,
+						 xdprxss->dp_base + XDPRX_HDCP_TIMER_OFFSET);
+	if (IS_ERR(xdprxss->hdcp2x)) {
+		dev_err(xdprxss->dev, "failed to initialize hdcp timer\n");
+		return PTR_ERR(xdprxss->hdcp2x);
+	}
+
+	xhdcp2x_timer_attach(xdprxss->hdcp2x, xdprxss->tmr_config);
+
+	xlnx_hdcp_tmrcntr_set_handler(xdprxss->tmr_config, xlnx_hdcp2x_rx_timer_handler,
+				      (void *)xdprxss);
+
+	xdprxss->hdcp2x_timer_irq = platform_get_irq_byname(pdev, "dprxss_timer_irq");
+
+	if (xdprxss->hdcp2x_timer_irq < 0) {
+		dev_err(xdprxss->dev, "failed to get HDCP Timer irq");
+		return -EINVAL;
+	}
+
+	ret = devm_request_threaded_irq(xdprxss->dev, xdprxss->hdcp2x_timer_irq, NULL,
+					xlnx_timer_irq_handler, IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					"dprxss_timer_irq", xdprxss);
+	if (ret < 0) {
+		dev_err(xdprxss->dev, "failed to register hdcp timer irq");
+		return ret;
+	}
+	xhdcp2x_rx_set_callback(xdprxss->hdcp2x, XHDCP2X_RX_HANDLER_DP_AUX_READ,
+				dprx_hdcp2x_dpcd_rd_handler);
+	xhdcp2x_rx_set_callback(xdprxss->hdcp2x, XHDCP2X_RX_HANDLER_DP_AUX_WRITE,
+				dprx_hdcp2x_dpcd_wr_handler);
+	xhdcp2x_rx_set_callback(xdprxss->hdcp2x, XHDCP2X_RX_HANDLER_DP_CP_IRQ_SET,
+				dprx_hdcp2x_cp_irq_set_handler);
+	xhdcp2x_rx_set_callback(xdprxss->hdcp2x, XHDCP2X_RX_NOTIFICATION_HANDLER,
+				dprx_hdcp2x_notification_handler);
+
+	return 0;
+}
+
+static irqreturn_t xdprxss_hdcp1x_irq_handler(int irq, void *dev_id)
+{
+	struct xdprxss_state *state = (struct xdprxss_state *)dev_id;
+
+	xhdcp1x_rx_handle_intr(state->hdcp1x);
+
+	return IRQ_HANDLED;
+}
+
+static int dprx_hdcp1x_dpcd_rd_handler(void *ref, u32 offset, u8 *buff,
+				       u32 buff_size)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+	u32 value, alignment, num_this_time, idx, reg_offset, num_read = 0;
+	u8 *read_buf = buff;
+
+	/* Truncate if necessary */
+	if ((buff_size + offset) > XDPRX_DPCD_HDCP1X_PORT_REG_LENGTH)
+		buff_size = XDPRX_DPCD_HDCP1X_PORT_REG_LENGTH - offset;
+
+	/* Determine reg_offset */
+	reg_offset = XDPRX_DPCD_HDCP1X_PORT_OFST;
+	reg_offset += offset;
+
+	/* Iterate through the reads */
+	do {
+		alignment = reg_offset & ALIGN_FOR_RDWR;
+		num_this_time = BYTES_PER_RDWR;
+		if (alignment)
+			num_this_time = BYTES_PER_RDWR - alignment;
+		if (num_this_time > buff_size)
+			num_this_time = buff_size;
+
+		value = xdprxss_read(xdprxss, (reg_offset & ~ALIGN_FOR_RDWR));
+		if (alignment)
+			value >>= (BITS_PER_BYTE * alignment);
+
+		for (idx = 0; idx < num_this_time; idx++) {
+			read_buf[idx] = (u8)(value & 0xFF);
+			value >>= BITS_PER_BYTE;
+		}
+
+		read_buf += num_this_time;
+		buff_size -= num_this_time;
+		reg_offset += num_this_time;
+		num_read += num_this_time;
+	} while (buff_size > 0);
+
+	return num_read;
+}
+
+static int dprx_hdcp1x_dpcd_wr_handler(void *ref, u32 offset, u8 *buff,
+				       u32 buff_size)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+	u32 mask, temp, reg_offset, value = 0, alignment, num_written = 0;
+	int num_this_time, idx;
+	u8 *write_buf = buff;
+
+	if ((buff_size + offset) > XDPRX_DPCD_HDCP1X_PORT_REG_LENGTH)
+		buff_size = XDPRX_DPCD_HDCP1X_PORT_REG_LENGTH - offset;
+	reg_offset = XDPRX_DPCD_HDCP1X_PORT_OFST;
+	reg_offset += offset;
+
+	/* Iterate through the writes */
+	do {
+		alignment = reg_offset & ALIGN_FOR_RDWR;
+		num_this_time = BYTES_PER_RDWR;
+		if (alignment)
+			num_this_time = BYTES_PER_RDWR - alignment;
+
+		if (num_this_time > (int)buff_size)
+			num_this_time = buff_size;
+
+		/* Check for simple case */
+		if (num_this_time == BYTES_PER_RDWR) {
+			for (idx = ALIGN_FOR_RDWR; idx >= 0; idx--) {
+				value <<= BITS_PER_BYTE;
+				value |= write_buf[idx];
+			}
+		} else {
+			/* Otherwise - must read and modify existing memory */
+			if (offset == XDPRX_DPCD_HDCP1X_PORT_KSVFIFO) {
+				for (idx = num_this_time - 1; idx >= 0; idx--) {
+					value <<= BITS_PER_BYTE;
+					value |= write_buf[idx];
+				}
+			} else {
+				temp = 0;
+				mask = 0xFF;
+				if (alignment)
+					mask <<= (BITS_PER_BYTE * alignment);
+				value = xdprxss_read(xdprxss, (reg_offset & ~ALIGN_FOR_RDWR));
+				for (idx = 0; idx < num_this_time; idx++) {
+					temp = write_buf[idx];
+					temp <<= (BITS_PER_BYTE * (alignment + idx));
+					value &= ~mask;
+					value |= temp;
+					mask <<= BITS_PER_BYTE;
+				}
+			}
+		}
+
+		xdprxss_write(xdprxss, (reg_offset & ~ALIGN_FOR_RDWR), value);
+
+		write_buf += num_this_time;
+		buff_size -= num_this_time;
+		if (offset != XDPRX_DPCD_HDCP1X_PORT_KSVFIFO)
+			reg_offset += num_this_time;
+		num_written += num_this_time;
+	} while (buff_size > 0);
+
+	return num_written;
+}
+
+static void dprx_hdcp1x_notification_handler(void *ref, u32 notification)
+{
+	struct xdprxss_state *xdprxss = (struct xdprxss_state *)ref;
+
+	switch (notification) {
+	case XHDCP1X_RX_NOTIFY_AUTHENTICATED:
+		dev_info(xdprxss->dev, "HDCP1X Rx Authenticated\n");
+		break;
+	case XHDCP1X_RX_NOTIFY_UN_AUTHENTICATED:
+		dev_info(xdprxss->dev, "HDCP1X Rx Un-Authenticated\n");
+		break;
+	case XHDCP1X_RX_NOTIFY_SET_CP_IRQ:
+		dev_dbg(xdprxss->dev,
+			"HDCP1X Rx Requested for CP_IRQ generation\n");
+		break;
+	}
+}
+
+static int dprx_register_hdcp1x_dev(struct xdprxss_state *xdprxss)
+{
+	xdprxss->hdcp1x = xhdcp1x_rx_init(xdprxss->dev, xdprxss,
+					  xdprxss->dp_base + XDPRX_HDCP1X_REG_OFFSET,
+					  0, XHDCP1X_DP);
+	if (IS_ERR(xdprxss->hdcp1x)) {
+		dev_err(xdprxss->dev, "failed to initialize hdcp1x\n");
+		return PTR_ERR(xdprxss->hdcp1x);
+	}
+
+	xdprxss->hdcp1x_key = devm_kzalloc(xdprxss->dev, HDCP1X_KEYS_SIZE,
+					   GFP_KERNEL);
+	if (!xdprxss->hdcp1x_key)
+		return -ENOMEM;
+
+	xhdcp1x_rx_set_callback(xdprxss->hdcp1x, XHDCP1X_RX_RD_HANDLER,
+				dprx_hdcp1x_dpcd_rd_handler);
+	xhdcp1x_rx_set_callback(xdprxss->hdcp1x, XHDCP1X_RX_WR_HANDLER,
+				dprx_hdcp1x_dpcd_wr_handler);
+	xhdcp1x_rx_set_callback(xdprxss->hdcp1x,
+				XHDCP1X_RX_NOTIFICATION_HANDLER,
+				dprx_hdcp1x_notification_handler);
+
+	return 0;
+}
+
+static int xdprxss_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xdprxss_state *xdprxss;
+	struct device_node *node;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int ret, irq;
+	unsigned int i = 0, j;
+	struct xlnx_dprx_audio_data *adata;
+
+	xdprxss = devm_kzalloc(dev, sizeof(*xdprxss), GFP_KERNEL);
+	if (!xdprxss)
+		return -ENOMEM;
+
+	xdprxss->dev = &pdev->dev;
+	node = xdprxss->dev->of_node;
+
+	ret = xlnx_find_device(pdev, xdprxss, "xlnx,dp-retimer");
+	if (ret)
+		return ret;
+	xdprxss->retimer_prvdata = xdprxss->prvdata;
+
+	ret = xlnx_find_device(pdev, xdprxss, "xlnx,vidphy");
+	if (ret)
+		return ret;
+	xdprxss->vidphy_prvdata = xdprxss->prvdata;
+
+	xdprxss->rx_audio_data =
+		devm_kzalloc(&pdev->dev, sizeof(struct xlnx_dprx_audio_data),
+			     GFP_KERNEL);
+	if (!xdprxss->rx_audio_data)
+		return -ENOMEM;
+
+	adata = xdprxss->rx_audio_data;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dp_base");
+	xdprxss->dp_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(xdprxss->dp_base)) {
+		dev_err(dev, "couldn't map DisplayPort registers\n");
+		return -ENODEV;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "edid_base");
+	xdprxss->edid_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(xdprxss->edid_base)) {
+		dev_err(dev, "Couldn't map EDID IP memory\n");
+		return -ENOENT;
+	}
+
+	xdprxss->axi_clk = devm_clk_get(dev, "s_axi_aclk");
+	if (IS_ERR(xdprxss->axi_clk)) {
+		ret = PTR_ERR(xdprxss->axi_clk);
+		dev_err(&pdev->dev, "failed to get s_axi_clk (%d)\n", ret);
+		return ret;
+	}
+
+	xdprxss->rx_lnk_clk = devm_clk_get(dev, "rx_lnk_clk");
+	if (IS_ERR(xdprxss->rx_lnk_clk)) {
+		ret = PTR_ERR(xdprxss->rx_lnk_clk);
+		dev_err(&pdev->dev, "failed to get rx_lnk_clk (%d)\n", ret);
+		return ret;
+	}
+
+	xdprxss->rx_vid_clk = devm_clk_get(dev, "rx_vid_clk");
+	if (IS_ERR(xdprxss->rx_vid_clk)) {
+		ret = PTR_ERR(xdprxss->rx_vid_clk);
+		dev_err(&pdev->dev, "failed to get rx_vid_clk (%d)\n", ret);
+		return ret;
+	}
+
+	ret = xdprxss_parse_of(xdprxss);
+	if (ret < 0)
+		goto clk_err;
+
+	if (!xdprxss->versal_gt_present) {
+		/* acquire vphy lanes */
+		for (i = 0; i < xdprxss->max_lanecount; i++) {
+			char phy_name[16];
+
+			snprintf(phy_name, sizeof(phy_name), "dp-phy%d", i);
+			xdprxss->phy[i] = devm_phy_get(xdprxss->dev, phy_name);
+			if (IS_ERR(xdprxss->phy[i])) {
+				ret = PTR_ERR(xdprxss->phy[i]);
+				xdprxss->phy[i] = NULL;
+				if (ret == -EPROBE_DEFER)
+					dev_info(dev, "phy not ready -EPROBE_DEFER\n");
+				else
+					dev_err(dev,
+						"failed to get phy lane %s i %d, ret = %d\n",
+						phy_name, i, ret);
+				goto error_phy;
+			}
+			ret = phy_init(xdprxss->phy[i]);
+			if (ret) {
+				dev_err(dev,
+					"failed to init phy lane %d\n", i);
+				goto error_phy;
+			}
+		}
+	} else {
+		xdprxss->phy[0] = devm_phy_get(xdprxss->dev, "dp-gtquad");
+		if (IS_ERR(xdprxss->phy[0]))
+			return dev_err_probe(dev, PTR_ERR(xdprxss->phy[0]),
+					"failed to get phy\n");
+
+		ret = phy_init(xdprxss->phy[0]);
+		if (ret) {
+			dev_err(dev, "failed to init phy\n");
+			goto error_phy;
+		}
+
+		ret = xlnx_find_device(pdev, xdprxss, "xlnx,xilinx-vfmc");
+		if (ret)
+			return ret;
+
+		ret = xlnx_dp_rx_gt_control_init(xdprxss);
+		if (ret < 0)
+			return ret;
+
+		if (get_rx_dec_clk_lock(xdprxss))
+			dev_info(dev, "rx decryption clock failed to lock\n");
+	}
+
+	ret = clk_prepare_enable(xdprxss->axi_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable axi_clk (%d)\n", ret);
+		goto error_phy;
+	}
+
+	ret = clk_prepare_enable(xdprxss->rx_lnk_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable rx_lnk_clk (%d)\n", ret);
+		goto rx_lnk_clk_err;
+	}
+
+	ret = clk_prepare_enable(xdprxss->rx_vid_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable rx_vid_clk (%d)\n", ret);
+		goto rx_vid_clk_err;
+	}
+
+	spin_lock_init(&xdprxss->lock);
+
+	/* Initialize the DP core */
+	xdprxss_core_init(xdprxss);
+
+	/* Initialize V4L2 subdevice and media entity */
+	xdprxss->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xdprxss->subdev;
+	v4l2_subdev_init(subdev, &xdprxss_ops);
+	subdev->dev = &pdev->dev;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+
+	subdev->flags = V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	subdev->entity.ops = &xdprxss_media_ops;
+
+	v4l2_set_subdevdata(subdev, xdprxss);
+	ret = media_entity_pads_init(&subdev->entity, 1, &xdprxss->pad);
+	if (ret < 0)
+		goto error;
+
+	ret = v4l2_ctrl_handler_init(&xdprxss->ctrl_handler,
+				     ARRAY_SIZE(xdprxss_ctrls));
+	if (ret < 0) {
+		dev_err(xdprxss->dev, "failed to initialize V4L2 ctrl\n");
+		goto error;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xdprxss_ctrls); i++) {
+		struct v4l2_ctrl *ctrl;
+
+		dev_dbg(xdprxss->dev, "%d ctrl = 0x%x\n", i,
+			xdprxss_ctrls[i].id);
+		ctrl = v4l2_ctrl_new_custom(&xdprxss->ctrl_handler,
+					    &xdprxss_ctrls[i], NULL);
+		if (!ctrl) {
+			dev_err(xdprxss->dev, "Failed for %s ctrl\n",
+				xdprxss_ctrls[i].name);
+			v4l2_ctrl_handler_free(&xdprxss->ctrl_handler);
+			goto error;
+		}
+	}
+
+	if (xdprxss->ctrl_handler.error) {
+		dev_err(xdprxss->dev, "failed to add controls\n");
+		ret = xdprxss->ctrl_handler.error;
+		v4l2_ctrl_handler_free(&xdprxss->ctrl_handler);
+		goto error;
+	}
+
+	subdev->ctrl_handler = &xdprxss->ctrl_handler;
+	ret = v4l2_ctrl_handler_setup(&xdprxss->ctrl_handler);
+	if (ret < 0) {
+		dev_err(xdprxss->dev, "failed to set controls\n");
+		goto error;
+	}
+
+	/* Register interrupt handler */
+	irq = irq_of_parse_and_map(node, 0);
+	ret = devm_request_irq(xdprxss->dev, irq, xdprxss_irq_handler,
+			       IRQF_SHARED, subdev->name, xdprxss);
+	if (ret) {
+		dev_err(dev, "Err = %d Interrupt handler reg failed!\n",
+			ret);
+		goto error;
+	}
+
+	platform_set_drvdata(pdev, xdprxss);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	if (xdprxss->audio_enable) {
+		ret = dprx_register_aud_dev(xdprxss->dev);
+		if (ret < 0) {
+			xdprxss->audio_init = false;
+			dev_err(xdprxss->dev, "dp rx audio init failed\n");
+			goto error;
+		} else {
+			xdprxss->audio_init = true;
+			init_waitqueue_head(&adata->audio_update_q);
+			dev_info(xdprxss->dev, "dp rx audio initialized\n");
+		}
+	}
+
+	if (xdprxss->hdcp22_enable) {
+		ret = dprx_register_hdcp2x_dev(xdprxss, pdev);
+		if (ret < 0) {
+			dev_err(xdprxss->dev, "dp rx hdcp2/x init failed\n");
+			goto error;
+		}
+		xdprxss_enable_hdcp2x_interrupts(xdprxss);
+	}
+
+	if (xdprxss->hdcp_enable) {
+		xdprxss->hdcp1x_keymgmt_base = syscon_regmap_lookup_by_phandle(node,
+									       "xlnx,hdcp1x_keymgmt");
+		if (IS_ERR(xdprxss->hdcp1x_keymgmt_base)) {
+			dev_err(dev, "couldn't map hdcp1x Keymgmt registers\n");
+			return -ENODEV;
+		}
+
+		ret = dprx_register_hdcp1x_dev(xdprxss);
+		if (ret < 0) {
+			dev_err(xdprxss->dev, "dp rx hdcp1x init failed\n");
+			goto error;
+		}
+
+		irq = irq_of_parse_and_map(node, 2);
+		ret = devm_request_irq(xdprxss->dev, irq,
+				       xdprxss_hdcp1x_irq_handler,
+				       IRQF_SHARED, "dprxss_hdcp1x", xdprxss);
+		if (ret) {
+			dev_err(dev, "err: hdcp1x interrupt registration failed!\n");
+			goto error;
+		}
+
+		/* Enable HDCP1x Interrupts */
+		xdprxss_enable_hdcp1x_interrupts(xdprxss);
+	}
+
+	INIT_DELAYED_WORK(&xdprxss->tp1_work, xlnx_dp_tp1_work_func);
+	INIT_DELAYED_WORK(&xdprxss->unplug_work, xlnx_dp_unplug_work_func);
+	INIT_WORK(&xdprxss->lane_set_work, xlnx_dp_laneset_work_func);
+	INIT_WORK(&xdprxss->link_qual_work, xlnx_dp_linkqual_work_func);
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+clk_err:
+	clk_disable_unprepare(xdprxss->rx_vid_clk);
+rx_vid_clk_err:
+	clk_disable_unprepare(xdprxss->rx_lnk_clk);
+rx_lnk_clk_err:
+	clk_disable_unprepare(xdprxss->axi_clk);
+error_phy:
+	dev_dbg(dev, " %s error_phy:\n", __func__);
+	/* release the lanes that we did get, if we did not get all lanes */
+	if (!xdprxss->versal_gt_present) {
+		for (j = 0; j < i; j++) {
+			if (xdprxss->phy[j]) {
+				dev_dbg(dev,
+					"phy_exit() xdprxss->phy[%d] = %p\n",
+					j, xdprxss->phy[j]);
+				phy_exit(xdprxss->phy[j]);
+			}
+		}
+	} else {
+		phy_exit(xdprxss->phy[0]);
+	}
+
+	return ret;
+}
+
+static int xdprxss_remove(struct platform_device *pdev)
+{
+	struct xdprxss_state *xdprxss = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xdprxss->subdev;
+	unsigned int i;
+
+	cancel_delayed_work_sync(&xdprxss->tp1_work);
+	cancel_work_sync(&xdprxss->lane_set_work);
+	cancel_work_sync(&xdprxss->link_qual_work);
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xdprxss->rx_vid_clk);
+	clk_disable_unprepare(xdprxss->rx_lnk_clk);
+	clk_disable_unprepare(xdprxss->axi_clk);
+	if (!xdprxss->versal_gt_present)
+		for (i = 0; i < XDPRX_MAX_LANE_COUNT; i++)
+			phy_exit(xdprxss->phy[i]);
+	else
+		phy_exit(xdprxss->phy[0]);
+
+	if (xdprxss->audio_init)
+		dprx_unregister_aud_dev(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id xdprxss_of_id_table[] = {
+	{ .compatible = "xlnx,v-dp-rxss-3.0", },
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, xdprxss_of_id_table);
+
+static struct platform_driver xdprxss_driver = {
+	.driver = {
+		.name		= "xilinx-dprxss",
+		.of_match_table	= xdprxss_of_id_table,
+	},
+	.probe			= xdprxss_probe,
+	.remove			= xdprxss_remove,
+};
+
+module_platform_driver(xdprxss_driver);
+
+MODULE_AUTHOR("Rajesh Gugulothu <gugulothu.rajesh@xilinx.com");
+MODULE_DESCRIPTION("Xilinx DP Rx Subsystem Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-gamma-coeff.h b/drivers/media/platform/xilinx/xilinx-gamma-coeff.h
new file mode 100644
index 000000000..344260008
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-gamma-coeff.h
@@ -0,0 +1,5385 @@
+/*
+ * Xilinx Gamma Correction IP
+ *
+ * Copyright (C) 2017 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __XILINX_GAMMA_COEFF_H__
+#define __XILINX_GAMMA_COEFF_H__
+
+#define GAMMA_CURVE_LENGTH	(40)
+
+#define GAMMA_BPC_8			(8)
+#define GAMMA8_TABLE_LENGTH		BIT(GAMMA_BPC_8)
+static const u16 xgamma8_01[GAMMA8_TABLE_LENGTH] = {
+	0, 147, 157, 164, 168, 172, 175, 178,
+	180, 183, 184, 186, 188, 189, 191, 192,
+	193, 195, 196, 197, 198, 199, 200, 200,
+	201, 202, 203, 204, 204, 205, 206, 207,
+	207, 208, 208, 209, 210, 210, 211, 211,
+	212, 212, 213, 213, 214, 214, 215, 215,
+	216, 216, 217, 217, 218, 218, 218, 219,
+	219, 220, 220, 220, 221, 221, 221, 222,
+	222, 222, 223, 223, 223, 224, 224, 224,
+	225, 225, 225, 226, 226, 226, 227, 227,
+	227, 227, 228, 228, 228, 228, 229, 229,
+	229, 230, 230, 230, 230, 231, 231, 231,
+	231, 232, 232, 232, 232, 232, 233, 233,
+	233, 233, 234, 234, 234, 234, 234, 235,
+	235, 235, 235, 235, 236, 236, 236, 236,
+	236, 237, 237, 237, 237, 237, 238, 238,
+	238, 238, 238, 239, 239, 239, 239, 239,
+	239, 240, 240, 240, 240, 240, 240, 241,
+	241, 241, 241, 241, 241, 242, 242, 242,
+	242, 242, 242, 243, 243, 243, 243, 243,
+	243, 244, 244, 244, 244, 244, 244, 244,
+	245, 245, 245, 245, 245, 245, 245, 246,
+	246, 246, 246, 246, 246, 246, 247, 247,
+	247, 247, 247, 247, 247, 247, 248, 248,
+	248, 248, 248, 248, 248, 249, 249, 249,
+	249, 249, 249, 249, 249, 249, 250, 250,
+	250, 250, 250, 250, 250, 250, 251, 251,
+	251, 251, 251, 251, 251, 251, 251, 252,
+	252, 252, 252, 252, 252, 252, 252, 252,
+	253, 253, 253, 253, 253, 253, 253, 253,
+	253, 254, 254, 254, 254, 254, 254, 254,
+	254, 254, 254, 255, 255, 255, 255, 255,
+};
+
+static const u16 xgamma8_02[GAMMA8_TABLE_LENGTH] = {
+	0, 84, 97, 105, 111, 116, 120, 124,
+	128, 131, 133, 136, 138, 141, 143, 145,
+	147, 148, 150, 152, 153, 155, 156, 158,
+	159, 160, 162, 163, 164, 165, 166, 167,
+	168, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 178, 179, 179, 180, 181, 182,
+	183, 183, 184, 185, 186, 186, 187, 188,
+	188, 189, 190, 190, 191, 192, 192, 193,
+	193, 194, 195, 195, 196, 196, 197, 197,
+	198, 199, 199, 200, 200, 201, 201, 202,
+	202, 203, 203, 204, 204, 205, 205, 206,
+	206, 207, 207, 208, 208, 208, 209, 209,
+	210, 210, 211, 211, 211, 212, 212, 213,
+	213, 214, 214, 214, 215, 215, 216, 216,
+	216, 217, 217, 217, 218, 218, 219, 219,
+	219, 220, 220, 220, 221, 221, 221, 222,
+	222, 223, 223, 223, 224, 224, 224, 225,
+	225, 225, 226, 226, 226, 227, 227, 227,
+	227, 228, 228, 228, 229, 229, 229, 230,
+	230, 230, 231, 231, 231, 231, 232, 232,
+	232, 233, 233, 233, 233, 234, 234, 234,
+	235, 235, 235, 235, 236, 236, 236, 237,
+	237, 237, 237, 238, 238, 238, 238, 239,
+	239, 239, 239, 240, 240, 240, 240, 241,
+	241, 241, 241, 242, 242, 242, 242, 243,
+	243, 243, 243, 244, 244, 244, 244, 245,
+	245, 245, 245, 246, 246, 246, 246, 246,
+	247, 247, 247, 247, 248, 248, 248, 248,
+	248, 249, 249, 249, 249, 250, 250, 250,
+	250, 250, 251, 251, 251, 251, 252, 252,
+	252, 252, 252, 253, 253, 253, 253, 253,
+	254, 254, 254, 254, 254, 255, 255, 255,
+};
+
+static const u16 xgamma8_03[GAMMA8_TABLE_LENGTH] = {
+	0, 48, 60, 67, 73, 78, 83, 87,
+	90, 94, 97, 99, 102, 104, 107, 109,
+	111, 113, 115, 117, 119, 121, 122, 124,
+	125, 127, 129, 130, 131, 133, 134, 136,
+	137, 138, 139, 141, 142, 143, 144, 145,
+	146, 147, 148, 149, 151, 152, 153, 154,
+	155, 155, 156, 157, 158, 159, 160, 161,
+	162, 163, 164, 164, 165, 166, 167, 168,
+	168, 169, 170, 171, 172, 172, 173, 174,
+	174, 175, 176, 177, 177, 178, 179, 179,
+	180, 181, 181, 182, 183, 183, 184, 185,
+	185, 186, 187, 187, 188, 188, 189, 190,
+	190, 191, 191, 192, 193, 193, 194, 194,
+	195, 195, 196, 197, 197, 198, 198, 199,
+	199, 200, 200, 201, 201, 202, 202, 203,
+	203, 204, 204, 205, 205, 206, 206, 207,
+	207, 208, 208, 209, 209, 210, 210, 211,
+	211, 212, 212, 213, 213, 213, 214, 214,
+	215, 215, 216, 216, 217, 217, 217, 218,
+	218, 219, 219, 220, 220, 220, 221, 221,
+	222, 222, 223, 223, 223, 224, 224, 225,
+	225, 225, 226, 226, 227, 227, 227, 228,
+	228, 229, 229, 229, 230, 230, 230, 231,
+	231, 232, 232, 232, 233, 233, 233, 234,
+	234, 235, 235, 235, 236, 236, 236, 237,
+	237, 237, 238, 238, 238, 239, 239, 240,
+	240, 240, 241, 241, 241, 242, 242, 242,
+	243, 243, 243, 244, 244, 244, 245, 245,
+	245, 246, 246, 246, 247, 247, 247, 248,
+	248, 248, 249, 249, 249, 249, 250, 250,
+	250, 251, 251, 251, 252, 252, 252, 253,
+	253, 253, 253, 254, 254, 254, 255, 255,
+};
+
+static const u16 xgamma8_04[GAMMA8_TABLE_LENGTH] = {
+	0, 28, 37, 43, 48, 53, 57, 61,
+	64, 67, 70, 73, 75, 78, 80, 82,
+	84, 86, 88, 90, 92, 94, 96, 97,
+	99, 101, 102, 104, 105, 107, 108, 110,
+	111, 113, 114, 115, 117, 118, 119, 120,
+	122, 123, 124, 125, 126, 127, 129, 130,
+	131, 132, 133, 134, 135, 136, 137, 138,
+	139, 140, 141, 142, 143, 144, 145, 146,
+	147, 148, 149, 149, 150, 151, 152, 153,
+	154, 155, 155, 156, 157, 158, 159, 160,
+	160, 161, 162, 163, 164, 164, 165, 166,
+	167, 167, 168, 169, 170, 170, 171, 172,
+	173, 173, 174, 175, 175, 176, 177, 177,
+	178, 179, 179, 180, 181, 182, 182, 183,
+	183, 184, 185, 185, 186, 187, 187, 188,
+	189, 189, 190, 190, 191, 192, 192, 193,
+	194, 194, 195, 195, 196, 197, 197, 198,
+	198, 199, 199, 200, 201, 201, 202, 202,
+	203, 203, 204, 205, 205, 206, 206, 207,
+	207, 208, 208, 209, 209, 210, 211, 211,
+	212, 212, 213, 213, 214, 214, 215, 215,
+	216, 216, 217, 217, 218, 218, 219, 219,
+	220, 220, 221, 221, 222, 222, 223, 223,
+	224, 224, 225, 225, 226, 226, 227, 227,
+	228, 228, 229, 229, 230, 230, 230, 231,
+	231, 232, 232, 233, 233, 234, 234, 235,
+	235, 235, 236, 236, 237, 237, 238, 238,
+	239, 239, 240, 240, 240, 241, 241, 242,
+	242, 243, 243, 243, 244, 244, 245, 245,
+	246, 246, 246, 247, 247, 248, 248, 248,
+	249, 249, 250, 250, 251, 251, 251, 252,
+	252, 253, 253, 253, 254, 254, 255, 255,
+};
+
+static const u16 xgamma8_05[GAMMA8_TABLE_LENGTH] = {
+	0, 16, 23, 28, 32, 36, 39, 42,
+	45, 48, 50, 53, 55, 58, 60, 62,
+	64, 66, 68, 70, 71, 73, 75, 77,
+	78, 80, 81, 83, 84, 86, 87, 89,
+	90, 92, 93, 94, 96, 97, 98, 100,
+	101, 102, 103, 105, 106, 107, 108, 109,
+	111, 112, 113, 114, 115, 116, 117, 118,
+	119, 121, 122, 123, 124, 125, 126, 127,
+	128, 129, 130, 131, 132, 133, 134, 135,
+	135, 136, 137, 138, 139, 140, 141, 142,
+	143, 144, 145, 145, 146, 147, 148, 149,
+	150, 151, 151, 152, 153, 154, 155, 156,
+	156, 157, 158, 159, 160, 160, 161, 162,
+	163, 164, 164, 165, 166, 167, 167, 168,
+	169, 170, 170, 171, 172, 173, 173, 174,
+	175, 176, 176, 177, 178, 179, 179, 180,
+	181, 181, 182, 183, 183, 184, 185, 186,
+	186, 187, 188, 188, 189, 190, 190, 191,
+	192, 192, 193, 194, 194, 195, 196, 196,
+	197, 198, 198, 199, 199, 200, 201, 201,
+	202, 203, 203, 204, 204, 205, 206, 206,
+	207, 208, 208, 209, 209, 210, 211, 211,
+	212, 212, 213, 214, 214, 215, 215, 216,
+	217, 217, 218, 218, 219, 220, 220, 221,
+	221, 222, 222, 223, 224, 224, 225, 225,
+	226, 226, 227, 228, 228, 229, 229, 230,
+	230, 231, 231, 232, 233, 233, 234, 234,
+	235, 235, 236, 236, 237, 237, 238, 238,
+	239, 240, 240, 241, 241, 242, 242, 243,
+	243, 244, 244, 245, 245, 246, 246, 247,
+	247, 248, 248, 249, 249, 250, 250, 251,
+	251, 252, 252, 253, 253, 254, 254, 255,
+};
+
+static const u16 xgamma8_06[GAMMA8_TABLE_LENGTH] = {
+	0, 9, 14, 18, 21, 24, 27, 29,
+	32, 34, 37, 39, 41, 43, 45, 47,
+	48, 50, 52, 54, 55, 57, 59, 60,
+	62, 63, 65, 66, 68, 69, 71, 72,
+	73, 75, 76, 77, 79, 80, 81, 83,
+	84, 85, 86, 88, 89, 90, 91, 92,
+	94, 95, 96, 97, 98, 99, 100, 102,
+	103, 104, 105, 106, 107, 108, 109, 110,
+	111, 112, 113, 114, 115, 116, 117, 118,
+	119, 120, 121, 122, 123, 124, 125, 126,
+	127, 128, 129, 130, 131, 132, 133, 134,
+	135, 136, 137, 137, 138, 139, 140, 141,
+	142, 143, 144, 145, 145, 146, 147, 148,
+	149, 150, 151, 151, 152, 153, 154, 155,
+	156, 156, 157, 158, 159, 160, 161, 161,
+	162, 163, 164, 165, 165, 166, 167, 168,
+	169, 169, 170, 171, 172, 173, 173, 174,
+	175, 176, 176, 177, 178, 179, 179, 180,
+	181, 182, 182, 183, 184, 185, 185, 186,
+	187, 188, 188, 189, 190, 191, 191, 192,
+	193, 194, 194, 195, 196, 196, 197, 198,
+	199, 199, 200, 201, 201, 202, 203, 203,
+	204, 205, 206, 206, 207, 208, 208, 209,
+	210, 210, 211, 212, 212, 213, 214, 214,
+	215, 216, 216, 217, 218, 218, 219, 220,
+	220, 221, 222, 222, 223, 224, 224, 225,
+	226, 226, 227, 228, 228, 229, 230, 230,
+	231, 231, 232, 233, 233, 234, 235, 235,
+	236, 237, 237, 238, 238, 239, 240, 240,
+	241, 242, 242, 243, 243, 244, 245, 245,
+	246, 247, 247, 248, 248, 249, 250, 250,
+	251, 251, 252, 253, 253, 254, 254, 255,
+};
+
+static const u16 xgamma8_07[GAMMA8_TABLE_LENGTH] = {
+	0, 5, 9, 11, 14, 16, 18, 21,
+	23, 25, 26, 28, 30, 32, 33, 35,
+	37, 38, 40, 41, 43, 44, 46, 47,
+	49, 50, 52, 53, 54, 56, 57, 58,
+	60, 61, 62, 64, 65, 66, 67, 69,
+	70, 71, 72, 73, 75, 76, 77, 78,
+	79, 80, 82, 83, 84, 85, 86, 87,
+	88, 89, 90, 92, 93, 94, 95, 96,
+	97, 98, 99, 100, 101, 102, 103, 104,
+	105, 106, 107, 108, 109, 110, 111, 112,
+	113, 114, 115, 116, 117, 118, 119, 120,
+	121, 122, 123, 124, 125, 126, 127, 128,
+	129, 130, 131, 131, 132, 133, 134, 135,
+	136, 137, 138, 139, 140, 141, 142, 142,
+	143, 144, 145, 146, 147, 148, 149, 150,
+	150, 151, 152, 153, 154, 155, 156, 157,
+	157, 158, 159, 160, 161, 162, 163, 163,
+	164, 165, 166, 167, 168, 168, 169, 170,
+	171, 172, 173, 173, 174, 175, 176, 177,
+	178, 178, 179, 180, 181, 182, 182, 183,
+	184, 185, 186, 186, 187, 188, 189, 190,
+	190, 191, 192, 193, 194, 194, 195, 196,
+	197, 197, 198, 199, 200, 201, 201, 202,
+	203, 204, 204, 205, 206, 207, 208, 208,
+	209, 210, 211, 211, 212, 213, 214, 214,
+	215, 216, 217, 217, 218, 219, 220, 220,
+	221, 222, 223, 223, 224, 225, 226, 226,
+	227, 228, 228, 229, 230, 231, 231, 232,
+	233, 234, 234, 235, 236, 237, 237, 238,
+	239, 239, 240, 241, 242, 242, 243, 244,
+	244, 245, 246, 247, 247, 248, 249, 249,
+	250, 251, 251, 252, 253, 254, 254, 255,
+};
+
+static const u16 xgamma8_08[GAMMA8_TABLE_LENGTH] = {
+	0, 3, 5, 7, 9, 11, 13, 14,
+	16, 18, 19, 21, 22, 24, 25, 26,
+	28, 29, 31, 32, 33, 35, 36, 37,
+	39, 40, 41, 42, 44, 45, 46, 47,
+	48, 50, 51, 52, 53, 54, 56, 57,
+	58, 59, 60, 61, 63, 64, 65, 66,
+	67, 68, 69, 70, 71, 73, 74, 75,
+	76, 77, 78, 79, 80, 81, 82, 83,
+	84, 85, 86, 88, 89, 90, 91, 92,
+	93, 94, 95, 96, 97, 98, 99, 100,
+	101, 102, 103, 104, 105, 106, 107, 108,
+	109, 110, 111, 112, 113, 114, 115, 116,
+	117, 118, 119, 120, 121, 122, 123, 123,
+	124, 125, 126, 127, 128, 129, 130, 131,
+	132, 133, 134, 135, 136, 137, 138, 139,
+	140, 140, 141, 142, 143, 144, 145, 146,
+	147, 148, 149, 150, 151, 151, 152, 153,
+	154, 155, 156, 157, 158, 159, 160, 161,
+	161, 162, 163, 164, 165, 166, 167, 168,
+	169, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 177, 178, 179, 180, 181, 182,
+	183, 183, 184, 185, 186, 187, 188, 189,
+	190, 190, 191, 192, 193, 194, 195, 196,
+	196, 197, 198, 199, 200, 201, 202, 202,
+	203, 204, 205, 206, 207, 207, 208, 209,
+	210, 211, 212, 212, 213, 214, 215, 216,
+	217, 217, 218, 219, 220, 221, 222, 222,
+	223, 224, 225, 226, 227, 227, 228, 229,
+	230, 231, 232, 232, 233, 234, 235, 236,
+	236, 237, 238, 239, 240, 240, 241, 242,
+	243, 244, 245, 245, 246, 247, 248, 249,
+	249, 250, 251, 252, 253, 253, 254, 255,
+};
+
+static const u16 xgamma8_09[GAMMA8_TABLE_LENGTH] = {
+	0, 2, 3, 5, 6, 7, 9, 10,
+	11, 13, 14, 15, 16, 18, 19, 20,
+	21, 22, 23, 25, 26, 27, 28, 29,
+	30, 32, 33, 34, 35, 36, 37, 38,
+	39, 40, 42, 43, 44, 45, 46, 47,
+	48, 49, 50, 51, 52, 54, 55, 56,
+	57, 58, 59, 60, 61, 62, 63, 64,
+	65, 66, 67, 68, 69, 70, 71, 72,
+	73, 75, 76, 77, 78, 79, 80, 81,
+	82, 83, 84, 85, 86, 87, 88, 89,
+	90, 91, 92, 93, 94, 95, 96, 97,
+	98, 99, 100, 101, 102, 103, 104, 105,
+	106, 107, 108, 109, 110, 111, 112, 113,
+	114, 115, 116, 117, 118, 119, 120, 121,
+	122, 123, 124, 125, 126, 126, 127, 128,
+	129, 130, 131, 132, 133, 134, 135, 136,
+	137, 138, 139, 140, 141, 142, 143, 144,
+	145, 146, 147, 148, 149, 150, 151, 152,
+	152, 153, 154, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 166, 167,
+	168, 169, 170, 170, 171, 172, 173, 174,
+	175, 176, 177, 178, 179, 180, 181, 182,
+	183, 184, 185, 185, 186, 187, 188, 189,
+	190, 191, 192, 193, 194, 195, 196, 197,
+	198, 198, 199, 200, 201, 202, 203, 204,
+	205, 206, 207, 208, 209, 210, 210, 211,
+	212, 213, 214, 215, 216, 217, 218, 219,
+	220, 221, 221, 222, 223, 224, 225, 226,
+	227, 228, 229, 230, 231, 231, 232, 233,
+	234, 235, 236, 237, 238, 239, 240, 241,
+	241, 242, 243, 244, 245, 246, 247, 248,
+	249, 250, 250, 251, 252, 253, 254, 255,
+};
+
+static const u16 xgamma8_10[GAMMA8_TABLE_LENGTH] = {
+	0, 1, 2, 3, 4, 5, 6, 7,
+	8, 9, 10, 11, 12, 13, 14, 15,
+	16, 17, 18, 19, 20, 21, 22, 23,
+	24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39,
+	40, 41, 42, 43, 44, 45, 46, 47,
+	48, 49, 50, 51, 52, 53, 54, 55,
+	56, 57, 58, 59, 60, 61, 62, 63,
+	64, 65, 66, 67, 68, 69, 70, 71,
+	72, 73, 74, 75, 76, 77, 78, 79,
+	80, 81, 82, 83, 84, 85, 86, 87,
+	88, 89, 90, 91, 92, 93, 94, 95,
+	96, 97, 98, 99, 100, 101, 102, 103,
+	104, 105, 106, 107, 108, 109, 110, 111,
+	112, 113, 114, 115, 116, 117, 118, 119,
+	120, 121, 122, 123, 124, 125, 126, 127,
+	128, 129, 130, 131, 132, 133, 134, 135,
+	136, 137, 138, 139, 140, 141, 142, 143,
+	144, 145, 146, 147, 148, 149, 150, 151,
+	152, 153, 154, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 166, 167,
+	168, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 178, 179, 180, 181, 182, 183,
+	184, 185, 186, 187, 188, 189, 190, 191,
+	192, 193, 194, 195, 196, 197, 198, 199,
+	200, 201, 202, 203, 204, 205, 206, 207,
+	208, 209, 210, 211, 212, 213, 214, 215,
+	216, 217, 218, 219, 220, 221, 222, 223,
+	224, 225, 226, 227, 228, 229, 230, 231,
+	232, 233, 234, 235, 236, 237, 238, 239,
+	240, 241, 242, 243, 244, 245, 246, 247,
+	248, 249, 250, 251, 252, 253, 254, 255,
+};
+
+static const u16 xgamma8_11[GAMMA8_TABLE_LENGTH] = {
+	0, 1, 1, 2, 3, 3, 4, 5,
+	6, 6, 7, 8, 9, 10, 10, 11,
+	12, 13, 14, 15, 16, 16, 17, 18,
+	19, 20, 21, 22, 22, 23, 24, 25,
+	26, 27, 28, 29, 30, 31, 31, 32,
+	33, 34, 35, 36, 37, 38, 39, 40,
+	41, 42, 42, 43, 44, 45, 46, 47,
+	48, 49, 50, 51, 52, 53, 54, 55,
+	56, 57, 58, 59, 60, 61, 62, 62,
+	63, 64, 65, 66, 67, 68, 69, 70,
+	71, 72, 73, 74, 75, 76, 77, 78,
+	79, 80, 81, 82, 83, 84, 85, 86,
+	87, 88, 89, 90, 91, 92, 93, 94,
+	95, 96, 97, 98, 99, 100, 101, 102,
+	103, 104, 105, 106, 107, 108, 109, 110,
+	111, 112, 113, 114, 115, 116, 117, 118,
+	119, 121, 122, 123, 124, 125, 126, 127,
+	128, 129, 130, 131, 132, 133, 134, 135,
+	136, 137, 138, 139, 140, 141, 142, 143,
+	144, 145, 146, 147, 149, 150, 151, 152,
+	153, 154, 155, 156, 157, 158, 159, 160,
+	161, 162, 163, 164, 165, 166, 167, 169,
+	170, 171, 172, 173, 174, 175, 176, 177,
+	178, 179, 180, 181, 182, 183, 184, 186,
+	187, 188, 189, 190, 191, 192, 193, 194,
+	195, 196, 197, 198, 199, 201, 202, 203,
+	204, 205, 206, 207, 208, 209, 210, 211,
+	212, 214, 215, 216, 217, 218, 219, 220,
+	221, 222, 223, 224, 225, 227, 228, 229,
+	230, 231, 232, 233, 234, 235, 236, 237,
+	239, 240, 241, 242, 243, 244, 245, 246,
+	247, 248, 250, 251, 252, 253, 254, 255,
+};
+
+static const u16 xgamma8_12[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 1, 1, 2, 2, 3, 3,
+	4, 5, 5, 6, 7, 7, 8, 9,
+	9, 10, 11, 11, 12, 13, 13, 14,
+	15, 16, 16, 17, 18, 19, 20, 20,
+	21, 22, 23, 24, 24, 25, 26, 27,
+	28, 28, 29, 30, 31, 32, 33, 34,
+	34, 35, 36, 37, 38, 39, 40, 40,
+	41, 42, 43, 44, 45, 46, 47, 48,
+	49, 49, 50, 51, 52, 53, 54, 55,
+	56, 57, 58, 59, 60, 61, 62, 62,
+	63, 64, 65, 66, 67, 68, 69, 70,
+	71, 72, 73, 74, 75, 76, 77, 78,
+	79, 80, 81, 82, 83, 84, 85, 86,
+	87, 88, 89, 90, 91, 92, 93, 94,
+	95, 96, 97, 98, 99, 100, 101, 102,
+	103, 104, 105, 106, 107, 108, 109, 110,
+	112, 113, 114, 115, 116, 117, 118, 119,
+	120, 121, 122, 123, 124, 125, 126, 127,
+	128, 130, 131, 132, 133, 134, 135, 136,
+	137, 138, 139, 140, 141, 142, 144, 145,
+	146, 147, 148, 149, 150, 151, 152, 153,
+	155, 156, 157, 158, 159, 160, 161, 162,
+	163, 165, 166, 167, 168, 169, 170, 171,
+	172, 173, 175, 176, 177, 178, 179, 180,
+	181, 183, 184, 185, 186, 187, 188, 189,
+	191, 192, 193, 194, 195, 196, 197, 199,
+	200, 201, 202, 203, 204, 205, 207, 208,
+	209, 210, 211, 212, 214, 215, 216, 217,
+	218, 219, 221, 222, 223, 224, 225, 226,
+	228, 229, 230, 231, 232, 234, 235, 236,
+	237, 238, 239, 241, 242, 243, 244, 245,
+	247, 248, 249, 250, 251, 253, 254, 255,
+};
+
+static const u16 xgamma8_13[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 1, 1, 2, 2, 2,
+	3, 3, 4, 4, 5, 5, 6, 6,
+	7, 8, 8, 9, 9, 10, 11, 11,
+	12, 12, 13, 14, 14, 15, 16, 16,
+	17, 18, 19, 19, 20, 21, 21, 22,
+	23, 24, 24, 25, 26, 27, 28, 28,
+	29, 30, 31, 31, 32, 33, 34, 35,
+	36, 36, 37, 38, 39, 40, 41, 41,
+	42, 43, 44, 45, 46, 47, 47, 48,
+	49, 50, 51, 52, 53, 54, 55, 56,
+	57, 57, 58, 59, 60, 61, 62, 63,
+	64, 65, 66, 67, 68, 69, 70, 71,
+	72, 73, 74, 75, 76, 76, 77, 78,
+	79, 80, 81, 82, 83, 84, 85, 86,
+	88, 89, 90, 91, 92, 93, 94, 95,
+	96, 97, 98, 99, 100, 101, 102, 103,
+	104, 105, 106, 107, 108, 109, 110, 112,
+	113, 114, 115, 116, 117, 118, 119, 120,
+	121, 122, 124, 125, 126, 127, 128, 129,
+	130, 131, 132, 133, 135, 136, 137, 138,
+	139, 140, 141, 143, 144, 145, 146, 147,
+	148, 149, 151, 152, 153, 154, 155, 156,
+	157, 159, 160, 161, 162, 163, 164, 166,
+	167, 168, 169, 170, 172, 173, 174, 175,
+	176, 178, 179, 180, 181, 182, 184, 185,
+	186, 187, 188, 190, 191, 192, 193, 194,
+	196, 197, 198, 199, 201, 202, 203, 204,
+	206, 207, 208, 209, 210, 212, 213, 214,
+	215, 217, 218, 219, 220, 222, 223, 224,
+	226, 227, 228, 229, 231, 232, 233, 234,
+	236, 237, 238, 240, 241, 242, 243, 245,
+	246, 247, 249, 250, 251, 252, 254, 255,
+};
+
+static const u16 xgamma8_14[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 1, 1, 1, 1, 2,
+	2, 2, 3, 3, 4, 4, 4, 5,
+	5, 6, 6, 7, 7, 8, 8, 9,
+	9, 10, 10, 11, 12, 12, 13, 13,
+	14, 15, 15, 16, 16, 17, 18, 18,
+	19, 20, 20, 21, 22, 22, 23, 24,
+	25, 25, 26, 27, 28, 28, 29, 30,
+	31, 31, 32, 33, 34, 34, 35, 36,
+	37, 38, 38, 39, 40, 41, 42, 43,
+	43, 44, 45, 46, 47, 48, 49, 49,
+	50, 51, 52, 53, 54, 55, 56, 57,
+	57, 58, 59, 60, 61, 62, 63, 64,
+	65, 66, 67, 68, 69, 70, 71, 72,
+	73, 74, 75, 76, 77, 78, 79, 80,
+	81, 82, 83, 84, 85, 86, 87, 88,
+	89, 90, 91, 92, 93, 94, 95, 96,
+	97, 98, 99, 100, 101, 103, 104, 105,
+	106, 107, 108, 109, 110, 111, 112, 113,
+	115, 116, 117, 118, 119, 120, 121, 122,
+	124, 125, 126, 127, 128, 129, 130, 132,
+	133, 134, 135, 136, 137, 139, 140, 141,
+	142, 143, 145, 146, 147, 148, 149, 151,
+	152, 153, 154, 155, 157, 158, 159, 160,
+	161, 163, 164, 165, 166, 168, 169, 170,
+	171, 173, 174, 175, 176, 178, 179, 180,
+	181, 183, 184, 185, 187, 188, 189, 190,
+	192, 193, 194, 196, 197, 198, 200, 201,
+	202, 203, 205, 206, 207, 209, 210, 211,
+	213, 214, 215, 217, 218, 219, 221, 222,
+	223, 225, 226, 227, 229, 230, 232, 233,
+	234, 236, 237, 238, 240, 241, 242, 244,
+	245, 247, 248, 249, 251, 252, 254, 255,
+};
+
+static const u16 xgamma8_15[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 1, 1, 1, 1,
+	1, 2, 2, 2, 3, 3, 3, 4,
+	4, 4, 5, 5, 6, 6, 6, 7,
+	7, 8, 8, 9, 9, 10, 10, 11,
+	11, 12, 12, 13, 14, 14, 15, 15,
+	16, 16, 17, 18, 18, 19, 20, 20,
+	21, 21, 22, 23, 23, 24, 25, 26,
+	26, 27, 28, 28, 29, 30, 31, 31,
+	32, 33, 34, 34, 35, 36, 37, 37,
+	38, 39, 40, 41, 41, 42, 43, 44,
+	45, 46, 46, 47, 48, 49, 50, 51,
+	52, 53, 53, 54, 55, 56, 57, 58,
+	59, 60, 61, 62, 63, 64, 65, 65,
+	66, 67, 68, 69, 70, 71, 72, 73,
+	74, 75, 76, 77, 78, 79, 80, 81,
+	82, 83, 84, 85, 86, 88, 89, 90,
+	91, 92, 93, 94, 95, 96, 97, 98,
+	99, 100, 102, 103, 104, 105, 106, 107,
+	108, 109, 110, 112, 113, 114, 115, 116,
+	117, 119, 120, 121, 122, 123, 124, 126,
+	127, 128, 129, 130, 132, 133, 134, 135,
+	136, 138, 139, 140, 141, 142, 144, 145,
+	146, 147, 149, 150, 151, 152, 154, 155,
+	156, 158, 159, 160, 161, 163, 164, 165,
+	167, 168, 169, 171, 172, 173, 174, 176,
+	177, 178, 180, 181, 182, 184, 185, 187,
+	188, 189, 191, 192, 193, 195, 196, 197,
+	199, 200, 202, 203, 204, 206, 207, 209,
+	210, 211, 213, 214, 216, 217, 218, 220,
+	221, 223, 224, 226, 227, 228, 230, 231,
+	233, 234, 236, 237, 239, 240, 242, 243,
+	245, 246, 248, 249, 251, 252, 254, 255,
+};
+
+static const u16 xgamma8_16[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 2, 2, 2, 2, 3,
+	3, 3, 4, 4, 4, 5, 5, 5,
+	6, 6, 7, 7, 7, 8, 8, 9,
+	9, 10, 10, 11, 11, 12, 12, 13,
+	13, 14, 14, 15, 15, 16, 16, 17,
+	18, 18, 19, 19, 20, 21, 21, 22,
+	23, 23, 24, 25, 25, 26, 27, 27,
+	28, 29, 29, 30, 31, 31, 32, 33,
+	34, 34, 35, 36, 37, 38, 38, 39,
+	40, 41, 42, 42, 43, 44, 45, 46,
+	46, 47, 48, 49, 50, 51, 52, 53,
+	53, 54, 55, 56, 57, 58, 59, 60,
+	61, 62, 63, 64, 64, 65, 66, 67,
+	68, 69, 70, 71, 72, 73, 74, 75,
+	76, 77, 78, 79, 80, 81, 83, 84,
+	85, 86, 87, 88, 89, 90, 91, 92,
+	93, 94, 95, 97, 98, 99, 100, 101,
+	102, 103, 104, 106, 107, 108, 109, 110,
+	111, 113, 114, 115, 116, 117, 119, 120,
+	121, 122, 123, 125, 126, 127, 128, 130,
+	131, 132, 133, 135, 136, 137, 138, 140,
+	141, 142, 143, 145, 146, 147, 149, 150,
+	151, 153, 154, 155, 157, 158, 159, 161,
+	162, 163, 165, 166, 167, 169, 170, 171,
+	173, 174, 176, 177, 178, 180, 181, 183,
+	184, 185, 187, 188, 190, 191, 193, 194,
+	196, 197, 198, 200, 201, 203, 204, 206,
+	207, 209, 210, 212, 213, 215, 216, 218,
+	219, 221, 222, 224, 225, 227, 228, 230,
+	231, 233, 235, 236, 238, 239, 241, 242,
+	244, 245, 247, 249, 250, 252, 253, 255,
+};
+
+static const u16 xgamma8_17[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 2, 2, 2,
+	2, 3, 3, 3, 3, 4, 4, 4,
+	5, 5, 5, 6, 6, 6, 7, 7,
+	7, 8, 8, 9, 9, 10, 10, 10,
+	11, 11, 12, 12, 13, 13, 14, 14,
+	15, 15, 16, 17, 17, 18, 18, 19,
+	19, 20, 21, 21, 22, 22, 23, 24,
+	24, 25, 26, 26, 27, 28, 28, 29,
+	30, 30, 31, 32, 33, 33, 34, 35,
+	36, 36, 37, 38, 39, 39, 40, 41,
+	42, 43, 43, 44, 45, 46, 47, 48,
+	48, 49, 50, 51, 52, 53, 54, 55,
+	56, 56, 57, 58, 59, 60, 61, 62,
+	63, 64, 65, 66, 67, 68, 69, 70,
+	71, 72, 73, 74, 75, 76, 77, 78,
+	79, 80, 81, 82, 83, 84, 85, 86,
+	88, 89, 90, 91, 92, 93, 94, 95,
+	97, 98, 99, 100, 101, 102, 103, 105,
+	106, 107, 108, 109, 111, 112, 113, 114,
+	115, 117, 118, 119, 120, 122, 123, 124,
+	125, 127, 128, 129, 131, 132, 133, 134,
+	136, 137, 138, 140, 141, 142, 144, 145,
+	146, 148, 149, 151, 152, 153, 155, 156,
+	157, 159, 160, 162, 163, 164, 166, 167,
+	169, 170, 172, 173, 174, 176, 177, 179,
+	180, 182, 183, 185, 186, 188, 189, 191,
+	192, 194, 195, 197, 198, 200, 201, 203,
+	205, 206, 208, 209, 211, 212, 214, 216,
+	217, 219, 220, 222, 224, 225, 227, 228,
+	230, 232, 233, 235, 237, 238, 240, 242,
+	243, 245, 247, 248, 250, 252, 253, 255,
+};
+
+static const u16 xgamma8_18[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 3, 3, 3, 3,
+	4, 4, 4, 4, 5, 5, 5, 6,
+	6, 6, 7, 7, 8, 8, 8, 9,
+	9, 10, 10, 10, 11, 11, 12, 12,
+	13, 13, 14, 14, 15, 15, 16, 16,
+	17, 17, 18, 18, 19, 19, 20, 21,
+	21, 22, 22, 23, 24, 24, 25, 26,
+	26, 27, 28, 28, 29, 30, 30, 31,
+	32, 32, 33, 34, 35, 35, 36, 37,
+	38, 38, 39, 40, 41, 41, 42, 43,
+	44, 45, 46, 46, 47, 48, 49, 50,
+	51, 52, 53, 53, 54, 55, 56, 57,
+	58, 59, 60, 61, 62, 63, 64, 65,
+	66, 67, 68, 69, 70, 71, 72, 73,
+	74, 75, 76, 77, 78, 79, 80, 81,
+	82, 83, 84, 86, 87, 88, 89, 90,
+	91, 92, 93, 95, 96, 97, 98, 99,
+	100, 102, 103, 104, 105, 107, 108, 109,
+	110, 111, 113, 114, 115, 116, 118, 119,
+	120, 122, 123, 124, 126, 127, 128, 129,
+	131, 132, 134, 135, 136, 138, 139, 140,
+	142, 143, 145, 146, 147, 149, 150, 152,
+	153, 154, 156, 157, 159, 160, 162, 163,
+	165, 166, 168, 169, 171, 172, 174, 175,
+	177, 178, 180, 181, 183, 184, 186, 188,
+	189, 191, 192, 194, 195, 197, 199, 200,
+	202, 204, 205, 207, 208, 210, 212, 213,
+	215, 217, 218, 220, 222, 224, 225, 227,
+	229, 230, 232, 234, 236, 237, 239, 241,
+	243, 244, 246, 248, 250, 251, 253, 255,
+};
+
+static const u16 xgamma8_19[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 1, 1, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 4, 4, 4, 4, 5,
+	5, 5, 6, 6, 6, 7, 7, 7,
+	8, 8, 8, 9, 9, 9, 10, 10,
+	11, 11, 12, 12, 12, 13, 13, 14,
+	14, 15, 15, 16, 16, 17, 17, 18,
+	18, 19, 20, 20, 21, 21, 22, 22,
+	23, 24, 24, 25, 26, 26, 27, 28,
+	28, 29, 30, 30, 31, 32, 32, 33,
+	34, 35, 35, 36, 37, 38, 38, 39,
+	40, 41, 41, 42, 43, 44, 45, 46,
+	46, 47, 48, 49, 50, 51, 52, 53,
+	53, 54, 55, 56, 57, 58, 59, 60,
+	61, 62, 63, 64, 65, 66, 67, 68,
+	69, 70, 71, 72, 73, 74, 75, 76,
+	77, 78, 79, 81, 82, 83, 84, 85,
+	86, 87, 88, 90, 91, 92, 93, 94,
+	95, 97, 98, 99, 100, 101, 103, 104,
+	105, 106, 108, 109, 110, 112, 113, 114,
+	115, 117, 118, 119, 121, 122, 123, 125,
+	126, 127, 129, 130, 132, 133, 134, 136,
+	137, 139, 140, 141, 143, 144, 146, 147,
+	149, 150, 152, 153, 155, 156, 158, 159,
+	161, 162, 164, 165, 167, 168, 170, 172,
+	173, 175, 176, 178, 180, 181, 183, 184,
+	186, 188, 189, 191, 193, 194, 196, 198,
+	199, 201, 203, 204, 206, 208, 210, 211,
+	213, 215, 217, 218, 220, 222, 224, 225,
+	227, 229, 231, 233, 235, 236, 238, 240,
+	242, 244, 246, 247, 249, 251, 253, 255,
+};
+
+static const u16 xgamma8_20[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 4, 4,
+	4, 4, 5, 5, 5, 5, 6, 6,
+	6, 7, 7, 7, 8, 8, 8, 9,
+	9, 9, 10, 10, 11, 11, 11, 12,
+	12, 13, 13, 14, 14, 15, 15, 16,
+	16, 17, 17, 18, 18, 19, 19, 20,
+	20, 21, 21, 22, 23, 23, 24, 24,
+	25, 26, 26, 27, 28, 28, 29, 30,
+	30, 31, 32, 32, 33, 34, 35, 35,
+	36, 37, 38, 38, 39, 40, 41, 42,
+	42, 43, 44, 45, 46, 47, 47, 48,
+	49, 50, 51, 52, 53, 54, 55, 56,
+	56, 57, 58, 59, 60, 61, 62, 63,
+	64, 65, 66, 67, 68, 69, 70, 71,
+	73, 74, 75, 76, 77, 78, 79, 80,
+	81, 82, 84, 85, 86, 87, 88, 89,
+	91, 92, 93, 94, 95, 97, 98, 99,
+	100, 102, 103, 104, 105, 107, 108, 109,
+	111, 112, 113, 115, 116, 117, 119, 120,
+	121, 123, 124, 126, 127, 128, 130, 131,
+	133, 134, 136, 137, 139, 140, 142, 143,
+	145, 146, 148, 149, 151, 152, 154, 155,
+	157, 158, 160, 162, 163, 165, 166, 168,
+	170, 171, 173, 175, 176, 178, 180, 181,
+	183, 185, 186, 188, 190, 192, 193, 195,
+	197, 199, 200, 202, 204, 206, 207, 209,
+	211, 213, 215, 217, 218, 220, 222, 224,
+	226, 228, 230, 232, 233, 235, 237, 239,
+	241, 243, 245, 247, 249, 251, 253, 255,
+};
+
+static const u16 xgamma8_21[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 4, 4, 4, 4, 5, 5,
+	5, 5, 6, 6, 6, 7, 7, 7,
+	8, 8, 8, 9, 9, 9, 10, 10,
+	11, 11, 11, 12, 12, 13, 13, 14,
+	14, 14, 15, 15, 16, 16, 17, 17,
+	18, 18, 19, 20, 20, 21, 21, 22,
+	22, 23, 24, 24, 25, 25, 26, 27,
+	27, 28, 29, 29, 30, 31, 31, 32,
+	33, 33, 34, 35, 36, 36, 37, 38,
+	39, 40, 40, 41, 42, 43, 44, 44,
+	45, 46, 47, 48, 49, 50, 51, 51,
+	52, 53, 54, 55, 56, 57, 58, 59,
+	60, 61, 62, 63, 64, 65, 66, 67,
+	68, 69, 70, 71, 72, 73, 75, 76,
+	77, 78, 79, 80, 81, 83, 84, 85,
+	86, 87, 88, 90, 91, 92, 93, 95,
+	96, 97, 98, 100, 101, 102, 104, 105,
+	106, 107, 109, 110, 112, 113, 114, 116,
+	117, 118, 120, 121, 123, 124, 126, 127,
+	129, 130, 131, 133, 134, 136, 137, 139,
+	141, 142, 144, 145, 147, 148, 150, 151,
+	153, 155, 156, 158, 160, 161, 163, 165,
+	166, 168, 170, 171, 173, 175, 176, 178,
+	180, 182, 183, 185, 187, 189, 191, 192,
+	194, 196, 198, 200, 202, 203, 205, 207,
+	209, 211, 213, 215, 217, 219, 221, 223,
+	225, 226, 228, 230, 232, 234, 236, 238,
+	241, 243, 245, 247, 249, 251, 253, 255,
+};
+
+static const u16 xgamma8_22[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2,
+	3, 3, 3, 3, 3, 4, 4, 4,
+	4, 5, 5, 5, 5, 6, 6, 6,
+	6, 7, 7, 7, 8, 8, 8, 9,
+	9, 9, 10, 10, 11, 11, 11, 12,
+	12, 13, 13, 13, 14, 14, 15, 15,
+	16, 16, 17, 17, 18, 18, 19, 19,
+	20, 20, 21, 22, 22, 23, 23, 24,
+	25, 25, 26, 26, 27, 28, 28, 29,
+	30, 30, 31, 32, 33, 33, 34, 35,
+	35, 36, 37, 38, 39, 39, 40, 41,
+	42, 43, 43, 44, 45, 46, 47, 48,
+	49, 49, 50, 51, 52, 53, 54, 55,
+	56, 57, 58, 59, 60, 61, 62, 63,
+	64, 65, 66, 67, 68, 69, 70, 71,
+	73, 74, 75, 76, 77, 78, 79, 81,
+	82, 83, 84, 85, 87, 88, 89, 90,
+	91, 93, 94, 95, 97, 98, 99, 100,
+	102, 103, 105, 106, 107, 109, 110, 111,
+	113, 114, 116, 117, 119, 120, 121, 123,
+	124, 126, 127, 129, 130, 132, 133, 135,
+	137, 138, 140, 141, 143, 145, 146, 148,
+	149, 151, 153, 154, 156, 158, 159, 161,
+	163, 165, 166, 168, 170, 172, 173, 175,
+	177, 179, 181, 182, 184, 186, 188, 190,
+	192, 194, 196, 197, 199, 201, 203, 205,
+	207, 209, 211, 213, 215, 217, 219, 221,
+	223, 225, 227, 229, 231, 234, 236, 238,
+	240, 242, 244, 246, 248, 251, 253, 255,
+};
+
+static const u16 xgamma8_23[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 3, 3, 3, 3, 3,
+	4, 4, 4, 4, 4, 5, 5, 5,
+	5, 6, 6, 6, 7, 7, 7, 7,
+	8, 8, 8, 9, 9, 10, 10, 10,
+	11, 11, 11, 12, 12, 13, 13, 13,
+	14, 14, 15, 15, 16, 16, 17, 17,
+	18, 18, 19, 19, 20, 20, 21, 21,
+	22, 23, 23, 24, 24, 25, 26, 26,
+	27, 28, 28, 29, 30, 30, 31, 32,
+	32, 33, 34, 35, 35, 36, 37, 38,
+	38, 39, 40, 41, 42, 42, 43, 44,
+	45, 46, 47, 48, 49, 49, 50, 51,
+	52, 53, 54, 55, 56, 57, 58, 59,
+	60, 61, 62, 63, 64, 65, 66, 67,
+	69, 70, 71, 72, 73, 74, 75, 76,
+	78, 79, 80, 81, 82, 84, 85, 86,
+	87, 89, 90, 91, 92, 94, 95, 96,
+	98, 99, 100, 102, 103, 104, 106, 107,
+	109, 110, 112, 113, 114, 116, 117, 119,
+	120, 122, 123, 125, 126, 128, 130, 131,
+	133, 134, 136, 138, 139, 141, 143, 144,
+	146, 148, 149, 151, 153, 154, 156, 158,
+	160, 161, 163, 165, 167, 169, 170, 172,
+	174, 176, 178, 180, 182, 183, 185, 187,
+	189, 191, 193, 195, 197, 199, 201, 203,
+	205, 207, 209, 211, 213, 215, 218, 220,
+	222, 224, 226, 228, 230, 233, 235, 237,
+	239, 241, 244, 246, 248, 250, 253, 255,
+};
+
+static const u16 xgamma8_24[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 2, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4,
+	5, 5, 5, 5, 6, 6, 6, 6,
+	7, 7, 7, 8, 8, 8, 9, 9,
+	9, 10, 10, 10, 11, 11, 11, 12,
+	12, 13, 13, 14, 14, 14, 15, 15,
+	16, 16, 17, 17, 18, 18, 19, 19,
+	20, 20, 21, 22, 22, 23, 23, 24,
+	24, 25, 26, 26, 27, 28, 28, 29,
+	30, 30, 31, 32, 32, 33, 34, 35,
+	35, 36, 37, 38, 39, 39, 40, 41,
+	42, 43, 43, 44, 45, 46, 47, 48,
+	49, 50, 51, 52, 53, 53, 54, 55,
+	56, 57, 58, 59, 60, 62, 63, 64,
+	65, 66, 67, 68, 69, 70, 71, 73,
+	74, 75, 76, 77, 78, 80, 81, 82,
+	83, 85, 86, 87, 88, 90, 91, 92,
+	94, 95, 96, 98, 99, 100, 102, 103,
+	105, 106, 108, 109, 111, 112, 114, 115,
+	117, 118, 120, 121, 123, 124, 126, 127,
+	129, 131, 132, 134, 136, 137, 139, 141,
+	142, 144, 146, 148, 149, 151, 153, 155,
+	156, 158, 160, 162, 164, 166, 167, 169,
+	171, 173, 175, 177, 179, 181, 183, 185,
+	187, 189, 191, 193, 195, 197, 199, 201,
+	203, 205, 207, 210, 212, 214, 216, 218,
+	220, 223, 225, 227, 229, 232, 234, 236,
+	239, 241, 243, 246, 248, 250, 253, 255,
+};
+
+static const u16 xgamma8_25[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2,
+	2, 3, 3, 3, 3, 3, 4, 4,
+	4, 4, 4, 5, 5, 5, 5, 6,
+	6, 6, 6, 7, 7, 7, 7, 8,
+	8, 8, 9, 9, 9, 10, 10, 10,
+	11, 11, 12, 12, 12, 13, 13, 14,
+	14, 15, 15, 15, 16, 16, 17, 17,
+	18, 18, 19, 19, 20, 20, 21, 22,
+	22, 23, 23, 24, 25, 25, 26, 26,
+	27, 28, 28, 29, 30, 30, 31, 32,
+	33, 33, 34, 35, 36, 36, 37, 38,
+	39, 40, 40, 41, 42, 43, 44, 45,
+	46, 46, 47, 48, 49, 50, 51, 52,
+	53, 54, 55, 56, 57, 58, 59, 60,
+	61, 62, 63, 64, 65, 67, 68, 69,
+	70, 71, 72, 73, 75, 76, 77, 78,
+	80, 81, 82, 83, 85, 86, 87, 89,
+	90, 91, 93, 94, 95, 97, 98, 99,
+	101, 102, 104, 105, 107, 108, 110, 111,
+	113, 114, 116, 117, 119, 121, 122, 124,
+	125, 127, 129, 130, 132, 134, 135, 137,
+	139, 141, 142, 144, 146, 148, 150, 151,
+	153, 155, 157, 159, 161, 163, 165, 166,
+	168, 170, 172, 174, 176, 178, 180, 182,
+	184, 186, 189, 191, 193, 195, 197, 199,
+	201, 204, 206, 208, 210, 212, 215, 217,
+	219, 221, 224, 226, 228, 231, 233, 235,
+	238, 240, 243, 245, 248, 250, 253, 255,
+};
+
+static const u16 xgamma8_26[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3,
+	3, 3, 4, 4, 4, 4, 5, 5,
+	5, 5, 5, 6, 6, 6, 6, 7,
+	7, 7, 8, 8, 8, 9, 9, 9,
+	10, 10, 10, 11, 11, 11, 12, 12,
+	13, 13, 13, 14, 14, 15, 15, 16,
+	16, 17, 17, 18, 18, 19, 19, 20,
+	20, 21, 21, 22, 22, 23, 24, 24,
+	25, 25, 26, 27, 27, 28, 29, 29,
+	30, 31, 31, 32, 33, 34, 34, 35,
+	36, 37, 38, 38, 39, 40, 41, 42,
+	42, 43, 44, 45, 46, 47, 48, 49,
+	50, 51, 52, 53, 54, 55, 56, 57,
+	58, 59, 60, 61, 62, 63, 64, 65,
+	66, 68, 69, 70, 71, 72, 73, 75,
+	76, 77, 78, 80, 81, 82, 84, 85,
+	86, 88, 89, 90, 92, 93, 94, 96,
+	97, 99, 100, 102, 103, 105, 106, 108,
+	109, 111, 112, 114, 115, 117, 119, 120,
+	122, 124, 125, 127, 129, 130, 132, 134,
+	136, 137, 139, 141, 143, 145, 146, 148,
+	150, 152, 154, 156, 158, 160, 162, 164,
+	166, 168, 170, 172, 174, 176, 178, 180,
+	182, 184, 186, 188, 191, 193, 195, 197,
+	199, 202, 204, 206, 209, 211, 213, 215,
+	218, 220, 223, 225, 227, 230, 232, 235,
+	237, 240, 242, 245, 247, 250, 252, 255,
+};
+
+static const u16 xgamma8_27[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 2, 3, 3,
+	3, 3, 3, 3, 3, 4, 4, 4,
+	4, 4, 5, 5, 5, 5, 6, 6,
+	6, 6, 7, 7, 7, 7, 8, 8,
+	8, 9, 9, 9, 10, 10, 10, 11,
+	11, 12, 12, 12, 13, 13, 14, 14,
+	14, 15, 15, 16, 16, 17, 17, 18,
+	18, 19, 19, 20, 20, 21, 21, 22,
+	23, 23, 24, 24, 25, 26, 26, 27,
+	28, 28, 29, 30, 30, 31, 32, 33,
+	33, 34, 35, 36, 36, 37, 38, 39,
+	40, 41, 41, 42, 43, 44, 45, 46,
+	47, 48, 49, 50, 51, 51, 52, 53,
+	55, 56, 57, 58, 59, 60, 61, 62,
+	63, 64, 65, 66, 68, 69, 70, 71,
+	72, 74, 75, 76, 77, 79, 80, 81,
+	83, 84, 85, 87, 88, 89, 91, 92,
+	94, 95, 97, 98, 100, 101, 103, 104,
+	106, 107, 109, 110, 112, 114, 115, 117,
+	119, 120, 122, 124, 125, 127, 129, 131,
+	132, 134, 136, 138, 140, 141, 143, 145,
+	147, 149, 151, 153, 155, 157, 159, 161,
+	163, 165, 167, 169, 171, 173, 175, 178,
+	180, 182, 184, 186, 188, 191, 193, 195,
+	198, 200, 202, 205, 207, 209, 212, 214,
+	216, 219, 221, 224, 226, 229, 231, 234,
+	237, 239, 242, 244, 247, 250, 252, 255,
+};
+
+static const u16 xgamma8_28[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2,
+	2, 3, 3, 3, 3, 3, 3, 3,
+	4, 4, 4, 4, 4, 5, 5, 5,
+	5, 6, 6, 6, 6, 7, 7, 7,
+	7, 8, 8, 8, 9, 9, 9, 10,
+	10, 10, 11, 11, 11, 12, 12, 13,
+	13, 13, 14, 14, 15, 15, 16, 16,
+	17, 17, 18, 18, 19, 19, 20, 20,
+	21, 21, 22, 22, 23, 24, 24, 25,
+	25, 26, 27, 27, 28, 29, 29, 30,
+	31, 32, 32, 33, 34, 35, 35, 36,
+	37, 38, 39, 39, 40, 41, 42, 43,
+	44, 45, 46, 47, 48, 49, 50, 50,
+	51, 52, 54, 55, 56, 57, 58, 59,
+	60, 61, 62, 63, 64, 66, 67, 68,
+	69, 70, 72, 73, 74, 75, 77, 78,
+	79, 81, 82, 83, 85, 86, 87, 89,
+	90, 92, 93, 95, 96, 98, 99, 101,
+	102, 104, 105, 107, 109, 110, 112, 114,
+	115, 117, 119, 120, 122, 124, 126, 127,
+	129, 131, 133, 135, 137, 138, 140, 142,
+	144, 146, 148, 150, 152, 154, 156, 158,
+	160, 162, 164, 167, 169, 171, 173, 175,
+	177, 180, 182, 184, 186, 189, 191, 193,
+	196, 198, 200, 203, 205, 208, 210, 213,
+	215, 218, 220, 223, 225, 228, 231, 233,
+	236, 239, 241, 244, 247, 249, 252, 255,
+};
+
+static const u16 xgamma8_29[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4,
+	5, 5, 5, 5, 6, 6, 6, 6,
+	7, 7, 7, 7, 8, 8, 8, 9,
+	9, 9, 9, 10, 10, 11, 11, 11,
+	12, 12, 12, 13, 13, 14, 14, 15,
+	15, 15, 16, 16, 17, 17, 18, 18,
+	19, 19, 20, 21, 21, 22, 22, 23,
+	23, 24, 25, 25, 26, 27, 27, 28,
+	29, 29, 30, 31, 32, 32, 33, 34,
+	35, 35, 36, 37, 38, 39, 39, 40,
+	41, 42, 43, 44, 45, 46, 47, 48,
+	49, 50, 51, 52, 53, 54, 55, 56,
+	57, 58, 59, 60, 61, 62, 64, 65,
+	66, 67, 68, 70, 71, 72, 73, 75,
+	76, 77, 79, 80, 81, 83, 84, 86,
+	87, 88, 90, 91, 93, 94, 96, 97,
+	99, 101, 102, 104, 105, 107, 109, 110,
+	112, 114, 115, 117, 119, 121, 122, 124,
+	126, 128, 130, 132, 134, 135, 137, 139,
+	141, 143, 145, 147, 149, 151, 153, 155,
+	158, 160, 162, 164, 166, 168, 171, 173,
+	175, 177, 180, 182, 184, 187, 189, 191,
+	194, 196, 199, 201, 204, 206, 209, 211,
+	214, 216, 219, 222, 224, 227, 230, 232,
+	235, 238, 241, 244, 246, 249, 252, 255,
+};
+
+static const u16 xgamma8_30[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3, 3, 4, 4,
+	4, 4, 4, 5, 5, 5, 5, 6,
+	6, 6, 6, 6, 7, 7, 7, 8,
+	8, 8, 8, 9, 9, 9, 10, 10,
+	10, 11, 11, 12, 12, 12, 13, 13,
+	14, 14, 14, 15, 15, 16, 16, 17,
+	17, 18, 18, 19, 19, 20, 20, 21,
+	22, 22, 23, 23, 24, 25, 25, 26,
+	27, 27, 28, 29, 29, 30, 31, 32,
+	32, 33, 34, 35, 35, 36, 37, 38,
+	39, 40, 40, 41, 42, 43, 44, 45,
+	46, 47, 48, 49, 50, 51, 52, 53,
+	54, 55, 56, 57, 58, 60, 61, 62,
+	63, 64, 65, 67, 68, 69, 70, 72,
+	73, 74, 76, 77, 78, 80, 81, 82,
+	84, 85, 87, 88, 90, 91, 93, 94,
+	96, 97, 99, 101, 102, 104, 105, 107,
+	109, 111, 112, 114, 116, 118, 119, 121,
+	123, 125, 127, 129, 131, 132, 134, 136,
+	138, 140, 142, 144, 147, 149, 151, 153,
+	155, 157, 159, 162, 164, 166, 168, 171,
+	173, 175, 178, 180, 182, 185, 187, 190,
+	192, 195, 197, 200, 202, 205, 207, 210,
+	213, 215, 218, 221, 223, 226, 229, 232,
+	235, 237, 240, 243, 246, 249, 252, 255,
+};
+
+static const u16 xgamma8_31[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 3, 3,
+	4, 4, 4, 4, 4, 4, 5, 5,
+	5, 5, 6, 6, 6, 6, 6, 7,
+	7, 7, 8, 8, 8, 8, 9, 9,
+	9, 10, 10, 10, 11, 11, 12, 12,
+	12, 13, 13, 14, 14, 14, 15, 15,
+	16, 16, 17, 17, 18, 18, 19, 19,
+	20, 20, 21, 22, 22, 23, 23, 24,
+	25, 25, 26, 27, 27, 28, 29, 29,
+	30, 31, 32, 32, 33, 34, 35, 36,
+	36, 37, 38, 39, 40, 41, 42, 42,
+	43, 44, 45, 46, 47, 48, 49, 50,
+	51, 52, 53, 54, 56, 57, 58, 59,
+	60, 61, 62, 64, 65, 66, 67, 69,
+	70, 71, 73, 74, 75, 77, 78, 79,
+	81, 82, 84, 85, 87, 88, 90, 91,
+	93, 94, 96, 97, 99, 101, 102, 104,
+	106, 108, 109, 111, 113, 115, 116, 118,
+	120, 122, 124, 126, 128, 130, 132, 134,
+	136, 138, 140, 142, 144, 146, 148, 150,
+	152, 155, 157, 159, 161, 164, 166, 168,
+	171, 173, 175, 178, 180, 183, 185, 188,
+	190, 193, 195, 198, 201, 203, 206, 209,
+	211, 214, 217, 220, 222, 225, 228, 231,
+	234, 237, 240, 243, 246, 249, 252, 255,
+};
+
+static const u16 xgamma8_32[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4,
+	4, 5, 5, 5, 5, 6, 6, 6,
+	6, 6, 7, 7, 7, 8, 8, 8,
+	8, 9, 9, 9, 10, 10, 10, 11,
+	11, 12, 12, 12, 13, 13, 14, 14,
+	14, 15, 15, 16, 16, 17, 17, 18,
+	18, 19, 19, 20, 21, 21, 22, 22,
+	23, 23, 24, 25, 25, 26, 27, 27,
+	28, 29, 30, 30, 31, 32, 33, 33,
+	34, 35, 36, 37, 37, 38, 39, 40,
+	41, 42, 43, 44, 45, 46, 47, 48,
+	49, 50, 51, 52, 53, 54, 55, 56,
+	57, 59, 60, 61, 62, 63, 65, 66,
+	67, 68, 70, 71, 72, 74, 75, 76,
+	78, 79, 81, 82, 84, 85, 87, 88,
+	90, 91, 93, 95, 96, 98, 99, 101,
+	103, 105, 106, 108, 110, 112, 113, 115,
+	117, 119, 121, 123, 125, 127, 129, 131,
+	133, 135, 137, 139, 141, 143, 146, 148,
+	150, 152, 154, 157, 159, 161, 164, 166,
+	168, 171, 173, 176, 178, 181, 183, 186,
+	188, 191, 194, 196, 199, 202, 204, 207,
+	210, 213, 216, 219, 221, 224, 227, 230,
+	233, 236, 239, 242, 246, 249, 252, 255,
+};
+
+static const u16 xgamma8_33[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3, 3, 4, 4,
+	4, 4, 4, 4, 5, 5, 5, 5,
+	6, 6, 6, 6, 7, 7, 7, 7,
+	8, 8, 8, 9, 9, 9, 9, 10,
+	10, 11, 11, 11, 12, 12, 12, 13,
+	13, 14, 14, 15, 15, 15, 16, 16,
+	17, 17, 18, 18, 19, 19, 20, 21,
+	21, 22, 22, 23, 24, 24, 25, 26,
+	26, 27, 28, 28, 29, 30, 31, 31,
+	32, 33, 34, 34, 35, 36, 37, 38,
+	39, 40, 40, 41, 42, 43, 44, 45,
+	46, 47, 48, 49, 50, 51, 53, 54,
+	55, 56, 57, 58, 59, 61, 62, 63,
+	64, 66, 67, 68, 70, 71, 72, 74,
+	75, 76, 78, 79, 81, 82, 84, 85,
+	87, 88, 90, 92, 93, 95, 97, 98,
+	100, 102, 103, 105, 107, 109, 111, 113,
+	114, 116, 118, 120, 122, 124, 126, 128,
+	130, 132, 134, 136, 139, 141, 143, 145,
+	147, 150, 152, 154, 157, 159, 161, 164,
+	166, 169, 171, 174, 176, 179, 181, 184,
+	187, 189, 192, 195, 198, 200, 203, 206,
+	209, 212, 215, 217, 220, 223, 226, 230,
+	233, 236, 239, 242, 245, 248, 252, 255,
+};
+
+static const u16 xgamma8_34[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 3, 3,
+	3, 4, 4, 4, 4, 4, 5, 5,
+	5, 5, 5, 6, 6, 6, 6, 7,
+	7, 7, 7, 8, 8, 8, 9, 9,
+	9, 10, 10, 10, 11, 11, 11, 12,
+	12, 12, 13, 13, 14, 14, 15, 15,
+	16, 16, 17, 17, 18, 18, 19, 19,
+	20, 20, 21, 21, 22, 23, 23, 24,
+	24, 25, 26, 26, 27, 28, 29, 29,
+	30, 31, 32, 32, 33, 34, 35, 36,
+	37, 37, 38, 39, 40, 41, 42, 43,
+	44, 45, 46, 47, 48, 49, 50, 51,
+	52, 53, 55, 56, 57, 58, 59, 60,
+	62, 63, 64, 66, 67, 68, 70, 71,
+	72, 74, 75, 77, 78, 80, 81, 83,
+	84, 86, 87, 89, 90, 92, 94, 95,
+	97, 99, 101, 102, 104, 106, 108, 110,
+	112, 114, 115, 117, 119, 121, 123, 125,
+	128, 130, 132, 134, 136, 138, 141, 143,
+	145, 147, 150, 152, 154, 157, 159, 162,
+	164, 167, 169, 172, 174, 177, 180, 182,
+	185, 188, 190, 193, 196, 199, 202, 205,
+	208, 210, 213, 216, 219, 223, 226, 229,
+	232, 235, 238, 242, 245, 248, 252, 255,
+};
+
+static const u16 xgamma8_35[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4,
+	4, 5, 5, 5, 5, 5, 6, 6,
+	6, 6, 7, 7, 7, 7, 8, 8,
+	8, 9, 9, 9, 10, 10, 10, 11,
+	11, 11, 12, 12, 13, 13, 13, 14,
+	14, 15, 15, 16, 16, 17, 17, 18,
+	18, 19, 19, 20, 20, 21, 22, 22,
+	23, 23, 24, 25, 25, 26, 27, 28,
+	28, 29, 30, 30, 31, 32, 33, 34,
+	35, 35, 36, 37, 38, 39, 40, 41,
+	42, 43, 44, 45, 46, 47, 48, 49,
+	50, 51, 52, 53, 54, 56, 57, 58,
+	59, 60, 62, 63, 64, 66, 67, 68,
+	70, 71, 72, 74, 75, 77, 78, 80,
+	81, 83, 85, 86, 88, 89, 91, 93,
+	94, 96, 98, 100, 102, 103, 105, 107,
+	109, 111, 113, 115, 117, 119, 121, 123,
+	125, 127, 129, 131, 134, 136, 138, 140,
+	143, 145, 147, 150, 152, 155, 157, 159,
+	162, 165, 167, 170, 172, 175, 178, 180,
+	183, 186, 189, 192, 194, 197, 200, 203,
+	206, 209, 212, 215, 219, 222, 225, 228,
+	231, 235, 238, 241, 245, 248, 252, 255,
+};
+
+static const u16 xgamma8_36[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3, 3, 4, 4,
+	4, 4, 4, 4, 5, 5, 5, 5,
+	6, 6, 6, 6, 6, 7, 7, 7,
+	8, 8, 8, 8, 9, 9, 9, 10,
+	10, 10, 11, 11, 12, 12, 12, 13,
+	13, 14, 14, 15, 15, 15, 16, 16,
+	17, 17, 18, 18, 19, 20, 20, 21,
+	21, 22, 23, 23, 24, 24, 25, 26,
+	27, 27, 28, 29, 29, 30, 31, 32,
+	33, 33, 34, 35, 36, 37, 38, 39,
+	40, 41, 42, 42, 43, 44, 46, 47,
+	48, 49, 50, 51, 52, 53, 54, 56,
+	57, 58, 59, 61, 62, 63, 64, 66,
+	67, 69, 70, 71, 73, 74, 76, 77,
+	79, 80, 82, 83, 85, 87, 88, 90,
+	92, 94, 95, 97, 99, 101, 103, 104,
+	106, 108, 110, 112, 114, 116, 118, 120,
+	122, 125, 127, 129, 131, 133, 136, 138,
+	140, 143, 145, 147, 150, 152, 155, 157,
+	160, 162, 165, 168, 170, 173, 176, 179,
+	181, 184, 187, 190, 193, 196, 199, 202,
+	205, 208, 211, 214, 218, 221, 224, 227,
+	231, 234, 237, 241, 244, 248, 251, 255,
+};
+
+static const u16 xgamma8_37[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 3, 3,
+	3, 4, 4, 4, 4, 4, 5, 5,
+	5, 5, 5, 6, 6, 6, 6, 7,
+	7, 7, 7, 8, 8, 8, 9, 9,
+	9, 10, 10, 10, 11, 11, 11, 12,
+	12, 13, 13, 13, 14, 14, 15, 15,
+	16, 16, 17, 17, 18, 18, 19, 19,
+	20, 20, 21, 22, 22, 23, 24, 24,
+	25, 26, 26, 27, 28, 28, 29, 30,
+	31, 32, 32, 33, 34, 35, 36, 37,
+	38, 39, 39, 40, 41, 42, 43, 44,
+	45, 47, 48, 49, 50, 51, 52, 53,
+	54, 56, 57, 58, 59, 61, 62, 63,
+	65, 66, 67, 69, 70, 72, 73, 75,
+	76, 78, 79, 81, 83, 84, 86, 88,
+	89, 91, 93, 95, 96, 98, 100, 102,
+	104, 106, 108, 110, 112, 114, 116, 118,
+	120, 122, 124, 127, 129, 131, 133, 136,
+	138, 140, 143, 145, 148, 150, 153, 155,
+	158, 160, 163, 166, 169, 171, 174, 177,
+	180, 183, 186, 188, 191, 194, 198, 201,
+	204, 207, 210, 213, 217, 220, 223, 227,
+	230, 233, 237, 241, 244, 248, 251, 255,
+};
+
+static const u16 xgamma8_38[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4,
+	4, 5, 5, 5, 5, 6, 6, 6,
+	6, 6, 7, 7, 7, 8, 8, 8,
+	8, 9, 9, 9, 10, 10, 10, 11,
+	11, 12, 12, 12, 13, 13, 14, 14,
+	15, 15, 15, 16, 16, 17, 18, 18,
+	19, 19, 20, 20, 21, 21, 22, 23,
+	23, 24, 25, 25, 26, 27, 28, 28,
+	29, 30, 31, 31, 32, 33, 34, 35,
+	36, 37, 38, 38, 39, 40, 41, 42,
+	43, 44, 45, 47, 48, 49, 50, 51,
+	52, 53, 55, 56, 57, 58, 60, 61,
+	62, 64, 65, 66, 68, 69, 71, 72,
+	74, 75, 77, 78, 80, 82, 83, 85,
+	87, 88, 90, 92, 94, 96, 98, 99,
+	101, 103, 105, 107, 109, 111, 113, 115,
+	118, 120, 122, 124, 126, 129, 131, 133,
+	136, 138, 141, 143, 146, 148, 151, 153,
+	156, 158, 161, 164, 167, 169, 172, 175,
+	178, 181, 184, 187, 190, 193, 196, 199,
+	203, 206, 209, 212, 216, 219, 222, 226,
+	229, 233, 237, 240, 244, 247, 251, 255,
+};
+
+static const u16 xgamma8_39[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 3, 3,
+	3, 3, 3, 3, 3, 4, 4, 4,
+	4, 4, 4, 5, 5, 5, 5, 5,
+	6, 6, 6, 6, 7, 7, 7, 7,
+	8, 8, 8, 9, 9, 9, 10, 10,
+	10, 11, 11, 11, 12, 12, 13, 13,
+	13, 14, 14, 15, 15, 16, 16, 17,
+	17, 18, 18, 19, 20, 20, 21, 21,
+	22, 23, 23, 24, 25, 25, 26, 27,
+	27, 28, 29, 30, 31, 31, 32, 33,
+	34, 35, 36, 37, 38, 38, 39, 40,
+	41, 42, 43, 45, 46, 47, 48, 49,
+	50, 51, 52, 54, 55, 56, 57, 59,
+	60, 61, 63, 64, 66, 67, 68, 70,
+	71, 73, 74, 76, 78, 79, 81, 83,
+	84, 86, 88, 90, 91, 93, 95, 97,
+	99, 101, 103, 105, 107, 109, 111, 113,
+	115, 117, 120, 122, 124, 126, 129, 131,
+	133, 136, 138, 141, 143, 146, 149, 151,
+	154, 157, 159, 162, 165, 168, 171, 173,
+	176, 179, 182, 185, 189, 192, 195, 198,
+	201, 205, 208, 211, 215, 218, 222, 225,
+	229, 232, 236, 240, 243, 247, 251, 255,
+};
+
+static const u16 xgamma8_40[GAMMA8_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 2, 2, 2,
+	2, 3, 3, 3, 3, 3, 3, 3,
+	4, 4, 4, 4, 4, 5, 5, 5,
+	5, 5, 6, 6, 6, 6, 7, 7,
+	7, 7, 8, 8, 8, 9, 9, 9,
+	9, 10, 10, 11, 11, 11, 12, 12,
+	13, 13, 13, 14, 14, 15, 15, 16,
+	16, 17, 17, 18, 18, 19, 19, 20,
+	21, 21, 22, 23, 23, 24, 25, 25,
+	26, 27, 27, 28, 29, 30, 31, 31,
+	32, 33, 34, 35, 36, 37, 38, 39,
+	40, 41, 42, 43, 44, 45, 46, 47,
+	48, 49, 50, 52, 53, 54, 55, 57,
+	58, 59, 61, 62, 63, 65, 66, 68,
+	69, 71, 72, 74, 75, 77, 79, 80,
+	82, 84, 85, 87, 89, 91, 93, 95,
+	96, 98, 100, 102, 104, 107, 109, 111,
+	113, 115, 117, 120, 122, 124, 126, 129,
+	131, 134, 136, 139, 141, 144, 146, 149,
+	152, 155, 157, 160, 163, 166, 169, 172,
+	175, 178, 181, 184, 187, 190, 194, 197,
+	200, 203, 207, 210, 214, 217, 221, 224,
+	228, 232, 236, 239, 243, 247, 251, 255,
+};
+
+static const u16 *xgamma8_curves[GAMMA_CURVE_LENGTH] =  {
+	&xgamma8_01[0],
+	&xgamma8_02[0],
+	&xgamma8_03[0],
+	&xgamma8_04[0],
+	&xgamma8_05[0],
+	&xgamma8_06[0],
+	&xgamma8_07[0],
+	&xgamma8_08[0],
+	&xgamma8_09[0],
+	&xgamma8_10[0],
+	&xgamma8_11[0],
+	&xgamma8_12[0],
+	&xgamma8_13[0],
+	&xgamma8_14[0],
+	&xgamma8_15[0],
+	&xgamma8_16[0],
+	&xgamma8_17[0],
+	&xgamma8_18[0],
+	&xgamma8_19[0],
+	&xgamma8_20[0],
+	&xgamma8_21[0],
+	&xgamma8_22[0],
+	&xgamma8_23[0],
+	&xgamma8_24[0],
+	&xgamma8_25[0],
+	&xgamma8_26[0],
+	&xgamma8_27[0],
+	&xgamma8_28[0],
+	&xgamma8_29[0],
+	&xgamma8_30[0],
+	&xgamma8_31[0],
+	&xgamma8_32[0],
+	&xgamma8_33[0],
+	&xgamma8_34[0],
+	&xgamma8_35[0],
+	&xgamma8_36[0],
+	&xgamma8_37[0],
+	&xgamma8_38[0],
+	&xgamma8_39[0],
+	&xgamma8_40[0],
+};
+
+#define GAMMA_BPC_10		(10)
+#define GAMMA10_TABLE_LENGTH	BIT(GAMMA_BPC_10)
+static const u16 xgamma10_01[GAMMA10_TABLE_LENGTH] = {
+	0, 512, 548, 571, 588, 601, 612, 621, 630, 637, 644,
+	650, 656, 661, 666, 671, 675, 679, 683, 687, 690, 694,
+	697, 700, 703, 706, 709, 711, 714, 716, 719, 721, 723,
+	726, 728, 730, 732, 734, 736, 738, 740, 742, 743, 745,
+	747, 749, 750, 752, 753, 755, 756, 758, 759, 761, 762,
+	764, 765, 766, 768, 769, 770, 772, 773, 774, 775, 777,
+	778, 779, 780, 781, 782, 783, 785, 786, 787, 788, 789,
+	790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800,
+	800, 801, 802, 803, 804, 805, 806, 807, 807, 808, 809,
+	810, 811, 812, 812, 813, 814, 815, 815, 816, 817, 818,
+	819, 819, 820, 821, 821, 822, 823, 824, 824, 825, 826,
+	826, 827, 828, 828, 829, 830, 830, 831, 832, 832, 833,
+	834, 834, 835, 835, 836, 837, 837, 838, 838, 839, 840,
+	840, 841, 841, 842, 843, 843, 844, 844, 845, 845, 846,
+	847, 847, 848, 848, 849, 849, 850, 850, 851, 851, 852,
+	852, 853, 853, 854, 854, 855, 855, 856, 856, 857, 857,
+	858, 858, 859, 859, 860, 860, 861, 861, 862, 862, 863,
+	863, 864, 864, 864, 865, 865, 866, 866, 867, 867, 868,
+	868, 869, 869, 869, 870, 870, 871, 871, 872, 872, 872,
+	873, 873, 874, 874, 874, 875, 875, 876, 876, 876, 877,
+	877, 878, 878, 878, 879, 879, 880, 880, 880, 881, 881,
+	882, 882, 882, 883, 883, 883, 884, 884, 885, 885, 885,
+	886, 886, 886, 887, 887, 887, 888, 888, 889, 889, 889,
+	890, 890, 890, 891, 891, 891, 892, 892, 892, 893, 893,
+	893, 894, 894, 894, 895, 895, 895, 896, 896, 896, 897,
+	897, 897, 898, 898, 898, 899, 899, 899, 900, 900, 900,
+	901, 901, 901, 902, 902, 902, 902, 903, 903, 903, 904,
+	904, 904, 905, 905, 905, 906, 906, 906, 906, 907, 907,
+	907, 908, 908, 908, 908, 909, 909, 909, 910, 910, 910,
+	910, 911, 911, 911, 912, 912, 912, 912, 913, 913, 913,
+	914, 914, 914, 914, 915, 915, 915, 915, 916, 916, 916,
+	917, 917, 917, 917, 918, 918, 918, 918, 919, 919, 919,
+	919, 920, 920, 920, 921, 921, 921, 921, 922, 922, 922,
+	922, 923, 923, 923, 923, 924, 924, 924, 924, 925, 925,
+	925, 925, 926, 926, 926, 926, 927, 927, 927, 927, 928,
+	928, 928, 928, 928, 929, 929, 929, 929, 930, 930, 930,
+	930, 931, 931, 931, 931, 932, 932, 932, 932, 932, 933,
+	933, 933, 933, 934, 934, 934, 934, 935, 935, 935, 935,
+	935, 936, 936, 936, 936, 937, 937, 937, 937, 937, 938,
+	938, 938, 938, 939, 939, 939, 939, 939, 940, 940, 940,
+	940, 940, 941, 941, 941, 941, 942, 942, 942, 942, 942,
+	943, 943, 943, 943, 943, 944, 944, 944, 944, 944, 945,
+	945, 945, 945, 945, 946, 946, 946, 946, 946, 947, 947,
+	947, 947, 947, 948, 948, 948, 948, 948, 949, 949, 949,
+	949, 949, 950, 950, 950, 950, 950, 951, 951, 951, 951,
+	951, 952, 952, 952, 952, 952, 953, 953, 953, 953, 953,
+	953, 954, 954, 954, 954, 954, 955, 955, 955, 955, 955,
+	956, 956, 956, 956, 956, 956, 957, 957, 957, 957, 957,
+	958, 958, 958, 958, 958, 958, 959, 959, 959, 959, 959,
+	960, 960, 960, 960, 960, 960, 961, 961, 961, 961, 961,
+	961, 962, 962, 962, 962, 962, 962, 963, 963, 963, 963,
+	963, 964, 964, 964, 964, 964, 964, 965, 965, 965, 965,
+	965, 965, 966, 966, 966, 966, 966, 966, 967, 967, 967,
+	967, 967, 967, 968, 968, 968, 968, 968, 968, 969, 969,
+	969, 969, 969, 969, 970, 970, 970, 970, 970, 970, 970,
+	971, 971, 971, 971, 971, 971, 972, 972, 972, 972, 972,
+	972, 973, 973, 973, 973, 973, 973, 974, 974, 974, 974,
+	974, 974, 974, 975, 975, 975, 975, 975, 975, 976, 976,
+	976, 976, 976, 976, 976, 977, 977, 977, 977, 977, 977,
+	977, 978, 978, 978, 978, 978, 978, 979, 979, 979, 979,
+	979, 979, 979, 980, 980, 980, 980, 980, 980, 980, 981,
+	981, 981, 981, 981, 981, 981, 982, 982, 982, 982, 982,
+	982, 982, 983, 983, 983, 983, 983, 983, 983, 984, 984,
+	984, 984, 984, 984, 984, 985, 985, 985, 985, 985, 985,
+	985, 986, 986, 986, 986, 986, 986, 986, 987, 987, 987,
+	987, 987, 987, 987, 988, 988, 988, 988, 988, 988, 988,
+	989, 989, 989, 989, 989, 989, 989, 989, 990, 990, 990,
+	990, 990, 990, 990, 991, 991, 991, 991, 991, 991, 991,
+	991, 992, 992, 992, 992, 992, 992, 992, 993, 993, 993,
+	993, 993, 993, 993, 993, 994, 994, 994, 994, 994, 994,
+	994, 994, 995, 995, 995, 995, 995, 995, 995, 996, 996,
+	996, 996, 996, 996, 996, 996, 997, 997, 997, 997, 997,
+	997, 997, 997, 998, 998, 998, 998, 998, 998, 998, 998,
+	999, 999, 999, 999, 999, 999, 999, 999, 1000, 1000, 1000,
+	1000, 1000, 1000, 1000, 1000, 1000, 1001, 1001, 1001, 1001, 1001,
+	1001, 1001, 1001, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002,
+	1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1004, 1004, 1004,
+	1004, 1004, 1004, 1004, 1004, 1004, 1005, 1005, 1005, 1005, 1005,
+	1005, 1005, 1005, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006,
+	1006, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1008,
+	1008, 1008, 1008, 1008, 1008, 1008, 1008, 1009, 1009, 1009, 1009,
+	1009, 1009, 1009, 1009, 1009, 1010, 1010, 1010, 1010, 1010, 1010,
+	1010, 1010, 1010, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011,
+	1011, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1013,
+	1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1014, 1014, 1014,
+	1014, 1014, 1014, 1014, 1014, 1014, 1014, 1015, 1015, 1015, 1015,
+	1015, 1015, 1015, 1015, 1015, 1016, 1016, 1016, 1016, 1016, 1016,
+	1016, 1016, 1016, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017,
+	1017, 1017, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018,
+	1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1020,
+	1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1021, 1021,
+	1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1023, 1023, 1023, 1023,
+	1023,
+};
+
+static const u16 xgamma10_02[GAMMA10_TABLE_LENGTH] = {
+	0, 256, 294, 319, 338, 353, 366, 378, 388, 397, 405,
+	413, 420, 427, 434, 440, 445, 451, 456, 461, 466, 470,
+	475, 479, 483, 487, 491, 495, 498, 502, 505, 508, 512,
+	515, 518, 521, 524, 527, 529, 532, 535, 538, 540, 543,
+	545, 548, 550, 552, 555, 557, 559, 562, 564, 566, 568,
+	570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 589,
+	591, 593, 595, 597, 598, 600, 602, 603, 605, 607, 608,
+	610, 611, 613, 614, 616, 618, 619, 621, 622, 623, 625,
+	626, 628, 629, 631, 632, 633, 635, 636, 637, 639, 640,
+	641, 643, 644, 645, 646, 648, 649, 650, 651, 653, 654,
+	655, 656, 657, 658, 660, 661, 662, 663, 664, 665, 666,
+	668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678,
+	679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689,
+	690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700,
+	700, 701, 702, 703, 704, 705, 706, 707, 708, 708, 709,
+	710, 711, 712, 713, 714, 714, 715, 716, 717, 718, 719,
+	719, 720, 721, 722, 723, 723, 724, 725, 726, 727, 727,
+	728, 729, 730, 731, 731, 732, 733, 734, 734, 735, 736,
+	737, 737, 738, 739, 740, 740, 741, 742, 742, 743, 744,
+	745, 745, 746, 747, 747, 748, 749, 750, 750, 751, 752,
+	752, 753, 754, 754, 755, 756, 756, 757, 758, 758, 759,
+	760, 760, 761, 762, 762, 763, 764, 764, 765, 765, 766,
+	767, 767, 768, 769, 769, 770, 771, 771, 772, 772, 773,
+	774, 774, 775, 775, 776, 777, 777, 778, 778, 779, 780,
+	780, 781, 781, 782, 783, 783, 784, 784, 785, 785, 786,
+	787, 787, 788, 788, 789, 789, 790, 791, 791, 792, 792,
+	793, 793, 794, 794, 795, 796, 796, 797, 797, 798, 798,
+	799, 799, 800, 800, 801, 801, 802, 803, 803, 804, 804,
+	805, 805, 806, 806, 807, 807, 808, 808, 809, 809, 810,
+	810, 811, 811, 812, 812, 813, 813, 814, 814, 815, 815,
+	816, 816, 817, 817, 818, 818, 819, 819, 820, 820, 821,
+	821, 822, 822, 823, 823, 824, 824, 825, 825, 825, 826,
+	826, 827, 827, 828, 828, 829, 829, 830, 830, 831, 831,
+	832, 832, 832, 833, 833, 834, 834, 835, 835, 836, 836,
+	837, 837, 837, 838, 838, 839, 839, 840, 840, 841, 841,
+	841, 842, 842, 843, 843, 844, 844, 844, 845, 845, 846,
+	846, 847, 847, 847, 848, 848, 849, 849, 850, 850, 850,
+	851, 851, 852, 852, 852, 853, 853, 854, 854, 855, 855,
+	855, 856, 856, 857, 857, 857, 858, 858, 859, 859, 859,
+	860, 860, 861, 861, 861, 862, 862, 863, 863, 863, 864,
+	864, 865, 865, 865, 866, 866, 866, 867, 867, 868, 868,
+	868, 869, 869, 870, 870, 870, 871, 871, 871, 872, 872,
+	873, 873, 873, 874, 874, 875, 875, 875, 876, 876, 876,
+	877, 877, 877, 878, 878, 879, 879, 879, 880, 880, 880,
+	881, 881, 882, 882, 882, 883, 883, 883, 884, 884, 884,
+	885, 885, 885, 886, 886, 887, 887, 887, 888, 888, 888,
+	889, 889, 889, 890, 890, 890, 891, 891, 891, 892, 892,
+	892, 893, 893, 894, 894, 894, 895, 895, 895, 896, 896,
+	896, 897, 897, 897, 898, 898, 898, 899, 899, 899, 900,
+	900, 900, 901, 901, 901, 902, 902, 902, 903, 903, 903,
+	904, 904, 904, 905, 905, 905, 906, 906, 906, 907, 907,
+	907, 908, 908, 908, 908, 909, 909, 909, 910, 910, 910,
+	911, 911, 911, 912, 912, 912, 913, 913, 913, 914, 914,
+	914, 914, 915, 915, 915, 916, 916, 916, 917, 917, 917,
+	918, 918, 918, 919, 919, 919, 919, 920, 920, 920, 921,
+	921, 921, 922, 922, 922, 923, 923, 923, 923, 924, 924,
+	924, 925, 925, 925, 926, 926, 926, 926, 927, 927, 927,
+	928, 928, 928, 928, 929, 929, 929, 930, 930, 930, 931,
+	931, 931, 931, 932, 932, 932, 933, 933, 933, 933, 934,
+	934, 934, 935, 935, 935, 935, 936, 936, 936, 937, 937,
+	937, 937, 938, 938, 938, 939, 939, 939, 939, 940, 940,
+	940, 941, 941, 941, 941, 942, 942, 942, 942, 943, 943,
+	943, 944, 944, 944, 944, 945, 945, 945, 946, 946, 946,
+	946, 947, 947, 947, 947, 948, 948, 948, 949, 949, 949,
+	949, 950, 950, 950, 950, 951, 951, 951, 951, 952, 952,
+	952, 953, 953, 953, 953, 954, 954, 954, 954, 955, 955,
+	955, 955, 956, 956, 956, 956, 957, 957, 957, 958, 958,
+	958, 958, 959, 959, 959, 959, 960, 960, 960, 960, 961,
+	961, 961, 961, 962, 962, 962, 962, 963, 963, 963, 963,
+	964, 964, 964, 964, 965, 965, 965, 965, 966, 966, 966,
+	966, 967, 967, 967, 967, 968, 968, 968, 968, 969, 969,
+	969, 969, 970, 970, 970, 970, 971, 971, 971, 971, 972,
+	972, 972, 972, 973, 973, 973, 973, 974, 974, 974, 974,
+	975, 975, 975, 975, 976, 976, 976, 976, 977, 977, 977,
+	977, 978, 978, 978, 978, 978, 979, 979, 979, 979, 980,
+	980, 980, 980, 981, 981, 981, 981, 982, 982, 982, 982,
+	983, 983, 983, 983, 983, 984, 984, 984, 984, 985, 985,
+	985, 985, 986, 986, 986, 986, 986, 987, 987, 987, 987,
+	988, 988, 988, 988, 989, 989, 989, 989, 989, 990, 990,
+	990, 990, 991, 991, 991, 991, 992, 992, 992, 992, 992,
+	993, 993, 993, 993, 994, 994, 994, 994, 994, 995, 995,
+	995, 995, 996, 996, 996, 996, 996, 997, 997, 997, 997,
+	998, 998, 998, 998, 998, 999, 999, 999, 999, 1000, 1000,
+	1000, 1000, 1000, 1001, 1001, 1001, 1001, 1002, 1002, 1002, 1002,
+	1002, 1003, 1003, 1003, 1003, 1003, 1004, 1004, 1004, 1004, 1005,
+	1005, 1005, 1005, 1005, 1006, 1006, 1006, 1006, 1006, 1007, 1007,
+	1007, 1007, 1008, 1008, 1008, 1008, 1008, 1009, 1009, 1009, 1009,
+	1009, 1010, 1010, 1010, 1010, 1010, 1011, 1011, 1011, 1011, 1012,
+	1012, 1012, 1012, 1012, 1013, 1013, 1013, 1013, 1013, 1014, 1014,
+	1014, 1014, 1014, 1015, 1015, 1015, 1015, 1015, 1016, 1016, 1016,
+	1016, 1017, 1017, 1017, 1017, 1017, 1018, 1018, 1018, 1018, 1018,
+	1019, 1019, 1019, 1019, 1019, 1020, 1020, 1020, 1020, 1020, 1021,
+	1021, 1021, 1021, 1021, 1022, 1022, 1022, 1022, 1022, 1023, 1023,
+	1023,
+};
+
+static const u16 xgamma10_03[GAMMA10_TABLE_LENGTH] = {
+	0, 128, 157, 178, 194, 207, 219, 229, 239, 247, 255,
+	263, 270, 276, 282, 288, 294, 299, 304, 309, 314, 319,
+	323, 328, 332, 336, 340, 344, 348, 351, 355, 358, 362,
+	365, 368, 372, 375, 378, 381, 384, 387, 390, 393, 395,
+	398, 401, 403, 406, 409, 411, 414, 416, 419, 421, 423,
+	426, 428, 430, 432, 435, 437, 439, 441, 443, 445, 447,
+	450, 452, 454, 456, 458, 460, 461, 463, 465, 467, 469,
+	471, 473, 474, 476, 478, 480, 482, 483, 485, 487, 488,
+	490, 492, 493, 495, 497, 498, 500, 501, 503, 505, 506,
+	508, 509, 511, 512, 514, 515, 517, 518, 520, 521, 523,
+	524, 525, 527, 528, 530, 531, 532, 534, 535, 537, 538,
+	539, 541, 542, 543, 544, 546, 547, 548, 550, 551, 552,
+	553, 555, 556, 557, 558, 560, 561, 562, 563, 565, 566,
+	567, 568, 569, 570, 572, 573, 574, 575, 576, 577, 579,
+	580, 581, 582, 583, 584, 585, 586, 587, 589, 590, 591,
+	592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602,
+	603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613,
+	614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624,
+	625, 626, 627, 628, 629, 630, 631, 632, 633, 633, 634,
+	635, 636, 637, 638, 639, 640, 641, 642, 642, 643, 644,
+	645, 646, 647, 648, 649, 649, 650, 651, 652, 653, 654,
+	655, 655, 656, 657, 658, 659, 660, 661, 661, 662, 663,
+	664, 665, 665, 666, 667, 668, 669, 670, 670, 671, 672,
+	673, 674, 674, 675, 676, 677, 677, 678, 679, 680, 681,
+	681, 682, 683, 684, 684, 685, 686, 687, 688, 688, 689,
+	690, 691, 691, 692, 693, 694, 694, 695, 696, 696, 697,
+	698, 699, 699, 700, 701, 702, 702, 703, 704, 704, 705,
+	706, 707, 707, 708, 709, 709, 710, 711, 712, 712, 713,
+	714, 714, 715, 716, 716, 717, 718, 718, 719, 720, 721,
+	721, 722, 723, 723, 724, 725, 725, 726, 727, 727, 728,
+	729, 729, 730, 731, 731, 732, 733, 733, 734, 734, 735,
+	736, 736, 737, 738, 738, 739, 740, 740, 741, 742, 742,
+	743, 743, 744, 745, 745, 746, 747, 747, 748, 748, 749,
+	750, 750, 751, 752, 752, 753, 753, 754, 755, 755, 756,
+	756, 757, 758, 758, 759, 759, 760, 761, 761, 762, 762,
+	763, 764, 764, 765, 765, 766, 767, 767, 768, 768, 769,
+	770, 770, 771, 771, 772, 772, 773, 774, 774, 775, 775,
+	776, 776, 777, 778, 778, 779, 779, 780, 780, 781, 782,
+	782, 783, 783, 784, 784, 785, 785, 786, 787, 787, 788,
+	788, 789, 789, 790, 790, 791, 792, 792, 793, 793, 794,
+	794, 795, 795, 796, 796, 797, 797, 798, 799, 799, 800,
+	800, 801, 801, 802, 802, 803, 803, 804, 804, 805, 805,
+	806, 806, 807, 808, 808, 809, 809, 810, 810, 811, 811,
+	812, 812, 813, 813, 814, 814, 815, 815, 816, 816, 817,
+	817, 818, 818, 819, 819, 820, 820, 821, 821, 822, 822,
+	823, 823, 824, 824, 825, 825, 826, 826, 827, 827, 828,
+	828, 829, 829, 830, 830, 831, 831, 832, 832, 833, 833,
+	834, 834, 835, 835, 836, 836, 836, 837, 837, 838, 838,
+	839, 839, 840, 840, 841, 841, 842, 842, 843, 843, 844,
+	844, 845, 845, 845, 846, 846, 847, 847, 848, 848, 849,
+	849, 850, 850, 851, 851, 852, 852, 852, 853, 853, 854,
+	854, 855, 855, 856, 856, 857, 857, 857, 858, 858, 859,
+	859, 860, 860, 861, 861, 862, 862, 862, 863, 863, 864,
+	864, 865, 865, 866, 866, 866, 867, 867, 868, 868, 869,
+	869, 869, 870, 870, 871, 871, 872, 872, 873, 873, 873,
+	874, 874, 875, 875, 876, 876, 876, 877, 877, 878, 878,
+	879, 879, 879, 880, 880, 881, 881, 882, 882, 882, 883,
+	883, 884, 884, 885, 885, 885, 886, 886, 887, 887, 887,
+	888, 888, 889, 889, 890, 890, 890, 891, 891, 892, 892,
+	892, 893, 893, 894, 894, 895, 895, 895, 896, 896, 897,
+	897, 897, 898, 898, 899, 899, 899, 900, 900, 901, 901,
+	901, 902, 902, 903, 903, 903, 904, 904, 905, 905, 905,
+	906, 906, 907, 907, 907, 908, 908, 909, 909, 909, 910,
+	910, 911, 911, 911, 912, 912, 913, 913, 913, 914, 914,
+	915, 915, 915, 916, 916, 916, 917, 917, 918, 918, 918,
+	919, 919, 920, 920, 920, 921, 921, 921, 922, 922, 923,
+	923, 923, 924, 924, 925, 925, 925, 926, 926, 926, 927,
+	927, 928, 928, 928, 929, 929, 929, 930, 930, 931, 931,
+	931, 932, 932, 932, 933, 933, 934, 934, 934, 935, 935,
+	935, 936, 936, 936, 937, 937, 938, 938, 938, 939, 939,
+	939, 940, 940, 941, 941, 941, 942, 942, 942, 943, 943,
+	943, 944, 944, 945, 945, 945, 946, 946, 946, 947, 947,
+	947, 948, 948, 948, 949, 949, 950, 950, 950, 951, 951,
+	951, 952, 952, 952, 953, 953, 953, 954, 954, 955, 955,
+	955, 956, 956, 956, 957, 957, 957, 958, 958, 958, 959,
+	959, 959, 960, 960, 960, 961, 961, 962, 962, 962, 963,
+	963, 963, 964, 964, 964, 965, 965, 965, 966, 966, 966,
+	967, 967, 967, 968, 968, 968, 969, 969, 969, 970, 970,
+	970, 971, 971, 971, 972, 972, 972, 973, 973, 973, 974,
+	974, 974, 975, 975, 975, 976, 976, 976, 977, 977, 977,
+	978, 978, 978, 979, 979, 979, 980, 980, 980, 981, 981,
+	981, 982, 982, 982, 983, 983, 983, 984, 984, 984, 985,
+	985, 985, 986, 986, 986, 987, 987, 987, 988, 988, 988,
+	989, 989, 989, 990, 990, 990, 991, 991, 991, 992, 992,
+	992, 993, 993, 993, 994, 994, 994, 994, 995, 995, 995,
+	996, 996, 996, 997, 997, 997, 998, 998, 998, 999, 999,
+	999, 1000, 1000, 1000, 1001, 1001, 1001, 1001, 1002, 1002, 1002,
+	1003, 1003, 1003, 1004, 1004, 1004, 1005, 1005, 1005, 1006, 1006,
+	1006, 1006, 1007, 1007, 1007, 1008, 1008, 1008, 1009, 1009, 1009,
+	1010, 1010, 1010, 1011, 1011, 1011, 1011, 1012, 1012, 1012, 1013,
+	1013, 1013, 1014, 1014, 1014, 1015, 1015, 1015, 1015, 1016, 1016,
+	1016, 1017, 1017, 1017, 1018, 1018, 1018, 1018, 1019, 1019, 1019,
+	1020, 1020, 1020, 1021, 1021, 1021, 1021, 1022, 1022, 1022, 1023,
+	1023,
+};
+
+static const u16 xgamma10_04[GAMMA10_TABLE_LENGTH] = {
+	0, 64, 84, 99, 111, 122, 131, 139, 147, 154, 161,
+	167, 173, 178, 184, 189, 194, 199, 203, 208, 212, 216,
+	220, 224, 228, 232, 235, 239, 243, 246, 249, 253, 256,
+	259, 262, 265, 268, 271, 274, 277, 280, 283, 285, 288,
+	291, 293, 296, 298, 301, 303, 306, 308, 311, 313, 315,
+	318, 320, 322, 325, 327, 329, 331, 333, 335, 338, 340,
+	342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362,
+	364, 365, 367, 369, 371, 373, 375, 376, 378, 380, 382,
+	383, 385, 387, 389, 390, 392, 394, 395, 397, 399, 400,
+	402, 404, 405, 407, 408, 410, 412, 413, 415, 416, 418,
+	419, 421, 422, 424, 425, 427, 428, 430, 431, 433, 434,
+	436, 437, 438, 440, 441, 443, 444, 445, 447, 448, 450,
+	451, 452, 454, 455, 456, 458, 459, 460, 462, 463, 464,
+	466, 467, 468, 470, 471, 472, 473, 475, 476, 477, 478,
+	480, 481, 482, 483, 485, 486, 487, 488, 489, 491, 492,
+	493, 494, 495, 497, 498, 499, 500, 501, 503, 504, 505,
+	506, 507, 508, 509, 511, 512, 513, 514, 515, 516, 517,
+	518, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529,
+	530, 531, 533, 534, 535, 536, 537, 538, 539, 540, 541,
+	542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552,
+	553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563,
+	564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574,
+	575, 576, 577, 578, 578, 579, 580, 581, 582, 583, 584,
+	585, 586, 587, 588, 589, 590, 591, 591, 592, 593, 594,
+	595, 596, 597, 598, 599, 600, 600, 601, 602, 603, 604,
+	605, 606, 607, 607, 608, 609, 610, 611, 612, 613, 614,
+	614, 615, 616, 617, 618, 619, 620, 620, 621, 622, 623,
+	624, 625, 625, 626, 627, 628, 629, 630, 630, 631, 632,
+	633, 634, 635, 635, 636, 637, 638, 639, 639, 640, 641,
+	642, 643, 643, 644, 645, 646, 647, 647, 648, 649, 650,
+	651, 651, 652, 653, 654, 655, 655, 656, 657, 658, 658,
+	659, 660, 661, 662, 662, 663, 664, 665, 665, 666, 667,
+	668, 668, 669, 670, 671, 671, 672, 673, 674, 674, 675,
+	676, 677, 677, 678, 679, 680, 680, 681, 682, 683, 683,
+	684, 685, 685, 686, 687, 688, 688, 689, 690, 691, 691,
+	692, 693, 693, 694, 695, 696, 696, 697, 698, 698, 699,
+	700, 701, 701, 702, 703, 703, 704, 705, 705, 706, 707,
+	708, 708, 709, 710, 710, 711, 712, 712, 713, 714, 714,
+	715, 716, 717, 717, 718, 719, 719, 720, 721, 721, 722,
+	723, 723, 724, 725, 725, 726, 727, 727, 728, 729, 729,
+	730, 731, 731, 732, 733, 733, 734, 735, 735, 736, 737,
+	737, 738, 739, 739, 740, 740, 741, 742, 742, 743, 744,
+	744, 745, 746, 746, 747, 748, 748, 749, 749, 750, 751,
+	751, 752, 753, 753, 754, 755, 755, 756, 756, 757, 758,
+	758, 759, 760, 760, 761, 761, 762, 763, 763, 764, 765,
+	765, 766, 766, 767, 768, 768, 769, 769, 770, 771, 771,
+	772, 773, 773, 774, 774, 775, 776, 776, 777, 777, 778,
+	779, 779, 780, 780, 781, 782, 782, 783, 783, 784, 785,
+	785, 786, 786, 787, 788, 788, 789, 789, 790, 791, 791,
+	792, 792, 793, 793, 794, 795, 795, 796, 796, 797, 798,
+	798, 799, 799, 800, 800, 801, 802, 802, 803, 803, 804,
+	804, 805, 806, 806, 807, 807, 808, 808, 809, 810, 810,
+	811, 811, 812, 812, 813, 814, 814, 815, 815, 816, 816,
+	817, 818, 818, 819, 819, 820, 820, 821, 821, 822, 823,
+	823, 824, 824, 825, 825, 826, 826, 827, 827, 828, 829,
+	829, 830, 830, 831, 831, 832, 832, 833, 834, 834, 835,
+	835, 836, 836, 837, 837, 838, 838, 839, 839, 840, 841,
+	841, 842, 842, 843, 843, 844, 844, 845, 845, 846, 846,
+	847, 847, 848, 849, 849, 850, 850, 851, 851, 852, 852,
+	853, 853, 854, 854, 855, 855, 856, 856, 857, 857, 858,
+	859, 859, 860, 860, 861, 861, 862, 862, 863, 863, 864,
+	864, 865, 865, 866, 866, 867, 867, 868, 868, 869, 869,
+	870, 870, 871, 871, 872, 872, 873, 873, 874, 874, 875,
+	875, 876, 876, 877, 877, 878, 878, 879, 879, 880, 880,
+	881, 881, 882, 882, 883, 883, 884, 884, 885, 885, 886,
+	886, 887, 887, 888, 888, 889, 889, 890, 890, 891, 891,
+	892, 892, 893, 893, 894, 894, 895, 895, 896, 896, 897,
+	897, 898, 898, 899, 899, 900, 900, 901, 901, 902, 902,
+	903, 903, 904, 904, 905, 905, 905, 906, 906, 907, 907,
+	908, 908, 909, 909, 910, 910, 911, 911, 912, 912, 913,
+	913, 914, 914, 915, 915, 915, 916, 916, 917, 917, 918,
+	918, 919, 919, 920, 920, 921, 921, 922, 922, 923, 923,
+	923, 924, 924, 925, 925, 926, 926, 927, 927, 928, 928,
+	929, 929, 929, 930, 930, 931, 931, 932, 932, 933, 933,
+	934, 934, 935, 935, 935, 936, 936, 937, 937, 938, 938,
+	939, 939, 940, 940, 940, 941, 941, 942, 942, 943, 943,
+	944, 944, 945, 945, 945, 946, 946, 947, 947, 948, 948,
+	949, 949, 949, 950, 950, 951, 951, 952, 952, 953, 953,
+	953, 954, 954, 955, 955, 956, 956, 957, 957, 957, 958,
+	958, 959, 959, 960, 960, 961, 961, 961, 962, 962, 963,
+	963, 964, 964, 965, 965, 965, 966, 966, 967, 967, 968,
+	968, 968, 969, 969, 970, 970, 971, 971, 971, 972, 972,
+	973, 973, 974, 974, 974, 975, 975, 976, 976, 977, 977,
+	977, 978, 978, 979, 979, 980, 980, 980, 981, 981, 982,
+	982, 983, 983, 983, 984, 984, 985, 985, 986, 986, 986,
+	987, 987, 988, 988, 989, 989, 989, 990, 990, 991, 991,
+	991, 992, 992, 993, 993, 994, 994, 994, 995, 995, 996,
+	996, 996, 997, 997, 998, 998, 999, 999, 999, 1000, 1000,
+	1001, 1001, 1001, 1002, 1002, 1003, 1003, 1004, 1004, 1004, 1005,
+	1005, 1006, 1006, 1006, 1007, 1007, 1008, 1008, 1008, 1009, 1009,
+	1010, 1010, 1010, 1011, 1011, 1012, 1012, 1013, 1013, 1013, 1014,
+	1014, 1015, 1015, 1015, 1016, 1016, 1017, 1017, 1017, 1018, 1018,
+	1019, 1019, 1019, 1020, 1020, 1021, 1021, 1021, 1022, 1022, 1023,
+	1023,
+};
+
+static const u16 xgamma10_05[GAMMA10_TABLE_LENGTH] = {
+	0, 32, 45, 55, 64, 72, 78, 85, 90, 96, 101,
+	106, 111, 115, 120, 124, 128, 132, 136, 139, 143, 147,
+	150, 153, 157, 160, 163, 166, 169, 172, 175, 178, 181,
+	184, 186, 189, 192, 195, 197, 200, 202, 205, 207, 210,
+	212, 215, 217, 219, 222, 224, 226, 228, 231, 233, 235,
+	237, 239, 241, 244, 246, 248, 250, 252, 254, 256, 258,
+	260, 262, 264, 266, 268, 270, 271, 273, 275, 277, 279,
+	281, 282, 284, 286, 288, 290, 291, 293, 295, 297, 298,
+	300, 302, 303, 305, 307, 308, 310, 312, 313, 315, 317,
+	318, 320, 321, 323, 325, 326, 328, 329, 331, 332, 334,
+	335, 337, 338, 340, 341, 343, 344, 346, 347, 349, 350,
+	352, 353, 355, 356, 358, 359, 360, 362, 363, 365, 366,
+	367, 369, 370, 372, 373, 374, 376, 377, 378, 380, 381,
+	382, 384, 385, 386, 388, 389, 390, 392, 393, 394, 396,
+	397, 398, 399, 401, 402, 403, 405, 406, 407, 408, 410,
+	411, 412, 413, 415, 416, 417, 418, 419, 421, 422, 423,
+	424, 426, 427, 428, 429, 430, 431, 433, 434, 435, 436,
+	437, 439, 440, 441, 442, 443, 444, 445, 447, 448, 449,
+	450, 451, 452, 453, 455, 456, 457, 458, 459, 460, 461,
+	462, 463, 465, 466, 467, 468, 469, 470, 471, 472, 473,
+	474, 475, 477, 478, 479, 480, 481, 482, 483, 484, 485,
+	486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 497,
+	498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508,
+	509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519,
+	520, 521, 522, 523, 524, 525, 526, 527, 527, 528, 529,
+	530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540,
+	541, 542, 543, 544, 545, 546, 547, 547, 548, 549, 550,
+	551, 552, 553, 554, 555, 556, 557, 558, 559, 559, 560,
+	561, 562, 563, 564, 565, 566, 567, 568, 569, 569, 570,
+	571, 572, 573, 574, 575, 576, 577, 577, 578, 579, 580,
+	581, 582, 583, 584, 585, 585, 586, 587, 588, 589, 590,
+	591, 591, 592, 593, 594, 595, 596, 597, 598, 598, 599,
+	600, 601, 602, 603, 603, 604, 605, 606, 607, 608, 609,
+	609, 610, 611, 612, 613, 614, 614, 615, 616, 617, 618,
+	619, 619, 620, 621, 622, 623, 623, 624, 625, 626, 627,
+	628, 628, 629, 630, 631, 632, 632, 633, 634, 635, 636,
+	636, 637, 638, 639, 640, 640, 641, 642, 643, 644, 644,
+	645, 646, 647, 648, 648, 649, 650, 651, 652, 652, 653,
+	654, 655, 655, 656, 657, 658, 659, 659, 660, 661, 662,
+	662, 663, 664, 665, 666, 666, 667, 668, 669, 669, 670,
+	671, 672, 672, 673, 674, 675, 675, 676, 677, 678, 678,
+	679, 680, 681, 681, 682, 683, 684, 684, 685, 686, 687,
+	687, 688, 689, 690, 690, 691, 692, 693, 693, 694, 695,
+	696, 696, 697, 698, 699, 699, 700, 701, 701, 702, 703,
+	704, 704, 705, 706, 707, 707, 708, 709, 709, 710, 711,
+	712, 712, 713, 714, 714, 715, 716, 717, 717, 718, 719,
+	719, 720, 721, 722, 722, 723, 724, 724, 725, 726, 727,
+	727, 728, 729, 729, 730, 731, 731, 732, 733, 734, 734,
+	735, 736, 736, 737, 738, 738, 739, 740, 740, 741, 742,
+	743, 743, 744, 745, 745, 746, 747, 747, 748, 749, 749,
+	750, 751, 751, 752, 753, 754, 754, 755, 756, 756, 757,
+	758, 758, 759, 760, 760, 761, 762, 762, 763, 764, 764,
+	765, 766, 766, 767, 768, 768, 769, 770, 770, 771, 772,
+	772, 773, 774, 774, 775, 776, 776, 777, 778, 778, 779,
+	780, 780, 781, 781, 782, 783, 783, 784, 785, 785, 786,
+	787, 787, 788, 789, 789, 790, 791, 791, 792, 793, 793,
+	794, 794, 795, 796, 796, 797, 798, 798, 799, 800, 800,
+	801, 802, 802, 803, 803, 804, 805, 805, 806, 807, 807,
+	808, 809, 809, 810, 810, 811, 812, 812, 813, 814, 814,
+	815, 815, 816, 817, 817, 818, 819, 819, 820, 820, 821,
+	822, 822, 823, 824, 824, 825, 825, 826, 827, 827, 828,
+	829, 829, 830, 830, 831, 832, 832, 833, 833, 834, 835,
+	835, 836, 836, 837, 838, 838, 839, 840, 840, 841, 841,
+	842, 843, 843, 844, 844, 845, 846, 846, 847, 847, 848,
+	849, 849, 850, 850, 851, 852, 852, 853, 853, 854, 855,
+	855, 856, 856, 857, 858, 858, 859, 859, 860, 861, 861,
+	862, 862, 863, 864, 864, 865, 865, 866, 867, 867, 868,
+	868, 869, 869, 870, 871, 871, 872, 872, 873, 874, 874,
+	875, 875, 876, 877, 877, 878, 878, 879, 879, 880, 881,
+	881, 882, 882, 883, 883, 884, 885, 885, 886, 886, 887,
+	888, 888, 889, 889, 890, 890, 891, 892, 892, 893, 893,
+	894, 894, 895, 896, 896, 897, 897, 898, 898, 899, 900,
+	900, 901, 901, 902, 902, 903, 904, 904, 905, 905, 906,
+	906, 907, 907, 908, 909, 909, 910, 910, 911, 911, 912,
+	913, 913, 914, 914, 915, 915, 916, 916, 917, 918, 918,
+	919, 919, 920, 920, 921, 921, 922, 923, 923, 924, 924,
+	925, 925, 926, 926, 927, 928, 928, 929, 929, 930, 930,
+	931, 931, 932, 932, 933, 934, 934, 935, 935, 936, 936,
+	937, 937, 938, 939, 939, 940, 940, 941, 941, 942, 942,
+	943, 943, 944, 944, 945, 946, 946, 947, 947, 948, 948,
+	949, 949, 950, 950, 951, 952, 952, 953, 953, 954, 954,
+	955, 955, 956, 956, 957, 957, 958, 958, 959, 960, 960,
+	961, 961, 962, 962, 963, 963, 964, 964, 965, 965, 966,
+	966, 967, 967, 968, 969, 969, 970, 970, 971, 971, 972,
+	972, 973, 973, 974, 974, 975, 975, 976, 976, 977, 977,
+	978, 979, 979, 980, 980, 981, 981, 982, 982, 983, 983,
+	984, 984, 985, 985, 986, 986, 987, 987, 988, 988, 989,
+	989, 990, 990, 991, 992, 992, 993, 993, 994, 994, 995,
+	995, 996, 996, 997, 997, 998, 998, 999, 999, 1000, 1000,
+	1001, 1001, 1002, 1002, 1003, 1003, 1004, 1004, 1005, 1005, 1006,
+	1006, 1007, 1007, 1008, 1008, 1009, 1009, 1010, 1010, 1011, 1011,
+	1012, 1012, 1013, 1013, 1014, 1014, 1015, 1015, 1016, 1016, 1017,
+	1017, 1018, 1018, 1019, 1019, 1020, 1020, 1021, 1021, 1022, 1022,
+	1023,
+};
+
+static const u16 xgamma10_06[GAMMA10_TABLE_LENGTH] = {
+	0, 16, 24, 31, 37, 42, 47, 51, 56, 60, 64,
+	67, 71, 75, 78, 81, 84, 88, 91, 94, 97, 99,
+	102, 105, 108, 110, 113, 116, 118, 121, 123, 126, 128,
+	130, 133, 135, 137, 140, 142, 144, 146, 148, 151, 153,
+	155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175,
+	177, 179, 181, 183, 185, 187, 188, 190, 192, 194, 196,
+	198, 199, 201, 203, 205, 206, 208, 210, 212, 213, 215,
+	217, 218, 220, 222, 223, 225, 227, 228, 230, 232, 233,
+	235, 236, 238, 240, 241, 243, 244, 246, 247, 249, 250,
+	252, 253, 255, 257, 258, 260, 261, 263, 264, 265, 267,
+	268, 270, 271, 273, 274, 276, 277, 279, 280, 281, 283,
+	284, 286, 287, 288, 290, 291, 293, 294, 295, 297, 298,
+	299, 301, 302, 303, 305, 306, 308, 309, 310, 312, 313,
+	314, 315, 317, 318, 319, 321, 322, 323, 325, 326, 327,
+	328, 330, 331, 332, 334, 335, 336, 337, 339, 340, 341,
+	342, 344, 345, 346, 347, 349, 350, 351, 352, 353, 355,
+	356, 357, 358, 359, 361, 362, 363, 364, 365, 367, 368,
+	369, 370, 371, 373, 374, 375, 376, 377, 378, 380, 381,
+	382, 383, 384, 385, 387, 388, 389, 390, 391, 392, 393,
+	394, 396, 397, 398, 399, 400, 401, 402, 403, 405, 406,
+	407, 408, 409, 410, 411, 412, 413, 415, 416, 417, 418,
+	419, 420, 421, 422, 423, 424, 425, 426, 428, 429, 430,
+	431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441,
+	442, 443, 445, 446, 447, 448, 449, 450, 451, 452, 453,
+	454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464,
+	465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475,
+	476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486,
+	487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497,
+	498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 507,
+	508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518,
+	519, 520, 521, 522, 523, 524, 525, 525, 526, 527, 528,
+	529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 538,
+	539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 548,
+	549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 558,
+	559, 560, 561, 562, 563, 564, 565, 566, 566, 567, 568,
+	569, 570, 571, 572, 573, 574, 574, 575, 576, 577, 578,
+	579, 580, 581, 581, 582, 583, 584, 585, 586, 587, 588,
+	588, 589, 590, 591, 592, 593, 594, 594, 595, 596, 597,
+	598, 599, 600, 601, 601, 602, 603, 604, 605, 606, 606,
+	607, 608, 609, 610, 611, 612, 612, 613, 614, 615, 616,
+	617, 617, 618, 619, 620, 621, 622, 622, 623, 624, 625,
+	626, 627, 627, 628, 629, 630, 631, 632, 632, 633, 634,
+	635, 636, 637, 637, 638, 639, 640, 641, 642, 642, 643,
+	644, 645, 646, 646, 647, 648, 649, 650, 650, 651, 652,
+	653, 654, 655, 655, 656, 657, 658, 659, 659, 660, 661,
+	662, 663, 663, 664, 665, 666, 667, 667, 668, 669, 670,
+	671, 671, 672, 673, 674, 675, 675, 676, 677, 678, 678,
+	679, 680, 681, 682, 682, 683, 684, 685, 686, 686, 687,
+	688, 689, 689, 690, 691, 692, 693, 693, 694, 695, 696,
+	696, 697, 698, 699, 700, 700, 701, 702, 703, 703, 704,
+	705, 706, 707, 707, 708, 709, 710, 710, 711, 712, 713,
+	713, 714, 715, 716, 716, 717, 718, 719, 719, 720, 721,
+	722, 723, 723, 724, 725, 726, 726, 727, 728, 729, 729,
+	730, 731, 732, 732, 733, 734, 735, 735, 736, 737, 738,
+	738, 739, 740, 741, 741, 742, 743, 743, 744, 745, 746,
+	746, 747, 748, 749, 749, 750, 751, 752, 752, 753, 754,
+	755, 755, 756, 757, 758, 758, 759, 760, 760, 761, 762,
+	763, 763, 764, 765, 766, 766, 767, 768, 768, 769, 770,
+	771, 771, 772, 773, 774, 774, 775, 776, 776, 777, 778,
+	779, 779, 780, 781, 781, 782, 783, 784, 784, 785, 786,
+	786, 787, 788, 789, 789, 790, 791, 791, 792, 793, 794,
+	794, 795, 796, 796, 797, 798, 799, 799, 800, 801, 801,
+	802, 803, 803, 804, 805, 806, 806, 807, 808, 808, 809,
+	810, 811, 811, 812, 813, 813, 814, 815, 815, 816, 817,
+	818, 818, 819, 820, 820, 821, 822, 822, 823, 824, 824,
+	825, 826, 827, 827, 828, 829, 829, 830, 831, 831, 832,
+	833, 833, 834, 835, 835, 836, 837, 838, 838, 839, 840,
+	840, 841, 842, 842, 843, 844, 844, 845, 846, 846, 847,
+	848, 848, 849, 850, 851, 851, 852, 853, 853, 854, 855,
+	855, 856, 857, 857, 858, 859, 859, 860, 861, 861, 862,
+	863, 863, 864, 865, 865, 866, 867, 867, 868, 869, 869,
+	870, 871, 871, 872, 873, 873, 874, 875, 875, 876, 877,
+	877, 878, 879, 879, 880, 881, 881, 882, 883, 883, 884,
+	885, 885, 886, 887, 887, 888, 889, 889, 890, 891, 891,
+	892, 893, 893, 894, 895, 895, 896, 897, 897, 898, 898,
+	899, 900, 900, 901, 902, 902, 903, 904, 904, 905, 906,
+	906, 907, 908, 908, 909, 910, 910, 911, 911, 912, 913,
+	913, 914, 915, 915, 916, 917, 917, 918, 919, 919, 920,
+	921, 921, 922, 922, 923, 924, 924, 925, 926, 926, 927,
+	928, 928, 929, 930, 930, 931, 931, 932, 933, 933, 934,
+	935, 935, 936, 937, 937, 938, 938, 939, 940, 940, 941,
+	942, 942, 943, 944, 944, 945, 945, 946, 947, 947, 948,
+	949, 949, 950, 950, 951, 952, 952, 953, 954, 954, 955,
+	956, 956, 957, 957, 958, 959, 959, 960, 961, 961, 962,
+	962, 963, 964, 964, 965, 966, 966, 967, 967, 968, 969,
+	969, 970, 970, 971, 972, 972, 973, 974, 974, 975, 975,
+	976, 977, 977, 978, 979, 979, 980, 980, 981, 982, 982,
+	983, 983, 984, 985, 985, 986, 987, 987, 988, 988, 989,
+	990, 990, 991, 991, 992, 993, 993, 994, 995, 995, 996,
+	996, 997, 998, 998, 999, 999, 1000, 1001, 1001, 1002, 1002,
+	1003, 1004, 1004, 1005, 1006, 1006, 1007, 1007, 1008, 1009, 1009,
+	1010, 1010, 1011, 1012, 1012, 1013, 1013, 1014, 1015, 1015, 1016,
+	1016, 1017, 1018, 1018, 1019, 1019, 1020, 1021, 1021, 1022, 1022,
+	1023,
+};
+
+static const u16 xgamma10_07[GAMMA10_TABLE_LENGTH] = {
+	0, 8, 13, 17, 21, 25, 28, 31, 34, 37, 40,
+	43, 46, 48, 51, 53, 56, 58, 60, 63, 65, 67,
+	70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
+	92, 94, 96, 98, 100, 102, 104, 106, 108, 109, 111,
+	113, 115, 117, 118, 120, 122, 124, 125, 127, 129, 131,
+	132, 134, 136, 137, 139, 140, 142, 144, 145, 147, 149,
+	150, 152, 153, 155, 157, 158, 160, 161, 163, 164, 166,
+	167, 169, 170, 172, 173, 175, 176, 178, 179, 181, 182,
+	184, 185, 187, 188, 190, 191, 192, 194, 195, 197, 198,
+	199, 201, 202, 204, 205, 206, 208, 209, 211, 212, 213,
+	215, 216, 217, 219, 220, 222, 223, 224, 226, 227, 228,
+	230, 231, 232, 234, 235, 236, 237, 239, 240, 241, 243,
+	244, 245, 247, 248, 249, 250, 252, 253, 254, 256, 257,
+	258, 259, 261, 262, 263, 264, 266, 267, 268, 269, 271,
+	272, 273, 274, 275, 277, 278, 279, 280, 282, 283, 284,
+	285, 286, 288, 289, 290, 291, 292, 294, 295, 296, 297,
+	298, 300, 301, 302, 303, 304, 306, 307, 308, 309, 310,
+	311, 313, 314, 315, 316, 317, 318, 319, 321, 322, 323,
+	324, 325, 326, 327, 329, 330, 331, 332, 333, 334, 335,
+	337, 338, 339, 340, 341, 342, 343, 344, 346, 347, 348,
+	349, 350, 351, 352, 353, 354, 355, 357, 358, 359, 360,
+	361, 362, 363, 364, 365, 366, 368, 369, 370, 371, 372,
+	373, 374, 375, 376, 377, 378, 379, 380, 382, 383, 384,
+	385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395,
+	396, 397, 398, 400, 401, 402, 403, 404, 405, 406, 407,
+	408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418,
+	419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429,
+	430, 431, 432, 433, 434, 435, 436, 437, 439, 440, 441,
+	442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452,
+	452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462,
+	463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473,
+	474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484,
+	485, 486, 487, 488, 489, 490, 491, 492, 492, 493, 494,
+	495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505,
+	506, 507, 508, 509, 510, 511, 511, 512, 513, 514, 515,
+	516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526,
+	526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536,
+	537, 538, 538, 539, 540, 541, 542, 543, 544, 545, 546,
+	547, 548, 549, 549, 550, 551, 552, 553, 554, 555, 556,
+	557, 558, 559, 560, 560, 561, 562, 563, 564, 565, 566,
+	567, 568, 569, 569, 570, 571, 572, 573, 574, 575, 576,
+	577, 578, 578, 579, 580, 581, 582, 583, 584, 585, 586,
+	586, 587, 588, 589, 590, 591, 592, 593, 594, 594, 595,
+	596, 597, 598, 599, 600, 601, 601, 602, 603, 604, 605,
+	606, 607, 608, 608, 609, 610, 611, 612, 613, 614, 615,
+	615, 616, 617, 618, 619, 620, 621, 622, 622, 623, 624,
+	625, 626, 627, 628, 628, 629, 630, 631, 632, 633, 634,
+	634, 635, 636, 637, 638, 639, 640, 640, 641, 642, 643,
+	644, 645, 646, 646, 647, 648, 649, 650, 651, 652, 652,
+	653, 654, 655, 656, 657, 657, 658, 659, 660, 661, 662,
+	663, 663, 664, 665, 666, 667, 668, 668, 669, 670, 671,
+	672, 673, 673, 674, 675, 676, 677, 678, 678, 679, 680,
+	681, 682, 683, 683, 684, 685, 686, 687, 688, 688, 689,
+	690, 691, 692, 693, 693, 694, 695, 696, 697, 698, 698,
+	699, 700, 701, 702, 703, 703, 704, 705, 706, 707, 707,
+	708, 709, 710, 711, 712, 712, 713, 714, 715, 716, 716,
+	717, 718, 719, 720, 721, 721, 722, 723, 724, 725, 725,
+	726, 727, 728, 729, 729, 730, 731, 732, 733, 733, 734,
+	735, 736, 737, 738, 738, 739, 740, 741, 742, 742, 743,
+	744, 745, 746, 746, 747, 748, 749, 750, 750, 751, 752,
+	753, 754, 754, 755, 756, 757, 758, 758, 759, 760, 761,
+	761, 762, 763, 764, 765, 765, 766, 767, 768, 769, 769,
+	770, 771, 772, 773, 773, 774, 775, 776, 777, 777, 778,
+	779, 780, 780, 781, 782, 783, 784, 784, 785, 786, 787,
+	788, 788, 789, 790, 791, 791, 792, 793, 794, 795, 795,
+	796, 797, 798, 798, 799, 800, 801, 802, 802, 803, 804,
+	805, 805, 806, 807, 808, 809, 809, 810, 811, 812, 812,
+	813, 814, 815, 816, 816, 817, 818, 819, 819, 820, 821,
+	822, 822, 823, 824, 825, 826, 826, 827, 828, 829, 829,
+	830, 831, 832, 832, 833, 834, 835, 835, 836, 837, 838,
+	839, 839, 840, 841, 842, 842, 843, 844, 845, 845, 846,
+	847, 848, 848, 849, 850, 851, 851, 852, 853, 854, 854,
+	855, 856, 857, 857, 858, 859, 860, 860, 861, 862, 863,
+	864, 864, 865, 866, 867, 867, 868, 869, 870, 870, 871,
+	872, 873, 873, 874, 875, 876, 876, 877, 878, 879, 879,
+	880, 881, 881, 882, 883, 884, 884, 885, 886, 887, 887,
+	888, 889, 890, 890, 891, 892, 893, 893, 894, 895, 896,
+	896, 897, 898, 899, 899, 900, 901, 902, 902, 903, 904,
+	904, 905, 906, 907, 907, 908, 909, 910, 910, 911, 912,
+	913, 913, 914, 915, 916, 916, 917, 918, 918, 919, 920,
+	921, 921, 922, 923, 924, 924, 925, 926, 927, 927, 928,
+	929, 929, 930, 931, 932, 932, 933, 934, 935, 935, 936,
+	937, 937, 938, 939, 940, 940, 941, 942, 943, 943, 944,
+	945, 945, 946, 947, 948, 948, 949, 950, 950, 951, 952,
+	953, 953, 954, 955, 956, 956, 957, 958, 958, 959, 960,
+	961, 961, 962, 963, 963, 964, 965, 966, 966, 967, 968,
+	968, 969, 970, 971, 971, 972, 973, 973, 974, 975, 976,
+	976, 977, 978, 978, 979, 980, 981, 981, 982, 983, 983,
+	984, 985, 986, 986, 987, 988, 988, 989, 990, 991, 991,
+	992, 993, 993, 994, 995, 996, 996, 997, 998, 998, 999,
+	1000, 1000, 1001, 1002, 1003, 1003, 1004, 1005, 1005, 1006, 1007,
+	1008, 1008, 1009, 1010, 1010, 1011, 1012, 1012, 1013, 1014, 1015,
+	1015, 1016, 1017, 1017, 1018, 1019, 1019, 1020, 1021, 1022, 1022,
+	1023,
+};
+
+static const u16 xgamma10_08[GAMMA10_TABLE_LENGTH] = {
+	0, 4, 7, 10, 12, 14, 17, 19, 21, 23, 25,
+	27, 29, 31, 33, 35, 37, 39, 40, 42, 44, 46,
+	47, 49, 51, 53, 54, 56, 58, 59, 61, 62, 64,
+	66, 67, 69, 70, 72, 73, 75, 76, 78, 80, 81,
+	83, 84, 86, 87, 89, 90, 91, 93, 94, 96, 97,
+	99, 100, 102, 103, 104, 106, 107, 109, 110, 111, 113,
+	114, 116, 117, 118, 120, 121, 122, 124, 125, 126, 128,
+	129, 131, 132, 133, 135, 136, 137, 138, 140, 141, 142,
+	144, 145, 146, 148, 149, 150, 152, 153, 154, 155, 157,
+	158, 159, 160, 162, 163, 164, 166, 167, 168, 169, 171,
+	172, 173, 174, 176, 177, 178, 179, 181, 182, 183, 184,
+	185, 187, 188, 189, 190, 192, 193, 194, 195, 196, 198,
+	199, 200, 201, 202, 204, 205, 206, 207, 208, 210, 211,
+	212, 213, 214, 216, 217, 218, 219, 220, 221, 223, 224,
+	225, 226, 227, 228, 230, 231, 232, 233, 234, 235, 237,
+	238, 239, 240, 241, 242, 243, 245, 246, 247, 248, 249,
+	250, 251, 253, 254, 255, 256, 257, 258, 259, 260, 262,
+	263, 264, 265, 266, 267, 268, 269, 271, 272, 273, 274,
+	275, 276, 277, 278, 279, 281, 282, 283, 284, 285, 286,
+	287, 288, 289, 290, 292, 293, 294, 295, 296, 297, 298,
+	299, 300, 301, 302, 304, 305, 306, 307, 308, 309, 310,
+	311, 312, 313, 314, 315, 316, 318, 319, 320, 321, 322,
+	323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333,
+	335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345,
+	346, 347, 348, 349, 350, 351, 352, 353, 355, 356, 357,
+	358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368,
+	369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379,
+	380, 381, 382, 383, 384, 385, 386, 388, 389, 390, 391,
+	392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402,
+	403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413,
+	414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424,
+	425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435,
+	436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446,
+	447, 448, 449, 450, 451, 451, 452, 453, 454, 455, 456,
+	457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467,
+	468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478,
+	479, 480, 481, 482, 483, 484, 485, 486, 486, 487, 488,
+	489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499,
+	500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 509,
+	510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520,
+	521, 522, 523, 524, 525, 526, 527, 527, 528, 529, 530,
+	531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
+	542, 543, 543, 544, 545, 546, 547, 548, 549, 550, 551,
+	552, 553, 554, 555, 556, 557, 557, 558, 559, 560, 561,
+	562, 563, 564, 565, 566, 567, 568, 569, 570, 570, 571,
+	572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582,
+	582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592,
+	593, 594, 594, 595, 596, 597, 598, 599, 600, 601, 602,
+	603, 604, 604, 605, 606, 607, 608, 609, 610, 611, 612,
+	613, 614, 615, 615, 616, 617, 618, 619, 620, 621, 622,
+	623, 624, 624, 625, 626, 627, 628, 629, 630, 631, 632,
+	633, 634, 634, 635, 636, 637, 638, 639, 640, 641, 642,
+	643, 643, 644, 645, 646, 647, 648, 649, 650, 651, 651,
+	652, 653, 654, 655, 656, 657, 658, 659, 660, 660, 661,
+	662, 663, 664, 665, 666, 667, 668, 668, 669, 670, 671,
+	672, 673, 674, 675, 676, 676, 677, 678, 679, 680, 681,
+	682, 683, 684, 684, 685, 686, 687, 688, 689, 690, 691,
+	691, 692, 693, 694, 695, 696, 697, 698, 699, 699, 700,
+	701, 702, 703, 704, 705, 706, 706, 707, 708, 709, 710,
+	711, 712, 713, 713, 714, 715, 716, 717, 718, 719, 720,
+	720, 721, 722, 723, 724, 725, 726, 727, 727, 728, 729,
+	730, 731, 732, 733, 734, 734, 735, 736, 737, 738, 739,
+	740, 740, 741, 742, 743, 744, 745, 746, 747, 747, 748,
+	749, 750, 751, 752, 753, 753, 754, 755, 756, 757, 758,
+	759, 759, 760, 761, 762, 763, 764, 765, 766, 766, 767,
+	768, 769, 770, 771, 772, 772, 773, 774, 775, 776, 777,
+	778, 778, 779, 780, 781, 782, 783, 784, 784, 785, 786,
+	787, 788, 789, 790, 790, 791, 792, 793, 794, 795, 795,
+	796, 797, 798, 799, 800, 801, 801, 802, 803, 804, 805,
+	806, 807, 807, 808, 809, 810, 811, 812, 812, 813, 814,
+	815, 816, 817, 818, 818, 819, 820, 821, 822, 823, 823,
+	824, 825, 826, 827, 828, 829, 829, 830, 831, 832, 833,
+	834, 834, 835, 836, 837, 838, 839, 839, 840, 841, 842,
+	843, 844, 845, 845, 846, 847, 848, 849, 850, 850, 851,
+	852, 853, 854, 855, 855, 856, 857, 858, 859, 860, 860,
+	861, 862, 863, 864, 865, 865, 866, 867, 868, 869, 870,
+	870, 871, 872, 873, 874, 875, 875, 876, 877, 878, 879,
+	880, 880, 881, 882, 883, 884, 885, 885, 886, 887, 888,
+	889, 890, 890, 891, 892, 893, 894, 895, 895, 896, 897,
+	898, 899, 899, 900, 901, 902, 903, 904, 904, 905, 906,
+	907, 908, 909, 909, 910, 911, 912, 913, 913, 914, 915,
+	916, 917, 918, 918, 919, 920, 921, 922, 923, 923, 924,
+	925, 926, 927, 927, 928, 929, 930, 931, 932, 932, 933,
+	934, 935, 936, 936, 937, 938, 939, 940, 941, 941, 942,
+	943, 944, 945, 945, 946, 947, 948, 949, 950, 950, 951,
+	952, 953, 954, 954, 955, 956, 957, 958, 958, 959, 960,
+	961, 962, 963, 963, 964, 965, 966, 967, 967, 968, 969,
+	970, 971, 971, 972, 973, 974, 975, 976, 976, 977, 978,
+	979, 980, 980, 981, 982, 983, 984, 984, 985, 986, 987,
+	988, 988, 989, 990, 991, 992, 992, 993, 994, 995, 996,
+	997, 997, 998, 999, 1000, 1001, 1001, 1002, 1003, 1004, 1005,
+	1005, 1006, 1007, 1008, 1009, 1009, 1010, 1011, 1012, 1013, 1013,
+	1014, 1015, 1016, 1017, 1017, 1018, 1019, 1020, 1021, 1021, 1022,
+	1023,
+};
+
+static const u16 xgamma10_09[GAMMA10_TABLE_LENGTH] = {
+	0, 2, 4, 5, 7, 9, 10, 12, 13, 14, 16,
+	17, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31,
+	32, 34, 35, 36, 38, 39, 40, 41, 43, 44, 45,
+	47, 48, 49, 50, 52, 53, 54, 55, 57, 58, 59,
+	60, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72,
+	74, 75, 76, 77, 78, 80, 81, 82, 83, 84, 86,
+	87, 88, 89, 90, 92, 93, 94, 95, 96, 97, 99,
+	100, 101, 102, 103, 104, 106, 107, 108, 109, 110, 111,
+	112, 114, 115, 116, 117, 118, 119, 120, 122, 123, 124,
+	125, 126, 127, 128, 130, 131, 132, 133, 134, 135, 136,
+	137, 139, 140, 141, 142, 143, 144, 145, 146, 148, 149,
+	150, 151, 152, 153, 154, 155, 156, 158, 159, 160, 161,
+	162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173,
+	174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185,
+	186, 187, 188, 189, 190, 192, 193, 194, 195, 196, 197,
+	198, 199, 200, 201, 202, 203, 204, 206, 207, 208, 209,
+	210, 211, 212, 213, 214, 215, 216, 217, 218, 220, 221,
+	222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
+	233, 234, 235, 237, 238, 239, 240, 241, 242, 243, 244,
+	245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
+	257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267,
+	268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278,
+	280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290,
+	291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301,
+	302, 303, 304, 305, 306, 307, 308, 309, 311, 312, 313,
+	314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324,
+	325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335,
+	336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346,
+	347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357,
+	358, 359, 360, 361, 362, 363, 364, 365, 367, 368, 369,
+	370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380,
+	381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391,
+	392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402,
+	403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413,
+	414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424,
+	425, 426, 427, 427, 428, 429, 430, 431, 432, 433, 434,
+	435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445,
+	446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456,
+	457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467,
+	468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478,
+	479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489,
+	489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499,
+	500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510,
+	511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521,
+	522, 523, 524, 525, 525, 526, 527, 528, 529, 530, 531,
+	532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542,
+	543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553,
+	554, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563,
+	564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574,
+	575, 576, 577, 578, 579, 579, 580, 581, 582, 583, 584,
+	585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595,
+	596, 597, 598, 599, 600, 601, 601, 602, 603, 604, 605,
+	606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616,
+	617, 618, 619, 620, 621, 621, 622, 623, 624, 625, 626,
+	627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637,
+	638, 639, 640, 640, 641, 642, 643, 644, 645, 646, 647,
+	648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658,
+	658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668,
+	669, 670, 671, 672, 673, 674, 675, 675, 676, 677, 678,
+	679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689,
+	690, 691, 691, 692, 693, 694, 695, 696, 697, 698, 699,
+	700, 701, 702, 703, 704, 705, 706, 706, 707, 708, 709,
+	710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720,
+	721, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730,
+	731, 732, 733, 734, 735, 735, 736, 737, 738, 739, 740,
+	741, 742, 743, 744, 745, 746, 747, 748, 749, 749, 750,
+	751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761,
+	762, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771,
+	772, 773, 774, 775, 776, 776, 777, 778, 779, 780, 781,
+	782, 783, 784, 785, 786, 787, 788, 788, 789, 790, 791,
+	792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 801,
+	802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812,
+	813, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822,
+	823, 824, 825, 825, 826, 827, 828, 829, 830, 831, 832,
+	833, 834, 835, 836, 836, 837, 838, 839, 840, 841, 842,
+	843, 844, 845, 846, 847, 848, 848, 849, 850, 851, 852,
+	853, 854, 855, 856, 857, 858, 859, 859, 860, 861, 862,
+	863, 864, 865, 866, 867, 868, 869, 870, 870, 871, 872,
+	873, 874, 875, 876, 877, 878, 879, 880, 881, 881, 882,
+	883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 892,
+	893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 902,
+	903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913,
+	913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923,
+	923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933,
+	933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943,
+	943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953,
+	953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 962,
+	963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 972,
+	973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 982,
+	983, 984, 985, 986, 987, 988, 989, 990, 991, 991, 992,
+	993, 994, 995, 996, 997, 998, 999, 1000, 1000, 1001, 1002,
+	1003, 1004, 1005, 1006, 1007, 1008, 1009, 1009, 1010, 1011, 1012,
+	1013, 1014, 1015, 1016, 1017, 1018, 1018, 1019, 1020, 1021, 1022,
+	1023,
+};
+
+static const u16 xgamma10_10[GAMMA10_TABLE_LENGTH] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
+	11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
+	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
+	44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
+	55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
+	66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
+	77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
+	88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
+	99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
+	110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
+	121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
+	132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
+	143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
+	154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
+	165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
+	187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
+	198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
+	209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
+	220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,
+	231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
+	242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252,
+	253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263,
+	264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274,
+	275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285,
+	286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296,
+	297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307,
+	308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318,
+	319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329,
+	330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340,
+	341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351,
+	352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362,
+	363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373,
+	374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384,
+	385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395,
+	396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406,
+	407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417,
+	418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428,
+	429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439,
+	440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450,
+	451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461,
+	462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472,
+	473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483,
+	484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494,
+	495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505,
+	506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516,
+	517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
+	528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538,
+	539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549,
+	550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560,
+	561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571,
+	572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582,
+	583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593,
+	594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604,
+	605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615,
+	616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626,
+	627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637,
+	638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648,
+	649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659,
+	660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670,
+	671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681,
+	682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692,
+	693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703,
+	704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714,
+	715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725,
+	726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736,
+	737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747,
+	748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758,
+	759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769,
+	770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780,
+	781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791,
+	792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802,
+	803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813,
+	814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824,
+	825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835,
+	836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846,
+	847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857,
+	858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868,
+	869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879,
+	880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890,
+	891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901,
+	902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912,
+	913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923,
+	924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934,
+	935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945,
+	946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956,
+	957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967,
+	968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978,
+	979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989,
+	990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000,
+	1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011,
+	1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022,
+	1023,
+};
+
+static const u16 xgamma10_11[GAMMA10_TABLE_LENGTH] = {
+	0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 6,
+	7, 8, 8, 9, 10, 11, 11, 12, 13, 13, 14,
+	15, 16, 16, 17, 18, 19, 20, 20, 21, 22, 23,
+	23, 24, 25, 26, 27, 27, 28, 29, 30, 31, 31,
+	32, 33, 34, 35, 35, 36, 37, 38, 39, 39, 40,
+	41, 42, 43, 44, 44, 45, 46, 47, 48, 49, 49,
+	50, 51, 52, 53, 54, 54, 55, 56, 57, 58, 59,
+	59, 60, 61, 62, 63, 64, 65, 65, 66, 67, 68,
+	69, 70, 71, 71, 72, 73, 74, 75, 76, 77, 78,
+	78, 79, 80, 81, 82, 83, 84, 84, 85, 86, 87,
+	88, 89, 90, 91, 92, 92, 93, 94, 95, 96, 97,
+	98, 99, 100, 100, 101, 102, 103, 104, 105, 106, 107,
+	108, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
+	117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
+	127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
+	137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147,
+	148, 149, 149, 150, 151, 152, 153, 154, 155, 156, 157,
+	158, 159, 160, 161, 161, 162, 163, 164, 165, 166, 167,
+	168, 169, 170, 171, 172, 173, 174, 175, 175, 176, 177,
+	178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188,
+	189, 190, 191, 191, 192, 193, 194, 195, 196, 197, 198,
+	199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
+	210, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
+	220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,
+	231, 232, 232, 233, 234, 235, 236, 237, 238, 239, 240,
+	241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251,
+	252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 261,
+	262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272,
+	273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
+	284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294,
+	295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305,
+	306, 307, 307, 308, 309, 310, 311, 312, 313, 314, 315,
+	316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326,
+	327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337,
+	338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348,
+	349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359,
+	360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370,
+	371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381,
+	382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392,
+	393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403,
+	404, 405, 406, 407, 408, 409, 410, 411, 412, 414, 415,
+	416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426,
+	427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437,
+	438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448,
+	449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459,
+	460, 461, 462, 463, 464, 465, 466, 468, 469, 470, 471,
+	472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482,
+	483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493,
+	494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 505,
+	506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516,
+	517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
+	528, 529, 530, 531, 532, 533, 535, 536, 537, 538, 539,
+	540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550,
+	551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 562,
+	563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573,
+	574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584,
+	586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596,
+	597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 608,
+	609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619,
+	620, 621, 622, 623, 624, 625, 626, 627, 629, 630, 631,
+	632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642,
+	643, 644, 645, 646, 648, 649, 650, 651, 652, 653, 654,
+	655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665,
+	667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677,
+	678, 679, 680, 681, 682, 683, 685, 686, 687, 688, 689,
+	690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700,
+	702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712,
+	713, 714, 715, 716, 717, 719, 720, 721, 722, 723, 724,
+	725, 726, 727, 728, 729, 730, 731, 732, 733, 735, 736,
+	737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747,
+	748, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759,
+	760, 761, 762, 763, 764, 766, 767, 768, 769, 770, 771,
+	772, 773, 774, 775, 776, 777, 778, 779, 781, 782, 783,
+	784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 795,
+	796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806,
+	807, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818,
+	819, 820, 821, 823, 824, 825, 826, 827, 828, 829, 830,
+	831, 832, 833, 834, 835, 837, 838, 839, 840, 841, 842,
+	843, 844, 845, 846, 847, 848, 850, 851, 852, 853, 854,
+	855, 856, 857, 858, 859, 860, 861, 863, 864, 865, 866,
+	867, 868, 869, 870, 871, 872, 873, 874, 876, 877, 878,
+	879, 880, 881, 882, 883, 884, 885, 886, 887, 889, 890,
+	891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 902,
+	903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 914,
+	915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 926,
+	927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 938,
+	939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 950,
+	951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 962,
+	963, 964, 965, 966, 967, 968, 969, 970, 971, 973, 974,
+	975, 976, 977, 978, 979, 980, 981, 982, 983, 985, 986,
+	987, 988, 989, 990, 991, 992, 993, 994, 996, 997, 998,
+	999, 1000, 1001, 1002, 1003, 1004, 1005, 1007, 1008, 1009, 1010,
+	1011, 1012, 1013, 1014, 1015, 1016, 1018, 1019, 1020, 1021, 1022,
+	1023,
+};
+
+static const u16 xgamma10_12[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4,
+	4, 5, 5, 6, 6, 7, 7, 8, 9, 9, 10,
+	10, 11, 11, 12, 12, 13, 14, 14, 15, 15, 16,
+	17, 17, 18, 18, 19, 20, 20, 21, 22, 22, 23,
+	23, 24, 25, 25, 26, 27, 27, 28, 29, 29, 30,
+	31, 31, 32, 33, 33, 34, 35, 35, 36, 37, 37,
+	38, 39, 40, 40, 41, 42, 42, 43, 44, 44, 45,
+	46, 47, 47, 48, 49, 49, 50, 51, 52, 52, 53,
+	54, 55, 55, 56, 57, 58, 58, 59, 60, 61, 61,
+	62, 63, 64, 64, 65, 66, 67, 67, 68, 69, 70,
+	70, 71, 72, 73, 74, 74, 75, 76, 77, 77, 78,
+	79, 80, 81, 81, 82, 83, 84, 84, 85, 86, 87,
+	88, 88, 89, 90, 91, 92, 92, 93, 94, 95, 96,
+	96, 97, 98, 99, 100, 101, 101, 102, 103, 104, 105,
+	105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114,
+	115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123,
+	124, 125, 125, 126, 127, 128, 129, 130, 131, 131, 132,
+	133, 134, 135, 136, 137, 137, 138, 139, 140, 141, 142,
+	143, 143, 144, 145, 146, 147, 148, 149, 150, 150, 151,
+	152, 153, 154, 155, 156, 157, 157, 158, 159, 160, 161,
+	162, 163, 164, 164, 165, 166, 167, 168, 169, 170, 171,
+	172, 172, 173, 174, 175, 176, 177, 178, 179, 180, 180,
+	181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 190,
+	191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 200,
+	201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211,
+	211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221,
+	222, 223, 224, 224, 225, 226, 227, 228, 229, 230, 231,
+	232, 233, 234, 235, 236, 237, 238, 238, 239, 240, 241,
+	242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252,
+	253, 254, 255, 256, 256, 257, 258, 259, 260, 261, 262,
+	263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273,
+	274, 275, 276, 277, 278, 279, 280, 280, 281, 282, 283,
+	284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294,
+	295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305,
+	306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316,
+	317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327,
+	328, 329, 330, 331, 332, 333, 334, 334, 335, 336, 337,
+	338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348,
+	349, 350, 351, 353, 354, 355, 356, 357, 358, 359, 360,
+	361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371,
+	372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382,
+	383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393,
+	394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404,
+	405, 406, 407, 408, 409, 411, 412, 413, 414, 415, 416,
+	417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427,
+	428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 439,
+	440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450,
+	451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 462,
+	463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473,
+	474, 475, 476, 477, 478, 479, 481, 482, 483, 484, 485,
+	486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496,
+	497, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508,
+	509, 510, 511, 512, 513, 515, 516, 517, 518, 519, 520,
+	521, 522, 523, 524, 525, 526, 527, 529, 530, 531, 532,
+	533, 534, 535, 536, 537, 538, 539, 540, 541, 543, 544,
+	545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
+	557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567,
+	569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579,
+	581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591,
+	593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 604,
+	605, 606, 607, 608, 609, 610, 611, 612, 613, 615, 616,
+	617, 618, 619, 620, 621, 622, 623, 624, 626, 627, 628,
+	629, 630, 631, 632, 633, 634, 636, 637, 638, 639, 640,
+	641, 642, 643, 644, 646, 647, 648, 649, 650, 651, 652,
+	653, 654, 656, 657, 658, 659, 660, 661, 662, 663, 664,
+	666, 667, 668, 669, 670, 671, 672, 673, 675, 676, 677,
+	678, 679, 680, 681, 682, 683, 685, 686, 687, 688, 689,
+	690, 691, 692, 694, 695, 696, 697, 698, 699, 700, 701,
+	703, 704, 705, 706, 707, 708, 709, 710, 712, 713, 714,
+	715, 716, 717, 718, 720, 721, 722, 723, 724, 725, 726,
+	727, 729, 730, 731, 732, 733, 734, 735, 737, 738, 739,
+	740, 741, 742, 743, 745, 746, 747, 748, 749, 750, 751,
+	752, 754, 755, 756, 757, 758, 759, 760, 762, 763, 764,
+	765, 766, 767, 768, 770, 771, 772, 773, 774, 775, 776,
+	778, 779, 780, 781, 782, 783, 785, 786, 787, 788, 789,
+	790, 791, 793, 794, 795, 796, 797, 798, 799, 801, 802,
+	803, 804, 805, 806, 808, 809, 810, 811, 812, 813, 814,
+	816, 817, 818, 819, 820, 821, 823, 824, 825, 826, 827,
+	828, 830, 831, 832, 833, 834, 835, 836, 838, 839, 840,
+	841, 842, 843, 845, 846, 847, 848, 849, 850, 852, 853,
+	854, 855, 856, 857, 859, 860, 861, 862, 863, 864, 866,
+	867, 868, 869, 870, 871, 873, 874, 875, 876, 877, 878,
+	880, 881, 882, 883, 884, 885, 887, 888, 889, 890, 891,
+	892, 894, 895, 896, 897, 898, 900, 901, 902, 903, 904,
+	905, 907, 908, 909, 910, 911, 912, 914, 915, 916, 917,
+	918, 920, 921, 922, 923, 924, 925, 927, 928, 929, 930,
+	931, 932, 934, 935, 936, 937, 938, 940, 941, 942, 943,
+	944, 946, 947, 948, 949, 950, 951, 953, 954, 955, 956,
+	957, 959, 960, 961, 962, 963, 964, 966, 967, 968, 969,
+	970, 972, 973, 974, 975, 976, 978, 979, 980, 981, 982,
+	984, 985, 986, 987, 988, 989, 991, 992, 993, 994, 995,
+	997, 998, 999, 1000, 1001, 1003, 1004, 1005, 1006, 1007, 1009,
+	1010, 1011, 1012, 1013, 1015, 1016, 1017, 1018, 1019, 1021, 1022,
+	1023,
+};
+
+static const u16 xgamma10_13[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+	3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7,
+	7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11,
+	12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17,
+	17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+	23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28,
+	29, 30, 30, 31, 31, 32, 32, 33, 34, 34, 35,
+	35, 36, 37, 37, 38, 38, 39, 40, 40, 41, 42,
+	42, 43, 43, 44, 45, 45, 46, 47, 47, 48, 48,
+	49, 50, 50, 51, 52, 52, 53, 54, 54, 55, 56,
+	56, 57, 58, 58, 59, 60, 60, 61, 62, 62, 63,
+	64, 64, 65, 66, 67, 67, 68, 69, 69, 70, 71,
+	71, 72, 73, 74, 74, 75, 76, 76, 77, 78, 79,
+	79, 80, 81, 81, 82, 83, 84, 84, 85, 86, 87,
+	87, 88, 89, 89, 90, 91, 92, 92, 93, 94, 95,
+	95, 96, 97, 98, 98, 99, 100, 101, 102, 102, 103,
+	104, 105, 105, 106, 107, 108, 108, 109, 110, 111, 112,
+	112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120,
+	121, 122, 123, 123, 124, 125, 126, 127, 127, 128, 129,
+	130, 131, 131, 132, 133, 134, 135, 135, 136, 137, 138,
+	139, 140, 140, 141, 142, 143, 144, 145, 145, 146, 147,
+	148, 149, 149, 150, 151, 152, 153, 154, 155, 155, 156,
+	157, 158, 159, 160, 160, 161, 162, 163, 164, 165, 166,
+	166, 167, 168, 169, 170, 171, 172, 172, 173, 174, 175,
+	176, 177, 178, 178, 179, 180, 181, 182, 183, 184, 185,
+	185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 194,
+	195, 196, 197, 198, 199, 200, 200, 201, 202, 203, 204,
+	205, 206, 207, 208, 209, 209, 210, 211, 212, 213, 214,
+	215, 216, 217, 218, 218, 219, 220, 221, 222, 223, 224,
+	225, 226, 227, 228, 229, 229, 230, 231, 232, 233, 234,
+	235, 236, 237, 238, 239, 240, 241, 242, 242, 243, 244,
+	245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
+	256, 257, 257, 258, 259, 260, 261, 262, 263, 264, 265,
+	266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276,
+	277, 278, 278, 279, 280, 281, 282, 283, 284, 285, 286,
+	287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
+	298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308,
+	309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319,
+	320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330,
+	331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341,
+	342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352,
+	353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363,
+	364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374,
+	375, 376, 377, 378, 379, 380, 381, 383, 384, 385, 386,
+	387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397,
+	398, 399, 400, 401, 402, 403, 404, 405, 407, 408, 409,
+	410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420,
+	421, 422, 423, 424, 426, 427, 428, 429, 430, 431, 432,
+	433, 434, 435, 436, 437, 438, 439, 440, 442, 443, 444,
+	445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455,
+	457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467,
+	468, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479,
+	480, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491,
+	493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 504,
+	505, 506, 507, 508, 509, 510, 511, 512, 513, 515, 516,
+	517, 518, 519, 520, 521, 522, 523, 525, 526, 527, 528,
+	529, 530, 531, 532, 534, 535, 536, 537, 538, 539, 540,
+	541, 542, 544, 545, 546, 547, 548, 549, 550, 551, 553,
+	554, 555, 556, 557, 558, 559, 561, 562, 563, 564, 565,
+	566, 567, 568, 570, 571, 572, 573, 574, 575, 576, 578,
+	579, 580, 581, 582, 583, 584, 586, 587, 588, 589, 590,
+	591, 592, 594, 595, 596, 597, 598, 599, 600, 602, 603,
+	604, 605, 606, 607, 608, 610, 611, 612, 613, 614, 615,
+	617, 618, 619, 620, 621, 622, 624, 625, 626, 627, 628,
+	629, 630, 632, 633, 634, 635, 636, 637, 639, 640, 641,
+	642, 643, 644, 646, 647, 648, 649, 650, 652, 653, 654,
+	655, 656, 657, 659, 660, 661, 662, 663, 664, 666, 667,
+	668, 669, 670, 671, 673, 674, 675, 676, 677, 679, 680,
+	681, 682, 683, 684, 686, 687, 688, 689, 690, 692, 693,
+	694, 695, 696, 698, 699, 700, 701, 702, 704, 705, 706,
+	707, 708, 709, 711, 712, 713, 714, 715, 717, 718, 719,
+	720, 721, 723, 724, 725, 726, 727, 729, 730, 731, 732,
+	733, 735, 736, 737, 738, 739, 741, 742, 743, 744, 746,
+	747, 748, 749, 750, 752, 753, 754, 755, 756, 758, 759,
+	760, 761, 762, 764, 765, 766, 767, 769, 770, 771, 772,
+	773, 775, 776, 777, 778, 780, 781, 782, 783, 784, 786,
+	787, 788, 789, 791, 792, 793, 794, 795, 797, 798, 799,
+	800, 802, 803, 804, 805, 807, 808, 809, 810, 811, 813,
+	814, 815, 816, 818, 819, 820, 821, 823, 824, 825, 826,
+	827, 829, 830, 831, 832, 834, 835, 836, 837, 839, 840,
+	841, 842, 844, 845, 846, 847, 849, 850, 851, 852, 854,
+	855, 856, 857, 859, 860, 861, 862, 864, 865, 866, 867,
+	869, 870, 871, 872, 874, 875, 876, 877, 879, 880, 881,
+	882, 884, 885, 886, 887, 889, 890, 891, 892, 894, 895,
+	896, 897, 899, 900, 901, 903, 904, 905, 906, 908, 909,
+	910, 911, 913, 914, 915, 916, 918, 919, 920, 922, 923,
+	924, 925, 927, 928, 929, 930, 932, 933, 934, 935, 937,
+	938, 939, 941, 942, 943, 944, 946, 947, 948, 950, 951,
+	952, 953, 955, 956, 957, 958, 960, 961, 962, 964, 965,
+	966, 967, 969, 970, 971, 973, 974, 975, 976, 978, 979,
+	980, 982, 983, 984, 985, 987, 988, 989, 991, 992, 993,
+	994, 996, 997, 998, 1000, 1001, 1002, 1004, 1005, 1006, 1007,
+	1009, 1010, 1011, 1013, 1014, 1015, 1017, 1018, 1019, 1020, 1022,
+	1023,
+};
+
+static const u16 xgamma10_14[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
+	5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8,
+	8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12,
+	12, 13, 13, 14, 14, 15, 15, 15, 16, 16, 17,
+	17, 18, 18, 18, 19, 19, 20, 20, 21, 21, 22,
+	22, 23, 23, 23, 24, 24, 25, 25, 26, 26, 27,
+	27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32,
+	33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
+	39, 39, 40, 41, 41, 42, 42, 43, 43, 44, 45,
+	45, 46, 46, 47, 47, 48, 49, 49, 50, 50, 51,
+	52, 52, 53, 53, 54, 55, 55, 56, 56, 57, 58,
+	58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 64,
+	65, 66, 66, 67, 68, 68, 69, 70, 70, 71, 72,
+	72, 73, 74, 74, 75, 76, 76, 77, 78, 78, 79,
+	80, 80, 81, 82, 82, 83, 84, 84, 85, 86, 86,
+	87, 88, 88, 89, 90, 91, 91, 92, 93, 93, 94,
+	95, 95, 96, 97, 98, 98, 99, 100, 100, 101, 102,
+	103, 103, 104, 105, 106, 106, 107, 108, 109, 109, 110,
+	111, 111, 112, 113, 114, 114, 115, 116, 117, 117, 118,
+	119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127,
+	127, 128, 129, 130, 130, 131, 132, 133, 134, 134, 135,
+	136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144,
+	145, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153,
+	154, 154, 155, 156, 157, 158, 158, 159, 160, 161, 162,
+	163, 163, 164, 165, 166, 167, 168, 168, 169, 170, 171,
+	172, 173, 173, 174, 175, 176, 177, 178, 179, 179, 180,
+	181, 182, 183, 184, 185, 185, 186, 187, 188, 189, 190,
+	191, 191, 192, 193, 194, 195, 196, 197, 198, 198, 199,
+	200, 201, 202, 203, 204, 205, 205, 206, 207, 208, 209,
+	210, 211, 212, 213, 213, 214, 215, 216, 217, 218, 219,
+	220, 221, 222, 222, 223, 224, 225, 226, 227, 228, 229,
+	230, 231, 232, 232, 233, 234, 235, 236, 237, 238, 239,
+	240, 241, 242, 243, 244, 244, 245, 246, 247, 248, 249,
+	250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 259,
+	260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270,
+	271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281,
+	282, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291,
+	292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302,
+	303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313,
+	314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324,
+	325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335,
+	336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346,
+	347, 348, 349, 351, 352, 353, 354, 355, 356, 357, 358,
+	359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369,
+	370, 371, 372, 373, 374, 375, 377, 378, 379, 380, 381,
+	382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392,
+	393, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404,
+	405, 406, 407, 408, 410, 411, 412, 413, 414, 415, 416,
+	417, 418, 419, 420, 421, 423, 424, 425, 426, 427, 428,
+	429, 430, 431, 432, 433, 435, 436, 437, 438, 439, 440,
+	441, 442, 443, 444, 446, 447, 448, 449, 450, 451, 452,
+	453, 454, 456, 457, 458, 459, 460, 461, 462, 463, 464,
+	466, 467, 468, 469, 470, 471, 472, 473, 475, 476, 477,
+	478, 479, 480, 481, 482, 484, 485, 486, 487, 488, 489,
+	490, 491, 493, 494, 495, 496, 497, 498, 499, 501, 502,
+	503, 504, 505, 506, 507, 509, 510, 511, 512, 513, 514,
+	515, 517, 518, 519, 520, 521, 522, 524, 525, 526, 527,
+	528, 529, 531, 532, 533, 534, 535, 536, 537, 539, 540,
+	541, 542, 543, 544, 546, 547, 548, 549, 550, 552, 553,
+	554, 555, 556, 557, 559, 560, 561, 562, 563, 564, 566,
+	567, 568, 569, 570, 572, 573, 574, 575, 576, 578, 579,
+	580, 581, 582, 583, 585, 586, 587, 588, 589, 591, 592,
+	593, 594, 595, 597, 598, 599, 600, 601, 603, 604, 605,
+	606, 607, 609, 610, 611, 612, 613, 615, 616, 617, 618,
+	620, 621, 622, 623, 624, 626, 627, 628, 629, 630, 632,
+	633, 634, 635, 637, 638, 639, 640, 641, 643, 644, 645,
+	646, 648, 649, 650, 651, 653, 654, 655, 656, 657, 659,
+	660, 661, 662, 664, 665, 666, 667, 669, 670, 671, 672,
+	674, 675, 676, 677, 679, 680, 681, 682, 684, 685, 686,
+	687, 689, 690, 691, 692, 694, 695, 696, 697, 699, 700,
+	701, 702, 704, 705, 706, 707, 709, 710, 711, 712, 714,
+	715, 716, 717, 719, 720, 721, 723, 724, 725, 726, 728,
+	729, 730, 731, 733, 734, 735, 737, 738, 739, 740, 742,
+	743, 744, 745, 747, 748, 749, 751, 752, 753, 754, 756,
+	757, 758, 760, 761, 762, 763, 765, 766, 767, 769, 770,
+	771, 772, 774, 775, 776, 778, 779, 780, 782, 783, 784,
+	785, 787, 788, 789, 791, 792, 793, 794, 796, 797, 798,
+	800, 801, 802, 804, 805, 806, 808, 809, 810, 811, 813,
+	814, 815, 817, 818, 819, 821, 822, 823, 825, 826, 827,
+	829, 830, 831, 833, 834, 835, 836, 838, 839, 840, 842,
+	843, 844, 846, 847, 848, 850, 851, 852, 854, 855, 856,
+	858, 859, 860, 862, 863, 864, 866, 867, 868, 870, 871,
+	872, 874, 875, 876, 878, 879, 880, 882, 883, 884, 886,
+	887, 888, 890, 891, 893, 894, 895, 897, 898, 899, 901,
+	902, 903, 905, 906, 907, 909, 910, 911, 913, 914, 915,
+	917, 918, 920, 921, 922, 924, 925, 926, 928, 929, 930,
+	932, 933, 935, 936, 937, 939, 940, 941, 943, 944, 945,
+	947, 948, 950, 951, 952, 954, 955, 956, 958, 959, 961,
+	962, 963, 965, 966, 967, 969, 970, 972, 973, 974, 976,
+	977, 978, 980, 981, 983, 984, 985, 987, 988, 990, 991,
+	992, 994, 995, 996, 998, 999, 1001, 1002, 1003, 1005, 1006,
+	1008, 1009, 1010, 1012, 1013, 1015, 1016, 1017, 1019, 1020, 1022,
+	1023,
+};
+
+static const u16 xgamma10_15[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
+	1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6,
+	6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9,
+	9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12,
+	13, 13, 13, 14, 14, 15, 15, 15, 16, 16, 16,
+	17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21,
+	21, 22, 22, 22, 23, 23, 24, 24, 25, 25, 25,
+	26, 26, 27, 27, 28, 28, 28, 29, 29, 30, 30,
+	31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36,
+	36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41,
+	42, 42, 43, 43, 44, 44, 45, 45, 46, 46, 47,
+	47, 48, 48, 49, 50, 50, 51, 51, 52, 52, 53,
+	53, 54, 55, 55, 56, 56, 57, 57, 58, 59, 59,
+	60, 60, 61, 62, 62, 63, 63, 64, 64, 65, 66,
+	66, 67, 67, 68, 69, 69, 70, 71, 71, 72, 72,
+	73, 74, 74, 75, 76, 76, 77, 77, 78, 79, 79,
+	80, 81, 81, 82, 83, 83, 84, 84, 85, 86, 86,
+	87, 88, 88, 89, 90, 90, 91, 92, 92, 93, 94,
+	94, 95, 96, 97, 97, 98, 99, 99, 100, 101, 101,
+	102, 103, 103, 104, 105, 106, 106, 107, 108, 108, 109,
+	110, 110, 111, 112, 113, 113, 114, 115, 116, 116, 117,
+	118, 118, 119, 120, 121, 121, 122, 123, 124, 124, 125,
+	126, 127, 127, 128, 129, 130, 130, 131, 132, 133, 133,
+	134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 142,
+	143, 143, 144, 145, 146, 146, 147, 148, 149, 150, 150,
+	151, 152, 153, 154, 154, 155, 156, 157, 158, 158, 159,
+	160, 161, 162, 162, 163, 164, 165, 166, 167, 167, 168,
+	169, 170, 171, 171, 172, 173, 174, 175, 176, 176, 177,
+	178, 179, 180, 181, 181, 182, 183, 184, 185, 186, 187,
+	187, 188, 189, 190, 191, 192, 193, 193, 194, 195, 196,
+	197, 198, 199, 199, 200, 201, 202, 203, 204, 205, 206,
+	206, 207, 208, 209, 210, 211, 212, 213, 214, 214, 215,
+	216, 217, 218, 219, 220, 221, 222, 223, 223, 224, 225,
+	226, 227, 228, 229, 230, 231, 232, 233, 233, 234, 235,
+	236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 245,
+	246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256,
+	257, 258, 259, 260, 261, 261, 262, 263, 264, 265, 266,
+	267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277,
+	278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288,
+	289, 290, 291, 292, 293, 293, 294, 295, 296, 297, 298,
+	299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309,
+	310, 311, 312, 314, 315, 316, 317, 318, 319, 320, 321,
+	322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332,
+	333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343,
+	344, 345, 346, 347, 349, 350, 351, 352, 353, 354, 355,
+	356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366,
+	368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378,
+	379, 380, 381, 383, 384, 385, 386, 387, 388, 389, 390,
+	391, 392, 393, 395, 396, 397, 398, 399, 400, 401, 402,
+	403, 404, 405, 407, 408, 409, 410, 411, 412, 413, 414,
+	415, 417, 418, 419, 420, 421, 422, 423, 424, 425, 427,
+	428, 429, 430, 431, 432, 433, 434, 436, 437, 438, 439,
+	440, 441, 442, 444, 445, 446, 447, 448, 449, 450, 451,
+	453, 454, 455, 456, 457, 458, 460, 461, 462, 463, 464,
+	465, 466, 468, 469, 470, 471, 472, 473, 475, 476, 477,
+	478, 479, 480, 482, 483, 484, 485, 486, 487, 489, 490,
+	491, 492, 493, 494, 496, 497, 498, 499, 500, 501, 503,
+	504, 505, 506, 507, 509, 510, 511, 512, 513, 515, 516,
+	517, 518, 519, 521, 522, 523, 524, 525, 527, 528, 529,
+	530, 531, 533, 534, 535, 536, 537, 539, 540, 541, 542,
+	543, 545, 546, 547, 548, 550, 551, 552, 553, 554, 556,
+	557, 558, 559, 561, 562, 563, 564, 565, 567, 568, 569,
+	570, 572, 573, 574, 575, 577, 578, 579, 580, 582, 583,
+	584, 585, 587, 588, 589, 590, 591, 593, 594, 595, 596,
+	598, 599, 600, 602, 603, 604, 605, 607, 608, 609, 610,
+	612, 613, 614, 615, 617, 618, 619, 620, 622, 623, 624,
+	626, 627, 628, 629, 631, 632, 633, 634, 636, 637, 638,
+	640, 641, 642, 643, 645, 646, 647, 649, 650, 651, 652,
+	654, 655, 656, 658, 659, 660, 662, 663, 664, 665, 667,
+	668, 669, 671, 672, 673, 675, 676, 677, 678, 680, 681,
+	682, 684, 685, 686, 688, 689, 690, 692, 693, 694, 696,
+	697, 698, 700, 701, 702, 703, 705, 706, 707, 709, 710,
+	711, 713, 714, 715, 717, 718, 719, 721, 722, 723, 725,
+	726, 727, 729, 730, 731, 733, 734, 735, 737, 738, 740,
+	741, 742, 744, 745, 746, 748, 749, 750, 752, 753, 754,
+	756, 757, 758, 760, 761, 763, 764, 765, 767, 768, 769,
+	771, 772, 773, 775, 776, 778, 779, 780, 782, 783, 784,
+	786, 787, 789, 790, 791, 793, 794, 795, 797, 798, 800,
+	801, 802, 804, 805, 806, 808, 809, 811, 812, 813, 815,
+	816, 818, 819, 820, 822, 823, 825, 826, 827, 829, 830,
+	832, 833, 834, 836, 837, 839, 840, 841, 843, 844, 846,
+	847, 848, 850, 851, 853, 854, 855, 857, 858, 860, 861,
+	863, 864, 865, 867, 868, 870, 871, 872, 874, 875, 877,
+	878, 880, 881, 882, 884, 885, 887, 888, 890, 891, 892,
+	894, 895, 897, 898, 900, 901, 902, 904, 905, 907, 908,
+	910, 911, 913, 914, 915, 917, 918, 920, 921, 923, 924,
+	926, 927, 929, 930, 931, 933, 934, 936, 937, 939, 940,
+	942, 943, 945, 946, 947, 949, 950, 952, 953, 955, 956,
+	958, 959, 961, 962, 964, 965, 967, 968, 969, 971, 972,
+	974, 975, 977, 978, 980, 981, 983, 984, 986, 987, 989,
+	990, 992, 993, 995, 996, 998, 999, 1001, 1002, 1004, 1005,
+	1007, 1008, 1010, 1011, 1013, 1014, 1016, 1017, 1019, 1020, 1022,
+	1023,
+};
+
+static const u16 xgamma10_16[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4,
+	4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6,
+	7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9,
+	10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12,
+	13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16,
+	16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 20,
+	20, 21, 21, 21, 22, 22, 22, 23, 23, 24, 24,
+	24, 25, 25, 26, 26, 26, 27, 27, 28, 28, 28,
+	29, 29, 30, 30, 31, 31, 31, 32, 32, 33, 33,
+	34, 34, 35, 35, 35, 36, 36, 37, 37, 38, 38,
+	39, 39, 40, 40, 41, 41, 41, 42, 42, 43, 43,
+	44, 44, 45, 45, 46, 46, 47, 47, 48, 48, 49,
+	49, 50, 50, 51, 52, 52, 53, 53, 54, 54, 55,
+	55, 56, 56, 57, 57, 58, 58, 59, 60, 60, 61,
+	61, 62, 62, 63, 63, 64, 65, 65, 66, 66, 67,
+	67, 68, 69, 69, 70, 70, 71, 72, 72, 73, 73,
+	74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 80,
+	81, 81, 82, 82, 83, 84, 84, 85, 86, 86, 87,
+	87, 88, 89, 89, 90, 91, 91, 92, 93, 93, 94,
+	95, 95, 96, 97, 97, 98, 99, 99, 100, 101, 101,
+	102, 103, 103, 104, 105, 105, 106, 107, 107, 108, 109,
+	109, 110, 111, 111, 112, 113, 114, 114, 115, 116, 116,
+	117, 118, 119, 119, 120, 121, 121, 122, 123, 124, 124,
+	125, 126, 126, 127, 128, 129, 129, 130, 131, 132, 132,
+	133, 134, 135, 135, 136, 137, 138, 138, 139, 140, 141,
+	141, 142, 143, 144, 144, 145, 146, 147, 148, 148, 149,
+	150, 151, 151, 152, 153, 154, 155, 155, 156, 157, 158,
+	159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 167,
+	167, 168, 169, 170, 171, 171, 172, 173, 174, 175, 176,
+	176, 177, 178, 179, 180, 181, 181, 182, 183, 184, 185,
+	186, 186, 187, 188, 189, 190, 191, 192, 192, 193, 194,
+	195, 196, 197, 198, 198, 199, 200, 201, 202, 203, 204,
+	204, 205, 206, 207, 208, 209, 210, 211, 212, 212, 213,
+	214, 215, 216, 217, 218, 219, 220, 220, 221, 222, 223,
+	224, 225, 226, 227, 228, 229, 230, 230, 231, 232, 233,
+	234, 235, 236, 237, 238, 239, 240, 241, 242, 242, 243,
+	244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
+	255, 256, 257, 258, 258, 259, 260, 261, 262, 263, 264,
+	265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275,
+	276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286,
+	287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
+	298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308,
+	309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319,
+	320, 321, 322, 323, 324, 325, 326, 327, 329, 330, 331,
+	332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342,
+	343, 344, 345, 346, 348, 349, 350, 351, 352, 353, 354,
+	355, 356, 357, 358, 359, 360, 362, 363, 364, 365, 366,
+	367, 368, 369, 370, 371, 372, 374, 375, 376, 377, 378,
+	379, 380, 381, 382, 383, 385, 386, 387, 388, 389, 390,
+	391, 392, 393, 395, 396, 397, 398, 399, 400, 401, 402,
+	404, 405, 406, 407, 408, 409, 410, 411, 413, 414, 415,
+	416, 417, 418, 419, 421, 422, 423, 424, 425, 426, 428,
+	429, 430, 431, 432, 433, 434, 436, 437, 438, 439, 440,
+	441, 443, 444, 445, 446, 447, 448, 450, 451, 452, 453,
+	454, 456, 457, 458, 459, 460, 461, 463, 464, 465, 466,
+	467, 469, 470, 471, 472, 473, 475, 476, 477, 478, 479,
+	481, 482, 483, 484, 485, 487, 488, 489, 490, 491, 493,
+	494, 495, 496, 498, 499, 500, 501, 502, 504, 505, 506,
+	507, 509, 510, 511, 512, 514, 515, 516, 517, 519, 520,
+	521, 522, 523, 525, 526, 527, 528, 530, 531, 532, 533,
+	535, 536, 537, 538, 540, 541, 542, 544, 545, 546, 547,
+	549, 550, 551, 552, 554, 555, 556, 557, 559, 560, 561,
+	563, 564, 565, 566, 568, 569, 570, 572, 573, 574, 575,
+	577, 578, 579, 581, 582, 583, 584, 586, 587, 588, 590,
+	591, 592, 594, 595, 596, 598, 599, 600, 601, 603, 604,
+	605, 607, 608, 609, 611, 612, 613, 615, 616, 617, 619,
+	620, 621, 623, 624, 625, 627, 628, 629, 631, 632, 633,
+	635, 636, 637, 639, 640, 641, 643, 644, 645, 647, 648,
+	649, 651, 652, 653, 655, 656, 657, 659, 660, 662, 663,
+	664, 666, 667, 668, 670, 671, 672, 674, 675, 677, 678,
+	679, 681, 682, 683, 685, 686, 688, 689, 690, 692, 693,
+	694, 696, 697, 699, 700, 701, 703, 704, 706, 707, 708,
+	710, 711, 712, 714, 715, 717, 718, 719, 721, 722, 724,
+	725, 727, 728, 729, 731, 732, 734, 735, 736, 738, 739,
+	741, 742, 743, 745, 746, 748, 749, 751, 752, 753, 755,
+	756, 758, 759, 761, 762, 763, 765, 766, 768, 769, 771,
+	772, 774, 775, 776, 778, 779, 781, 782, 784, 785, 787,
+	788, 789, 791, 792, 794, 795, 797, 798, 800, 801, 803,
+	804, 805, 807, 808, 810, 811, 813, 814, 816, 817, 819,
+	820, 822, 823, 825, 826, 827, 829, 830, 832, 833, 835,
+	836, 838, 839, 841, 842, 844, 845, 847, 848, 850, 851,
+	853, 854, 856, 857, 859, 860, 862, 863, 865, 866, 868,
+	869, 871, 872, 874, 875, 877, 878, 880, 881, 883, 884,
+	886, 887, 889, 890, 892, 893, 895, 897, 898, 900, 901,
+	903, 904, 906, 907, 909, 910, 912, 913, 915, 916, 918,
+	919, 921, 923, 924, 926, 927, 929, 930, 932, 933, 935,
+	936, 938, 940, 941, 943, 944, 946, 947, 949, 950, 952,
+	954, 955, 957, 958, 960, 961, 963, 964, 966, 968, 969,
+	971, 972, 974, 975, 977, 979, 980, 982, 983, 985, 986,
+	988, 990, 991, 993, 994, 996, 998, 999, 1001, 1002, 1004,
+	1005, 1007, 1009, 1010, 1012, 1013, 1015, 1017, 1018, 1020, 1021,
+	1023,
+};
+
+static const u16 xgamma10_17[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5,
+	5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7,
+	7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9,
+	10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12,
+	13, 13, 13, 13, 14, 14, 14, 15, 15, 15, 15,
+	16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19,
+	19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23,
+	23, 23, 24, 24, 25, 25, 25, 26, 26, 26, 27,
+	27, 28, 28, 28, 29, 29, 29, 30, 30, 31, 31,
+	31, 32, 32, 33, 33, 34, 34, 34, 35, 35, 36,
+	36, 37, 37, 37, 38, 38, 39, 39, 40, 40, 40,
+	41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 46,
+	46, 46, 47, 47, 48, 48, 49, 49, 50, 50, 51,
+	51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56,
+	57, 57, 58, 58, 59, 60, 60, 61, 61, 62, 62,
+	63, 63, 64, 64, 65, 65, 66, 67, 67, 68, 68,
+	69, 69, 70, 70, 71, 72, 72, 73, 73, 74, 74,
+	75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 81,
+	82, 82, 83, 83, 84, 85, 85, 86, 86, 87, 88,
+	88, 89, 89, 90, 91, 91, 92, 93, 93, 94, 95,
+	95, 96, 96, 97, 98, 98, 99, 100, 100, 101, 102,
+	102, 103, 104, 104, 105, 106, 106, 107, 108, 108, 109,
+	110, 110, 111, 112, 112, 113, 114, 114, 115, 116, 116,
+	117, 118, 119, 119, 120, 121, 121, 122, 123, 124, 124,
+	125, 126, 126, 127, 128, 129, 129, 130, 131, 131, 132,
+	133, 134, 134, 135, 136, 137, 137, 138, 139, 140, 140,
+	141, 142, 143, 143, 144, 145, 146, 146, 147, 148, 149,
+	149, 150, 151, 152, 153, 153, 154, 155, 156, 156, 157,
+	158, 159, 160, 160, 161, 162, 163, 164, 164, 165, 166,
+	167, 168, 168, 169, 170, 171, 172, 172, 173, 174, 175,
+	176, 177, 177, 178, 179, 180, 181, 182, 182, 183, 184,
+	185, 186, 187, 187, 188, 189, 190, 191, 192, 193, 193,
+	194, 195, 196, 197, 198, 199, 199, 200, 201, 202, 203,
+	204, 205, 206, 206, 207, 208, 209, 210, 211, 212, 213,
+	213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 222,
+	223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233,
+	233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,
+	244, 245, 246, 247, 248, 248, 249, 250, 251, 252, 253,
+	254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264,
+	265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275,
+	276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286,
+	287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
+	298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308,
+	309, 310, 311, 312, 313, 314, 315, 316, 317, 319, 320,
+	321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331,
+	332, 333, 334, 336, 337, 338, 339, 340, 341, 342, 343,
+	344, 345, 346, 347, 349, 350, 351, 352, 353, 354, 355,
+	356, 357, 358, 360, 361, 362, 363, 364, 365, 366, 367,
+	368, 370, 371, 372, 373, 374, 375, 376, 377, 379, 380,
+	381, 382, 383, 384, 385, 386, 388, 389, 390, 391, 392,
+	393, 394, 396, 397, 398, 399, 400, 401, 403, 404, 405,
+	406, 407, 408, 409, 411, 412, 413, 414, 415, 417, 418,
+	419, 420, 421, 422, 424, 425, 426, 427, 428, 430, 431,
+	432, 433, 434, 435, 437, 438, 439, 440, 441, 443, 444,
+	445, 446, 448, 449, 450, 451, 452, 454, 455, 456, 457,
+	458, 460, 461, 462, 463, 465, 466, 467, 468, 469, 471,
+	472, 473, 474, 476, 477, 478, 479, 481, 482, 483, 484,
+	486, 487, 488, 489, 491, 492, 493, 494, 496, 497, 498,
+	499, 501, 502, 503, 505, 506, 507, 508, 510, 511, 512,
+	513, 515, 516, 517, 519, 520, 521, 522, 524, 525, 526,
+	528, 529, 530, 532, 533, 534, 535, 537, 538, 539, 541,
+	542, 543, 545, 546, 547, 549, 550, 551, 552, 554, 555,
+	556, 558, 559, 560, 562, 563, 564, 566, 567, 568, 570,
+	571, 572, 574, 575, 576, 578, 579, 580, 582, 583, 584,
+	586, 587, 589, 590, 591, 593, 594, 595, 597, 598, 599,
+	601, 602, 604, 605, 606, 608, 609, 610, 612, 613, 615,
+	616, 617, 619, 620, 621, 623, 624, 626, 627, 628, 630,
+	631, 633, 634, 635, 637, 638, 640, 641, 642, 644, 645,
+	647, 648, 649, 651, 652, 654, 655, 656, 658, 659, 661,
+	662, 664, 665, 666, 668, 669, 671, 672, 674, 675, 676,
+	678, 679, 681, 682, 684, 685, 686, 688, 689, 691, 692,
+	694, 695, 697, 698, 699, 701, 702, 704, 705, 707, 708,
+	710, 711, 713, 714, 716, 717, 718, 720, 721, 723, 724,
+	726, 727, 729, 730, 732, 733, 735, 736, 738, 739, 741,
+	742, 744, 745, 747, 748, 750, 751, 753, 754, 756, 757,
+	759, 760, 762, 763, 765, 766, 768, 769, 771, 772, 774,
+	775, 777, 778, 780, 781, 783, 784, 786, 787, 789, 790,
+	792, 793, 795, 797, 798, 800, 801, 803, 804, 806, 807,
+	809, 810, 812, 814, 815, 817, 818, 820, 821, 823, 824,
+	826, 827, 829, 831, 832, 834, 835, 837, 838, 840, 842,
+	843, 845, 846, 848, 849, 851, 853, 854, 856, 857, 859,
+	860, 862, 864, 865, 867, 868, 870, 872, 873, 875, 876,
+	878, 880, 881, 883, 884, 886, 888, 889, 891, 892, 894,
+	896, 897, 899, 900, 902, 904, 905, 907, 908, 910, 912,
+	913, 915, 917, 918, 920, 921, 923, 925, 926, 928, 930,
+	931, 933, 935, 936, 938, 939, 941, 943, 944, 946, 948,
+	949, 951, 953, 954, 956, 958, 959, 961, 963, 964, 966,
+	968, 969, 971, 973, 974, 976, 978, 979, 981, 983, 984,
+	986, 988, 989, 991, 993, 994, 996, 998, 999, 1001, 1003,
+	1004, 1006, 1008, 1009, 1011, 1013, 1015, 1016, 1018, 1020, 1021,
+	1023,
+};
+
+static const u16 xgamma10_18[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
+	4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
+	5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
+	10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12,
+	12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15,
+	15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18,
+	18, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22,
+	22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25,
+	26, 26, 26, 27, 27, 27, 28, 28, 29, 29, 29,
+	30, 30, 30, 31, 31, 32, 32, 32, 33, 33, 33,
+	34, 34, 35, 35, 35, 36, 36, 37, 37, 38, 38,
+	38, 39, 39, 40, 40, 40, 41, 41, 42, 42, 43,
+	43, 43, 44, 44, 45, 45, 46, 46, 47, 47, 48,
+	48, 48, 49, 49, 50, 50, 51, 51, 52, 52, 53,
+	53, 54, 54, 55, 55, 56, 56, 57, 57, 58, 58,
+	59, 59, 60, 60, 61, 61, 62, 62, 63, 63, 64,
+	64, 65, 65, 66, 66, 67, 68, 68, 69, 69, 70,
+	70, 71, 71, 72, 72, 73, 74, 74, 75, 75, 76,
+	76, 77, 78, 78, 79, 79, 80, 80, 81, 82, 82,
+	83, 83, 84, 85, 85, 86, 86, 87, 88, 88, 89,
+	89, 90, 91, 91, 92, 92, 93, 94, 94, 95, 96,
+	96, 97, 97, 98, 99, 99, 100, 101, 101, 102, 103,
+	103, 104, 104, 105, 106, 106, 107, 108, 108, 109, 110,
+	110, 111, 112, 112, 113, 114, 114, 115, 116, 117, 117,
+	118, 119, 119, 120, 121, 121, 122, 123, 123, 124, 125,
+	126, 126, 127, 128, 128, 129, 130, 131, 131, 132, 133,
+	133, 134, 135, 136, 136, 137, 138, 139, 139, 140, 141,
+	142, 142, 143, 144, 145, 145, 146, 147, 148, 148, 149,
+	150, 151, 151, 152, 153, 154, 155, 155, 156, 157, 158,
+	158, 159, 160, 161, 162, 162, 163, 164, 165, 166, 166,
+	167, 168, 169, 170, 170, 171, 172, 173, 174, 175, 175,
+	176, 177, 178, 179, 179, 180, 181, 182, 183, 184, 184,
+	185, 186, 187, 188, 189, 190, 190, 191, 192, 193, 194,
+	195, 196, 196, 197, 198, 199, 200, 201, 202, 203, 203,
+	204, 205, 206, 207, 208, 209, 210, 210, 211, 212, 213,
+	214, 215, 216, 217, 218, 219, 219, 220, 221, 222, 223,
+	224, 225, 226, 227, 228, 229, 230, 230, 231, 232, 233,
+	234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244,
+	245, 246, 247, 247, 248, 249, 250, 251, 252, 253, 254,
+	255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265,
+	266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276,
+	277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287,
+	288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298,
+	299, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310,
+	311, 312, 313, 314, 315, 316, 317, 319, 320, 321, 322,
+	323, 324, 325, 326, 327, 328, 329, 330, 331, 333, 334,
+	335, 336, 337, 338, 339, 340, 341, 342, 344, 345, 346,
+	347, 348, 349, 350, 351, 353, 354, 355, 356, 357, 358,
+	359, 360, 362, 363, 364, 365, 366, 367, 368, 370, 371,
+	372, 373, 374, 375, 376, 378, 379, 380, 381, 382, 383,
+	385, 386, 387, 388, 389, 390, 392, 393, 394, 395, 396,
+	397, 399, 400, 401, 402, 403, 405, 406, 407, 408, 409,
+	411, 412, 413, 414, 415, 417, 418, 419, 420, 421, 423,
+	424, 425, 426, 427, 429, 430, 431, 432, 434, 435, 436,
+	437, 439, 440, 441, 442, 443, 445, 446, 447, 448, 450,
+	451, 452, 453, 455, 456, 457, 458, 460, 461, 462, 464,
+	465, 466, 467, 469, 470, 471, 472, 474, 475, 476, 478,
+	479, 480, 481, 483, 484, 485, 487, 488, 489, 490, 492,
+	493, 494, 496, 497, 498, 500, 501, 502, 504, 505, 506,
+	507, 509, 510, 511, 513, 514, 515, 517, 518, 519, 521,
+	522, 523, 525, 526, 527, 529, 530, 531, 533, 534, 535,
+	537, 538, 540, 541, 542, 544, 545, 546, 548, 549, 550,
+	552, 553, 555, 556, 557, 559, 560, 561, 563, 564, 566,
+	567, 568, 570, 571, 572, 574, 575, 577, 578, 579, 581,
+	582, 584, 585, 586, 588, 589, 591, 592, 594, 595, 596,
+	598, 599, 601, 602, 603, 605, 606, 608, 609, 611, 612,
+	613, 615, 616, 618, 619, 621, 622, 624, 625, 626, 628,
+	629, 631, 632, 634, 635, 637, 638, 640, 641, 642, 644,
+	645, 647, 648, 650, 651, 653, 654, 656, 657, 659, 660,
+	662, 663, 665, 666, 668, 669, 671, 672, 673, 675, 676,
+	678, 679, 681, 682, 684, 686, 687, 689, 690, 692, 693,
+	695, 696, 698, 699, 701, 702, 704, 705, 707, 708, 710,
+	711, 713, 714, 716, 717, 719, 721, 722, 724, 725, 727,
+	728, 730, 731, 733, 734, 736, 738, 739, 741, 742, 744,
+	745, 747, 749, 750, 752, 753, 755, 756, 758, 760, 761,
+	763, 764, 766, 767, 769, 771, 772, 774, 775, 777, 779,
+	780, 782, 783, 785, 787, 788, 790, 791, 793, 795, 796,
+	798, 799, 801, 803, 804, 806, 807, 809, 811, 812, 814,
+	816, 817, 819, 820, 822, 824, 825, 827, 829, 830, 832,
+	834, 835, 837, 839, 840, 842, 843, 845, 847, 848, 850,
+	852, 853, 855, 857, 858, 860, 862, 863, 865, 867, 868,
+	870, 872, 873, 875, 877, 878, 880, 882, 884, 885, 887,
+	889, 890, 892, 894, 895, 897, 899, 900, 902, 904, 906,
+	907, 909, 911, 912, 914, 916, 918, 919, 921, 923, 924,
+	926, 928, 930, 931, 933, 935, 936, 938, 940, 942, 943,
+	945, 947, 949, 950, 952, 954, 956, 957, 959, 961, 963,
+	964, 966, 968, 970, 971, 973, 975, 977, 978, 980, 982,
+	984, 986, 987, 989, 991, 993, 994, 996, 998, 1000, 1002,
+	1003, 1005, 1007, 1009, 1010, 1012, 1014, 1016, 1018, 1019, 1021,
+	1023,
+};
+
+static const u16 xgamma10_19[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
+	4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
+	6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
+	10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12,
+	12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15,
+	15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17,
+	18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21,
+	21, 21, 22, 22, 22, 22, 23, 23, 23, 24, 24,
+	24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 28,
+	28, 28, 29, 29, 29, 30, 30, 30, 31, 31, 32,
+	32, 32, 33, 33, 33, 34, 34, 35, 35, 35, 36,
+	36, 36, 37, 37, 38, 38, 38, 39, 39, 40, 40,
+	41, 41, 41, 42, 42, 43, 43, 43, 44, 44, 45,
+	45, 46, 46, 46, 47, 47, 48, 48, 49, 49, 50,
+	50, 51, 51, 51, 52, 52, 53, 53, 54, 54, 55,
+	55, 56, 56, 57, 57, 58, 58, 59, 59, 60, 60,
+	61, 61, 62, 62, 63, 63, 64, 64, 65, 65, 66,
+	66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71,
+	72, 72, 73, 74, 74, 75, 75, 76, 76, 77, 77,
+	78, 79, 79, 80, 80, 81, 81, 82, 83, 83, 84,
+	84, 85, 85, 86, 87, 87, 88, 88, 89, 90, 90,
+	91, 91, 92, 93, 93, 94, 94, 95, 96, 96, 97,
+	98, 98, 99, 99, 100, 101, 101, 102, 103, 103, 104,
+	105, 105, 106, 107, 107, 108, 108, 109, 110, 110, 111,
+	112, 112, 113, 114, 114, 115, 116, 116, 117, 118, 119,
+	119, 120, 121, 121, 122, 123, 123, 124, 125, 125, 126,
+	127, 128, 128, 129, 130, 130, 131, 132, 133, 133, 134,
+	135, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142,
+	143, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150,
+	151, 152, 153, 154, 154, 155, 156, 157, 157, 158, 159,
+	160, 161, 161, 162, 163, 164, 165, 165, 166, 167, 168,
+	169, 169, 170, 171, 172, 173, 173, 174, 175, 176, 177,
+	178, 178, 179, 180, 181, 182, 183, 183, 184, 185, 186,
+	187, 188, 188, 189, 190, 191, 192, 193, 194, 195, 195,
+	196, 197, 198, 199, 200, 201, 201, 202, 203, 204, 205,
+	206, 207, 208, 209, 209, 210, 211, 212, 213, 214, 215,
+	216, 217, 218, 219, 219, 220, 221, 222, 223, 224, 225,
+	226, 227, 228, 229, 230, 231, 232, 232, 233, 234, 235,
+	236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246,
+	247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257,
+	258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268,
+	269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279,
+	280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290,
+	291, 292, 293, 294, 295, 296, 297, 299, 300, 301, 302,
+	303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 314,
+	315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 326,
+	327, 328, 329, 330, 331, 332, 333, 334, 336, 337, 338,
+	339, 340, 341, 342, 343, 345, 346, 347, 348, 349, 350,
+	351, 353, 354, 355, 356, 357, 358, 360, 361, 362, 363,
+	364, 365, 367, 368, 369, 370, 371, 372, 374, 375, 376,
+	377, 378, 379, 381, 382, 383, 384, 385, 387, 388, 389,
+	390, 391, 393, 394, 395, 396, 397, 399, 400, 401, 402,
+	404, 405, 406, 407, 408, 410, 411, 412, 413, 415, 416,
+	417, 418, 420, 421, 422, 423, 425, 426, 427, 428, 430,
+	431, 432, 433, 435, 436, 437, 439, 440, 441, 442, 444,
+	445, 446, 447, 449, 450, 451, 453, 454, 455, 456, 458,
+	459, 460, 462, 463, 464, 466, 467, 468, 470, 471, 472,
+	473, 475, 476, 477, 479, 480, 481, 483, 484, 485, 487,
+	488, 489, 491, 492, 493, 495, 496, 498, 499, 500, 502,
+	503, 504, 506, 507, 508, 510, 511, 512, 514, 515, 517,
+	518, 519, 521, 522, 523, 525, 526, 528, 529, 530, 532,
+	533, 535, 536, 537, 539, 540, 542, 543, 544, 546, 547,
+	549, 550, 551, 553, 554, 556, 557, 559, 560, 561, 563,
+	564, 566, 567, 569, 570, 572, 573, 574, 576, 577, 579,
+	580, 582, 583, 585, 586, 587, 589, 590, 592, 593, 595,
+	596, 598, 599, 601, 602, 604, 605, 607, 608, 610, 611,
+	613, 614, 616, 617, 619, 620, 622, 623, 625, 626, 628,
+	629, 631, 632, 634, 635, 637, 638, 640, 641, 643, 644,
+	646, 647, 649, 650, 652, 653, 655, 656, 658, 660, 661,
+	663, 664, 666, 667, 669, 670, 672, 674, 675, 677, 678,
+	680, 681, 683, 684, 686, 688, 689, 691, 692, 694, 696,
+	697, 699, 700, 702, 703, 705, 707, 708, 710, 711, 713,
+	715, 716, 718, 719, 721, 723, 724, 726, 728, 729, 731,
+	732, 734, 736, 737, 739, 741, 742, 744, 745, 747, 749,
+	750, 752, 754, 755, 757, 759, 760, 762, 764, 765, 767,
+	768, 770, 772, 773, 775, 777, 778, 780, 782, 783, 785,
+	787, 789, 790, 792, 794, 795, 797, 799, 800, 802, 804,
+	805, 807, 809, 810, 812, 814, 816, 817, 819, 821, 822,
+	824, 826, 828, 829, 831, 833, 834, 836, 838, 840, 841,
+	843, 845, 847, 848, 850, 852, 854, 855, 857, 859, 861,
+	862, 864, 866, 868, 869, 871, 873, 875, 876, 878, 880,
+	882, 883, 885, 887, 889, 891, 892, 894, 896, 898, 899,
+	901, 903, 905, 907, 908, 910, 912, 914, 916, 917, 919,
+	921, 923, 925, 926, 928, 930, 932, 934, 936, 937, 939,
+	941, 943, 945, 947, 948, 950, 952, 954, 956, 958, 959,
+	961, 963, 965, 967, 969, 970, 972, 974, 976, 978, 980,
+	982, 983, 985, 987, 989, 991, 993, 995, 997, 998, 1000,
+	1002, 1004, 1006, 1008, 1010, 1012, 1014, 1015, 1017, 1019, 1021,
+	1023,
+};
+
+static const u16 xgamma10_20[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4,
+	4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6,
+	6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
+	10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12,
+	12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14,
+	14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17,
+	17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20,
+	20, 20, 21, 21, 21, 21, 22, 22, 22, 23, 23,
+	23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26,
+	27, 27, 27, 28, 28, 28, 29, 29, 29, 30, 30,
+	30, 31, 31, 31, 32, 32, 32, 33, 33, 33, 34,
+	34, 35, 35, 35, 36, 36, 36, 37, 37, 38, 38,
+	38, 39, 39, 39, 40, 40, 41, 41, 41, 42, 42,
+	43, 43, 44, 44, 44, 45, 45, 46, 46, 46, 47,
+	47, 48, 48, 49, 49, 49, 50, 50, 51, 51, 52,
+	52, 53, 53, 54, 54, 54, 55, 55, 56, 56, 57,
+	57, 58, 58, 59, 59, 60, 60, 61, 61, 62, 62,
+	63, 63, 64, 64, 65, 65, 66, 66, 67, 67, 68,
+	68, 69, 69, 70, 70, 71, 71, 72, 72, 73, 73,
+	74, 74, 75, 76, 76, 77, 77, 78, 78, 79, 79,
+	80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 86,
+	86, 87, 87, 88, 89, 89, 90, 90, 91, 92, 92,
+	93, 93, 94, 95, 95, 96, 96, 97, 98, 98, 99,
+	99, 100, 101, 101, 102, 103, 103, 104, 105, 105, 106,
+	106, 107, 108, 108, 109, 110, 110, 111, 112, 112, 113,
+	114, 114, 115, 116, 116, 117, 118, 118, 119, 120, 120,
+	121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128,
+	129, 130, 130, 131, 132, 132, 133, 134, 135, 135, 136,
+	137, 137, 138, 139, 140, 140, 141, 142, 143, 143, 144,
+	145, 146, 146, 147, 148, 149, 149, 150, 151, 152, 153,
+	153, 154, 155, 156, 156, 157, 158, 159, 160, 160, 161,
+	162, 163, 164, 164, 165, 166, 167, 168, 168, 169, 170,
+	171, 172, 172, 173, 174, 175, 176, 177, 177, 178, 179,
+	180, 181, 182, 182, 183, 184, 185, 186, 187, 188, 188,
+	189, 190, 191, 192, 193, 194, 194, 195, 196, 197, 198,
+	199, 200, 201, 201, 202, 203, 204, 205, 206, 207, 208,
+	209, 210, 210, 211, 212, 213, 214, 215, 216, 217, 218,
+	219, 220, 221, 221, 222, 223, 224, 225, 226, 227, 228,
+	229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
+	240, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
+	250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260,
+	261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271,
+	273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283,
+	284, 285, 286, 287, 288, 289, 290, 291, 292, 294, 295,
+	296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 307,
+	308, 309, 310, 311, 312, 313, 314, 315, 316, 318, 319,
+	320, 321, 322, 323, 324, 325, 327, 328, 329, 330, 331,
+	332, 333, 335, 336, 337, 338, 339, 340, 341, 343, 344,
+	345, 346, 347, 348, 350, 351, 352, 353, 354, 355, 357,
+	358, 359, 360, 361, 363, 364, 365, 366, 367, 369, 370,
+	371, 372, 373, 375, 376, 377, 378, 379, 381, 382, 383,
+	384, 386, 387, 388, 389, 390, 392, 393, 394, 395, 397,
+	398, 399, 400, 402, 403, 404, 405, 407, 408, 409, 410,
+	412, 413, 414, 416, 417, 418, 419, 421, 422, 423, 425,
+	426, 427, 428, 430, 431, 432, 434, 435, 436, 437, 439,
+	440, 441, 443, 444, 445, 447, 448, 449, 451, 452, 453,
+	455, 456, 457, 459, 460, 461, 463, 464, 465, 467, 468,
+	469, 471, 472, 474, 475, 476, 478, 479, 480, 482, 483,
+	484, 486, 487, 489, 490, 491, 493, 494, 496, 497, 498,
+	500, 501, 503, 504, 505, 507, 508, 510, 511, 512, 514,
+	515, 517, 518, 519, 521, 522, 524, 525, 527, 528, 530,
+	531, 532, 534, 535, 537, 538, 540, 541, 543, 544, 545,
+	547, 548, 550, 551, 553, 554, 556, 557, 559, 560, 562,
+	563, 565, 566, 568, 569, 571, 572, 574, 575, 577, 578,
+	580, 581, 583, 584, 586, 587, 589, 590, 592, 593, 595,
+	596, 598, 599, 601, 602, 604, 605, 607, 609, 610, 612,
+	613, 615, 616, 618, 619, 621, 622, 624, 626, 627, 629,
+	630, 632, 633, 635, 637, 638, 640, 641, 643, 645, 646,
+	648, 649, 651, 652, 654, 656, 657, 659, 660, 662, 664,
+	665, 667, 669, 670, 672, 673, 675, 677, 678, 680, 682,
+	683, 685, 686, 688, 690, 691, 693, 695, 696, 698, 700,
+	701, 703, 705, 706, 708, 710, 711, 713, 715, 716, 718,
+	720, 721, 723, 725, 726, 728, 730, 731, 733, 735, 736,
+	738, 740, 742, 743, 745, 747, 748, 750, 752, 754, 755,
+	757, 759, 760, 762, 764, 766, 767, 769, 771, 773, 774,
+	776, 778, 780, 781, 783, 785, 787, 788, 790, 792, 794,
+	795, 797, 799, 801, 802, 804, 806, 808, 809, 811, 813,
+	815, 817, 818, 820, 822, 824, 826, 827, 829, 831, 833,
+	835, 836, 838, 840, 842, 844, 845, 847, 849, 851, 853,
+	855, 856, 858, 860, 862, 864, 866, 867, 869, 871, 873,
+	875, 877, 878, 880, 882, 884, 886, 888, 890, 892, 893,
+	895, 897, 899, 901, 903, 905, 907, 908, 910, 912, 914,
+	916, 918, 920, 922, 924, 925, 927, 929, 931, 933, 935,
+	937, 939, 941, 943, 945, 946, 948, 950, 952, 954, 956,
+	958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978,
+	979, 981, 983, 985, 987, 989, 991, 993, 995, 997, 999,
+	1001, 1003, 1005, 1007, 1009, 1011, 1013, 1015, 1017, 1019, 1021,
+	1023,
+};
+
+static const u16 xgamma10_21[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
+	9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11,
+	12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14,
+	14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16,
+	16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19,
+	19, 19, 20, 20, 20, 21, 21, 21, 21, 22, 22,
+	22, 22, 23, 23, 23, 24, 24, 24, 24, 25, 25,
+	25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 29,
+	29, 29, 29, 30, 30, 30, 31, 31, 31, 32, 32,
+	33, 33, 33, 34, 34, 34, 35, 35, 35, 36, 36,
+	36, 37, 37, 38, 38, 38, 39, 39, 39, 40, 40,
+	41, 41, 41, 42, 42, 43, 43, 43, 44, 44, 45,
+	45, 45, 46, 46, 47, 47, 47, 48, 48, 49, 49,
+	50, 50, 50, 51, 51, 52, 52, 53, 53, 54, 54,
+	54, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59,
+	59, 60, 60, 61, 61, 62, 62, 63, 63, 64, 64,
+	65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70,
+	70, 71, 71, 72, 72, 73, 74, 74, 75, 75, 76,
+	76, 77, 77, 78, 78, 79, 79, 80, 81, 81, 82,
+	82, 83, 83, 84, 85, 85, 86, 86, 87, 87, 88,
+	89, 89, 90, 90, 91, 91, 92, 93, 93, 94, 94,
+	95, 96, 96, 97, 97, 98, 99, 99, 100, 101, 101,
+	102, 102, 103, 104, 104, 105, 106, 106, 107, 108, 108,
+	109, 110, 110, 111, 111, 112, 113, 113, 114, 115, 115,
+	116, 117, 117, 118, 119, 120, 120, 121, 122, 122, 123,
+	124, 124, 125, 126, 126, 127, 128, 129, 129, 130, 131,
+	131, 132, 133, 134, 134, 135, 136, 136, 137, 138, 139,
+	139, 140, 141, 142, 142, 143, 144, 145, 145, 146, 147,
+	148, 148, 149, 150, 151, 152, 152, 153, 154, 155, 155,
+	156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164,
+	165, 166, 167, 167, 168, 169, 170, 171, 171, 172, 173,
+	174, 175, 176, 176, 177, 178, 179, 180, 181, 181, 182,
+	183, 184, 185, 186, 187, 187, 188, 189, 190, 191, 192,
+	193, 194, 194, 195, 196, 197, 198, 199, 200, 201, 202,
+	202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
+	212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,
+	223, 224, 225, 226, 227, 227, 228, 229, 230, 231, 232,
+	233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,
+	244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
+	255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265,
+	266, 267, 268, 269, 271, 272, 273, 274, 275, 276, 277,
+	278, 279, 280, 281, 282, 283, 284, 285, 286, 288, 289,
+	290, 291, 292, 293, 294, 295, 296, 297, 298, 300, 301,
+	302, 303, 304, 305, 306, 307, 308, 310, 311, 312, 313,
+	314, 315, 316, 317, 319, 320, 321, 322, 323, 324, 326,
+	327, 328, 329, 330, 331, 332, 334, 335, 336, 337, 338,
+	339, 341, 342, 343, 344, 345, 347, 348, 349, 350, 351,
+	353, 354, 355, 356, 357, 359, 360, 361, 362, 363, 365,
+	366, 367, 368, 370, 371, 372, 373, 375, 376, 377, 378,
+	380, 381, 382, 383, 385, 386, 387, 388, 390, 391, 392,
+	393, 395, 396, 397, 399, 400, 401, 402, 404, 405, 406,
+	408, 409, 410, 411, 413, 414, 415, 417, 418, 419, 421,
+	422, 423, 425, 426, 427, 429, 430, 431, 433, 434, 435,
+	437, 438, 439, 441, 442, 443, 445, 446, 447, 449, 450,
+	452, 453, 454, 456, 457, 458, 460, 461, 463, 464, 465,
+	467, 468, 469, 471, 472, 474, 475, 477, 478, 479, 481,
+	482, 484, 485, 486, 488, 489, 491, 492, 494, 495, 496,
+	498, 499, 501, 502, 504, 505, 507, 508, 509, 511, 512,
+	514, 515, 517, 518, 520, 521, 523, 524, 526, 527, 529,
+	530, 532, 533, 535, 536, 538, 539, 541, 542, 544, 545,
+	547, 548, 550, 551, 553, 554, 556, 557, 559, 560, 562,
+	563, 565, 566, 568, 569, 571, 573, 574, 576, 577, 579,
+	580, 582, 583, 585, 587, 588, 590, 591, 593, 595, 596,
+	598, 599, 601, 602, 604, 606, 607, 609, 610, 612, 614,
+	615, 617, 618, 620, 622, 623, 625, 627, 628, 630, 631,
+	633, 635, 636, 638, 640, 641, 643, 645, 646, 648, 650,
+	651, 653, 654, 656, 658, 659, 661, 663, 664, 666, 668,
+	670, 671, 673, 675, 676, 678, 680, 681, 683, 685, 686,
+	688, 690, 692, 693, 695, 697, 698, 700, 702, 704, 705,
+	707, 709, 711, 712, 714, 716, 717, 719, 721, 723, 724,
+	726, 728, 730, 732, 733, 735, 737, 739, 740, 742, 744,
+	746, 747, 749, 751, 753, 755, 756, 758, 760, 762, 764,
+	765, 767, 769, 771, 773, 774, 776, 778, 780, 782, 784,
+	785, 787, 789, 791, 793, 795, 796, 798, 800, 802, 804,
+	806, 807, 809, 811, 813, 815, 817, 819, 821, 822, 824,
+	826, 828, 830, 832, 834, 836, 837, 839, 841, 843, 845,
+	847, 849, 851, 853, 855, 856, 858, 860, 862, 864, 866,
+	868, 870, 872, 874, 876, 878, 880, 882, 883, 885, 887,
+	889, 891, 893, 895, 897, 899, 901, 903, 905, 907, 909,
+	911, 913, 915, 917, 919, 921, 923, 925, 927, 929, 931,
+	933, 935, 937, 939, 941, 943, 945, 947, 949, 951, 953,
+	955, 957, 959, 961, 963, 965, 967, 969, 971, 973, 975,
+	977, 979, 981, 984, 986, 988, 990, 992, 994, 996, 998,
+	1000, 1002, 1004, 1006, 1008, 1010, 1013, 1015, 1017, 1019, 1021,
+	1023,
+};
+
+static const u16 xgamma10_22[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
+	9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11,
+	11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13,
+	13, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16,
+	16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+	18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21,
+	21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24,
+	24, 25, 25, 25, 25, 26, 26, 26, 27, 27, 27,
+	28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 31,
+	31, 31, 32, 32, 32, 33, 33, 33, 34, 34, 34,
+	35, 35, 35, 36, 36, 37, 37, 37, 38, 38, 38,
+	39, 39, 39, 40, 40, 41, 41, 41, 42, 42, 43,
+	43, 43, 44, 44, 44, 45, 45, 46, 46, 46, 47,
+	47, 48, 48, 49, 49, 49, 50, 50, 51, 51, 52,
+	52, 52, 53, 53, 54, 54, 55, 55, 55, 56, 56,
+	57, 57, 58, 58, 59, 59, 60, 60, 61, 61, 61,
+	62, 62, 63, 63, 64, 64, 65, 65, 66, 66, 67,
+	67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 72,
+	73, 73, 74, 75, 75, 76, 76, 77, 77, 78, 78,
+	79, 79, 80, 80, 81, 82, 82, 83, 83, 84, 84,
+	85, 85, 86, 87, 87, 88, 88, 89, 89, 90, 91,
+	91, 92, 92, 93, 94, 94, 95, 95, 96, 97, 97,
+	98, 98, 99, 100, 100, 101, 102, 102, 103, 103, 104,
+	105, 105, 106, 107, 107, 108, 109, 109, 110, 110, 111,
+	112, 112, 113, 114, 114, 115, 116, 116, 117, 118, 118,
+	119, 120, 121, 121, 122, 123, 123, 124, 125, 125, 126,
+	127, 127, 128, 129, 130, 130, 131, 132, 132, 133, 134,
+	135, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142,
+	143, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150,
+	151, 152, 153, 154, 154, 155, 156, 157, 157, 158, 159,
+	160, 161, 161, 162, 163, 164, 165, 166, 166, 167, 168,
+	169, 170, 170, 171, 172, 173, 174, 175, 175, 176, 177,
+	178, 179, 180, 181, 181, 182, 183, 184, 185, 186, 187,
+	187, 188, 189, 190, 191, 192, 193, 194, 194, 195, 196,
+	197, 198, 199, 200, 201, 202, 203, 203, 204, 205, 206,
+	207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 216,
+	217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227,
+	228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
+	239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
+	250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260,
+	261, 262, 263, 264, 265, 266, 267, 269, 270, 271, 272,
+	273, 274, 275, 276, 277, 278, 279, 280, 281, 283, 284,
+	285, 286, 287, 288, 289, 290, 291, 292, 294, 295, 296,
+	297, 298, 299, 300, 301, 303, 304, 305, 306, 307, 308,
+	309, 311, 312, 313, 314, 315, 316, 317, 319, 320, 321,
+	322, 323, 324, 326, 327, 328, 329, 330, 332, 333, 334,
+	335, 336, 338, 339, 340, 341, 342, 344, 345, 346, 347,
+	348, 350, 351, 352, 353, 355, 356, 357, 358, 360, 361,
+	362, 363, 365, 366, 367, 368, 370, 371, 372, 373, 375,
+	376, 377, 378, 380, 381, 382, 384, 385, 386, 387, 389,
+	390, 391, 393, 394, 395, 397, 398, 399, 401, 402, 403,
+	405, 406, 407, 409, 410, 411, 413, 414, 415, 417, 418,
+	419, 421, 422, 423, 425, 426, 427, 429, 430, 432, 433,
+	434, 436, 437, 438, 440, 441, 443, 444, 445, 447, 448,
+	450, 451, 452, 454, 455, 457, 458, 459, 461, 462, 464,
+	465, 467, 468, 469, 471, 472, 474, 475, 477, 478, 480,
+	481, 483, 484, 485, 487, 488, 490, 491, 493, 494, 496,
+	497, 499, 500, 502, 503, 505, 506, 508, 509, 511, 512,
+	514, 515, 517, 518, 520, 521, 523, 524, 526, 527, 529,
+	530, 532, 534, 535, 537, 538, 540, 541, 543, 544, 546,
+	548, 549, 551, 552, 554, 555, 557, 559, 560, 562, 563,
+	565, 567, 568, 570, 571, 573, 575, 576, 578, 579, 581,
+	583, 584, 586, 587, 589, 591, 592, 594, 596, 597, 599,
+	601, 602, 604, 605, 607, 609, 610, 612, 614, 615, 617,
+	619, 620, 622, 624, 625, 627, 629, 631, 632, 634, 636,
+	637, 639, 641, 642, 644, 646, 648, 649, 651, 653, 654,
+	656, 658, 660, 661, 663, 665, 667, 668, 670, 672, 674,
+	675, 677, 679, 681, 682, 684, 686, 688, 689, 691, 693,
+	695, 697, 698, 700, 702, 704, 705, 707, 709, 711, 713,
+	714, 716, 718, 720, 722, 724, 725, 727, 729, 731, 733,
+	735, 736, 738, 740, 742, 744, 746, 747, 749, 751, 753,
+	755, 757, 759, 760, 762, 764, 766, 768, 770, 772, 774,
+	776, 777, 779, 781, 783, 785, 787, 789, 791, 793, 795,
+	796, 798, 800, 802, 804, 806, 808, 810, 812, 814, 816,
+	818, 820, 822, 824, 826, 828, 829, 831, 833, 835, 837,
+	839, 841, 843, 845, 847, 849, 851, 853, 855, 857, 859,
+	861, 863, 865, 867, 869, 871, 873, 875, 877, 879, 881,
+	883, 885, 887, 889, 892, 894, 896, 898, 900, 902, 904,
+	906, 908, 910, 912, 914, 916, 918, 920, 922, 925, 927,
+	929, 931, 933, 935, 937, 939, 941, 943, 945, 948, 950,
+	952, 954, 956, 958, 960, 962, 965, 967, 969, 971, 973,
+	975, 977, 980, 982, 984, 986, 988, 990, 992, 995, 997,
+	999, 1001, 1003, 1005, 1008, 1010, 1012, 1014, 1016, 1019, 1021,
+	1023,
+};
+
+static const u16 xgamma10_23[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
+	9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11,
+	11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13,
+	13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15,
+	15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18,
+	18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20,
+	21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23,
+	23, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26,
+	27, 27, 27, 27, 28, 28, 28, 29, 29, 29, 30,
+	30, 30, 30, 31, 31, 31, 32, 32, 32, 33, 33,
+	33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37,
+	37, 38, 38, 38, 39, 39, 39, 40, 40, 40, 41,
+	41, 42, 42, 42, 43, 43, 43, 44, 44, 45, 45,
+	45, 46, 46, 47, 47, 47, 48, 48, 49, 49, 49,
+	50, 50, 51, 51, 52, 52, 52, 53, 53, 54, 54,
+	55, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59,
+	59, 60, 60, 61, 61, 62, 62, 63, 63, 64, 64,
+	65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70,
+	70, 71, 71, 72, 72, 73, 73, 74, 74, 75, 75,
+	76, 76, 77, 77, 78, 78, 79, 80, 80, 81, 81,
+	82, 82, 83, 83, 84, 85, 85, 86, 86, 87, 87,
+	88, 89, 89, 90, 90, 91, 91, 92, 93, 93, 94,
+	94, 95, 96, 96, 97, 97, 98, 99, 99, 100, 100,
+	101, 102, 102, 103, 104, 104, 105, 106, 106, 107, 107,
+	108, 109, 109, 110, 111, 111, 112, 113, 113, 114, 115,
+	115, 116, 117, 117, 118, 119, 119, 120, 121, 121, 122,
+	123, 124, 124, 125, 126, 126, 127, 128, 128, 129, 130,
+	131, 131, 132, 133, 133, 134, 135, 136, 136, 137, 138,
+	139, 139, 140, 141, 142, 142, 143, 144, 145, 145, 146,
+	147, 148, 148, 149, 150, 151, 152, 152, 153, 154, 155,
+	156, 156, 157, 158, 159, 160, 160, 161, 162, 163, 164,
+	164, 165, 166, 167, 168, 168, 169, 170, 171, 172, 173,
+	174, 174, 175, 176, 177, 178, 179, 179, 180, 181, 182,
+	183, 184, 185, 186, 186, 187, 188, 189, 190, 191, 192,
+	193, 194, 194, 195, 196, 197, 198, 199, 200, 201, 202,
+	203, 204, 204, 205, 206, 207, 208, 209, 210, 211, 212,
+	213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 222,
+	223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233,
+	234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244,
+	245, 246, 248, 249, 250, 251, 252, 253, 254, 255, 256,
+	257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 268,
+	269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 280,
+	281, 282, 283, 284, 285, 286, 287, 288, 290, 291, 292,
+	293, 294, 295, 296, 298, 299, 300, 301, 302, 303, 304,
+	306, 307, 308, 309, 310, 311, 313, 314, 315, 316, 317,
+	319, 320, 321, 322, 323, 325, 326, 327, 328, 329, 331,
+	332, 333, 334, 335, 337, 338, 339, 340, 342, 343, 344,
+	345, 347, 348, 349, 350, 352, 353, 354, 355, 357, 358,
+	359, 360, 362, 363, 364, 366, 367, 368, 369, 371, 372,
+	373, 375, 376, 377, 379, 380, 381, 383, 384, 385, 386,
+	388, 389, 390, 392, 393, 394, 396, 397, 399, 400, 401,
+	403, 404, 405, 407, 408, 409, 411, 412, 414, 415, 416,
+	418, 419, 420, 422, 423, 425, 426, 427, 429, 430, 432,
+	433, 435, 436, 437, 439, 440, 442, 443, 444, 446, 447,
+	449, 450, 452, 453, 455, 456, 458, 459, 460, 462, 463,
+	465, 466, 468, 469, 471, 472, 474, 475, 477, 478, 480,
+	481, 483, 484, 486, 487, 489, 490, 492, 493, 495, 496,
+	498, 499, 501, 502, 504, 506, 507, 509, 510, 512, 513,
+	515, 516, 518, 520, 521, 523, 524, 526, 527, 529, 531,
+	532, 534, 535, 537, 539, 540, 542, 543, 545, 547, 548,
+	550, 551, 553, 555, 556, 558, 560, 561, 563, 565, 566,
+	568, 569, 571, 573, 574, 576, 578, 579, 581, 583, 584,
+	586, 588, 590, 591, 593, 595, 596, 598, 600, 601, 603,
+	605, 606, 608, 610, 612, 613, 615, 617, 619, 620, 622,
+	624, 625, 627, 629, 631, 632, 634, 636, 638, 640, 641,
+	643, 645, 647, 648, 650, 652, 654, 655, 657, 659, 661,
+	663, 664, 666, 668, 670, 672, 674, 675, 677, 679, 681,
+	683, 684, 686, 688, 690, 692, 694, 696, 697, 699, 701,
+	703, 705, 707, 709, 710, 712, 714, 716, 718, 720, 722,
+	724, 725, 727, 729, 731, 733, 735, 737, 739, 741, 743,
+	745, 746, 748, 750, 752, 754, 756, 758, 760, 762, 764,
+	766, 768, 770, 772, 774, 776, 778, 780, 782, 784, 786,
+	787, 789, 791, 793, 795, 797, 799, 801, 803, 805, 807,
+	809, 811, 814, 816, 818, 820, 822, 824, 826, 828, 830,
+	832, 834, 836, 838, 840, 842, 844, 846, 848, 850, 852,
+	854, 857, 859, 861, 863, 865, 867, 869, 871, 873, 875,
+	878, 880, 882, 884, 886, 888, 890, 892, 894, 897, 899,
+	901, 903, 905, 907, 909, 912, 914, 916, 918, 920, 922,
+	925, 927, 929, 931, 933, 936, 938, 940, 942, 944, 946,
+	949, 951, 953, 955, 958, 960, 962, 964, 966, 969, 971,
+	973, 975, 978, 980, 982, 984, 987, 989, 991, 993, 996,
+	998, 1000, 1002, 1005, 1007, 1009, 1012, 1014, 1016, 1018, 1021,
+	1023,
+};
+
+static const u16 xgamma10_24[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9,
+	9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11,
+	11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13,
+	13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15,
+	15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17,
+	17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 20,
+	20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22,
+	23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25,
+	26, 26, 26, 26, 27, 27, 27, 28, 28, 28, 28,
+	29, 29, 29, 30, 30, 30, 31, 31, 31, 32, 32,
+	32, 32, 33, 33, 33, 34, 34, 34, 35, 35, 35,
+	36, 36, 36, 37, 37, 38, 38, 38, 39, 39, 39,
+	40, 40, 40, 41, 41, 41, 42, 42, 43, 43, 43,
+	44, 44, 44, 45, 45, 46, 46, 46, 47, 47, 48,
+	48, 48, 49, 49, 50, 50, 50, 51, 51, 52, 52,
+	53, 53, 53, 54, 54, 55, 55, 56, 56, 56, 57,
+	57, 58, 58, 59, 59, 60, 60, 61, 61, 61, 62,
+	62, 63, 63, 64, 64, 65, 65, 66, 66, 67, 67,
+	68, 68, 69, 69, 70, 70, 71, 71, 72, 72, 73,
+	73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 79,
+	79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 85,
+	85, 86, 86, 87, 87, 88, 89, 89, 90, 90, 91,
+	91, 92, 93, 93, 94, 94, 95, 96, 96, 97, 97,
+	98, 99, 99, 100, 100, 101, 102, 102, 103, 104, 104,
+	105, 106, 106, 107, 107, 108, 109, 109, 110, 111, 111,
+	112, 113, 113, 114, 115, 115, 116, 117, 117, 118, 119,
+	119, 120, 121, 121, 122, 123, 124, 124, 125, 126, 126,
+	127, 128, 129, 129, 130, 131, 131, 132, 133, 134, 134,
+	135, 136, 137, 137, 138, 139, 140, 140, 141, 142, 143,
+	143, 144, 145, 146, 146, 147, 148, 149, 149, 150, 151,
+	152, 153, 153, 154, 155, 156, 157, 157, 158, 159, 160,
+	161, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169,
+	170, 171, 171, 172, 173, 174, 175, 176, 177, 177, 178,
+	179, 180, 181, 182, 183, 184, 184, 185, 186, 187, 188,
+	189, 190, 191, 192, 192, 193, 194, 195, 196, 197, 198,
+	199, 200, 201, 202, 203, 204, 204, 205, 206, 207, 208,
+	209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
+	220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,
+	231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
+	242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252,
+	253, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264,
+	265, 266, 268, 269, 270, 271, 272, 273, 274, 275, 276,
+	277, 279, 280, 281, 282, 283, 284, 285, 287, 288, 289,
+	290, 291, 292, 293, 295, 296, 297, 298, 299, 300, 302,
+	303, 304, 305, 306, 308, 309, 310, 311, 312, 314, 315,
+	316, 317, 318, 320, 321, 322, 323, 324, 326, 327, 328,
+	329, 331, 332, 333, 334, 336, 337, 338, 339, 341, 342,
+	343, 344, 346, 347, 348, 350, 351, 352, 353, 355, 356,
+	357, 359, 360, 361, 363, 364, 365, 367, 368, 369, 370,
+	372, 373, 374, 376, 377, 378, 380, 381, 383, 384, 385,
+	387, 388, 389, 391, 392, 393, 395, 396, 398, 399, 400,
+	402, 403, 405, 406, 407, 409, 410, 412, 413, 414, 416,
+	417, 419, 420, 421, 423, 424, 426, 427, 429, 430, 432,
+	433, 434, 436, 437, 439, 440, 442, 443, 445, 446, 448,
+	449, 451, 452, 454, 455, 457, 458, 460, 461, 463, 464,
+	466, 467, 469, 470, 472, 473, 475, 476, 478, 479, 481,
+	483, 484, 486, 487, 489, 490, 492, 493, 495, 497, 498,
+	500, 501, 503, 505, 506, 508, 509, 511, 512, 514, 516,
+	517, 519, 521, 522, 524, 525, 527, 529, 530, 532, 534,
+	535, 537, 539, 540, 542, 543, 545, 547, 548, 550, 552,
+	553, 555, 557, 559, 560, 562, 564, 565, 567, 569, 570,
+	572, 574, 576, 577, 579, 581, 582, 584, 586, 588, 589,
+	591, 593, 595, 596, 598, 600, 602, 603, 605, 607, 609,
+	610, 612, 614, 616, 618, 619, 621, 623, 625, 627, 628,
+	630, 632, 634, 636, 637, 639, 641, 643, 645, 647, 648,
+	650, 652, 654, 656, 658, 660, 661, 663, 665, 667, 669,
+	671, 673, 674, 676, 678, 680, 682, 684, 686, 688, 690,
+	692, 693, 695, 697, 699, 701, 703, 705, 707, 709, 711,
+	713, 715, 717, 719, 721, 723, 724, 726, 728, 730, 732,
+	734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754,
+	756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 777,
+	779, 781, 783, 785, 787, 789, 791, 793, 795, 797, 799,
+	801, 803, 805, 808, 810, 812, 814, 816, 818, 820, 822,
+	824, 826, 829, 831, 833, 835, 837, 839, 841, 844, 846,
+	848, 850, 852, 854, 856, 859, 861, 863, 865, 867, 870,
+	872, 874, 876, 878, 880, 883, 885, 887, 889, 891, 894,
+	896, 898, 900, 903, 905, 907, 909, 912, 914, 916, 918,
+	921, 923, 925, 927, 930, 932, 934, 936, 939, 941, 943,
+	946, 948, 950, 952, 955, 957, 959, 962, 964, 966, 969,
+	971, 973, 976, 978, 980, 983, 985, 987, 990, 992, 994,
+	997, 999, 1002, 1004, 1006, 1009, 1011, 1013, 1016, 1018, 1021,
+	1023,
+};
+
+static const u16 xgamma10_25[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9,
+	9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11,
+	11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
+	13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14,
+	15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17,
+	17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19,
+	19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 22,
+	22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 25,
+	25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 28,
+	28, 28, 28, 29, 29, 29, 30, 30, 30, 31, 31,
+	31, 31, 32, 32, 32, 33, 33, 33, 34, 34, 34,
+	35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38,
+	38, 39, 39, 39, 40, 40, 40, 41, 41, 42, 42,
+	42, 43, 43, 43, 44, 44, 45, 45, 45, 46, 46,
+	46, 47, 47, 48, 48, 48, 49, 49, 50, 50, 50,
+	51, 51, 52, 52, 53, 53, 53, 54, 54, 55, 55,
+	56, 56, 56, 57, 57, 58, 58, 59, 59, 60, 60,
+	60, 61, 61, 62, 62, 63, 63, 64, 64, 65, 65,
+	66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71,
+	71, 72, 72, 73, 73, 74, 74, 75, 75, 76, 76,
+	77, 77, 78, 78, 79, 79, 80, 80, 81, 82, 82,
+	83, 83, 84, 84, 85, 85, 86, 87, 87, 88, 88,
+	89, 89, 90, 91, 91, 92, 92, 93, 94, 94, 95,
+	95, 96, 97, 97, 98, 98, 99, 100, 100, 101, 102,
+	102, 103, 103, 104, 105, 105, 106, 107, 107, 108, 109,
+	109, 110, 110, 111, 112, 112, 113, 114, 114, 115, 116,
+	117, 117, 118, 119, 119, 120, 121, 121, 122, 123, 123,
+	124, 125, 126, 126, 127, 128, 128, 129, 130, 131, 131,
+	132, 133, 133, 134, 135, 136, 136, 137, 138, 139, 139,
+	140, 141, 142, 143, 143, 144, 145, 146, 146, 147, 148,
+	149, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157,
+	158, 158, 159, 160, 161, 162, 162, 163, 164, 165, 166,
+	167, 167, 168, 169, 170, 171, 172, 173, 173, 174, 175,
+	176, 177, 178, 179, 180, 180, 181, 182, 183, 184, 185,
+	186, 187, 188, 188, 189, 190, 191, 192, 193, 194, 195,
+	196, 197, 198, 199, 200, 200, 201, 202, 203, 204, 205,
+	206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
+	217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227,
+	228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
+	239, 240, 241, 242, 243, 244, 245, 247, 248, 249, 250,
+	251, 252, 253, 254, 255, 256, 257, 258, 260, 261, 262,
+	263, 264, 265, 266, 267, 268, 270, 271, 272, 273, 274,
+	275, 276, 277, 279, 280, 281, 282, 283, 284, 286, 287,
+	288, 289, 290, 291, 293, 294, 295, 296, 297, 298, 300,
+	301, 302, 303, 304, 306, 307, 308, 309, 311, 312, 313,
+	314, 315, 317, 318, 319, 320, 322, 323, 324, 325, 327,
+	328, 329, 330, 332, 333, 334, 336, 337, 338, 339, 341,
+	342, 343, 345, 346, 347, 349, 350, 351, 352, 354, 355,
+	356, 358, 359, 360, 362, 363, 364, 366, 367, 369, 370,
+	371, 373, 374, 375, 377, 378, 379, 381, 382, 384, 385,
+	386, 388, 389, 391, 392, 393, 395, 396, 398, 399, 400,
+	402, 403, 405, 406, 408, 409, 411, 412, 413, 415, 416,
+	418, 419, 421, 422, 424, 425, 427, 428, 430, 431, 433,
+	434, 436, 437, 439, 440, 442, 443, 445, 446, 448, 449,
+	451, 452, 454, 455, 457, 458, 460, 461, 463, 465, 466,
+	468, 469, 471, 472, 474, 476, 477, 479, 480, 482, 483,
+	485, 487, 488, 490, 491, 493, 495, 496, 498, 500, 501,
+	503, 504, 506, 508, 509, 511, 513, 514, 516, 518, 519,
+	521, 523, 524, 526, 528, 529, 531, 533, 534, 536, 538,
+	540, 541, 543, 545, 546, 548, 550, 552, 553, 555, 557,
+	558, 560, 562, 564, 565, 567, 569, 571, 572, 574, 576,
+	578, 580, 581, 583, 585, 587, 588, 590, 592, 594, 596,
+	597, 599, 601, 603, 605, 607, 608, 610, 612, 614, 616,
+	618, 619, 621, 623, 625, 627, 629, 631, 632, 634, 636,
+	638, 640, 642, 644, 646, 648, 649, 651, 653, 655, 657,
+	659, 661, 663, 665, 667, 669, 671, 673, 674, 676, 678,
+	680, 682, 684, 686, 688, 690, 692, 694, 696, 698, 700,
+	702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722,
+	724, 726, 728, 730, 732, 734, 736, 739, 741, 743, 745,
+	747, 749, 751, 753, 755, 757, 759, 761, 763, 766, 768,
+	770, 772, 774, 776, 778, 780, 782, 785, 787, 789, 791,
+	793, 795, 797, 800, 802, 804, 806, 808, 810, 813, 815,
+	817, 819, 821, 824, 826, 828, 830, 832, 835, 837, 839,
+	841, 843, 846, 848, 850, 852, 855, 857, 859, 861, 864,
+	866, 868, 870, 873, 875, 877, 880, 882, 884, 886, 889,
+	891, 893, 896, 898, 900, 903, 905, 907, 910, 912, 914,
+	917, 919, 921, 924, 926, 928, 931, 933, 935, 938, 940,
+	942, 945, 947, 950, 952, 954, 957, 959, 962, 964, 966,
+	969, 971, 974, 976, 979, 981, 983, 986, 988, 991, 993,
+	996, 998, 1001, 1003, 1006, 1008, 1011, 1013, 1016, 1018, 1021,
+	1023,
+};
+
+static const u16 xgamma10_26[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
+	9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
+	11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12,
+	12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14,
+	14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16,
+	16, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19,
+	19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21,
+	21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24,
+	24, 24, 25, 25, 25, 25, 26, 26, 26, 27, 27,
+	27, 27, 28, 28, 28, 28, 29, 29, 29, 30, 30,
+	30, 31, 31, 31, 31, 32, 32, 32, 33, 33, 33,
+	34, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37,
+	37, 38, 38, 38, 39, 39, 39, 40, 40, 40, 41,
+	41, 41, 42, 42, 43, 43, 43, 44, 44, 44, 45,
+	45, 46, 46, 46, 47, 47, 47, 48, 48, 49, 49,
+	49, 50, 50, 51, 51, 51, 52, 52, 53, 53, 54,
+	54, 54, 55, 55, 56, 56, 57, 57, 57, 58, 58,
+	59, 59, 60, 60, 61, 61, 62, 62, 62, 63, 63,
+	64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69,
+	69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74,
+	75, 75, 76, 76, 77, 77, 78, 78, 79, 80, 80,
+	81, 81, 82, 82, 83, 83, 84, 84, 85, 86, 86,
+	87, 87, 88, 88, 89, 90, 90, 91, 91, 92, 93,
+	93, 94, 94, 95, 96, 96, 97, 97, 98, 99, 99,
+	100, 100, 101, 102, 102, 103, 104, 104, 105, 106, 106,
+	107, 107, 108, 109, 109, 110, 111, 111, 112, 113, 113,
+	114, 115, 115, 116, 117, 117, 118, 119, 120, 120, 121,
+	122, 122, 123, 124, 124, 125, 126, 127, 127, 128, 129,
+	129, 130, 131, 132, 132, 133, 134, 135, 135, 136, 137,
+	138, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145,
+	146, 147, 148, 149, 149, 150, 151, 152, 153, 153, 154,
+	155, 156, 157, 157, 158, 159, 160, 161, 162, 162, 163,
+	164, 165, 166, 167, 167, 168, 169, 170, 171, 172, 173,
+	173, 174, 175, 176, 177, 178, 179, 180, 181, 181, 182,
+	183, 184, 185, 186, 187, 188, 189, 190, 191, 191, 192,
+	193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
+	204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214,
+	215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225,
+	226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236,
+	237, 238, 239, 240, 241, 242, 243, 245, 246, 247, 248,
+	249, 250, 251, 252, 253, 254, 256, 257, 258, 259, 260,
+	261, 262, 263, 264, 266, 267, 268, 269, 270, 271, 272,
+	274, 275, 276, 277, 278, 279, 281, 282, 283, 284, 285,
+	286, 288, 289, 290, 291, 292, 294, 295, 296, 297, 299,
+	300, 301, 302, 303, 305, 306, 307, 308, 310, 311, 312,
+	313, 315, 316, 317, 318, 320, 321, 322, 323, 325, 326,
+	327, 329, 330, 331, 333, 334, 335, 336, 338, 339, 340,
+	342, 343, 344, 346, 347, 348, 350, 351, 352, 354, 355,
+	356, 358, 359, 361, 362, 363, 365, 366, 367, 369, 370,
+	372, 373, 374, 376, 377, 379, 380, 381, 383, 384, 386,
+	387, 389, 390, 391, 393, 394, 396, 397, 399, 400, 402,
+	403, 405, 406, 407, 409, 410, 412, 413, 415, 416, 418,
+	419, 421, 422, 424, 425, 427, 428, 430, 432, 433, 435,
+	436, 438, 439, 441, 442, 444, 445, 447, 449, 450, 452,
+	453, 455, 456, 458, 460, 461, 463, 464, 466, 468, 469,
+	471, 472, 474, 476, 477, 479, 481, 482, 484, 485, 487,
+	489, 490, 492, 494, 495, 497, 499, 500, 502, 504, 505,
+	507, 509, 510, 512, 514, 516, 517, 519, 521, 522, 524,
+	526, 528, 529, 531, 533, 535, 536, 538, 540, 542, 543,
+	545, 547, 549, 550, 552, 554, 556, 558, 559, 561, 563,
+	565, 567, 568, 570, 572, 574, 576, 577, 579, 581, 583,
+	585, 587, 588, 590, 592, 594, 596, 598, 600, 601, 603,
+	605, 607, 609, 611, 613, 615, 617, 619, 620, 622, 624,
+	626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646,
+	648, 650, 651, 653, 655, 657, 659, 661, 663, 665, 667,
+	669, 671, 673, 675, 677, 679, 681, 683, 685, 688, 690,
+	692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712,
+	714, 716, 718, 721, 723, 725, 727, 729, 731, 733, 735,
+	737, 740, 742, 744, 746, 748, 750, 752, 755, 757, 759,
+	761, 763, 765, 768, 770, 772, 774, 776, 779, 781, 783,
+	785, 787, 790, 792, 794, 796, 798, 801, 803, 805, 807,
+	810, 812, 814, 816, 819, 821, 823, 826, 828, 830, 832,
+	835, 837, 839, 842, 844, 846, 849, 851, 853, 855, 858,
+	860, 862, 865, 867, 870, 872, 874, 877, 879, 881, 884,
+	886, 888, 891, 893, 896, 898, 900, 903, 905, 908, 910,
+	913, 915, 917, 920, 922, 925, 927, 930, 932, 934, 937,
+	939, 942, 944, 947, 949, 952, 954, 957, 959, 962, 964,
+	967, 969, 972, 974, 977, 979, 982, 984, 987, 990, 992,
+	995, 997, 1000, 1002, 1005, 1007, 1010, 1013, 1015, 1018, 1020,
+	1023,
+};
+
+static const u16 xgamma10_27[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
+	9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
+	10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12,
+	12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14,
+	14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16,
+	16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18,
+	18, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21,
+	21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
+	24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26,
+	26, 27, 27, 27, 27, 28, 28, 28, 29, 29, 29,
+	29, 30, 30, 30, 31, 31, 31, 32, 32, 32, 32,
+	33, 33, 33, 34, 34, 34, 35, 35, 35, 36, 36,
+	36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 40,
+	40, 40, 41, 41, 41, 42, 42, 43, 43, 43, 44,
+	44, 44, 45, 45, 46, 46, 46, 47, 47, 47, 48,
+	48, 49, 49, 49, 50, 50, 51, 51, 51, 52, 52,
+	53, 53, 54, 54, 54, 55, 55, 56, 56, 57, 57,
+	57, 58, 58, 59, 59, 60, 60, 61, 61, 61, 62,
+	62, 63, 63, 64, 64, 65, 65, 66, 66, 67, 67,
+	68, 68, 69, 69, 70, 70, 71, 71, 72, 72, 73,
+	73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 78,
+	79, 79, 80, 81, 81, 82, 82, 83, 83, 84, 84,
+	85, 86, 86, 87, 87, 88, 88, 89, 90, 90, 91,
+	91, 92, 92, 93, 94, 94, 95, 95, 96, 97, 97,
+	98, 99, 99, 100, 100, 101, 102, 102, 103, 104, 104,
+	105, 105, 106, 107, 107, 108, 109, 109, 110, 111, 111,
+	112, 113, 113, 114, 115, 115, 116, 117, 118, 118, 119,
+	120, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127,
+	127, 128, 129, 130, 130, 131, 132, 133, 133, 134, 135,
+	136, 136, 137, 138, 139, 139, 140, 141, 142, 143, 143,
+	144, 145, 146, 146, 147, 148, 149, 150, 150, 151, 152,
+	153, 154, 155, 155, 156, 157, 158, 159, 160, 160, 161,
+	162, 163, 164, 165, 165, 166, 167, 168, 169, 170, 171,
+	172, 172, 173, 174, 175, 176, 177, 178, 179, 180, 180,
+	181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
+	192, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,
+	202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
+	213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
+	224, 225, 226, 227, 228, 229, 230, 231, 233, 234, 235,
+	236, 237, 238, 239, 240, 241, 242, 243, 244, 246, 247,
+	248, 249, 250, 251, 252, 253, 254, 256, 257, 258, 259,
+	260, 261, 262, 263, 265, 266, 267, 268, 269, 270, 272,
+	273, 274, 275, 276, 278, 279, 280, 281, 282, 283, 285,
+	286, 287, 288, 290, 291, 292, 293, 294, 296, 297, 298,
+	299, 301, 302, 303, 304, 306, 307, 308, 309, 311, 312,
+	313, 315, 316, 317, 318, 320, 321, 322, 324, 325, 326,
+	328, 329, 330, 332, 333, 334, 336, 337, 338, 340, 341,
+	342, 344, 345, 346, 348, 349, 351, 352, 353, 355, 356,
+	357, 359, 360, 362, 363, 364, 366, 367, 369, 370, 372,
+	373, 374, 376, 377, 379, 380, 382, 383, 385, 386, 387,
+	389, 390, 392, 393, 395, 396, 398, 399, 401, 402, 404,
+	405, 407, 408, 410, 411, 413, 414, 416, 417, 419, 421,
+	422, 424, 425, 427, 428, 430, 431, 433, 435, 436, 438,
+	439, 441, 442, 444, 446, 447, 449, 450, 452, 454, 455,
+	457, 459, 460, 462, 463, 465, 467, 468, 470, 472, 473,
+	475, 477, 478, 480, 482, 483, 485, 487, 488, 490, 492,
+	494, 495, 497, 499, 500, 502, 504, 506, 507, 509, 511,
+	513, 514, 516, 518, 520, 521, 523, 525, 527, 528, 530,
+	532, 534, 536, 537, 539, 541, 543, 545, 546, 548, 550,
+	552, 554, 556, 557, 559, 561, 563, 565, 567, 569, 570,
+	572, 574, 576, 578, 580, 582, 584, 586, 587, 589, 591,
+	593, 595, 597, 599, 601, 603, 605, 607, 609, 611, 613,
+	614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634,
+	636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656,
+	659, 661, 663, 665, 667, 669, 671, 673, 675, 677, 679,
+	681, 683, 685, 688, 690, 692, 694, 696, 698, 700, 702,
+	705, 707, 709, 711, 713, 715, 717, 720, 722, 724, 726,
+	728, 730, 733, 735, 737, 739, 741, 744, 746, 748, 750,
+	752, 755, 757, 759, 761, 764, 766, 768, 770, 773, 775,
+	777, 779, 782, 784, 786, 789, 791, 793, 795, 798, 800,
+	802, 805, 807, 809, 812, 814, 816, 819, 821, 823, 826,
+	828, 831, 833, 835, 838, 840, 842, 845, 847, 850, 852,
+	854, 857, 859, 862, 864, 867, 869, 871, 874, 876, 879,
+	881, 884, 886, 889, 891, 894, 896, 899, 901, 903, 906,
+	908, 911, 914, 916, 919, 921, 924, 926, 929, 931, 934,
+	936, 939, 941, 944, 947, 949, 952, 954, 957, 959, 962,
+	965, 967, 970, 973, 975, 978, 980, 983, 986, 988, 991,
+	994, 996, 999, 1002, 1004, 1007, 1010, 1012, 1015, 1018, 1020,
+	1023,
+};
+
+static const u16 xgamma10_28[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
+	9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10,
+	10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 12,
+	12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14,
+	14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16,
+	16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18,
+	18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20,
+	20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23,
+	23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26,
+	26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 29,
+	29, 29, 29, 30, 30, 30, 31, 31, 31, 31, 32,
+	32, 32, 33, 33, 33, 34, 34, 34, 35, 35, 35,
+	35, 36, 36, 36, 37, 37, 37, 38, 38, 38, 39,
+	39, 40, 40, 40, 41, 41, 41, 42, 42, 42, 43,
+	43, 43, 44, 44, 45, 45, 45, 46, 46, 46, 47,
+	47, 48, 48, 48, 49, 49, 50, 50, 50, 51, 51,
+	52, 52, 52, 53, 53, 54, 54, 55, 55, 55, 56,
+	56, 57, 57, 58, 58, 58, 59, 59, 60, 60, 61,
+	61, 62, 62, 63, 63, 63, 64, 64, 65, 65, 66,
+	66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71,
+	72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77,
+	77, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83,
+	83, 84, 85, 85, 86, 86, 87, 87, 88, 89, 89,
+	90, 90, 91, 92, 92, 93, 93, 94, 95, 95, 96,
+	96, 97, 98, 98, 99, 99, 100, 101, 101, 102, 103,
+	103, 104, 105, 105, 106, 106, 107, 108, 108, 109, 110,
+	110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 117,
+	118, 119, 119, 120, 121, 122, 122, 123, 124, 124, 125,
+	126, 127, 127, 128, 129, 130, 130, 131, 132, 132, 133,
+	134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 142,
+	143, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151,
+	151, 152, 153, 154, 155, 155, 156, 157, 158, 159, 160,
+	161, 161, 162, 163, 164, 165, 166, 167, 167, 168, 169,
+	170, 171, 172, 173, 174, 175, 175, 176, 177, 178, 179,
+	180, 181, 182, 183, 184, 185, 186, 186, 187, 188, 189,
+	190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,
+	201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211,
+	212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,
+	223, 224, 225, 226, 228, 229, 230, 231, 232, 233, 234,
+	235, 236, 237, 238, 239, 241, 242, 243, 244, 245, 246,
+	247, 248, 249, 251, 252, 253, 254, 255, 256, 257, 259,
+	260, 261, 262, 263, 264, 266, 267, 268, 269, 270, 272,
+	273, 274, 275, 276, 278, 279, 280, 281, 282, 284, 285,
+	286, 287, 289, 290, 291, 292, 294, 295, 296, 297, 299,
+	300, 301, 302, 304, 305, 306, 308, 309, 310, 311, 313,
+	314, 315, 317, 318, 319, 321, 322, 323, 325, 326, 327,
+	329, 330, 331, 333, 334, 336, 337, 338, 340, 341, 342,
+	344, 345, 347, 348, 349, 351, 352, 354, 355, 356, 358,
+	359, 361, 362, 364, 365, 366, 368, 369, 371, 372, 374,
+	375, 377, 378, 380, 381, 383, 384, 386, 387, 389, 390,
+	392, 393, 395, 396, 398, 399, 401, 402, 404, 405, 407,
+	408, 410, 412, 413, 415, 416, 418, 419, 421, 423, 424,
+	426, 427, 429, 431, 432, 434, 435, 437, 439, 440, 442,
+	444, 445, 447, 448, 450, 452, 453, 455, 457, 458, 460,
+	462, 463, 465, 467, 468, 470, 472, 474, 475, 477, 479,
+	480, 482, 484, 486, 487, 489, 491, 493, 494, 496, 498,
+	500, 501, 503, 505, 507, 509, 510, 512, 514, 516, 518,
+	519, 521, 523, 525, 527, 528, 530, 532, 534, 536, 538,
+	539, 541, 543, 545, 547, 549, 551, 553, 554, 556, 558,
+	560, 562, 564, 566, 568, 570, 572, 574, 575, 577, 579,
+	581, 583, 585, 587, 589, 591, 593, 595, 597, 599, 601,
+	603, 605, 607, 609, 611, 613, 615, 617, 619, 621, 623,
+	625, 627, 629, 631, 633, 635, 637, 640, 642, 644, 646,
+	648, 650, 652, 654, 656, 658, 660, 663, 665, 667, 669,
+	671, 673, 675, 678, 680, 682, 684, 686, 688, 690, 693,
+	695, 697, 699, 701, 704, 706, 708, 710, 712, 715, 717,
+	719, 721, 724, 726, 728, 730, 733, 735, 737, 739, 742,
+	744, 746, 749, 751, 753, 755, 758, 760, 762, 765, 767,
+	769, 772, 774, 776, 779, 781, 783, 786, 788, 790, 793,
+	795, 798, 800, 802, 805, 807, 810, 812, 814, 817, 819,
+	822, 824, 827, 829, 831, 834, 836, 839, 841, 844, 846,
+	849, 851, 854, 856, 859, 861, 864, 866, 869, 871, 874,
+	876, 879, 881, 884, 887, 889, 892, 894, 897, 899, 902,
+	905, 907, 910, 912, 915, 918, 920, 923, 925, 928, 931,
+	933, 936, 939, 941, 944, 947, 949, 952, 955, 957, 960,
+	963, 965, 968, 971, 973, 976, 979, 982, 984, 987, 990,
+	992, 995, 998, 1001, 1004, 1006, 1009, 1012, 1015, 1017, 1020,
+	1023,
+};
+
+static const u16 xgamma10_29[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
+	9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12,
+	12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13,
+	14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
+	16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18,
+	18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20,
+	20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22,
+	23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25,
+	25, 26, 26, 26, 26, 27, 27, 27, 28, 28, 28,
+	28, 29, 29, 29, 29, 30, 30, 30, 31, 31, 31,
+	31, 32, 32, 32, 33, 33, 33, 34, 34, 34, 35,
+	35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38,
+	38, 39, 39, 39, 40, 40, 41, 41, 41, 42, 42,
+	42, 43, 43, 43, 44, 44, 44, 45, 45, 46, 46,
+	46, 47, 47, 48, 48, 48, 49, 49, 49, 50, 50,
+	51, 51, 52, 52, 52, 53, 53, 54, 54, 54, 55,
+	55, 56, 56, 57, 57, 57, 58, 58, 59, 59, 60,
+	60, 61, 61, 61, 62, 62, 63, 63, 64, 64, 65,
+	65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70,
+	71, 71, 72, 72, 73, 73, 74, 74, 75, 75, 76,
+	76, 77, 77, 78, 78, 79, 80, 80, 81, 81, 82,
+	82, 83, 83, 84, 85, 85, 86, 86, 87, 87, 88,
+	89, 89, 90, 90, 91, 92, 92, 93, 93, 94, 95,
+	95, 96, 96, 97, 98, 98, 99, 99, 100, 101, 101,
+	102, 103, 103, 104, 105, 105, 106, 107, 107, 108, 109,
+	109, 110, 111, 111, 112, 113, 113, 114, 115, 115, 116,
+	117, 117, 118, 119, 120, 120, 121, 122, 122, 123, 124,
+	125, 125, 126, 127, 128, 128, 129, 130, 131, 131, 132,
+	133, 134, 134, 135, 136, 137, 137, 138, 139, 140, 141,
+	141, 142, 143, 144, 145, 145, 146, 147, 148, 149, 149,
+	150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159,
+	160, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168,
+	169, 170, 171, 172, 173, 174, 175, 175, 176, 177, 178,
+	179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
+	190, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
+	200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,
+	211, 212, 214, 215, 216, 217, 218, 219, 220, 221, 222,
+	223, 224, 225, 226, 227, 228, 229, 231, 232, 233, 234,
+	235, 236, 237, 238, 239, 241, 242, 243, 244, 245, 246,
+	247, 248, 250, 251, 252, 253, 254, 255, 257, 258, 259,
+	260, 261, 263, 264, 265, 266, 267, 269, 270, 271, 272,
+	273, 275, 276, 277, 278, 280, 281, 282, 283, 285, 286,
+	287, 288, 290, 291, 292, 293, 295, 296, 297, 299, 300,
+	301, 302, 304, 305, 306, 308, 309, 310, 312, 313, 314,
+	316, 317, 318, 320, 321, 322, 324, 325, 327, 328, 329,
+	331, 332, 333, 335, 336, 338, 339, 340, 342, 343, 345,
+	346, 348, 349, 350, 352, 353, 355, 356, 358, 359, 361,
+	362, 363, 365, 366, 368, 369, 371, 372, 374, 375, 377,
+	378, 380, 381, 383, 384, 386, 388, 389, 391, 392, 394,
+	395, 397, 398, 400, 402, 403, 405, 406, 408, 409, 411,
+	413, 414, 416, 417, 419, 421, 422, 424, 426, 427, 429,
+	430, 432, 434, 435, 437, 439, 440, 442, 444, 445, 447,
+	449, 450, 452, 454, 456, 457, 459, 461, 462, 464, 466,
+	468, 469, 471, 473, 475, 476, 478, 480, 482, 483, 485,
+	487, 489, 491, 492, 494, 496, 498, 500, 501, 503, 505,
+	507, 509, 511, 512, 514, 516, 518, 520, 522, 524, 525,
+	527, 529, 531, 533, 535, 537, 539, 541, 542, 544, 546,
+	548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568,
+	570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590,
+	592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612,
+	614, 616, 618, 621, 623, 625, 627, 629, 631, 633, 635,
+	637, 640, 642, 644, 646, 648, 650, 652, 655, 657, 659,
+	661, 663, 665, 668, 670, 672, 674, 676, 679, 681, 683,
+	685, 688, 690, 692, 694, 697, 699, 701, 703, 706, 708,
+	710, 712, 715, 717, 719, 722, 724, 726, 729, 731, 733,
+	736, 738, 740, 743, 745, 747, 750, 752, 754, 757, 759,
+	762, 764, 766, 769, 771, 774, 776, 778, 781, 783, 786,
+	788, 791, 793, 795, 798, 800, 803, 805, 808, 810, 813,
+	815, 818, 820, 823, 825, 828, 830, 833, 835, 838, 841,
+	843, 846, 848, 851, 853, 856, 859, 861, 864, 866, 869,
+	872, 874, 877, 879, 882, 885, 887, 890, 893, 895, 898,
+	901, 903, 906, 909, 911, 914, 917, 919, 922, 925, 927,
+	930, 933, 936, 938, 941, 944, 947, 949, 952, 955, 958,
+	960, 963, 966, 969, 972, 974, 977, 980, 983, 986, 989,
+	991, 994, 997, 1000, 1003, 1006, 1009, 1011, 1014, 1017, 1020,
+	1023,
+};
+
+static const u16 xgamma10_30[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
+	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10,
+	10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12,
+	12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
+	14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15,
+	15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17,
+	18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20,
+	20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22,
+	22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25,
+	25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28,
+	28, 28, 28, 29, 29, 29, 30, 30, 30, 30, 31,
+	31, 31, 32, 32, 32, 33, 33, 33, 33, 34, 34,
+	34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38,
+	38, 38, 39, 39, 39, 40, 40, 40, 41, 41, 41,
+	42, 42, 42, 43, 43, 43, 44, 44, 45, 45, 45,
+	46, 46, 46, 47, 47, 48, 48, 48, 49, 49, 50,
+	50, 50, 51, 51, 52, 52, 52, 53, 53, 54, 54,
+	55, 55, 55, 56, 56, 57, 57, 58, 58, 58, 59,
+	59, 60, 60, 61, 61, 62, 62, 63, 63, 63, 64,
+	64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69,
+	70, 70, 71, 71, 72, 72, 73, 73, 74, 74, 75,
+	75, 76, 77, 77, 78, 78, 79, 79, 80, 80, 81,
+	81, 82, 83, 83, 84, 84, 85, 85, 86, 86, 87,
+	88, 88, 89, 89, 90, 91, 91, 92, 92, 93, 94,
+	94, 95, 95, 96, 97, 97, 98, 99, 99, 100, 100,
+	101, 102, 102, 103, 104, 104, 105, 106, 106, 107, 108,
+	108, 109, 110, 110, 111, 112, 112, 113, 114, 114, 115,
+	116, 117, 117, 118, 119, 119, 120, 121, 122, 122, 123,
+	124, 125, 125, 126, 127, 128, 128, 129, 130, 131, 131,
+	132, 133, 134, 134, 135, 136, 137, 137, 138, 139, 140,
+	141, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149,
+	150, 150, 151, 152, 153, 154, 155, 156, 156, 157, 158,
+	159, 160, 161, 162, 162, 163, 164, 165, 166, 167, 168,
+	169, 170, 171, 171, 172, 173, 174, 175, 176, 177, 178,
+	179, 180, 181, 182, 183, 184, 185, 185, 186, 187, 188,
+	189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
+	200, 201, 202, 203, 204, 205, 206, 207, 208, 210, 211,
+	212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,
+	223, 224, 226, 227, 228, 229, 230, 231, 232, 233, 234,
+	236, 237, 238, 239, 240, 241, 242, 244, 245, 246, 247,
+	248, 249, 250, 252, 253, 254, 255, 256, 258, 259, 260,
+	261, 262, 264, 265, 266, 267, 269, 270, 271, 272, 273,
+	275, 276, 277, 278, 280, 281, 282, 284, 285, 286, 287,
+	289, 290, 291, 293, 294, 295, 296, 298, 299, 300, 302,
+	303, 304, 306, 307, 308, 310, 311, 313, 314, 315, 317,
+	318, 319, 321, 322, 324, 325, 326, 328, 329, 331, 332,
+	333, 335, 336, 338, 339, 341, 342, 343, 345, 346, 348,
+	349, 351, 352, 354, 355, 357, 358, 360, 361, 363, 364,
+	366, 367, 369, 370, 372, 373, 375, 376, 378, 379, 381,
+	383, 384, 386, 387, 389, 390, 392, 394, 395, 397, 398,
+	400, 402, 403, 405, 406, 408, 410, 411, 413, 415, 416,
+	418, 419, 421, 423, 424, 426, 428, 429, 431, 433, 435,
+	436, 438, 440, 441, 443, 445, 447, 448, 450, 452, 453,
+	455, 457, 459, 460, 462, 464, 466, 468, 469, 471, 473,
+	475, 477, 478, 480, 482, 484, 486, 487, 489, 491, 493,
+	495, 497, 498, 500, 502, 504, 506, 508, 510, 512, 513,
+	515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535,
+	537, 539, 540, 542, 544, 546, 548, 550, 552, 554, 556,
+	558, 560, 562, 564, 566, 568, 570, 572, 574, 577, 579,
+	581, 583, 585, 587, 589, 591, 593, 595, 597, 599, 601,
+	604, 606, 608, 610, 612, 614, 616, 618, 621, 623, 625,
+	627, 629, 631, 634, 636, 638, 640, 642, 645, 647, 649,
+	651, 653, 656, 658, 660, 662, 665, 667, 669, 671, 674,
+	676, 678, 680, 683, 685, 687, 690, 692, 694, 697, 699,
+	701, 704, 706, 708, 711, 713, 715, 718, 720, 722, 725,
+	727, 730, 732, 734, 737, 739, 742, 744, 746, 749, 751,
+	754, 756, 759, 761, 764, 766, 769, 771, 774, 776, 779,
+	781, 784, 786, 789, 791, 794, 796, 799, 801, 804, 806,
+	809, 812, 814, 817, 819, 822, 824, 827, 830, 832, 835,
+	837, 840, 843, 845, 848, 851, 853, 856, 859, 861, 864,
+	867, 869, 872, 875, 878, 880, 883, 886, 888, 891, 894,
+	897, 899, 902, 905, 908, 910, 913, 916, 919, 922, 924,
+	927, 930, 933, 936, 938, 941, 944, 947, 950, 953, 956,
+	958, 961, 964, 967, 970, 973, 976, 979, 982, 984, 987,
+	990, 993, 996, 999, 1002, 1005, 1008, 1011, 1014, 1017, 1020,
+	1023,
+};
+
+static const u16 xgamma10_31[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
+	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10,
+	10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12,
+	12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
+	13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
+	15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17,
+	17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19,
+	20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22,
+	22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25,
+	25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,
+	28, 28, 28, 28, 29, 29, 29, 30, 30, 30, 30,
+	31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 34,
+	34, 34, 35, 35, 35, 36, 36, 36, 36, 37, 37,
+	37, 38, 38, 38, 39, 39, 39, 40, 40, 41, 41,
+	41, 42, 42, 42, 43, 43, 43, 44, 44, 44, 45,
+	45, 46, 46, 46, 47, 47, 47, 48, 48, 49, 49,
+	49, 50, 50, 51, 51, 51, 52, 52, 53, 53, 54,
+	54, 54, 55, 55, 56, 56, 57, 57, 57, 58, 58,
+	59, 59, 60, 60, 61, 61, 61, 62, 62, 63, 63,
+	64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69,
+	69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74,
+	75, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80,
+	81, 81, 82, 82, 83, 84, 84, 85, 85, 86, 86,
+	87, 88, 88, 89, 89, 90, 91, 91, 92, 92, 93,
+	94, 94, 95, 95, 96, 97, 97, 98, 99, 99, 100,
+	101, 101, 102, 102, 103, 104, 104, 105, 106, 106, 107,
+	108, 108, 109, 110, 111, 111, 112, 113, 113, 114, 115,
+	115, 116, 117, 118, 118, 119, 120, 120, 121, 122, 123,
+	123, 124, 125, 126, 126, 127, 128, 129, 129, 130, 131,
+	132, 132, 133, 134, 135, 136, 136, 137, 138, 139, 140,
+	140, 141, 142, 143, 144, 144, 145, 146, 147, 148, 149,
+	149, 150, 151, 152, 153, 154, 155, 155, 156, 157, 158,
+	159, 160, 161, 162, 162, 163, 164, 165, 166, 167, 168,
+	169, 170, 171, 171, 172, 173, 174, 175, 176, 177, 178,
+	179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
+	190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,
+	201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211,
+	212, 213, 214, 216, 217, 218, 219, 220, 221, 222, 223,
+	224, 225, 227, 228, 229, 230, 231, 232, 233, 234, 236,
+	237, 238, 239, 240, 241, 243, 244, 245, 246, 247, 248,
+	250, 251, 252, 253, 254, 256, 257, 258, 259, 260, 262,
+	263, 264, 265, 267, 268, 269, 270, 272, 273, 274, 275,
+	277, 278, 279, 281, 282, 283, 285, 286, 287, 288, 290,
+	291, 292, 294, 295, 296, 298, 299, 300, 302, 303, 305,
+	306, 307, 309, 310, 311, 313, 314, 316, 317, 318, 320,
+	321, 323, 324, 325, 327, 328, 330, 331, 333, 334, 336,
+	337, 338, 340, 341, 343, 344, 346, 347, 349, 350, 352,
+	353, 355, 356, 358, 359, 361, 362, 364, 366, 367, 369,
+	370, 372, 373, 375, 376, 378, 380, 381, 383, 384, 386,
+	388, 389, 391, 392, 394, 396, 397, 399, 401, 402, 404,
+	406, 407, 409, 411, 412, 414, 416, 417, 419, 421, 422,
+	424, 426, 427, 429, 431, 433, 434, 436, 438, 440, 441,
+	443, 445, 447, 448, 450, 452, 454, 456, 457, 459, 461,
+	463, 465, 466, 468, 470, 472, 474, 476, 477, 479, 481,
+	483, 485, 487, 489, 490, 492, 494, 496, 498, 500, 502,
+	504, 506, 508, 510, 511, 513, 515, 517, 519, 521, 523,
+	525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545,
+	547, 549, 551, 553, 555, 557, 559, 561, 564, 566, 568,
+	570, 572, 574, 576, 578, 580, 582, 584, 587, 589, 591,
+	593, 595, 597, 599, 602, 604, 606, 608, 610, 613, 615,
+	617, 619, 621, 624, 626, 628, 630, 632, 635, 637, 639,
+	641, 644, 646, 648, 651, 653, 655, 657, 660, 662, 664,
+	667, 669, 671, 674, 676, 678, 681, 683, 685, 688, 690,
+	692, 695, 697, 700, 702, 704, 707, 709, 712, 714, 717,
+	719, 721, 724, 726, 729, 731, 734, 736, 739, 741, 744,
+	746, 749, 751, 754, 756, 759, 761, 764, 766, 769, 772,
+	774, 777, 779, 782, 784, 787, 790, 792, 795, 797, 800,
+	803, 805, 808, 811, 813, 816, 819, 821, 824, 827, 829,
+	832, 835, 837, 840, 843, 845, 848, 851, 854, 856, 859,
+	862, 865, 867, 870, 873, 876, 879, 881, 884, 887, 890,
+	893, 895, 898, 901, 904, 907, 910, 913, 915, 918, 921,
+	924, 927, 930, 933, 936, 939, 942, 945, 947, 950, 953,
+	956, 959, 962, 965, 968, 971, 974, 977, 980, 983, 986,
+	989, 992, 995, 998, 1001, 1005, 1008, 1011, 1014, 1017, 1020,
+	1023,
+};
+
+static const u16 xgamma10_32[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
+	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10,
+	10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12,
+	12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
+	13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
+	15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17,
+	17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19,
+	20, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22,
+	22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24,
+	25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27,
+	27, 28, 28, 28, 28, 29, 29, 29, 30, 30, 30,
+	30, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33,
+	34, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37,
+	37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 41,
+	41, 41, 42, 42, 42, 43, 43, 43, 44, 44, 44,
+	45, 45, 46, 46, 46, 47, 47, 48, 48, 48, 49,
+	49, 49, 50, 50, 51, 51, 51, 52, 52, 53, 53,
+	54, 54, 54, 55, 55, 56, 56, 57, 57, 57, 58,
+	58, 59, 59, 60, 60, 61, 61, 62, 62, 62, 63,
+	63, 64, 64, 65, 65, 66, 66, 67, 67, 68, 68,
+	69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74,
+	74, 75, 75, 76, 77, 77, 78, 78, 79, 79, 80,
+	80, 81, 81, 82, 83, 83, 84, 84, 85, 85, 86,
+	87, 87, 88, 88, 89, 90, 90, 91, 91, 92, 93,
+	93, 94, 95, 95, 96, 96, 97, 98, 98, 99, 100,
+	100, 101, 102, 102, 103, 104, 104, 105, 106, 106, 107,
+	108, 108, 109, 110, 110, 111, 112, 112, 113, 114, 114,
+	115, 116, 117, 117, 118, 119, 120, 120, 121, 122, 122,
+	123, 124, 125, 125, 126, 127, 128, 129, 129, 130, 131,
+	132, 132, 133, 134, 135, 136, 136, 137, 138, 139, 140,
+	140, 141, 142, 143, 144, 145, 145, 146, 147, 148, 149,
+	150, 150, 151, 152, 153, 154, 155, 156, 157, 157, 158,
+	159, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168,
+	169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
+	180, 181, 182, 183, 184, 185, 186, 186, 187, 188, 189,
+	190, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,
+	202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
+	214, 215, 216, 217, 218, 219, 220, 221, 222, 224, 225,
+	226, 227, 228, 229, 230, 231, 233, 234, 235, 236, 237,
+	238, 240, 241, 242, 243, 244, 246, 247, 248, 249, 250,
+	252, 253, 254, 255, 257, 258, 259, 260, 262, 263, 264,
+	265, 267, 268, 269, 270, 272, 273, 274, 276, 277, 278,
+	280, 281, 282, 283, 285, 286, 287, 289, 290, 291, 293,
+	294, 296, 297, 298, 300, 301, 302, 304, 305, 307, 308,
+	309, 311, 312, 314, 315, 316, 318, 319, 321, 322, 324,
+	325, 327, 328, 330, 331, 332, 334, 335, 337, 338, 340,
+	341, 343, 344, 346, 347, 349, 351, 352, 354, 355, 357,
+	358, 360, 361, 363, 364, 366, 368, 369, 371, 372, 374,
+	376, 377, 379, 380, 382, 384, 385, 387, 389, 390, 392,
+	394, 395, 397, 399, 400, 402, 404, 405, 407, 409, 410,
+	412, 414, 416, 417, 419, 421, 423, 424, 426, 428, 430,
+	431, 433, 435, 437, 438, 440, 442, 444, 446, 447, 449,
+	451, 453, 455, 457, 458, 460, 462, 464, 466, 468, 469,
+	471, 473, 475, 477, 479, 481, 483, 485, 487, 488, 490,
+	492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512,
+	514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534,
+	536, 538, 540, 542, 544, 547, 549, 551, 553, 555, 557,
+	559, 561, 563, 565, 568, 570, 572, 574, 576, 578, 581,
+	583, 585, 587, 589, 591, 594, 596, 598, 600, 602, 605,
+	607, 609, 611, 614, 616, 618, 620, 623, 625, 627, 630,
+	632, 634, 636, 639, 641, 643, 646, 648, 650, 653, 655,
+	657, 660, 662, 665, 667, 669, 672, 674, 677, 679, 681,
+	684, 686, 689, 691, 694, 696, 698, 701, 703, 706, 708,
+	711, 713, 716, 718, 721, 723, 726, 728, 731, 734, 736,
+	739, 741, 744, 746, 749, 751, 754, 757, 759, 762, 765,
+	767, 770, 772, 775, 778, 780, 783, 786, 788, 791, 794,
+	796, 799, 802, 804, 807, 810, 813, 815, 818, 821, 824,
+	826, 829, 832, 835, 838, 840, 843, 846, 849, 852, 854,
+	857, 860, 863, 866, 869, 871, 874, 877, 880, 883, 886,
+	889, 892, 895, 897, 900, 903, 906, 909, 912, 915, 918,
+	921, 924, 927, 930, 933, 936, 939, 942, 945, 948, 951,
+	954, 957, 960, 963, 967, 970, 973, 976, 979, 982, 985,
+	988, 991, 994, 998, 1001, 1004, 1007, 1010, 1013, 1017, 1020,
+	1023,
+};
+
+static const u16 xgamma10_33[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+	8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
+	9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10,
+	10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12,
+	12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
+	13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
+	15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17,
+	17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+	19, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22,
+	22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24,
+	24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27,
+	27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30,
+	30, 31, 31, 31, 31, 32, 32, 32, 33, 33, 33,
+	33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37,
+	37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 40,
+	41, 41, 41, 42, 42, 42, 43, 43, 44, 44, 44,
+	45, 45, 45, 46, 46, 47, 47, 47, 48, 48, 48,
+	49, 49, 50, 50, 50, 51, 51, 52, 52, 53, 53,
+	53, 54, 54, 55, 55, 55, 56, 56, 57, 57, 58,
+	58, 59, 59, 59, 60, 60, 61, 61, 62, 62, 63,
+	63, 64, 64, 65, 65, 66, 66, 67, 67, 68, 68,
+	69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74,
+	74, 75, 75, 76, 76, 77, 77, 78, 79, 79, 80,
+	80, 81, 81, 82, 82, 83, 84, 84, 85, 85, 86,
+	87, 87, 88, 88, 89, 90, 90, 91, 91, 92, 93,
+	93, 94, 94, 95, 96, 96, 97, 98, 98, 99, 100,
+	100, 101, 102, 102, 103, 104, 104, 105, 106, 106, 107,
+	108, 108, 109, 110, 110, 111, 112, 112, 113, 114, 115,
+	115, 116, 117, 118, 118, 119, 120, 120, 121, 122, 123,
+	123, 124, 125, 126, 127, 127, 128, 129, 130, 130, 131,
+	132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140,
+	141, 142, 143, 143, 144, 145, 146, 147, 148, 148, 149,
+	150, 151, 152, 153, 154, 155, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 165, 166, 167, 168, 169,
+	170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,
+	181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
+	192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202,
+	203, 204, 206, 207, 208, 209, 210, 211, 212, 213, 214,
+	215, 216, 218, 219, 220, 221, 222, 223, 224, 226, 227,
+	228, 229, 230, 231, 233, 234, 235, 236, 237, 238, 240,
+	241, 242, 243, 245, 246, 247, 248, 249, 251, 252, 253,
+	254, 256, 257, 258, 259, 261, 262, 263, 265, 266, 267,
+	268, 270, 271, 272, 274, 275, 276, 278, 279, 280, 282,
+	283, 284, 286, 287, 288, 290, 291, 292, 294, 295, 297,
+	298, 299, 301, 302, 304, 305, 307, 308, 309, 311, 312,
+	314, 315, 317, 318, 320, 321, 322, 324, 325, 327, 328,
+	330, 331, 333, 334, 336, 337, 339, 341, 342, 344, 345,
+	347, 348, 350, 351, 353, 355, 356, 358, 359, 361, 362,
+	364, 366, 367, 369, 371, 372, 374, 375, 377, 379, 380,
+	382, 384, 385, 387, 389, 390, 392, 394, 395, 397, 399,
+	401, 402, 404, 406, 408, 409, 411, 413, 414, 416, 418,
+	420, 422, 423, 425, 427, 429, 431, 432, 434, 436, 438,
+	440, 441, 443, 445, 447, 449, 451, 453, 454, 456, 458,
+	460, 462, 464, 466, 468, 470, 472, 473, 475, 477, 479,
+	481, 483, 485, 487, 489, 491, 493, 495, 497, 499, 501,
+	503, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523,
+	525, 528, 530, 532, 534, 536, 538, 540, 542, 544, 547,
+	549, 551, 553, 555, 557, 559, 562, 564, 566, 568, 570,
+	573, 575, 577, 579, 581, 584, 586, 588, 590, 593, 595,
+	597, 599, 602, 604, 606, 609, 611, 613, 615, 618, 620,
+	622, 625, 627, 629, 632, 634, 637, 639, 641, 644, 646,
+	648, 651, 653, 656, 658, 661, 663, 665, 668, 670, 673,
+	675, 678, 680, 683, 685, 688, 690, 693, 695, 698, 700,
+	703, 705, 708, 710, 713, 716, 718, 721, 723, 726, 729,
+	731, 734, 736, 739, 742, 744, 747, 750, 752, 755, 758,
+	760, 763, 766, 768, 771, 774, 776, 779, 782, 785, 787,
+	790, 793, 796, 798, 801, 804, 807, 810, 812, 815, 818,
+	821, 824, 827, 829, 832, 835, 838, 841, 844, 847, 850,
+	852, 855, 858, 861, 864, 867, 870, 873, 876, 879, 882,
+	885, 888, 891, 894, 897, 900, 903, 906, 909, 912, 915,
+	918, 921, 924, 927, 930, 933, 937, 940, 943, 946, 949,
+	952, 955, 958, 962, 965, 968, 971, 974, 978, 981, 984,
+	987, 990, 994, 997, 1000, 1003, 1007, 1010, 1013, 1016, 1020,
+	1023,
+};
+
+static const u16 xgamma10_34[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8,
+	8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
+	9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10,
+	10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12,
+	12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
+	13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
+	15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17,
+	17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+	19, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22,
+	22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24,
+	24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27,
+	27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30,
+	30, 30, 31, 31, 31, 32, 32, 32, 33, 33, 33,
+	33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37,
+	37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 40,
+	41, 41, 41, 42, 42, 42, 43, 43, 43, 44, 44,
+	45, 45, 45, 46, 46, 46, 47, 47, 48, 48, 48,
+	49, 49, 50, 50, 50, 51, 51, 52, 52, 52, 53,
+	53, 54, 54, 55, 55, 55, 56, 56, 57, 57, 58,
+	58, 59, 59, 59, 60, 60, 61, 61, 62, 62, 63,
+	63, 64, 64, 65, 65, 66, 66, 67, 67, 68, 68,
+	69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74,
+	74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 80,
+	80, 81, 81, 82, 83, 83, 84, 84, 85, 86, 86,
+	87, 87, 88, 88, 89, 90, 90, 91, 92, 92, 93,
+	93, 94, 95, 95, 96, 97, 97, 98, 99, 99, 100,
+	101, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107,
+	108, 109, 109, 110, 111, 111, 112, 113, 114, 114, 115,
+	116, 117, 117, 118, 119, 119, 120, 121, 122, 123, 123,
+	124, 125, 126, 126, 127, 128, 129, 129, 130, 131, 132,
+	133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141,
+	142, 143, 143, 144, 145, 146, 147, 148, 149, 149, 150,
+	151, 152, 153, 154, 155, 156, 157, 157, 158, 159, 160,
+	161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
+	172, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,
+	182, 183, 184, 185, 186, 187, 188, 189, 191, 192, 193,
+	194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204,
+	205, 207, 208, 209, 210, 211, 212, 213, 214, 215, 217,
+	218, 219, 220, 221, 222, 223, 225, 226, 227, 228, 229,
+	231, 232, 233, 234, 235, 237, 238, 239, 240, 241, 243,
+	244, 245, 246, 248, 249, 250, 251, 253, 254, 255, 256,
+	258, 259, 260, 262, 263, 264, 266, 267, 268, 269, 271,
+	272, 273, 275, 276, 278, 279, 280, 282, 283, 284, 286,
+	287, 288, 290, 291, 293, 294, 296, 297, 298, 300, 301,
+	303, 304, 306, 307, 308, 310, 311, 313, 314, 316, 317,
+	319, 320, 322, 323, 325, 326, 328, 329, 331, 332, 334,
+	335, 337, 339, 340, 342, 343, 345, 346, 348, 350, 351,
+	353, 354, 356, 358, 359, 361, 363, 364, 366, 367, 369,
+	371, 372, 374, 376, 377, 379, 381, 383, 384, 386, 388,
+	389, 391, 393, 395, 396, 398, 400, 402, 403, 405, 407,
+	409, 410, 412, 414, 416, 418, 419, 421, 423, 425, 427,
+	429, 430, 432, 434, 436, 438, 440, 442, 443, 445, 447,
+	449, 451, 453, 455, 457, 459, 461, 463, 464, 466, 468,
+	470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490,
+	492, 494, 496, 498, 500, 503, 505, 507, 509, 511, 513,
+	515, 517, 519, 521, 523, 526, 528, 530, 532, 534, 536,
+	538, 541, 543, 545, 547, 549, 551, 554, 556, 558, 560,
+	563, 565, 567, 569, 572, 574, 576, 578, 581, 583, 585,
+	587, 590, 592, 594, 597, 599, 601, 604, 606, 608, 611,
+	613, 615, 618, 620, 623, 625, 627, 630, 632, 635, 637,
+	640, 642, 644, 647, 649, 652, 654, 657, 659, 662, 664,
+	667, 669, 672, 674, 677, 679, 682, 685, 687, 690, 692,
+	695, 697, 700, 703, 705, 708, 711, 713, 716, 718, 721,
+	724, 726, 729, 732, 734, 737, 740, 743, 745, 748, 751,
+	753, 756, 759, 762, 764, 767, 770, 773, 776, 778, 781,
+	784, 787, 790, 793, 795, 798, 801, 804, 807, 810, 813,
+	815, 818, 821, 824, 827, 830, 833, 836, 839, 842, 845,
+	848, 851, 854, 857, 860, 863, 866, 869, 872, 875, 878,
+	881, 884, 887, 890, 893, 896, 899, 903, 906, 909, 912,
+	915, 918, 921, 925, 928, 931, 934, 937, 940, 944, 947,
+	950, 953, 957, 960, 963, 966, 970, 973, 976, 979, 983,
+	986, 989, 993, 996, 999, 1003, 1006, 1009, 1013, 1016, 1020,
+	1023,
+};
+
+static const u16 xgamma10_35[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8,
+	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9,
+	9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12,
+	12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
+	13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
+	15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17,
+	17, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+	20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22,
+	22, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24,
+	24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27,
+	27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30,
+	30, 31, 31, 31, 31, 32, 32, 32, 33, 33, 33,
+	33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37,
+	37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 40,
+	41, 41, 41, 42, 42, 42, 43, 43, 43, 44, 44,
+	45, 45, 45, 46, 46, 47, 47, 47, 48, 48, 48,
+	49, 49, 50, 50, 50, 51, 51, 52, 52, 53, 53,
+	53, 54, 54, 55, 55, 56, 56, 56, 57, 57, 58,
+	58, 59, 59, 60, 60, 60, 61, 61, 62, 62, 63,
+	63, 64, 64, 65, 65, 66, 66, 67, 67, 68, 68,
+	69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74,
+	75, 75, 76, 76, 77, 77, 78, 78, 79, 79, 80,
+	81, 81, 82, 82, 83, 84, 84, 85, 85, 86, 86,
+	87, 88, 88, 89, 89, 90, 91, 91, 92, 93, 93,
+	94, 95, 95, 96, 96, 97, 98, 98, 99, 100, 100,
+	101, 102, 102, 103, 104, 104, 105, 106, 107, 107, 108,
+	109, 109, 110, 111, 111, 112, 113, 114, 114, 115, 116,
+	117, 117, 118, 119, 120, 120, 121, 122, 123, 123, 124,
+	125, 126, 126, 127, 128, 129, 130, 130, 131, 132, 133,
+	134, 135, 135, 136, 137, 138, 139, 140, 140, 141, 142,
+	143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152,
+	153, 154, 154, 155, 156, 157, 158, 159, 160, 161, 162,
+	163, 164, 165, 166, 167, 167, 168, 169, 170, 171, 172,
+	173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
+	184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195,
+	196, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207,
+	208, 209, 210, 211, 213, 214, 215, 216, 217, 218, 219,
+	221, 222, 223, 224, 225, 227, 228, 229, 230, 231, 233,
+	234, 235, 236, 237, 239, 240, 241, 242, 244, 245, 246,
+	247, 249, 250, 251, 253, 254, 255, 256, 258, 259, 260,
+	262, 263, 264, 266, 267, 268, 270, 271, 272, 274, 275,
+	277, 278, 279, 281, 282, 284, 285, 286, 288, 289, 291,
+	292, 293, 295, 296, 298, 299, 301, 302, 304, 305, 307,
+	308, 310, 311, 313, 314, 316, 317, 319, 320, 322, 323,
+	325, 326, 328, 329, 331, 332, 334, 336, 337, 339, 340,
+	342, 344, 345, 347, 348, 350, 352, 353, 355, 357, 358,
+	360, 362, 363, 365, 367, 368, 370, 372, 373, 375, 377,
+	378, 380, 382, 384, 385, 387, 389, 391, 392, 394, 396,
+	398, 400, 401, 403, 405, 407, 409, 410, 412, 414, 416,
+	418, 420, 421, 423, 425, 427, 429, 431, 433, 435, 436,
+	438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458,
+	460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480,
+	482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 503,
+	505, 507, 509, 511, 513, 515, 517, 520, 522, 524, 526,
+	528, 531, 533, 535, 537, 539, 542, 544, 546, 548, 550,
+	553, 555, 557, 560, 562, 564, 566, 569, 571, 573, 576,
+	578, 580, 583, 585, 587, 590, 592, 594, 597, 599, 602,
+	604, 606, 609, 611, 614, 616, 618, 621, 623, 626, 628,
+	631, 633, 636, 638, 641, 643, 646, 648, 651, 653, 656,
+	658, 661, 664, 666, 669, 671, 674, 677, 679, 682, 684,
+	687, 690, 692, 695, 698, 700, 703, 706, 708, 711, 714,
+	716, 719, 722, 725, 727, 730, 733, 736, 738, 741, 744,
+	747, 750, 752, 755, 758, 761, 764, 766, 769, 772, 775,
+	778, 781, 784, 787, 789, 792, 795, 798, 801, 804, 807,
+	810, 813, 816, 819, 822, 825, 828, 831, 834, 837, 840,
+	843, 846, 849, 852, 855, 858, 862, 865, 868, 871, 874,
+	877, 880, 883, 887, 890, 893, 896, 899, 902, 906, 909,
+	912, 915, 919, 922, 925, 928, 932, 935, 938, 941, 945,
+	948, 951, 955, 958, 961, 965, 968, 971, 975, 978, 982,
+	985, 988, 992, 995, 999, 1002, 1006, 1009, 1013, 1016, 1020,
+	1023,
+};
+
+static const u16 xgamma10_36[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8,
+	8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
+	9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10,
+	10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12,
+	12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13,
+	14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15,
+	15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17,
+	17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19,
+	20, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22,
+	22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24,
+	25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27,
+	27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30,
+	30, 31, 31, 31, 31, 32, 32, 32, 33, 33, 33,
+	34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 37,
+	37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 40,
+	41, 41, 41, 42, 42, 43, 43, 43, 44, 44, 44,
+	45, 45, 46, 46, 46, 47, 47, 47, 48, 48, 49,
+	49, 49, 50, 50, 51, 51, 52, 52, 52, 53, 53,
+	54, 54, 54, 55, 55, 56, 56, 57, 57, 58, 58,
+	58, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63,
+	64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69,
+	69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74,
+	75, 76, 76, 77, 77, 78, 78, 79, 79, 80, 81,
+	81, 82, 82, 83, 83, 84, 85, 85, 86, 86, 87,
+	88, 88, 89, 90, 90, 91, 91, 92, 93, 93, 94,
+	95, 95, 96, 97, 97, 98, 99, 99, 100, 101, 101,
+	102, 103, 103, 104, 105, 105, 106, 107, 107, 108, 109,
+	110, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117,
+	118, 118, 119, 120, 121, 121, 122, 123, 124, 125, 125,
+	126, 127, 128, 129, 129, 130, 131, 132, 133, 133, 134,
+	135, 136, 137, 138, 138, 139, 140, 141, 142, 143, 144,
+	145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153,
+	154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
+	165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
+	187, 188, 189, 190, 191, 192, 193, 194, 196, 197, 198,
+	199, 200, 201, 202, 203, 204, 205, 207, 208, 209, 210,
+	211, 212, 214, 215, 216, 217, 218, 219, 221, 222, 223,
+	224, 225, 227, 228, 229, 230, 231, 233, 234, 235, 236,
+	238, 239, 240, 241, 243, 244, 245, 247, 248, 249, 250,
+	252, 253, 254, 256, 257, 258, 260, 261, 262, 264, 265,
+	266, 268, 269, 271, 272, 273, 275, 276, 277, 279, 280,
+	282, 283, 285, 286, 287, 289, 290, 292, 293, 295, 296,
+	298, 299, 301, 302, 304, 305, 307, 308, 310, 311, 313,
+	314, 316, 317, 319, 320, 322, 324, 325, 327, 328, 330,
+	331, 333, 335, 336, 338, 339, 341, 343, 344, 346, 348,
+	349, 351, 353, 354, 356, 358, 359, 361, 363, 364, 366,
+	368, 370, 371, 373, 375, 377, 378, 380, 382, 384, 385,
+	387, 389, 391, 393, 394, 396, 398, 400, 402, 403, 405,
+	407, 409, 411, 413, 415, 416, 418, 420, 422, 424, 426,
+	428, 430, 432, 434, 436, 438, 439, 441, 443, 445, 447,
+	449, 451, 453, 455, 457, 459, 461, 463, 465, 467, 470,
+	472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492,
+	495, 497, 499, 501, 503, 505, 508, 510, 512, 514, 516,
+	518, 521, 523, 525, 527, 530, 532, 534, 536, 539, 541,
+	543, 545, 548, 550, 552, 555, 557, 559, 562, 564, 566,
+	569, 571, 573, 576, 578, 580, 583, 585, 588, 590, 592,
+	595, 597, 600, 602, 605, 607, 610, 612, 615, 617, 620,
+	622, 625, 627, 630, 632, 635, 637, 640, 642, 645, 648,
+	650, 653, 655, 658, 661, 663, 666, 669, 671, 674, 677,
+	679, 682, 685, 687, 690, 693, 695, 698, 701, 704, 706,
+	709, 712, 715, 717, 720, 723, 726, 729, 732, 734, 737,
+	740, 743, 746, 749, 751, 754, 757, 760, 763, 766, 769,
+	772, 775, 778, 781, 784, 787, 790, 793, 796, 799, 802,
+	805, 808, 811, 814, 817, 820, 823, 826, 829, 832, 835,
+	838, 842, 845, 848, 851, 854, 857, 860, 864, 867, 870,
+	873, 876, 880, 883, 886, 889, 893, 896, 899, 903, 906,
+	909, 912, 916, 919, 922, 926, 929, 932, 936, 939, 943,
+	946, 949, 953, 956, 960, 963, 967, 970, 973, 977, 980,
+	984, 987, 991, 994, 998, 1002, 1005, 1009, 1012, 1016, 1019,
+	1023,
+};
+
+static const u16 xgamma10_37[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
+	8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
+	9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12,
+	12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14,
+	14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
+	16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17,
+	18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20,
+	20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22,
+	22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24,
+	25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27,
+	28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30,
+	31, 31, 31, 31, 32, 32, 32, 33, 33, 33, 33,
+	34, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37,
+	37, 38, 38, 38, 39, 39, 39, 40, 40, 40, 41,
+	41, 41, 42, 42, 42, 43, 43, 44, 44, 44, 45,
+	45, 45, 46, 46, 47, 47, 47, 48, 48, 49, 49,
+	49, 50, 50, 51, 51, 51, 52, 52, 53, 53, 54,
+	54, 54, 55, 55, 56, 56, 57, 57, 58, 58, 58,
+	59, 59, 60, 60, 61, 61, 62, 62, 63, 63, 64,
+	64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69,
+	70, 70, 71, 71, 72, 72, 73, 73, 74, 75, 75,
+	76, 76, 77, 77, 78, 78, 79, 80, 80, 81, 81,
+	82, 82, 83, 84, 84, 85, 85, 86, 87, 87, 88,
+	89, 89, 90, 90, 91, 92, 92, 93, 94, 94, 95,
+	96, 96, 97, 98, 98, 99, 100, 100, 101, 102, 102,
+	103, 104, 104, 105, 106, 106, 107, 108, 109, 109, 110,
+	111, 112, 112, 113, 114, 114, 115, 116, 117, 118, 118,
+	119, 120, 121, 121, 122, 123, 124, 125, 125, 126, 127,
+	128, 129, 129, 130, 131, 132, 133, 134, 134, 135, 136,
+	137, 138, 139, 139, 140, 141, 142, 143, 144, 145, 146,
+	146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,
+	157, 158, 158, 159, 160, 161, 162, 163, 164, 165, 166,
+	167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
+	178, 179, 180, 181, 182, 184, 185, 186, 187, 188, 189,
+	190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201,
+	202, 203, 204, 206, 207, 208, 209, 210, 211, 213, 214,
+	215, 216, 217, 218, 220, 221, 222, 223, 225, 226, 227,
+	228, 229, 231, 232, 233, 234, 236, 237, 238, 240, 241,
+	242, 243, 245, 246, 247, 249, 250, 251, 253, 254, 255,
+	257, 258, 259, 261, 262, 263, 265, 266, 268, 269, 270,
+	272, 273, 275, 276, 277, 279, 280, 282, 283, 285, 286,
+	288, 289, 291, 292, 294, 295, 297, 298, 300, 301, 303,
+	304, 306, 307, 309, 310, 312, 313, 315, 316, 318, 320,
+	321, 323, 324, 326, 328, 329, 331, 332, 334, 336, 337,
+	339, 341, 342, 344, 346, 347, 349, 351, 352, 354, 356,
+	358, 359, 361, 363, 364, 366, 368, 370, 372, 373, 375,
+	377, 379, 380, 382, 384, 386, 388, 389, 391, 393, 395,
+	397, 399, 401, 402, 404, 406, 408, 410, 412, 414, 416,
+	418, 420, 421, 423, 425, 427, 429, 431, 433, 435, 437,
+	439, 441, 443, 445, 447, 449, 451, 453, 455, 457, 459,
+	462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 483,
+	485, 487, 489, 491, 493, 496, 498, 500, 502, 504, 507,
+	509, 511, 513, 515, 518, 520, 522, 524, 527, 529, 531,
+	534, 536, 538, 541, 543, 545, 548, 550, 552, 555, 557,
+	559, 562, 564, 567, 569, 571, 574, 576, 579, 581, 584,
+	586, 589, 591, 593, 596, 598, 601, 603, 606, 609, 611,
+	614, 616, 619, 621, 624, 626, 629, 632, 634, 637, 639,
+	642, 645, 647, 650, 653, 655, 658, 661, 663, 666, 669,
+	672, 674, 677, 680, 682, 685, 688, 691, 694, 696, 699,
+	702, 705, 708, 710, 713, 716, 719, 722, 725, 728, 730,
+	733, 736, 739, 742, 745, 748, 751, 754, 757, 760, 763,
+	766, 769, 772, 775, 778, 781, 784, 787, 790, 793, 796,
+	799, 802, 805, 809, 812, 815, 818, 821, 824, 827, 831,
+	834, 837, 840, 843, 847, 850, 853, 856, 860, 863, 866,
+	869, 873, 876, 879, 883, 886, 889, 893, 896, 899, 903,
+	906, 910, 913, 916, 920, 923, 927, 930, 934, 937, 940,
+	944, 947, 951, 954, 958, 961, 965, 969, 972, 976, 979,
+	983, 986, 990, 994, 997, 1001, 1005, 1008, 1012, 1016, 1019,
+	1023,
+};
+
+static const u16 xgamma10_38[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,
+	8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
+	9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11,
+	11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12,
+	12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14,
+	14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16,
+	16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18,
+	18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20,
+	20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22,
+	22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 25,
+	25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 28,
+	28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 31,
+	31, 31, 31, 32, 32, 32, 33, 33, 33, 33, 34,
+	34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37,
+	38, 38, 38, 39, 39, 39, 40, 40, 40, 41, 41,
+	41, 42, 42, 43, 43, 43, 44, 44, 44, 45, 45,
+	46, 46, 46, 47, 47, 47, 48, 48, 49, 49, 49,
+	50, 50, 51, 51, 52, 52, 52, 53, 53, 54, 54,
+	55, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59,
+	60, 60, 60, 61, 61, 62, 62, 63, 63, 64, 64,
+	65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70,
+	70, 71, 72, 72, 73, 73, 74, 74, 75, 75, 76,
+	76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82,
+	83, 83, 84, 85, 85, 86, 86, 87, 88, 88, 89,
+	90, 90, 91, 92, 92, 93, 93, 94, 95, 95, 96,
+	97, 97, 98, 99, 99, 100, 101, 102, 102, 103, 104,
+	104, 105, 106, 106, 107, 108, 109, 109, 110, 111, 112,
+	112, 113, 114, 115, 115, 116, 117, 118, 118, 119, 120,
+	121, 122, 122, 123, 124, 125, 126, 126, 127, 128, 129,
+	130, 130, 131, 132, 133, 134, 135, 136, 136, 137, 138,
+	139, 140, 141, 142, 143, 143, 144, 145, 146, 147, 148,
+	149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158,
+	159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
+	170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180,
+	182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,
+	193, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205,
+	206, 207, 208, 210, 211, 212, 213, 214, 216, 217, 218,
+	219, 220, 222, 223, 224, 225, 227, 228, 229, 230, 232,
+	233, 234, 235, 237, 238, 239, 241, 242, 243, 245, 246,
+	247, 249, 250, 251, 253, 254, 255, 257, 258, 259, 261,
+	262, 264, 265, 266, 268, 269, 271, 272, 274, 275, 276,
+	278, 279, 281, 282, 284, 285, 287, 288, 290, 291, 293,
+	294, 296, 297, 299, 300, 302, 303, 305, 307, 308, 310,
+	311, 313, 314, 316, 318, 319, 321, 323, 324, 326, 327,
+	329, 331, 332, 334, 336, 337, 339, 341, 342, 344, 346,
+	348, 349, 351, 353, 354, 356, 358, 360, 361, 363, 365,
+	367, 369, 370, 372, 374, 376, 378, 379, 381, 383, 385,
+	387, 389, 391, 392, 394, 396, 398, 400, 402, 404, 406,
+	408, 410, 412, 413, 415, 417, 419, 421, 423, 425, 427,
+	429, 431, 433, 435, 437, 439, 441, 443, 446, 448, 450,
+	452, 454, 456, 458, 460, 462, 464, 466, 469, 471, 473,
+	475, 477, 479, 482, 484, 486, 488, 490, 493, 495, 497,
+	499, 501, 504, 506, 508, 511, 513, 515, 517, 520, 522,
+	524, 527, 529, 531, 534, 536, 538, 541, 543, 546, 548,
+	550, 553, 555, 558, 560, 562, 565, 567, 570, 572, 575,
+	577, 580, 582, 585, 587, 590, 592, 595, 597, 600, 603,
+	605, 608, 610, 613, 616, 618, 621, 623, 626, 629, 631,
+	634, 637, 639, 642, 645, 648, 650, 653, 656, 658, 661,
+	664, 667, 669, 672, 675, 678, 681, 684, 686, 689, 692,
+	695, 698, 701, 703, 706, 709, 712, 715, 718, 721, 724,
+	727, 730, 733, 736, 739, 742, 745, 748, 751, 754, 757,
+	760, 763, 766, 769, 772, 775, 778, 781, 785, 788, 791,
+	794, 797, 800, 803, 807, 810, 813, 816, 820, 823, 826,
+	829, 832, 836, 839, 842, 846, 849, 852, 856, 859, 862,
+	866, 869, 872, 876, 879, 883, 886, 889, 893, 896, 900,
+	903, 907, 910, 914, 917, 921, 924, 928, 931, 935, 938,
+	942, 945, 949, 953, 956, 960, 964, 967, 971, 974, 978,
+	982, 986, 989, 993, 997, 1000, 1004, 1008, 1012, 1015, 1019,
+	1023,
+};
+
+static const u16 xgamma10_39[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8,
+	8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
+	9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11,
+	11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
+	12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,
+	14, 14, 14, 15, 15, 15, 15, 15, 15, 16, 16,
+	16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18,
+	18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20,
+	20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22,
+	23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25,
+	25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28,
+	28, 28, 29, 29, 29, 29, 30, 30, 30, 31, 31,
+	31, 31, 32, 32, 32, 33, 33, 33, 34, 34, 34,
+	35, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38,
+	38, 38, 39, 39, 39, 40, 40, 41, 41, 41, 42,
+	42, 42, 43, 43, 43, 44, 44, 45, 45, 45, 46,
+	46, 46, 47, 47, 48, 48, 48, 49, 49, 50, 50,
+	51, 51, 51, 52, 52, 53, 53, 53, 54, 54, 55,
+	55, 56, 56, 57, 57, 57, 58, 58, 59, 59, 60,
+	60, 61, 61, 62, 62, 63, 63, 64, 64, 65, 65,
+	66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71,
+	71, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77,
+	78, 78, 79, 79, 80, 80, 81, 82, 82, 83, 83,
+	84, 85, 85, 86, 87, 87, 88, 88, 89, 90, 90,
+	91, 92, 92, 93, 94, 94, 95, 96, 96, 97, 98,
+	98, 99, 100, 100, 101, 102, 102, 103, 104, 105, 105,
+	106, 107, 107, 108, 109, 110, 110, 111, 112, 113, 113,
+	114, 115, 116, 116, 117, 118, 119, 120, 120, 121, 122,
+	123, 124, 124, 125, 126, 127, 128, 129, 129, 130, 131,
+	132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141,
+	141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
+	152, 153, 153, 154, 155, 156, 157, 158, 159, 160, 161,
+	162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172,
+	173, 174, 176, 177, 178, 179, 180, 181, 182, 183, 184,
+	185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 196,
+	198, 199, 200, 201, 202, 203, 204, 206, 207, 208, 209,
+	210, 212, 213, 214, 215, 217, 218, 219, 220, 221, 223,
+	224, 225, 227, 228, 229, 230, 232, 233, 234, 236, 237,
+	238, 239, 241, 242, 243, 245, 246, 248, 249, 250, 252,
+	253, 254, 256, 257, 259, 260, 261, 263, 264, 266, 267,
+	269, 270, 271, 273, 274, 276, 277, 279, 280, 282, 283,
+	285, 286, 288, 289, 291, 292, 294, 295, 297, 299, 300,
+	302, 303, 305, 306, 308, 310, 311, 313, 314, 316, 318,
+	319, 321, 323, 324, 326, 328, 329, 331, 333, 334, 336,
+	338, 340, 341, 343, 345, 346, 348, 350, 352, 353, 355,
+	357, 359, 361, 362, 364, 366, 368, 370, 372, 373, 375,
+	377, 379, 381, 383, 385, 386, 388, 390, 392, 394, 396,
+	398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418,
+	420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440,
+	442, 444, 446, 448, 451, 453, 455, 457, 459, 461, 463,
+	466, 468, 470, 472, 474, 477, 479, 481, 483, 485, 488,
+	490, 492, 494, 497, 499, 501, 504, 506, 508, 511, 513,
+	515, 518, 520, 522, 525, 527, 529, 532, 534, 537, 539,
+	541, 544, 546, 549, 551, 554, 556, 559, 561, 564, 566,
+	569, 571, 574, 576, 579, 581, 584, 586, 589, 592, 594,
+	597, 599, 602, 605, 607, 610, 613, 615, 618, 621, 623,
+	626, 629, 632, 634, 637, 640, 643, 645, 648, 651, 654,
+	656, 659, 662, 665, 668, 671, 673, 676, 679, 682, 685,
+	688, 691, 694, 697, 700, 702, 705, 708, 711, 714, 717,
+	720, 723, 726, 729, 732, 735, 739, 742, 745, 748, 751,
+	754, 757, 760, 763, 766, 770, 773, 776, 779, 782, 786,
+	789, 792, 795, 798, 802, 805, 808, 811, 815, 818, 821,
+	825, 828, 831, 835, 838, 841, 845, 848, 852, 855, 858,
+	862, 865, 869, 872, 876, 879, 883, 886, 890, 893, 897,
+	900, 904, 907, 911, 914, 918, 922, 925, 929, 933, 936,
+	940, 944, 947, 951, 955, 958, 962, 966, 969, 973, 977,
+	981, 985, 988, 992, 996, 1000, 1004, 1007, 1011, 1015, 1019,
+	1023,
+};
+
+static const u16 xgamma10_40[GAMMA10_TABLE_LENGTH] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
+	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+	5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
+	6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8,
+	8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10,
+	10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11,
+	11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12,
+	13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14,
+	14, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16,
+	16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18,
+	18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20,
+	21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23,
+	23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25,
+	26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28,
+	29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31,
+	32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 35,
+	35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 38,
+	39, 39, 39, 40, 40, 40, 41, 41, 41, 42, 42,
+	43, 43, 43, 44, 44, 44, 45, 45, 46, 46, 46,
+	47, 47, 48, 48, 48, 49, 49, 50, 50, 50, 51,
+	51, 52, 52, 53, 53, 53, 54, 54, 55, 55, 56,
+	56, 57, 57, 57, 58, 58, 59, 59, 60, 60, 61,
+	61, 62, 62, 63, 63, 64, 64, 65, 65, 66, 66,
+	67, 67, 68, 68, 69, 69, 70, 70, 71, 72, 72,
+	73, 73, 74, 74, 75, 75, 76, 77, 77, 78, 78,
+	79, 79, 80, 81, 81, 82, 82, 83, 84, 84, 85,
+	85, 86, 87, 87, 88, 89, 89, 90, 91, 91, 92,
+	93, 93, 94, 95, 95, 96, 97, 97, 98, 99, 99,
+	100, 101, 101, 102, 103, 104, 104, 105, 106, 106, 107,
+	108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 116,
+	116, 117, 118, 119, 119, 120, 121, 122, 123, 123, 124,
+	125, 126, 127, 128, 128, 129, 130, 131, 132, 133, 134,
+	134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 143,
+	144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
+	155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165,
+	166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,
+	177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188,
+	189, 190, 192, 193, 194, 195, 196, 197, 199, 200, 201,
+	202, 203, 204, 206, 207, 208, 209, 210, 212, 213, 214,
+	215, 217, 218, 219, 220, 222, 223, 224, 226, 227, 228,
+	229, 231, 232, 233, 235, 236, 237, 239, 240, 241, 243,
+	244, 245, 247, 248, 250, 251, 252, 254, 255, 257, 258,
+	259, 261, 262, 264, 265, 267, 268, 270, 271, 273, 274,
+	276, 277, 279, 280, 282, 283, 285, 286, 288, 289, 291,
+	292, 294, 296, 297, 299, 300, 302, 304, 305, 307, 308,
+	310, 312, 313, 315, 317, 318, 320, 322, 323, 325, 327,
+	328, 330, 332, 333, 335, 337, 339, 340, 342, 344, 346,
+	348, 349, 351, 353, 355, 357, 358, 360, 362, 364, 366,
+	368, 369, 371, 373, 375, 377, 379, 381, 383, 385, 386,
+	388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
+	410, 412, 414, 416, 418, 420, 422, 424, 426, 429, 431,
+	433, 435, 437, 439, 441, 443, 445, 448, 450, 452, 454,
+	456, 458, 461, 463, 465, 467, 469, 472, 474, 476, 478,
+	481, 483, 485, 488, 490, 492, 495, 497, 499, 501, 504,
+	506, 509, 511, 513, 516, 518, 521, 523, 525, 528, 530,
+	533, 535, 538, 540, 543, 545, 548, 550, 553, 555, 558,
+	560, 563, 565, 568, 570, 573, 576, 578, 581, 583, 586,
+	589, 591, 594, 597, 599, 602, 605, 607, 610, 613, 616,
+	618, 621, 624, 627, 629, 632, 635, 638, 641, 643, 646,
+	649, 652, 655, 658, 660, 663, 666, 669, 672, 675, 678,
+	681, 684, 687, 690, 693, 696, 699, 702, 705, 708, 711,
+	714, 717, 720, 723, 726, 729, 732, 735, 739, 742, 745,
+	748, 751, 754, 758, 761, 764, 767, 770, 774, 777, 780,
+	783, 787, 790, 793, 797, 800, 803, 807, 810, 813, 817,
+	820, 824, 827, 830, 834, 837, 841, 844, 848, 851, 855,
+	858, 862, 865, 869, 872, 876, 879, 883, 886, 890, 894,
+	897, 901, 905, 908, 912, 916, 919, 923, 927, 930, 934,
+	938, 942, 945, 949, 953, 957, 960, 964, 968, 972, 976,
+	980, 984, 987, 991, 995, 999, 1003, 1007, 1011, 1015, 1019,
+	1023,
+};
+
+static const u16 *xgamma10_curves[GAMMA_CURVE_LENGTH] =  {
+	&xgamma10_01[0],
+	&xgamma10_02[0],
+	&xgamma10_03[0],
+	&xgamma10_04[0],
+	&xgamma10_05[0],
+	&xgamma10_06[0],
+	&xgamma10_07[0],
+	&xgamma10_08[0],
+	&xgamma10_09[0],
+	&xgamma10_10[0],
+	&xgamma10_11[0],
+	&xgamma10_12[0],
+	&xgamma10_13[0],
+	&xgamma10_14[0],
+	&xgamma10_15[0],
+	&xgamma10_16[0],
+	&xgamma10_17[0],
+	&xgamma10_18[0],
+	&xgamma10_19[0],
+	&xgamma10_20[0],
+	&xgamma10_21[0],
+	&xgamma10_22[0],
+	&xgamma10_23[0],
+	&xgamma10_24[0],
+	&xgamma10_25[0],
+	&xgamma10_26[0],
+	&xgamma10_27[0],
+	&xgamma10_28[0],
+	&xgamma10_29[0],
+	&xgamma10_30[0],
+	&xgamma10_31[0],
+	&xgamma10_32[0],
+	&xgamma10_33[0],
+	&xgamma10_34[0],
+	&xgamma10_35[0],
+	&xgamma10_36[0],
+	&xgamma10_37[0],
+	&xgamma10_38[0],
+	&xgamma10_39[0],
+	&xgamma10_40[0],
+};
+#endif /* __XILINX_GAMMA_COEFF_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-gamma-correction.h b/drivers/media/platform/xilinx/xilinx-gamma-correction.h
new file mode 100644
index 000000000..f8e43082a
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-gamma-correction.h
@@ -0,0 +1,657 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2022 - 2023, Advanced Micro Devices, Inc.
+ */
+
+#ifndef __XILINX_GAMMA_CORRECTION_H__
+#define __XILINX_GAMMA_CORRECTION_H__
+
+#define XISP_GAMMA_CURVE_LENGTH		(40)
+
+#define XISP_GAMMA_BPC_8			(6)
+#define XISP_GAMMA8_TABLE_LENGTH	BIT(XISP_GAMMA_BPC_8)
+
+static const u32 xgamma8_40[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.1 */
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x01000000, 0x01010101, 0x01010101, 0x02020101, 0x02020202, 0x03030303,
+	0x04040403, 0x05050504, 0x07070606, 0x09080807, 0x0b0a0a09, 0x0e0d0c0c,
+	0x11100f0e, 0x15141312, 0x1a181716, 0x1f1e1c1b, 0x26242221, 0x2e2c2a28,
+	0x37353230, 0x423f3c3a, 0x4f4c4845, 0x5e5a5653, 0x706b6763, 0x857f7a75,
+	0x9d97908b, 0xb9b2aaa4, 0xd9d1c8c1, 0xfff5ebe2
+};
+
+static const u32 xgamma8_39[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.2 */
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x01010100, 0x01010101, 0x01010101,
+	0x02020201, 0x02020202, 0x03030302, 0x03030303, 0x04040404, 0x05050504,
+	0x06060605, 0x07070706, 0x09080808, 0x0a0a0909, 0x0c0b0b0b, 0x0e0d0d0c,
+	0x100f0f0e, 0x12111110, 0x15141313, 0x18171615, 0x1b1a1918, 0x1e1d1c1c,
+	0x2221201f, 0x26252423, 0x2b2a2927, 0x302f2d2c, 0x36343331, 0x3c3a3937,
+	0x42403f3d, 0x49474644, 0x514f4d4b, 0x59575553, 0x62605e5c, 0x6c6a6765,
+	0x7774716f, 0x827f7c79, 0x8e8b8885, 0x9b989491, 0xa9a5a29e, 0xb8b4b0ad,
+	0xc8c4c0bc, 0xd9d5d0cc, 0xebe6e2dd, 0xfffaf5f0
+};
+
+static const u32 xgamma8_38[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.3 */
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x01010100, 0x01010101, 0x01010101, 0x02020202, 0x02020202, 0x03030303,
+	0x04040303, 0x05040404, 0x06050505, 0x07060606, 0x08070707, 0x09090808,
+	0x0a0a0a09, 0x0c0c0b0b, 0x0e0d0d0c, 0x0f0f0f0e, 0x11111010, 0x14131212,
+	0x16151514, 0x18181717, 0x1b1a1a19, 0x1e1d1d1c, 0x2120201f, 0x25242322,
+	0x28272625, 0x2c2b2a29, 0x302f2e2d, 0x34333231, 0x39383735, 0x3e3c3b3a,
+	0x4342403f, 0x48474544, 0x4e4c4b4a, 0x5452514f, 0x5a595755, 0x615f5d5c,
+	0x68666463, 0x6f6d6b6a, 0x77757371, 0x7f7d7b79, 0x87858381, 0x908e8b89,
+	0x99979492, 0xa3a09e9b, 0xadaaa8a5, 0xb7b4b2af, 0xc2bfbcba, 0xcdcac7c4,
+	0xd9d6d3d0, 0xe5e2dfdc, 0xf1eeebe8, 0xfffbf8f5
+};
+
+static const u32 xgamma8_37[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.4 */
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x01010101, 0x01010101, 0x02020201, 0x02020202, 0x03030303,
+	0x04040403, 0x05050504, 0x06060605, 0x07070706, 0x09080808, 0x0a0a0909,
+	0x0b0b0b0a, 0x0d0d0c0c, 0x0f0e0e0e, 0x1110100f, 0x13121211, 0x15151413,
+	0x17171616, 0x1a191918, 0x1d1c1b1b, 0x1f1f1e1d, 0x22222120, 0x25252423,
+	0x29282726, 0x2c2b2a2a, 0x302f2e2d, 0x34333231, 0x37363534, 0x3c3b3938,
+	0x403f3e3d, 0x44434241, 0x49484745, 0x4e4d4b4a, 0x5352504f, 0x58575554,
+	0x5d5c5b59, 0x6362605f, 0x69676664, 0x6f6d6c6a, 0x75737270, 0x7b7a7877,
+	0x82807f7d, 0x89878584, 0x908e8c8a, 0x97959391, 0x9e9c9b99, 0xa6a4a2a0,
+	0xaeacaaa8, 0xb6b4b2b0, 0xbebcbab8, 0xc7c5c2c0, 0xcfcdcbc9, 0xd8d6d4d2,
+	0xe2dfdddb, 0xebe9e6e4, 0xf5f2f0ed, 0xfffcfaf7
+};
+
+static const u32 xgamma8_36[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.5 */
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01010101, 0x02010101,
+	0x02020202, 0x03030303, 0x04040404, 0x05050505, 0x07060606, 0x08080707,
+	0x0a090909, 0x0b0b0b0a, 0x0d0d0c0c, 0x0f0f0e0e, 0x11111010, 0x13131212,
+	0x16151414, 0x18171716, 0x1b1a1919, 0x1d1d1c1b, 0x201f1f1e, 0x23222121,
+	0x26252424, 0x29282827, 0x2c2c2b2a, 0x302f2e2d, 0x33323231, 0x37363534,
+	0x3b3a3938, 0x3f3e3d3c, 0x43424140, 0x47464544, 0x4b4a4948, 0x504f4d4c,
+	0x54535251, 0x59585755, 0x5e5d5b5a, 0x6361605f, 0x68666564, 0x6d6c6a69,
+	0x7271706e, 0x78767574, 0x7d7c7a79, 0x8381807f, 0x89878684, 0x8f8d8c8a,
+	0x95939290, 0x9b999896, 0xa1a09e9c, 0xa8a6a4a3, 0xaeacaba9, 0xb5b3b1b0,
+	0xbcbab8b6, 0xc3c1bfbd, 0xcac8c6c4, 0xd1cfcdcb, 0xd8d6d4d3, 0xe0dedcda,
+	0xe7e5e3e1, 0xefedebe9, 0xf7f5f3f1, 0xfffdfbf9
+};
+
+static const u32 xgamma8_35[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.6 */
+	0x00000000, 0x00000000, 0x01010000, 0x02020101, 0x03030202, 0x04040303,
+	0x06050504, 0x07070606, 0x09080808, 0x0b0a0a09, 0x0d0c0c0b, 0x0f0e0e0d,
+	0x1110100f, 0x13131212, 0x16151414, 0x18181716, 0x1b1a1a19, 0x1e1d1c1c,
+	0x21201f1e, 0x24232221, 0x27262524, 0x2a292828, 0x2d2c2c2b, 0x31302f2e,
+	0x34333232, 0x38373635, 0x3b3b3a39, 0x3f3e3d3c, 0x43424140, 0x47464544,
+	0x4b4a4948, 0x4f4e4d4c, 0x54525150, 0x58575655, 0x5c5b5a59, 0x61605e5d,
+	0x65646362, 0x6a696866, 0x6f6e6c6b, 0x74727170, 0x78777675, 0x7d7c7b7a,
+	0x8381807f, 0x88868584, 0x8d8c8a89, 0x9291908e, 0x98969594, 0x9d9c9a99,
+	0xa3a1a09e, 0xa8a7a5a4, 0xaeacabaa, 0xb4b2b1af, 0xb9b8b7b5, 0xbfbebcbb,
+	0xc5c4c2c1, 0xcbcac8c7, 0xd2d0cecd, 0xd8d6d5d3, 0xdedcdbd9, 0xe4e3e1e0,
+	0xebe9e8e6, 0xf1f0eeec, 0xf8f6f5f3, 0xfffdfbfa
+};
+
+static const u32 xgamma8_34[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.7 */
+	0x00000000, 0x01010000, 0x02020201, 0x04040303, 0x06050504, 0x08070706,
+	0x0a090908, 0x0c0b0b0a, 0x0e0e0d0d, 0x1110100f, 0x14131212, 0x16161514,
+	0x19181817, 0x1c1b1b1a, 0x1f1e1d1d, 0x22212120, 0x25242423, 0x29282726,
+	0x2c2b2a29, 0x2f2e2e2d, 0x33323130, 0x36353534, 0x3a393837, 0x3e3d3c3b,
+	0x4141403f, 0x45444342, 0x49484746, 0x4d4c4b4a, 0x51504f4e, 0x55545352,
+	0x59585756, 0x5e5d5c5b, 0x6261605f, 0x66656463, 0x6b6a6867, 0x6f6e6d6c,
+	0x74727170, 0x78777675, 0x7d7c7a79, 0x81807f7e, 0x86858483, 0x8b8a8887,
+	0x908e8d8c, 0x94939291, 0x99989796, 0x9e9d9c9b, 0xa3a2a19f, 0xa8a7a6a4,
+	0xadacabaa, 0xb2b1b0af, 0xb8b6b5b4, 0xbdbbbab9, 0xc2c1bfbe, 0xc7c6c5c3,
+	0xcdcbcac9, 0xd2d1cfce, 0xd7d6d5d3, 0xdddcdad9, 0xe2e1e0de, 0xe8e7e5e4,
+	0xeeecebe9, 0xf3f2f0ef, 0xf9f7f6f5, 0xfffdfcfa
+};
+
+static const u32 xgamma8_33[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.8 */
+	0x00000000, 0x02020101, 0x05040303, 0x07060605, 0x09090808, 0x0c0b0b0a,
+	0x0f0e0d0d, 0x12111010, 0x15141313, 0x18171616, 0x1b1a1919, 0x1e1d1d1c,
+	0x2221201f, 0x25242322, 0x28282726, 0x2c2b2a29, 0x2f2f2e2d, 0x33323130,
+	0x37363534, 0x3a3a3938, 0x3e3d3c3b, 0x4241403f, 0x46454443, 0x4a494847,
+	0x4e4d4c4b, 0x5251504f, 0x56555453, 0x5a595857, 0x5e5d5c5b, 0x6261605f,
+	0x66656463, 0x6a696867, 0x6e6d6c6b, 0x7372716f, 0x77767574, 0x7b7a7978,
+	0x807f7d7c, 0x84838281, 0x88878685, 0x8d8c8b89, 0x91908f8e, 0x96959392,
+	0x9a999897, 0x9f9e9d9b, 0xa3a2a1a0, 0xa8a7a6a4, 0xadabaaa9, 0xb1b0afae,
+	0xb6b5b4b2, 0xbbb9b8b7, 0xbfbebdbc, 0xc4c3c2c0, 0xc9c8c6c5, 0xcecccbca,
+	0xd2d1d0cf, 0xd7d6d5d4, 0xdcdbdad8, 0xe1e0dedd, 0xe6e5e3e2, 0xebe9e8e7,
+	0xf0eeedec, 0xf5f3f2f1, 0xfaf8f7f6, 0xfffdfcfb
+};
+
+static const u32 xgamma8_32[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 0.9 */
+	0x01010000, 0x04030302, 0x07060605, 0x0a0a0908, 0x0e0d0c0b, 0x11100f0f,
+	0x15141312, 0x18171615, 0x1c1b1a19, 0x1f1e1d1c, 0x23222120, 0x26262524,
+	0x2a292827, 0x2e2d2c2b, 0x3231302f, 0x35343433, 0x39383736, 0x3d3c3b3a,
+	0x41403f3e, 0x45444342, 0x49484746, 0x4d4c4b4a, 0x51504f4e, 0x55545352,
+	0x59585756, 0x5d5c5b5a, 0x61605f5e, 0x65646362, 0x69686766, 0x6d6c6b6a,
+	0x71706f6e, 0x75747372, 0x79787776, 0x7d7c7b7a, 0x81807f7e, 0x86858482,
+	0x8a898887, 0x8e8d8c8b, 0x9291908f, 0x96959493, 0x9b9a9897, 0x9f9e9d9c,
+	0xa3a2a1a0, 0xa7a6a5a4, 0xacaba9a8, 0xb0afaead, 0xb4b3b2b1, 0xb8b7b6b5,
+	0xbdbcbbba, 0xc1c0bfbe, 0xc5c4c3c2, 0xcac9c8c7, 0xcecdcccb, 0xd2d1d0cf,
+	0xd7d6d5d4, 0xdbdad9d8, 0xe0dedddc, 0xe4e3e2e1, 0xe8e7e6e5, 0xedecebe9,
+	0xf1f0efee, 0xf6f5f3f2, 0xfaf9f8f7, 0xfffdfcfb
+};
+
+static const u32 xgamma8_31[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1 */
+	0x03010100, 0x07050503, 0x0a0a0808, 0x0f0e0c0c, 0x1311110f, 0x16161513,
+	0x1a1a1818, 0x1f1d1c1c, 0x2321211f, 0x26262423, 0x2a2a2828, 0x2f2d2d2b,
+	0x3331312f, 0x36363434, 0x3b3a3838, 0x3f3d3d3b, 0x4242413f, 0x46464444,
+	0x4b494948, 0x4f4d4d4b, 0x5252504f, 0x56565454, 0x5b595957, 0x5e5d5d5b,
+	0x62626060, 0x67666464, 0x6b696967, 0x6e6e6d6b, 0x72727070, 0x77757574,
+	0x7b797977, 0x7e7e7c7c, 0x82828080, 0x87858583, 0x8a898987, 0x8e8e8c8c,
+	0x93919090, 0x97959593, 0x9a9a9997, 0x9e9e9c9c, 0xa3a1a1a0, 0xa7a5a5a3,
+	0xaaaaa8a8, 0xafaeacac, 0xb3b1b1af, 0xb6b5b5b3, 0xbabab8b8, 0xbfbdbcbc,
+	0xc3c1c1bf, 0xc6c6c4c3, 0xcacac8c8, 0xcfcdcdcc, 0xd3d1d1cf, 0xd6d6d4d4,
+	0xdbdad8d8, 0xdfdddddb, 0xe2e2e1df, 0xe6e6e4e4, 0xebe9e8e8, 0xefededeb,
+	0xf2f2f0ef, 0xf6f6f4f4, 0xfbf9f9f8, 0xfffdfdfb
+};
+
+static const u32 xgamma8_30[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.1 */
+	0x04030100, 0x09080705, 0x0e0d0c0a, 0x1312110f, 0x18161514, 0x1c1b1a19,
+	0x211f1e1d, 0x25242322, 0x29282726, 0x2e2d2c2b, 0x3231302f, 0x36353433,
+	0x3b393837, 0x3f3e3d3c, 0x43424140, 0x47464544, 0x4b4a4948, 0x4f4e4d4c,
+	0x53525150, 0x57565554, 0x5b5a5958, 0x5f5e5d5c, 0x63626160, 0x67666564,
+	0x6b6a6968, 0x6f6e6d6c, 0x73727170, 0x77767574, 0x7b7a7978, 0x7f7e7d7c,
+	0x83828180, 0x87868584, 0x8b8a8988, 0x8f8e8d8c, 0x9291908f, 0x96959493,
+	0x9a999897, 0x9e9d9c9b, 0xa2a1a09f, 0xa5a5a4a3, 0xa9a8a7a6, 0xadacabaa,
+	0xb1b0afae, 0xb5b4b3b2, 0xb8b7b6b6, 0xbcbbbab9, 0xc0bfbebd, 0xc4c3c2c1,
+	0xc7c6c5c5, 0xcbcac9c8, 0xcfcecdcc, 0xd2d2d1d0, 0xd6d5d4d3, 0xdad9d8d7,
+	0xdedddcdb, 0xe1e0dfde, 0xe5e4e3e2, 0xe9e8e7e6, 0xecebeaea, 0xf0efeeed,
+	0xf4f3f2f1, 0xf7f6f5f4, 0xfbfaf9f8, 0xfffefdfc
+};
+
+static const u32 xgamma8_29[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.2 */
+	0x06040200, 0x0c0b0907, 0x12110f0e, 0x18161513, 0x1d1b1a19, 0x22211f1e,
+	0x27262423, 0x2c2a2928, 0x302f2e2d, 0x35343331, 0x39383736, 0x3e3d3c3a,
+	0x4241403f, 0x47454443, 0x4b4a4948, 0x4f4e4d4c, 0x53525150, 0x57565554,
+	0x5b5a5958, 0x605f5e5c, 0x64636261, 0x68676665, 0x6c6b6a69, 0x6f6f6e6d,
+	0x73727170, 0x77767574, 0x7b7a7978, 0x7f7e7d7c, 0x83828180, 0x87868584,
+	0x8a898988, 0x8e8d8c8b, 0x9291908f, 0x96959493, 0x99989797, 0x9d9c9b9a,
+	0xa1a09f9e, 0xa4a3a2a2, 0xa8a7a6a5, 0xacabaaa9, 0xafaeadac, 0xb3b2b1b0,
+	0xb6b5b4b4, 0xbab9b8b7, 0xbdbcbcbb, 0xc1c0bfbe, 0xc4c4c3c2, 0xc8c7c6c5,
+	0xcbcbcac9, 0xcfcecdcc, 0xd2d1d1d0, 0xd6d5d4d3, 0xd9d8d8d7, 0xdddcdbda,
+	0xe0dfdede, 0xe4e3e2e1, 0xe7e6e5e4, 0xeae9e9e8, 0xeeedeceb, 0xf1f0efef,
+	0xf4f4f3f2, 0xf8f7f6f5, 0xfbfaf9f9, 0xfffefdfc
+};
+
+static const u32 xgamma8_28[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.3 */
+	0x08060300, 0x100e0c0a, 0x16151311, 0x1c1b1918, 0x22211f1e, 0x28262523,
+	0x2d2c2a29, 0x32312f2e, 0x37363433, 0x3c3a3938, 0x403f3e3d, 0x45444342,
+	0x49484746, 0x4e4d4c4b, 0x5251504f, 0x56555453, 0x5b5a5958, 0x5f5e5d5c,
+	0x63626160, 0x67666564, 0x6b6a6968, 0x6f6e6d6c, 0x73727170, 0x77767574,
+	0x7b7a7978, 0x7e7e7d7c, 0x8281807f, 0x86858483, 0x8a898887, 0x8d8c8c8b,
+	0x91908f8e, 0x95949392, 0x98979696, 0x9c9b9a99, 0x9f9f9e9d, 0xa3a2a1a0,
+	0xa6a6a5a4, 0xaaa9a8a7, 0xadadacab, 0xb1b0afae, 0xb4b3b3b2, 0xb8b7b6b5,
+	0xbbbab9b8, 0xbebebdbc, 0xc2c1c0bf, 0xc5c4c3c3, 0xc8c8c7c6, 0xcccbcac9,
+	0xcfcecdcc, 0xd2d1d1d0, 0xd5d5d4d3, 0xd9d8d7d6, 0xdcdbdada, 0xdfdededd,
+	0xe2e2e1e0, 0xe6e5e4e3, 0xe9e8e7e6, 0xecebeae9, 0xefeeeded, 0xf2f1f1f0,
+	0xf5f4f4f3, 0xf8f8f7f6, 0xfbfbfaf9, 0xfffefdfc
+};
+
+static const u32 xgamma8_27[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.4 */
+	0x0a070400, 0x13110f0d, 0x1b191715, 0x21201e1c, 0x27262423, 0x2d2c2a29,
+	0x3331302f, 0x38373534, 0x3d3c3b39, 0x4241403e, 0x47464543, 0x4c4b4948,
+	0x504f4e4d, 0x55545351, 0x59585756, 0x5d5c5b5a, 0x6261605e, 0x66656463,
+	0x6a696867, 0x6e6d6c6b, 0x7271706f, 0x76757473, 0x7a797877, 0x7d7d7c7b,
+	0x81807f7e, 0x85848382, 0x89888786, 0x8c8b8a8a, 0x908f8e8d, 0x93939291,
+	0x97969594, 0x9a9a9998, 0x9e9d9c9b, 0xa1a1a09f, 0xa5a4a3a2, 0xa8a7a7a6,
+	0xacabaaa9, 0xafaeadac, 0xb2b1b1b0, 0xb5b5b4b3, 0xb9b8b7b6, 0xbcbbbaba,
+	0xbfbebebd, 0xc2c2c1c0, 0xc6c5c4c3, 0xc9c8c7c6, 0xcccbcac9, 0xcfcecdcd,
+	0xd2d1d0d0, 0xd5d4d4d3, 0xd8d7d7d6, 0xdbdadad9, 0xdedddddc, 0xe1e0e0df,
+	0xe4e3e3e2, 0xe7e6e6e5, 0xeae9e9e8, 0xedececeb, 0xf0efefee, 0xf3f2f2f1,
+	0xf6f5f4f4, 0xf9f8f7f7, 0xfcfbfaf9, 0xfffefdfc
+};
+
+static const u32 xgamma8_26[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.5 */
+	0x0d0a0600, 0x1714120f, 0x1f1d1b19, 0x26242321, 0x2d2b2928, 0x3331302e,
+	0x39373634, 0x3e3d3b3a, 0x4342413f, 0x48474645, 0x4d4c4b4a, 0x5251504f,
+	0x57565453, 0x5b5a5958, 0x605f5d5c, 0x64636261, 0x68676665, 0x6c6b6a69,
+	0x706f6e6d, 0x74737271, 0x78777675, 0x7c7b7a79, 0x807f7e7d, 0x84838281,
+	0x87868584, 0x8b8a8988, 0x8e8e8d8c, 0x9291908f, 0x95959493, 0x99989796,
+	0x9c9b9b9a, 0xa09f9e9d, 0xa3a2a1a1, 0xa6a6a5a4, 0xaaa9a8a7, 0xadacabaa,
+	0xb0afafae, 0xb3b3b2b1, 0xb6b6b5b4, 0xbab9b8b7, 0xbdbcbbba, 0xc0bfbebd,
+	0xc3c2c1c1, 0xc6c5c4c4, 0xc9c8c7c7, 0xcccbcaca, 0xcfcecdcd, 0xd2d1d0d0,
+	0xd5d4d3d3, 0xd8d7d6d5, 0xdbdad9d8, 0xdddddcdb, 0xe0e0dfde, 0xe3e2e2e1,
+	0xe6e5e4e4, 0xe9e8e7e7, 0xebebeae9, 0xeeeeedec, 0xf1f0f0ef, 0xf4f3f2f2,
+	0xf6f6f5f4, 0xf9f8f8f7, 0xfcfbfafa, 0xfffefdfc
+};
+
+static const u32 xgamma8_25[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.6 */
+	0x0f0c0700, 0x1a181512, 0x23211f1d, 0x2b292725, 0x32302e2d, 0x38373533,
+	0x3e3d3b3a, 0x44424140, 0x49484745, 0x4e4d4c4b, 0x53525150, 0x58575655,
+	0x5d5c5a59, 0x61605f5e, 0x66656362, 0x6a696867, 0x6e6d6c6b, 0x7271706f,
+	0x76757473, 0x7a797877, 0x7e7d7c7b, 0x8281807f, 0x85858483, 0x89888786,
+	0x8d8c8b8a, 0x908f8e8e, 0x94939291, 0x97969595, 0x9b9a9998, 0x9e9d9c9b,
+	0xa1a0a09f, 0xa4a4a3a2, 0xa8a7a6a5, 0xabaaa9a8, 0xaeadacac, 0xb1b0b0af,
+	0xb4b3b3b2, 0xb7b7b6b5, 0xbabab9b8, 0xbdbdbcbb, 0xc0c0bfbe, 0xc3c2c2c1,
+	0xc6c5c5c4, 0xc9c8c8c7, 0xcccbcaca, 0xcfcecdcd, 0xd2d1d0cf, 0xd4d4d3d2,
+	0xd7d6d6d5, 0xdad9d9d8, 0xdddcdbdb, 0xdfdfdedd, 0xe2e1e1e0, 0xe5e4e3e3,
+	0xe7e7e6e5, 0xeae9e9e8, 0xedecebeb, 0xefefeeed, 0xf2f1f1f0, 0xf4f4f3f2,
+	0xf7f6f6f5, 0xf9f9f8f8, 0xfcfbfbfa, 0xfffefdfd
+};
+
+static const u32 xgamma8_24[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.7 */
+	0x120e0900, 0x1e1c1916, 0x28252321, 0x302e2c2a, 0x37353332, 0x3d3c3a39,
+	0x4442413f, 0x49484645, 0x4f4d4c4b, 0x54535150, 0x59585755, 0x5e5d5b5a,
+	0x6261605f, 0x67666564, 0x6b6a6968, 0x706e6d6c, 0x74737271, 0x78777675,
+	0x7c7b7a79, 0x7f7f7e7d, 0x83828180, 0x87868584, 0x8b8a8988, 0x8e8d8c8b,
+	0x9291908f, 0x95949393, 0x98989796, 0x9c9b9a99, 0x9f9e9d9d, 0xa2a2a1a0,
+	0xa6a5a4a3, 0xa9a8a7a6, 0xacabaaaa, 0xafaeadad, 0xb2b1b0b0, 0xb5b4b3b3,
+	0xb8b7b6b6, 0xbbbab9b9, 0xbebdbcbc, 0xc1c0bfbe, 0xc3c3c2c1, 0xc6c6c5c4,
+	0xc9c8c8c7, 0xcccbcaca, 0xcfcecdcd, 0xd1d1d0cf, 0xd4d3d3d2, 0xd7d6d5d5,
+	0xd9d9d8d7, 0xdcdbdbda, 0xdededddd, 0xe1e0e0df, 0xe4e3e2e2, 0xe6e6e5e4,
+	0xe9e8e7e7, 0xebebeae9, 0xeeedecec, 0xf0efefee, 0xf3f2f1f1, 0xf5f4f4f3,
+	0xf7f7f6f6, 0xfaf9f9f8, 0xfcfcfbfa, 0xfffefdfd
+};
+
+static const u32 xgamma8_23[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.8 */
+	0x15110b00, 0x221f1c19, 0x2c2a2725, 0x3432302e, 0x3c3a3836, 0x43413f3d,
+	0x49474644, 0x4f4d4c4a, 0x54535150, 0x59585755, 0x5e5d5c5b, 0x63626160,
+	0x68676564, 0x6c6b6a69, 0x71706e6d, 0x75747372, 0x79787776, 0x7d7c7b7a,
+	0x81807f7e, 0x84848382, 0x88878685, 0x8c8b8a89, 0x8f8e8e8d, 0x93929190,
+	0x96959594, 0x9a999897, 0x9d9c9b9a, 0xa09f9f9e, 0xa3a3a2a1, 0xa6a6a5a4,
+	0xaaa9a8a7, 0xadacabaa, 0xb0afaead, 0xb3b2b1b0, 0xb6b5b4b3, 0xb8b8b7b6,
+	0xbbbbbab9, 0xbebdbdbc, 0xc1c0bfbf, 0xc4c3c2c2, 0xc6c6c5c4, 0xc9c8c8c7,
+	0xcccbcaca, 0xcececdcc, 0xd1d0d0cf, 0xd4d3d2d2, 0xd6d6d5d4, 0xd9d8d7d7,
+	0xdbdbdad9, 0xdedddcdc, 0xe0e0dfde, 0xe3e2e1e1, 0xe5e4e4e3, 0xe7e7e6e6,
+	0xeae9e9e8, 0xececebea, 0xefeeeded, 0xf1f0f0ef, 0xf3f3f2f1, 0xf5f5f4f4,
+	0xf8f7f7f6, 0xfaf9f9f8, 0xfcfcfbfb, 0xfffefdfd
+};
+
+static const u32 xgamma8_22[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 1.9 */
+	0x18130d00, 0x2623201c, 0x302e2b29, 0x39373533, 0x413f3d3b, 0x47464442,
+	0x4e4c4b49, 0x5452514f, 0x59585655, 0x5e5d5c5b, 0x63626160, 0x68676665,
+	0x6d6c6b69, 0x71706f6e, 0x76747372, 0x7a797877, 0x7e7d7c7b, 0x8281807f,
+	0x85848483, 0x89888786, 0x8d8c8b8a, 0x908f8f8e, 0x94939291, 0x97969595,
+	0x9a9a9998, 0x9e9d9c9b, 0xa1a09f9f, 0xa4a3a3a2, 0xa7a6a6a5, 0xaaa9a9a8,
+	0xadacacab, 0xb0afafae, 0xb3b2b2b1, 0xb6b5b5b4, 0xb9b8b7b7, 0xbcbbbab9,
+	0xbebebdbc, 0xc1c0c0bf, 0xc4c3c2c2, 0xc6c6c5c4, 0xc9c8c8c7, 0xcccbcaca,
+	0xcecdcdcc, 0xd1d0cfcf, 0xd3d3d2d1, 0xd6d5d4d4, 0xd8d7d7d6, 0xdbdad9d9,
+	0xdddcdcdb, 0xdfdfdede, 0xe2e1e0e0, 0xe4e3e3e2, 0xe6e6e5e5, 0xe9e8e7e7,
+	0xebeaeae9, 0xededeceb, 0xefefeeee, 0xf2f1f0f0, 0xf4f3f3f2, 0xf6f5f5f4,
+	0xf8f8f7f6, 0xfafaf9f9, 0xfcfcfbfb, 0xfffefdfd
+};
+
+static const u32 xgamma8_21[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2 */
+	0x1b160f00, 0x2a27231f, 0x34322f2d, 0x3d3b3937, 0x4543413f, 0x4c4a4947,
+	0x52514f4e, 0x58575554, 0x5e5d5b5a, 0x6362615f, 0x68676664, 0x6d6c6b69,
+	0x72706f6e, 0x76757473, 0x7a797877, 0x7e7d7c7b, 0x8281807f, 0x86858483,
+	0x8a898887, 0x8d8d8c8b, 0x91908f8e, 0x94949392, 0x98979695, 0x9b9a9999,
+	0x9e9e9d9c, 0xa2a1a09f, 0xa5a4a3a2, 0xa8a7a6a5, 0xabaaa9a8, 0xaeadacab,
+	0xb1b0afae, 0xb3b3b2b1, 0xb6b6b5b4, 0xb9b8b8b7, 0xbcbbbaba, 0xbebebdbc,
+	0xc1c0c0bf, 0xc4c3c2c2, 0xc6c6c5c4, 0xc9c8c8c7, 0xcbcbcac9, 0xcecdcdcc,
+	0xd0d0cfce, 0xd3d2d2d1, 0xd5d5d4d3, 0xd8d7d6d6, 0xdad9d9d8, 0xdcdcdbda,
+	0xdededddd, 0xe1e0e0df, 0xe3e2e2e1, 0xe5e5e4e4, 0xe7e7e6e6, 0xeae9e9e8,
+	0xecebebea, 0xeeededec, 0xf0f0efee, 0xf2f2f1f1, 0xf4f4f3f3, 0xf6f6f5f5,
+	0xf8f8f7f7, 0xfafaf9f9, 0xfcfcfbfb, 0xfffefdfd
+};
+
+static const u32 xgamma8_20[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.1 */
+	0x1e191200, 0x2e2a2723, 0x39363331, 0x42403d3b, 0x4a484644, 0x514f4d4b,
+	0x57555452, 0x5d5c5a59, 0x6361605e, 0x68676564, 0x6d6c6a69, 0x71706f6e,
+	0x76757473, 0x7a797877, 0x7f7d7c7b, 0x83828180, 0x86858584, 0x8a898887,
+	0x8e8d8c8b, 0x9191908f, 0x95949392, 0x98979796, 0x9c9b9a99, 0x9f9e9d9c,
+	0xa2a1a0a0, 0xa5a4a4a3, 0xa8a7a7a6, 0xabaaaaa9, 0xaeadadac, 0xb1b0afaf,
+	0xb4b3b2b2, 0xb6b6b5b4, 0xb9b9b8b7, 0xbcbbbbba, 0xbfbebdbd, 0xc1c0c0bf,
+	0xc4c3c2c2, 0xc6c6c5c4, 0xc9c8c7c7, 0xcbcbcac9, 0xcecdcccc, 0xd0cfcfce,
+	0xd2d2d1d1, 0xd5d4d3d3, 0xd7d6d6d5, 0xd9d9d8d8, 0xdbdbdada, 0xdedddddc,
+	0xe0dfdfde, 0xe2e2e1e0, 0xe4e4e3e3, 0xe6e6e5e5, 0xe9e8e7e7, 0xebeaeae9,
+	0xedececeb, 0xefeeeeed, 0xf1f0f0ef, 0xf3f2f2f1, 0xf5f4f4f3, 0xf7f6f6f5,
+	0xf9f8f8f7, 0xfbfafaf9, 0xfdfcfcfb, 0xfffefefd
+};
+
+static const u32 xgamma8_19[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.2 */
+	0x211c1400, 0x312e2a26, 0x3d3a3734, 0x4644413f, 0x4e4c4a48, 0x55535150,
+	0x5b5a5857, 0x61605e5d, 0x67666463, 0x6c6b6a68, 0x71706f6d, 0x76757372,
+	0x7a797877, 0x7e7d7c7b, 0x83828180, 0x87868584, 0x8a898888, 0x8e8d8c8b,
+	0x9291908f, 0x95949393, 0x99989796, 0x9c9b9a99, 0x9f9e9e9d, 0xa2a2a1a0,
+	0xa5a5a4a3, 0xa8a8a7a6, 0xababaaa9, 0xaeaeadac, 0xb1b0b0af, 0xb4b3b2b2,
+	0xb7b6b5b5, 0xb9b9b8b7, 0xbcbbbbba, 0xbebebdbd, 0xc1c0c0bf, 0xc4c3c2c2,
+	0xc6c5c5c4, 0xc8c8c7c7, 0xcbcacac9, 0xcdcdcccb, 0xd0cfcece, 0xd2d1d1d0,
+	0xd4d4d3d2, 0xd6d6d5d5, 0xd9d8d8d7, 0xdbdadad9, 0xdddcdcdb, 0xdfdfdede,
+	0xe1e1e0e0, 0xe3e3e2e2, 0xe5e5e4e4, 0xe7e7e6e6, 0xe9e9e8e8, 0xebebeaea,
+	0xededecec, 0xefefeeee, 0xf1f1f0f0, 0xf3f3f2f2, 0xf5f5f4f4, 0xf7f7f6f6,
+	0xf9f9f8f8, 0xfbfafaf9, 0xfdfcfcfb, 0xfffefefd
+};
+
+static const u32 xgamma8_18[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.3 */
+	0x241e1600, 0x35312e29, 0x413e3b38, 0x4a484543, 0x52504e4c, 0x59575654,
+	0x605e5c5b, 0x66646361, 0x6b6a6867, 0x706f6e6c, 0x75747371, 0x7a797776,
+	0x7e7d7c7b, 0x8281807f, 0x86858483, 0x8a898887, 0x8e8d8c8b, 0x9291908f,
+	0x95949493, 0x99989796, 0x9c9b9a9a, 0x9f9e9e9d, 0xa2a2a1a0, 0xa5a5a4a3,
+	0xa8a8a7a6, 0xababaaa9, 0xaeaeadac, 0xb1b0b0af, 0xb4b3b3b2, 0xb7b6b5b5,
+	0xb9b9b8b7, 0xbcbbbbba, 0xbebebdbc, 0xc1c0c0bf, 0xc3c3c2c2, 0xc6c5c5c4,
+	0xc8c8c7c6, 0xcbcac9c9, 0xcdcccccb, 0xcfcfcecd, 0xd1d1d0d0, 0xd4d3d3d2,
+	0xd6d5d5d4, 0xd8d7d7d6, 0xdadad9d9, 0xdcdcdbdb, 0xdededddd, 0xe0e0dfdf,
+	0xe2e2e1e1, 0xe4e4e3e3, 0xe6e6e5e5, 0xe8e8e7e7, 0xeaeae9e9, 0xececebeb,
+	0xeeeeeded, 0xf0f0efef, 0xf2f1f1f1, 0xf4f3f3f2, 0xf6f5f5f4, 0xf7f7f7f6,
+	0xf9f9f8f8, 0xfbfbfafa, 0xfdfcfcfb, 0xfffefefd
+};
+
+static const u32 xgamma8_17[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.4 */
+	0x28211900, 0x3935312d, 0x44423f3c, 0x4e4c4947, 0x56545250, 0x5d5b5a58,
+	0x6462605f, 0x69686765, 0x6f6e6c6b, 0x74737270, 0x79787775, 0x7e7c7b7a,
+	0x8281807f, 0x86858483, 0x8a898887, 0x8e8d8c8b, 0x9291908f, 0x95949393,
+	0x99989796, 0x9c9b9a99, 0x9f9e9e9d, 0xa2a2a1a0, 0xa5a5a4a3, 0xa8a8a7a6,
+	0xababaaa9, 0xaeaeadac, 0xb1b0b0af, 0xb4b3b2b2, 0xb6b6b5b4, 0xb9b8b8b7,
+	0xbcbbbaba, 0xbebebdbc, 0xc1c0bfbf, 0xc3c3c2c1, 0xc6c5c4c4, 0xc8c7c7c6,
+	0xcacac9c8, 0xcccccbcb, 0xcfcececd, 0xd1d0d0cf, 0xd3d3d2d1, 0xd5d5d4d4,
+	0xd7d7d6d6, 0xd9d9d8d8, 0xdcdbdbda, 0xdedddddc, 0xe0dfdfde, 0xe2e1e1e0,
+	0xe4e3e3e2, 0xe5e5e5e4, 0xe7e7e6e6, 0xe9e9e8e8, 0xebebeaea, 0xededecec,
+	0xefeeeeed, 0xf1f0f0ef, 0xf2f2f2f1, 0xf4f4f3f3, 0xf6f6f5f5, 0xf8f7f7f6,
+	0xf9f9f9f8, 0xfbfbfafa, 0xfdfcfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_16[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.5 */
+	0x2b241b00, 0x3c383430, 0x4845423f, 0x524f4d4b, 0x5a585654, 0x615f5d5c,
+	0x67666463, 0x6d6c6a69, 0x7371706f, 0x78777574, 0x7d7b7a79, 0x81807f7e,
+	0x85848382, 0x8a898886, 0x8d8d8c8b, 0x91908f8e, 0x95949392, 0x98989796,
+	0x9c9b9a99, 0x9f9e9d9d, 0xa2a1a1a0, 0xa5a5a4a3, 0xa8a8a7a6, 0xababaaa9,
+	0xaeadadac, 0xb1b0b0af, 0xb4b3b2b2, 0xb6b6b5b4, 0xb9b8b8b7, 0xbbbbbaba,
+	0xbebdbdbc, 0xc0c0bfbf, 0xc3c2c2c1, 0xc5c5c4c3, 0xc8c7c6c6, 0xcac9c9c8,
+	0xcccccbca, 0xcececdcd, 0xd0d0cfcf, 0xd3d2d2d1, 0xd5d4d4d3, 0xd7d6d6d5,
+	0xd9d8d8d7, 0xdbdadad9, 0xdddcdcdb, 0xdfdededd, 0xe1e0e0df, 0xe3e2e2e1,
+	0xe5e4e4e3, 0xe6e6e5e5, 0xe8e8e7e7, 0xeaeae9e9, 0xecebebeb, 0xeeededec,
+	0xefefefee, 0xf1f1f0f0, 0xf3f2f2f2, 0xf5f4f4f3, 0xf6f6f5f5, 0xf8f8f7f7,
+	0xfaf9f9f8, 0xfbfbfafa, 0xfdfcfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_15[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.6 */
+	0x2e271e00, 0x3f3c3833, 0x4c494643, 0x5553514e, 0x5d5b5957, 0x6563615f,
+	0x6b696866, 0x716f6e6d, 0x76757472, 0x7b7a7978, 0x807f7e7d, 0x85838281,
+	0x89888786, 0x8d8c8b8a, 0x91908f8e, 0x94949392, 0x98979695, 0x9b9b9a99,
+	0x9f9e9d9c, 0xa2a1a0a0, 0xa5a4a4a3, 0xa8a7a7a6, 0xabaaaaa9, 0xaeadadac,
+	0xb1b0afaf, 0xb3b3b2b1, 0xb6b5b5b4, 0xb9b8b7b7, 0xbbbbbab9, 0xbebdbcbc,
+	0xc0c0bfbe, 0xc3c2c1c1, 0xc5c4c4c3, 0xc7c7c6c5, 0xc9c9c8c8, 0xcccbcbca,
+	0xcecdcdcc, 0xd0cfcfce, 0xd2d2d1d0, 0xd4d4d3d3, 0xd6d6d5d5, 0xd8d8d7d7,
+	0xdadad9d9, 0xdcdcdbdb, 0xdededddd, 0xe0dfdfdf, 0xe2e1e1e0, 0xe4e3e3e2,
+	0xe6e5e5e4, 0xe7e7e6e6, 0xe9e9e8e8, 0xebeaeaea, 0xedececeb, 0xeeeeeded,
+	0xf0f0efef, 0xf2f1f1f0, 0xf3f3f3f2, 0xf5f5f4f4, 0xf7f6f6f5, 0xf8f8f7f7,
+	0xfaf9f9f9, 0xfbfbfbfa, 0xfdfdfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_14[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.7 */
+	0x312a2000, 0x433f3b36, 0x4f4c4946, 0x59575452, 0x615f5d5b, 0x68666563,
+	0x6f6d6b6a, 0x74737170, 0x7a787776, 0x7f7d7c7b, 0x83828180, 0x88878685,
+	0x8c8b8a89, 0x908f8e8d, 0x94939291, 0x97979695, 0x9b9a9998, 0x9e9d9d9c,
+	0xa2a1a09f, 0xa5a4a3a2, 0xa8a7a6a5, 0xabaaa9a9, 0xaeadacab, 0xb0b0afae,
+	0xb3b2b2b1, 0xb6b5b4b4, 0xb8b8b7b6, 0xbbbabab9, 0xbdbdbcbc, 0xc0bfbfbe,
+	0xc2c2c1c0, 0xc4c4c3c3, 0xc7c6c6c5, 0xc9c8c8c7, 0xcbcbcaca, 0xcdcdcccc,
+	0xcfcfcece, 0xd2d1d0d0, 0xd4d3d3d2, 0xd6d5d5d4, 0xd8d7d7d6, 0xdad9d9d8,
+	0xdbdbdada, 0xdddddcdc, 0xdfdfdede, 0xe1e1e0e0, 0xe3e2e2e1, 0xe5e4e4e3,
+	0xe6e6e6e5, 0xe8e8e7e7, 0xeae9e9e9, 0xecebebea, 0xededecec, 0xefeeeeee,
+	0xf1f0f0ef, 0xf2f2f1f1, 0xf4f3f3f3, 0xf5f5f5f4, 0xf7f7f6f6, 0xf8f8f8f7,
+	0xfafaf9f9, 0xfcfbfbfa, 0xfdfdfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_13[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.8 */
+	0x342d2300, 0x46423e39, 0x52504d4a, 0x5c5a5855, 0x6462605e, 0x6b6a6866,
+	0x72706f6d, 0x78767573, 0x7d7c7a79, 0x82817f7e, 0x87858483, 0x8b8a8988,
+	0x8f8e8d8c, 0x93929190, 0x97969594, 0x9a999898, 0x9e9d9c9b, 0xa1a09f9f,
+	0xa4a3a3a2, 0xa7a7a6a5, 0xaaaaa9a8, 0xadacacab, 0xb0afafae, 0xb3b2b1b1,
+	0xb5b5b4b3, 0xb8b7b7b6, 0xbabab9b9, 0xbdbcbcbb, 0xbfbfbebe, 0xc2c1c1c0,
+	0xc4c3c3c2, 0xc6c6c5c5, 0xc9c8c7c7, 0xcbcacac9, 0xcdcccccb, 0xcfcececd,
+	0xd1d0d0cf, 0xd3d2d2d1, 0xd5d4d4d3, 0xd7d6d6d5, 0xd9d8d8d7, 0xdbdadad9,
+	0xdddcdcdb, 0xdedededd, 0xe0e0dfdf, 0xe2e2e1e1, 0xe4e3e3e2, 0xe5e5e5e4,
+	0xe7e7e6e6, 0xe9e8e8e8, 0xebeaeae9, 0xececebeb, 0xeeededed, 0xefefefee,
+	0xf1f1f0f0, 0xf3f2f2f1, 0xf4f4f3f3, 0xf6f5f5f5, 0xf7f7f6f6, 0xf9f8f8f8,
+	0xfafaf9f9, 0xfcfbfbfb, 0xfdfdfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_12[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 2.9 */
+	0x372f2500, 0x4945413c, 0x5653504d, 0x5f5d5b58, 0x68666462, 0x6f6d6b6a,
+	0x75747270, 0x7b797877, 0x807f7d7c, 0x85848381, 0x8a888786, 0x8e8d8c8b,
+	0x9291908f, 0x96959493, 0x99999897, 0x9d9c9b9a, 0xa0a09f9e, 0xa4a3a2a1,
+	0xa7a6a5a4, 0xaaa9a8a7, 0xadacabaa, 0xafafaead, 0xb2b2b1b0, 0xb5b4b4b3,
+	0xb8b7b6b6, 0xbab9b9b8, 0xbdbcbbbb, 0xbfbebebd, 0xc1c1c0c0, 0xc4c3c2c2,
+	0xc6c5c5c4, 0xc8c7c7c6, 0xcacac9c9, 0xcccccbcb, 0xcececdcd, 0xd0d0cfcf,
+	0xd2d2d1d1, 0xd4d4d3d3, 0xd6d6d5d5, 0xd8d8d7d7, 0xdadad9d9, 0xdcdbdbda,
+	0xdedddddc, 0xdfdfdfde, 0xe1e1e0e0, 0xe3e3e2e2, 0xe5e4e4e3, 0xe6e6e5e5,
+	0xe8e8e7e7, 0xeae9e9e8, 0xebebeaea, 0xedececec, 0xeeeeeeed, 0xf0f0efef,
+	0xf1f1f1f0, 0xf3f3f2f2, 0xf4f4f4f3, 0xf6f6f5f5, 0xf7f7f7f6, 0xf9f9f8f8,
+	0xfafafaf9, 0xfcfbfbfb, 0xfdfdfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_11[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3 */
+	0x39322800, 0x4c49443f, 0x59565350, 0x63605e5c, 0x6b696765, 0x72706e6d,
+	0x78777573, 0x7e7c7b7a, 0x8382807f, 0x88878584, 0x8c8b8a89, 0x91908f8d,
+	0x95949392, 0x98979796, 0x9c9b9a99, 0xa09f9e9d, 0xa3a2a1a0, 0xa6a5a4a4,
+	0xa9a8a8a7, 0xacababaa, 0xafaeadad, 0xb2b1b0b0, 0xb4b4b3b2, 0xb7b6b6b5,
+	0xbab9b8b8, 0xbcbbbbba, 0xbebebdbd, 0xc1c0c0bf, 0xc3c2c2c1, 0xc5c5c4c4,
+	0xc7c7c6c6, 0xcac9c9c8, 0xcccbcbca, 0xcecdcdcc, 0xd0cfcfce, 0xd2d1d1d0,
+	0xd4d3d3d2, 0xd6d5d5d4, 0xd8d7d7d6, 0xd9d9d8d8, 0xdbdbdada, 0xdddddcdc,
+	0xdfdededd, 0xe0e0e0df, 0xe2e2e1e1, 0xe4e3e3e3, 0xe5e5e5e4, 0xe7e7e6e6,
+	0xe9e8e8e7, 0xeaeae9e9, 0xecebebeb, 0xedededec, 0xefefeeee, 0xf0f0f0ef,
+	0xf2f2f1f1, 0xf3f3f3f2, 0xf5f4f4f4, 0xf6f6f6f5, 0xf8f7f7f7, 0xf9f9f8f8,
+	0xfafafaf9, 0xfcfbfbfb, 0xfdfdfcfc, 0xfffefefd
+};
+
+static const u32 xgamma8_10[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.1 */
+	0x3c352a00, 0x4f4c4742, 0x5c595653, 0x6663615f, 0x6e6c6a68, 0x75737170,
+	0x7b7a7876, 0x817f7e7d, 0x86858382, 0x8b898887, 0x8f8e8d8c, 0x93929190,
+	0x97969594, 0x9b9a9998, 0x9f9e9d9c, 0xa2a1a09f, 0xa5a4a4a3, 0xa8a8a7a6,
+	0xababaaa9, 0xaeaeadac, 0xb1b0b0af, 0xb4b3b2b2, 0xb6b6b5b4, 0xb9b8b8b7,
+	0xbbbbbaba, 0xbebdbdbc, 0xc0c0bfbe, 0xc2c2c1c1, 0xc5c4c4c3, 0xc7c6c6c5,
+	0xc9c9c8c7, 0xcbcbcaca, 0xcdcdcccc, 0xcfcfcece, 0xd1d1d0d0, 0xd3d3d2d2,
+	0xd5d5d4d4, 0xd7d6d6d5, 0xd9d8d8d7, 0xdadadad9, 0xdcdcdbdb, 0xdededddd,
+	0xe0dfdfde, 0xe1e1e1e0, 0xe3e3e2e2, 0xe5e4e4e3, 0xe6e6e5e5, 0xe8e7e7e7,
+	0xe9e9e9e8, 0xebebeaea, 0xecececeb, 0xeeeeeded, 0xefefefee, 0xf1f0f0f0,
+	0xf2f2f2f1, 0xf4f3f3f3, 0xf5f5f4f4, 0xf6f6f6f5, 0xf8f8f7f7, 0xf9f9f9f8,
+	0xfbfafafa, 0xfcfcfbfb, 0xfdfdfdfc, 0xfffefefe
+};
+
+static const u32 xgamma8_09[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.2 */
+	0x3f382d00, 0x524f4a45, 0x5f5c5956, 0x69666462, 0x716f6d6b, 0x78767473,
+	0x7e7c7b79, 0x8382817f, 0x89878685, 0x8d8c8b8a, 0x9291908e, 0x96959493,
+	0x9a999897, 0x9d9c9c9b, 0xa1a09f9e, 0xa4a3a3a2, 0xa7a7a6a5, 0xabaaa9a8,
+	0xadadacab, 0xb0b0afae, 0xb3b2b2b1, 0xb6b5b4b4, 0xb8b8b7b6, 0xbbbabab9,
+	0xbdbdbcbb, 0xc0bfbebe, 0xc2c1c1c0, 0xc4c4c3c2, 0xc6c6c5c5, 0xc8c8c7c7,
+	0xcbcacac9, 0xcdcccccb, 0xcfcececd, 0xd1d0d0cf, 0xd2d2d2d1, 0xd4d4d3d3,
+	0xd6d6d5d5, 0xd8d8d7d7, 0xdad9d9d8, 0xdcdbdbda, 0xdddddcdc, 0xdfdedede,
+	0xe1e0e0df, 0xe2e2e1e1, 0xe4e3e3e3, 0xe5e5e5e4, 0xe7e7e6e6, 0xe8e8e8e7,
+	0xeaeae9e9, 0xebebebea, 0xededecec, 0xeeeeeeed, 0xf0efefef, 0xf1f1f1f0,
+	0xf3f2f2f2, 0xf4f4f3f3, 0xf5f5f5f4, 0xf7f6f6f6, 0xf8f8f7f7, 0xf9f9f9f8,
+	0xfbfafafa, 0xfcfcfbfb, 0xfdfdfdfc, 0xfffefefe
+};
+
+static const u32 xgamma8_08[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.3 */
+	0x423a2f00, 0x55514d48, 0x625f5c59, 0x6c696764, 0x7472706e, 0x7b797775,
+	0x817f7e7c, 0x86858382, 0x8b8a8987, 0x908f8e8c, 0x94939291, 0x98979695,
+	0x9c9b9a99, 0xa09f9e9d, 0xa3a2a1a1, 0xa6a6a5a4, 0xaaa9a8a7, 0xadacabaa,
+	0xafafaead, 0xb2b2b1b0, 0xb5b4b4b3, 0xb8b7b6b6, 0xbab9b9b8, 0xbdbcbbbb,
+	0xbfbebebd, 0xc1c1c0c0, 0xc3c3c2c2, 0xc6c5c5c4, 0xc8c7c7c6, 0xcac9c9c8,
+	0xcccbcbca, 0xcecdcdcc, 0xd0cfcfce, 0xd2d1d1d0, 0xd4d3d3d2, 0xd6d5d5d4,
+	0xd7d7d6d6, 0xd9d9d8d8, 0xdbdadad9, 0xdcdcdcdb, 0xdededddd, 0xe0dfdfdf,
+	0xe1e1e1e0, 0xe3e3e2e2, 0xe5e4e4e3, 0xe6e6e5e5, 0xe8e7e7e6, 0xe9e9e8e8,
+	0xebeaeae9, 0xececebeb, 0xedededec, 0xefefeeee, 0xf0f0f0ef, 0xf2f1f1f1,
+	0xf3f3f2f2, 0xf4f4f4f3, 0xf6f5f5f5, 0xf7f7f6f6, 0xf8f8f8f7, 0xfaf9f9f9,
+	0xfbfafafa, 0xfcfcfbfb, 0xfdfdfdfc, 0xfffefefe
+};
+
+static const u32 xgamma8_07[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.4 */
+	0x453d3100, 0x5854504b, 0x65625f5c, 0x6e6c6a67, 0x76747270, 0x7d7c7a78,
+	0x8382807f, 0x89878685, 0x8e8c8b8a, 0x9291908f, 0x97969493, 0x9b9a9998,
+	0x9e9d9c9c, 0xa2a1a09f, 0xa5a4a4a3, 0xa9a8a7a6, 0xacabaaa9, 0xafaeadac,
+	0xb1b1b0af, 0xb4b3b3b2, 0xb7b6b5b5, 0xb9b9b8b7, 0xbcbbbbba, 0xbebebdbc,
+	0xc1c0bfbf, 0xc3c2c2c1, 0xc5c4c4c3, 0xc7c7c6c6, 0xc9c9c8c8, 0xcbcbcaca,
+	0xcdcdcccc, 0xcfcfcece, 0xd1d1d0d0, 0xd3d3d2d2, 0xd5d4d4d3, 0xd7d6d6d5,
+	0xd8d8d7d7, 0xdadad9d9, 0xdcdbdbdb, 0xdddddddc, 0xdfdfdede, 0xe1e0e0df,
+	0xe2e2e1e1, 0xe4e3e3e3, 0xe5e5e5e4, 0xe7e6e6e6, 0xe8e8e8e7, 0xeae9e9e9,
+	0xebebeaea, 0xedececec, 0xeeeeeded, 0xefefefee, 0xf1f0f0f0, 0xf2f2f1f1,
+	0xf3f3f3f2, 0xf5f4f4f4, 0xf6f6f5f5, 0xf7f7f7f6, 0xf8f8f8f8, 0xfaf9f9f9,
+	0xfbfbfafa, 0xfcfcfcfb, 0xfdfdfdfc, 0xfffefefe
+};
+
+static const u32 xgamma8_06[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.5 */
+	0x473f3400, 0x5b57524d, 0x6765625e, 0x716f6c6a, 0x79777573, 0x807e7c7b,
+	0x86848381, 0x8b8a8987, 0x908f8e8c, 0x95949291, 0x99989796, 0x9d9c9b9a,
+	0xa1a09f9e, 0xa4a3a2a1, 0xa7a7a6a5, 0xabaaa9a8, 0xaeadacab, 0xb0b0afae,
+	0xb3b3b2b1, 0xb6b5b5b4, 0xb9b8b7b7, 0xbbbabab9, 0xbdbdbcbc, 0xc0bfbfbe,
+	0xc2c2c1c0, 0xc4c4c3c3, 0xc6c6c5c5, 0xc9c8c8c7, 0xcbcacac9, 0xcdcccccb,
+	0xcfcececd, 0xd0d0d0cf, 0xd2d2d1d1, 0xd4d4d3d3, 0xd6d5d5d5, 0xd8d7d7d6,
+	0xd9d9d9d8, 0xdbdbdada, 0xdddcdcdb, 0xdedededd, 0xe0dfdfdf, 0xe1e1e1e0,
+	0xe3e3e2e2, 0xe4e4e4e3, 0xe6e6e5e5, 0xe7e7e7e6, 0xe9e9e8e8, 0xeaeaeae9,
+	0xecebebeb, 0xededecec, 0xeeeeeeed, 0xf0efefef, 0xf1f1f0f0, 0xf2f2f2f1,
+	0xf4f3f3f3, 0xf5f5f4f4, 0xf6f6f6f5, 0xf7f7f7f6, 0xf9f8f8f8, 0xfafaf9f9,
+	0xfbfbfafa, 0xfcfcfcfb, 0xfdfdfdfc, 0xfffefefe
+};
+
+static const u32 xgamma8_05[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.6 */
+	0x4a423600, 0x5d595550, 0x6a676461, 0x74716f6d, 0x7b7a7876, 0x82817f7d,
+	0x88878584, 0x8e8c8b8a, 0x9291908f, 0x97969594, 0x9b9a9998, 0x9f9e9d9c,
+	0xa3a2a1a0, 0xa6a5a4a3, 0xa9a9a8a7, 0xacacabaa, 0xafafaead, 0xb2b2b1b0,
+	0xb5b4b4b3, 0xb8b7b6b6, 0xbabab9b8, 0xbdbcbbbb, 0xbfbebebd, 0xc1c1c0c0,
+	0xc4c3c2c2, 0xc6c5c5c4, 0xc8c7c7c6, 0xcac9c9c8, 0xcccbcbca, 0xcecdcdcc,
+	0xd0cfcfce, 0xd2d1d1d0, 0xd3d3d3d2, 0xd5d5d4d4, 0xd7d7d6d6, 0xd9d8d8d7,
+	0xdadad9d9, 0xdcdcdbdb, 0xdedddddc, 0xdfdfdede, 0xe1e0e0e0, 0xe2e2e1e1,
+	0xe4e3e3e3, 0xe5e5e4e4, 0xe7e6e6e6, 0xe8e8e7e7, 0xe9e9e9e8, 0xebeaeaea,
+	0xecececeb, 0xeeededed, 0xefefeeee, 0xf0f0efef, 0xf1f1f1f0, 0xf3f2f2f2,
+	0xf4f4f3f3, 0xf5f5f5f4, 0xf6f6f6f5, 0xf8f7f7f7, 0xf9f8f8f8, 0xfafaf9f9,
+	0xfbfbfbfa, 0xfcfcfcfb, 0xfdfdfdfd, 0xfffefefe
+};
+
+static const u32 xgamma8_04[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.7 */
+	0x4c443900, 0x605c5852, 0x6d6a6764, 0x7674726f, 0x7e7c7a78, 0x85838180,
+	0x8a898886, 0x908f8d8c, 0x95939291, 0x99989796, 0x9d9c9b9a, 0xa1a09f9e,
+	0xa5a4a3a2, 0xa8a7a6a5, 0xabaaaaa9, 0xaeaeadac, 0xb1b0b0af, 0xb4b3b3b2,
+	0xb7b6b5b5, 0xb9b9b8b7, 0xbcbbbbba, 0xbebebdbc, 0xc1c0bfbf, 0xc3c2c2c1,
+	0xc5c4c4c3, 0xc7c7c6c5, 0xc9c9c8c8, 0xcbcbcaca, 0xcdcdcccc, 0xcfcfcece,
+	0xd1d0d0d0, 0xd3d2d2d1, 0xd4d4d4d3, 0xd6d6d5d5, 0xd8d8d7d7, 0xdad9d9d8,
+	0xdbdbdada, 0xdddcdcdc, 0xdedededd, 0xe0e0dfdf, 0xe1e1e1e0, 0xe3e3e2e2,
+	0xe4e4e4e3, 0xe6e5e5e5, 0xe7e7e7e6, 0xe9e8e8e8, 0xeaeae9e9, 0xebebebea,
+	0xedececec, 0xeeeeeded, 0xefefefee, 0xf1f0f0f0, 0xf2f1f1f1, 0xf3f3f2f2,
+	0xf4f4f4f3, 0xf5f5f5f5, 0xf7f6f6f6, 0xf8f7f7f7, 0xf9f9f8f8, 0xfafafaf9,
+	0xfbfbfbfa, 0xfcfcfcfb, 0xfdfdfdfd, 0xfffefefe
+};
+
+static const u32 xgamma8_03[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.8 */
+	0x4f473b00, 0x625f5a55, 0x6f6c6966, 0x78767472, 0x807e7d7b, 0x87858482,
+	0x8d8b8a88, 0x92918f8e, 0x97969493, 0x9b9a9998, 0x9f9e9d9c, 0xa3a2a1a0,
+	0xa6a6a5a4, 0xaaa9a8a7, 0xadacabab, 0xb0afafae, 0xb3b2b1b1, 0xb6b5b4b4,
+	0xb8b8b7b6, 0xbbbabab9, 0xbdbdbcbb, 0xc0bfbebe, 0xc2c1c1c0, 0xc4c4c3c2,
+	0xc6c6c5c5, 0xc8c8c7c7, 0xcacac9c9, 0xcccccbcb, 0xcececdcd, 0xd0d0cfcf,
+	0xd2d2d1d1, 0xd4d3d3d2, 0xd6d5d5d4, 0xd7d7d6d6, 0xd9d8d8d8, 0xdadadad9,
+	0xdcdcdbdb, 0xdedddddc, 0xdfdfdede, 0xe1e0e0e0, 0xe2e2e1e1, 0xe4e3e3e3,
+	0xe5e5e4e4, 0xe6e6e6e5, 0xe8e7e7e7, 0xe9e9e9e8, 0xebeaeaea, 0xececebeb,
+	0xededecec, 0xeeeeeeed, 0xf0efefef, 0xf1f1f0f0, 0xf2f2f1f1, 0xf3f3f3f2,
+	0xf4f4f4f4, 0xf6f5f5f5, 0xf7f7f6f6, 0xf8f8f7f7, 0xf9f9f9f8, 0xfafafaf9,
+	0xfbfbfbfa, 0xfcfcfcfc, 0xfdfdfdfd, 0xfffefefe
+};
+
+static const u32 xgamma8_02[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 3.9 */
+	0x51493d00, 0x65615d57, 0x716f6c68, 0x7b797674, 0x83817f7d, 0x89888684,
+	0x8f8e8c8b, 0x94939290, 0x99989695, 0x9d9c9b9a, 0xa1a09f9e, 0xa5a4a3a2,
+	0xa8a7a7a6, 0xacabaaa9, 0xafaeadac, 0xb2b1b0af, 0xb5b4b3b2, 0xb7b7b6b5,
+	0xbab9b9b8, 0xbcbcbbba, 0xbfbebebd, 0xc1c0c0bf, 0xc3c3c2c2, 0xc5c5c4c4,
+	0xc8c7c7c6, 0xcac9c9c8, 0xcccbcbca, 0xcecdcdcc, 0xcfcfcece, 0xd1d1d0d0,
+	0xd3d3d2d2, 0xd5d4d4d3, 0xd6d6d6d5, 0xd8d8d7d7, 0xdad9d9d9, 0xdbdbdbda,
+	0xdddddcdc, 0xdedededd, 0xe0e0dfdf, 0xe1e1e1e0, 0xe3e2e2e2, 0xe4e4e4e3,
+	0xe6e5e5e5, 0xe7e7e6e6, 0xe8e8e8e7, 0xeae9e9e9, 0xebebeaea, 0xecececeb,
+	0xeeededed, 0xefeeeeee, 0xf0f0efef, 0xf1f1f1f0, 0xf2f2f2f2, 0xf4f3f3f3,
+	0xf5f4f4f4, 0xf6f6f5f5, 0xf7f7f6f6, 0xf8f8f8f7, 0xf9f9f9f8, 0xfafafaf9,
+	0xfbfbfbfb, 0xfcfcfcfc, 0xfdfdfdfd, 0xfffefefe
+};
+
+static const u32 xgamma8_01[XISP_GAMMA8_TABLE_LENGTH] = {
+	/* For Gamma : 4 */
+	0x534b3f00, 0x67635f5a, 0x74716e6b, 0x7d7b7976, 0x8583817f, 0x8b8a8886,
+	0x91908e8d, 0x96959492, 0x9b9a9897, 0x9f9e9d9c, 0xa3a2a1a0, 0xa7a6a5a4,
+	0xaaa9a8a7, 0xadacacab, 0xb0b0afae, 0xb3b3b2b1, 0xb6b5b5b4, 0xb9b8b7b7,
+	0xbbbbbab9, 0xbebdbdbc, 0xc0c0bfbe, 0xc2c2c1c1, 0xc5c4c3c3, 0xc7c6c6c5,
+	0xc9c8c8c7, 0xcbcacac9, 0xcdcccccb, 0xcfcececd, 0xd0d0d0cf, 0xd2d2d1d1,
+	0xd4d4d3d3, 0xd6d5d5d4, 0xd7d7d7d6, 0xd9d9d8d8, 0xdbdadad9, 0xdcdcdbdb,
+	0xdedddddd, 0xdfdfdede, 0xe1e0e0e0, 0xe2e2e1e1, 0xe4e3e3e2, 0xe5e5e4e4,
+	0xe6e6e6e5, 0xe8e7e7e7, 0xe9e9e8e8, 0xeaeaeae9, 0xebebebeb, 0xedececec,
+	0xeeeeeded, 0xefefefee, 0xf0f0f0ef, 0xf2f1f1f1, 0xf3f2f2f2, 0xf4f4f3f3,
+	0xf5f5f4f4, 0xf6f6f6f5, 0xf7f7f7f6, 0xf8f8f8f7, 0xf9f9f9f9, 0xfafafafa,
+	0xfbfbfbfb, 0xfcfcfcfc, 0xfdfdfdfd, 0xfffefefe
+};
+
+static const u32 *xgamma_curves[XISP_GAMMA_CURVE_LENGTH] =  {
+	&xgamma8_01[0],
+	&xgamma8_02[0],
+	&xgamma8_03[0],
+	&xgamma8_04[0],
+	&xgamma8_05[0],
+	&xgamma8_06[0],
+	&xgamma8_07[0],
+	&xgamma8_08[0],
+	&xgamma8_09[0],
+	&xgamma8_10[0],
+	&xgamma8_11[0],
+	&xgamma8_12[0],
+	&xgamma8_13[0],
+	&xgamma8_14[0],
+	&xgamma8_15[0],
+	&xgamma8_16[0],
+	&xgamma8_17[0],
+	&xgamma8_18[0],
+	&xgamma8_19[0],
+	&xgamma8_20[0],
+	&xgamma8_21[0],
+	&xgamma8_22[0],
+	&xgamma8_23[0],
+	&xgamma8_24[0],
+	&xgamma8_25[0],
+	&xgamma8_26[0],
+	&xgamma8_27[0],
+	&xgamma8_28[0],
+	&xgamma8_29[0],
+	&xgamma8_30[0],
+	&xgamma8_31[0],
+	&xgamma8_32[0],
+	&xgamma8_33[0],
+	&xgamma8_34[0],
+	&xgamma8_35[0],
+	&xgamma8_36[0],
+	&xgamma8_37[0],
+	&xgamma8_38[0],
+	&xgamma8_39[0],
+	&xgamma8_40[0],
+};
+
+#endif /* __XILINX_GAMMA_CORRECTION_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-gamma.c b/drivers/media/platform/xilinx/xilinx-gamma.c
new file mode 100644
index 000000000..6ee17892e
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-gamma.c
@@ -0,0 +1,565 @@
+/*
+ * Xilinx Gamma Correction IP
+ *
+ * Copyright (C) 2017 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-gamma-coeff.h"
+#include "xilinx-vip.h"
+
+#define XGAMMA_MIN_HEIGHT	(64)
+#define XGAMMA_MAX_HEIGHT	(4320)
+#define XGAMMA_DEF_HEIGHT	(720)
+#define XGAMMA_MIN_WIDTH	(64)
+#define XGAMMA_MAX_WIDTH	(8192)
+#define XGAMMA_DEF_WIDTH	(1280)
+
+#define XGAMMA_AP_CTRL			(0x0000)
+#define XGAMMA_GIE			(0x0004)
+#define XGAMMA_IER			(0x0008)
+#define XGAMMA_ISR			(0x000c)
+#define XGAMMA_WIDTH			(0x0010)
+#define XGAMMA_HEIGHT			(0x0018)
+#define XGAMMA_VIDEO_FORMAT		(0x0020)
+#define XGAMMA_GAMMA_LUT_0_BASE		(0x0800)
+#define XGAMMA_GAMMA_LUT_1_BASE		(0x1000)
+#define XGAMMA_GAMMA_LUT_2_BASE		(0x1800)
+
+#define XGAMMA_RESET_DEASSERT	(0)
+#define XGAMMA_RESET_ASSERT	(1)
+#define XGAMMA_START		BIT(0)
+#define XGAMMA_AUTO_RESTART	BIT(7)
+#define XGAMMA_STREAM_ON	(XGAMMA_START | XGAMMA_AUTO_RESTART)
+
+enum xgamma_video_format {
+	XGAMMA_RGB = 0,
+};
+
+/**
+ * struct xgamma_dev - Xilinx Video Gamma LUT device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: Scaler sub-device media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @ctrl_handler: V4L2 Control Handler for R,G,B Gamma Controls
+ * @red_lut: Pointer to the gamma coefficient as per the Red Gamma control
+ * @green_lut: Pointer to the gamma coefficient as per the Green Gamma control
+ * @blue_lut: Pointer to the gamma coefficient as per the Blue Gamma control
+ * @color_depth: Color depth of the Video Gamma IP
+ * @gamma_table: Pointer to the table containing various gamma values
+ * @rst_gpio: GPIO reset line to bring VPSS Scaler out of reset
+ * @max_width: Maximum width supported by this instance.
+ * @max_height: Maximum height supported by this instance.
+ */
+struct xgamma_dev {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	const u16 *red_lut;
+	const u16 *green_lut;
+	const u16 *blue_lut;
+	u32 color_depth;
+	const u16 **gamma_table;
+	struct gpio_desc *rst_gpio;
+	u32 max_width;
+	u32 max_height;
+};
+
+static inline u32 xg_read(struct xgamma_dev *xg, u32 reg)
+{
+	u32 data;
+
+	data = xvip_read(&xg->xvip, reg);
+	dev_dbg(xg->xvip.dev,
+		"Reading 0x%x from reg offset 0x%x", data, reg);
+	return data;
+}
+
+static inline void xg_write(struct xgamma_dev *xg, u32 reg, u32 data)
+{
+	dev_dbg(xg->xvip.dev,
+		"Writing 0x%x to reg offset 0x%x", data, reg);
+	xvip_write(&xg->xvip, reg, data);
+#ifdef DEBUG
+	if (xg_read(xg, reg) != data)
+		dev_err(xg->xvip.dev,
+			"Write 0x%x does not match read back", data);
+#endif
+}
+
+static inline struct xgamma_dev *to_xg(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xgamma_dev, xvip.subdev);
+}
+
+static struct v4l2_mbus_framefmt *
+__xg_get_pad_format(struct xgamma_dev *xg,
+		    struct v4l2_subdev_state *sd_state,
+		    unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xg->xvip.subdev, sd_state,
+						    pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xg->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static void xg_set_lut_entries(struct xgamma_dev *xg,
+			       const u16 *lut, const u32 lut_base)
+{
+	int itr;
+	u32 lut_offset, lut_data;
+
+	lut_offset = lut_base;
+	/* Write LUT Entries */
+	for (itr = 0; itr < BIT(xg->color_depth - 1); itr++) {
+		lut_data = (lut[2 * itr + 1] << 16) | lut[2 * itr];
+		xg_write(xg, lut_offset, lut_data);
+		lut_offset += 4;
+	}
+}
+
+static int xg_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xgamma_dev *xg = to_xg(subdev);
+
+	if (!enable) {
+		dev_dbg(xg->xvip.dev, "%s : Off", __func__);
+		gpiod_set_value_cansleep(xg->rst_gpio, XGAMMA_RESET_ASSERT);
+		gpiod_set_value_cansleep(xg->rst_gpio, XGAMMA_RESET_DEASSERT);
+		return 0;
+	}
+	dev_dbg(xg->xvip.dev, "%s : Started", __func__);
+
+	dev_dbg(xg->xvip.dev, "%s : Setting width %d and height %d",
+		__func__, xg->formats[XVIP_PAD_SINK].width,
+		xg->formats[XVIP_PAD_SINK].height);
+	xg_write(xg, XGAMMA_WIDTH, xg->formats[XVIP_PAD_SINK].width);
+	xg_write(xg, XGAMMA_HEIGHT, xg->formats[XVIP_PAD_SINK].height);
+	xg_write(xg, XGAMMA_VIDEO_FORMAT, XGAMMA_RGB);
+	xg_set_lut_entries(xg, xg->red_lut, XGAMMA_GAMMA_LUT_0_BASE);
+	xg_set_lut_entries(xg, xg->green_lut, XGAMMA_GAMMA_LUT_1_BASE);
+	xg_set_lut_entries(xg, xg->blue_lut, XGAMMA_GAMMA_LUT_2_BASE);
+
+	/* Start GAMMA Correction LUT Video IP */
+	xg_write(xg, XGAMMA_AP_CTRL, XGAMMA_STREAM_ON);
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops xg_video_ops = {
+	.s_stream = xg_s_stream,
+};
+
+static int xg_get_format(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_state *sd_state,
+			 struct v4l2_subdev_format *fmt)
+{
+	struct xgamma_dev *xg = to_xg(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xg_get_pad_format(xg, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xg_set_format(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_state *sd_state,
+			 struct v4l2_subdev_format *fmt)
+{
+	struct xgamma_dev *xg = to_xg(subdev);
+	struct v4l2_mbus_framefmt *__format;
+
+	__format = __xg_get_pad_format(xg, sd_state, fmt->pad, fmt->which);
+	if (!__format)
+		return -EINVAL;
+
+	*__format = fmt->format;
+
+	if (fmt->pad == XVIP_PAD_SINK) {
+		if (__format->code != MEDIA_BUS_FMT_RBG888_1X24) {
+			dev_dbg(xg->xvip.dev,
+				"Unsupported sink media bus code format");
+			__format->code = MEDIA_BUS_FMT_RBG888_1X24;
+		}
+	}
+	__format->width = clamp_t(unsigned int, fmt->format.width,
+				  XGAMMA_MIN_WIDTH, xg->max_width);
+	__format->height = clamp_t(unsigned int, fmt->format.height,
+				   XGAMMA_MIN_HEIGHT, xg->max_height);
+
+	fmt->format = *__format;
+	/* Propagate to Source Pad */
+	__format = __xg_get_pad_format(xg, sd_state, XVIP_PAD_SOURCE,
+				       fmt->which);
+	if (!__format)
+		return -EINVAL;
+
+	*__format = fmt->format;
+	return 0;
+}
+
+static int xg_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xgamma_dev *xg = to_xg(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xg->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SOURCE);
+	*format = xg->default_formats[XVIP_PAD_SOURCE];
+	return 0;
+}
+
+static int xg_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops xg_internal_ops = {
+	.open = xg_open,
+	.close = xg_close,
+};
+
+static const struct v4l2_subdev_pad_ops xg_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xg_get_format,
+	.set_fmt = xg_set_format,
+};
+
+static const struct v4l2_subdev_ops xg_ops = {
+	.video = &xg_video_ops,
+	.pad = &xg_pad_ops,
+};
+
+static int
+select_gamma(s32 value, const u16 **coeff, const u16 **xgamma_curves)
+{
+	if (!coeff)
+		return -EINVAL;
+	if (value <= 0 || value > GAMMA_CURVE_LENGTH)
+		return -EINVAL;
+
+	*coeff = *(xgamma_curves + value - 1);
+	return 0;
+}
+
+static int xg_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int rval;
+	struct xgamma_dev *xg =
+		container_of(ctrl->handler,
+			     struct xgamma_dev, ctrl_handler);
+	dev_dbg(xg->xvip.dev, "%s called", __func__);
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_GAMMA_CORR_RED_GAMMA:
+		rval = select_gamma(ctrl->val, &xg->red_lut, xg->gamma_table);
+		if (rval < 0) {
+			dev_err(xg->xvip.dev, "Invalid Red Gamma");
+			return rval;
+		}
+		dev_dbg(xg->xvip.dev, "%s: Setting Red Gamma to %d.%d",
+			__func__, ctrl->val / 10, ctrl->val % 10);
+		xg_set_lut_entries(xg, xg->red_lut, XGAMMA_GAMMA_LUT_0_BASE);
+		break;
+	case V4L2_CID_XILINX_GAMMA_CORR_BLUE_GAMMA:
+		rval = select_gamma(ctrl->val, &xg->blue_lut, xg->gamma_table);
+		if (rval < 0) {
+			dev_err(xg->xvip.dev, "Invalid Blue Gamma");
+			return rval;
+		}
+		dev_dbg(xg->xvip.dev, "%s: Setting Blue Gamma to %d.%d",
+			__func__, ctrl->val / 10, ctrl->val % 10);
+		xg_set_lut_entries(xg, xg->blue_lut, XGAMMA_GAMMA_LUT_1_BASE);
+		break;
+	case V4L2_CID_XILINX_GAMMA_CORR_GREEN_GAMMA:
+		rval = select_gamma(ctrl->val, &xg->green_lut, xg->gamma_table);
+		if (rval < 0) {
+			dev_err(xg->xvip.dev, "Invalid Green Gamma");
+			return -EINVAL;
+		}
+		dev_dbg(xg->xvip.dev, "%s: Setting Green Gamma to %d.%d",
+			__func__, ctrl->val / 10, ctrl->val % 10);
+		xg_set_lut_entries(xg, xg->green_lut, XGAMMA_GAMMA_LUT_2_BASE);
+		break;
+	}
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops xg_ctrl_ops = {
+	.s_ctrl = xg_s_ctrl,
+};
+
+static struct v4l2_ctrl_config xg_ctrls[] = {
+	/* Red Gamma */
+	{
+		.ops = &xg_ctrl_ops,
+		.id = V4L2_CID_XILINX_GAMMA_CORR_RED_GAMMA,
+		.name = "Red Gamma Correction|1->0.1|10->1.0",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 40,
+		.step = 1,
+		.def = 10,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Blue Gamma */
+	{
+		.ops = &xg_ctrl_ops,
+		.id = V4L2_CID_XILINX_GAMMA_CORR_BLUE_GAMMA,
+		.name = "Blue Gamma Correction|1->0.1|10->1.0",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 40,
+		.step = 1,
+		.def = 10,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Green Gamma */
+	{
+		.ops = &xg_ctrl_ops,
+		.id = V4L2_CID_XILINX_GAMMA_CORR_GREEN_GAMMA,
+		.name = "Green Gamma Correction|1->0.1|10->1.0)",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 40,
+		.step = 1,
+		.def = 10,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+};
+
+static const struct media_entity_operations xg_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int xg_parse_of(struct xgamma_dev *xg)
+{
+	struct device *dev = xg->xvip.dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id = 0;
+	int rval;
+
+	rval = of_property_read_u32(node, "xlnx,max-height", &xg->max_height);
+	if (rval < 0) {
+		dev_err(dev, "xlnx,max-height is missing!");
+		return -EINVAL;
+	} else if (xg->max_height > XGAMMA_MAX_HEIGHT ||
+		   xg->max_height < XGAMMA_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u32(node, "xlnx,max-width", &xg->max_width);
+	if (rval < 0) {
+		dev_err(dev, "xlnx,max-width is missing!");
+		return -EINVAL;
+	} else if (xg->max_width > XGAMMA_MAX_WIDTH ||
+		   xg->max_width < XGAMMA_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			rval = of_property_read_u32(port, "reg", &port_id);
+			if (rval < 0) {
+				dev_err(dev, "No reg in DT");
+				return rval;
+			}
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "Invalid reg in DT");
+				return -EINVAL;
+			}
+
+			rval = of_property_read_u32(port, "xlnx,video-width",
+						    &xg->color_depth);
+			if (rval < 0) {
+				dev_err(dev, "Missing xlnx-video-width in DT");
+				return rval;
+			}
+			switch (xg->color_depth) {
+			case GAMMA_BPC_8:
+				xg->gamma_table = xgamma8_curves;
+				break;
+			case GAMMA_BPC_10:
+				xg->gamma_table = xgamma10_curves;
+				break;
+			default:
+				dev_err(dev, "Unsupported color depth %d",
+					xg->color_depth);
+				return -EINVAL;
+			}
+		}
+	}
+
+	xg->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(xg->rst_gpio)) {
+		if (PTR_ERR(xg->rst_gpio) != -EPROBE_DEFER)
+			dev_err(dev, "Reset GPIO not setup in DT");
+		return PTR_ERR(xg->rst_gpio);
+	}
+	return 0;
+}
+
+static int xg_probe(struct platform_device *pdev)
+{
+	struct xgamma_dev *xg;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *def_fmt;
+	int rval, itr;
+
+	dev_dbg(&pdev->dev, "Gamma LUT Probe Started");
+	xg = devm_kzalloc(&pdev->dev, sizeof(*xg), GFP_KERNEL);
+	if (!xg)
+		return -ENOMEM;
+	xg->xvip.dev = &pdev->dev;
+	rval = xg_parse_of(xg);
+	if (rval < 0)
+		return rval;
+	rval = xvip_init_resources(&xg->xvip);
+	if (rval)
+		return -EIO;
+
+	dev_dbg(xg->xvip.dev, "Reset Xilinx Video Gamma Corrrection");
+	gpiod_set_value_cansleep(xg->rst_gpio, XGAMMA_RESET_DEASSERT);
+
+	/* Init V4L2 subdev */
+	subdev = &xg->xvip.subdev;
+	v4l2_subdev_init(subdev, &xg_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xg_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Default Formats Initialization */
+	def_fmt = &xg->default_formats[XVIP_PAD_SINK];
+	/* GAMMA LUT IP only to be supported for RGB */
+	def_fmt->code = MEDIA_BUS_FMT_RBG888_1X24;
+	def_fmt->field = V4L2_FIELD_NONE;
+	def_fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	def_fmt->width = XGAMMA_DEF_WIDTH;
+	def_fmt->height = XGAMMA_DEF_HEIGHT;
+	xg->formats[XVIP_PAD_SINK] = *def_fmt;
+
+	def_fmt = &xg->default_formats[XVIP_PAD_SOURCE];
+	*def_fmt = xg->default_formats[XVIP_PAD_SINK];
+	xg->formats[XVIP_PAD_SOURCE] = *def_fmt;
+
+	xg->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xg->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Init Media Entity */
+	subdev->entity.ops = &xg_media_ops;
+	rval = media_entity_pads_init(&subdev->entity, 2, xg->pads);
+	if (rval < 0)
+		goto media_error;
+
+	/* V4L2 Controls */
+	v4l2_ctrl_handler_init(&xg->ctrl_handler, ARRAY_SIZE(xg_ctrls));
+	for (itr = 0; itr < ARRAY_SIZE(xg_ctrls); itr++) {
+		v4l2_ctrl_new_custom(&xg->ctrl_handler,
+				     &xg_ctrls[itr], NULL);
+	}
+	if (xg->ctrl_handler.error) {
+		dev_err(&pdev->dev, "Failed to add V4L2 controls");
+		rval = xg->ctrl_handler.error;
+		goto ctrl_error;
+	}
+	subdev->ctrl_handler = &xg->ctrl_handler;
+	rval = v4l2_ctrl_handler_setup(&xg->ctrl_handler);
+	if (rval < 0) {
+		dev_err(&pdev->dev, "Failed to setup control handler");
+		goto  ctrl_error;
+	}
+
+	platform_set_drvdata(pdev, xg);
+	rval = v4l2_async_register_subdev(subdev);
+	if (rval < 0) {
+		dev_err(&pdev->dev, "failed to register subdev");
+		goto v4l2_subdev_error;
+	}
+	dev_info(&pdev->dev,
+		 "Xilinx %d-bit Video Gamma Correction LUT registered",
+		 xg->color_depth);
+	return 0;
+ctrl_error:
+	v4l2_ctrl_handler_free(&xg->ctrl_handler);
+v4l2_subdev_error:
+	media_entity_cleanup(&subdev->entity);
+media_error:
+	xvip_cleanup_resources(&xg->xvip);
+	return rval;
+}
+
+static int xg_remove(struct platform_device *pdev)
+{
+	struct xgamma_dev *xg = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xg->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	/* Add entry to cleanup v4l2 control handle */
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xg->xvip);
+	return 0;
+}
+
+static const struct of_device_id xg_of_id_table[] = {
+	{.compatible = "xlnx,v-gamma-lut"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xg_of_id_table);
+
+static struct platform_driver xg_driver = {
+	.driver = {
+		.name = "xilinx-gamma-lut",
+		.of_match_table = xg_of_id_table,
+	},
+	.probe = xg_probe,
+	.remove = xg_remove,
+};
+
+module_platform_driver(xg_driver);
+MODULE_DESCRIPTION("Xilinx Video Gamma Correction LUT Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-hdcp1x-rx.c b/drivers/media/platform/xilinx/xilinx-hdcp1x-rx.c
new file mode 100644
index 000000000..5bd6f2c6d
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdcp1x-rx.c
@@ -0,0 +1,824 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx HDCP1X driver
+ *
+ * Copyright (C) 2022 Xilinx, Inc.
+ *
+ * Author: Jagadeesh Banisetti <jagadeesh.banisetti@xilin.com>
+ *
+ */
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/xlnx/xilinx-hdcp1x-cipher.h>
+#include "xilinx-hdcp1x-rx.h"
+
+/*
+ * HDCP1X PORT registers, please refer
+ * 'HDCP on DisplayPort Specification Rev. 1.1' from DCP-LLC.
+ */
+#define XHDCP1X_PORT_OFFSET_BKSV	0x00
+#define XHDCP1X_PORT_OFFSET_RO		0x05
+#define XHDCP1X_PORT_OFFSET_AKSV	0x07
+#define XHDCP1X_PORT_OFFSET_AN		0x0C
+#define XHDCP1X_PORT_OFFSET_VH0		0x14
+#define XHDCP1X_PORT_OFFSET_VH1		0x18
+#define XHDCP1X_PORT_OFFSET_VH2		0x1C
+#define XHDCP1X_PORT_OFFSET_VH3		0x20
+#define XHDCP1X_PORT_OFFSET_VH4		0x24
+#define XHDCP1X_PORT_OFFSET_BCAPS	0x28
+#define XHDCP1X_PORT_OFFSET_BSTATUS	0x29
+#define XHDCP1X_PORT_OFFSET_BINFO	0x2A
+#define XHDCP1X_PORT_OFFSET_KSVFIFO	0x2C
+#define XHDCP1X_PORT_OFFSET_AINFO	0x3B
+#define XHDCP1X_PORT_OFFSET_DBG		0xC0
+#define XHDCP1X_PORT_HDCP_RESET_KSV	0xD0
+
+#define XHDCP1X_PORT_SIZE_BKSV		0x05
+#define XHDCP1X_PORT_SIZE_RO		0x02
+#define XHDCP1X_PORT_SIZE_RI		0x02
+#define XHDCP1X_PORT_SIZE_AKSV		0x05
+#define XHDCP1X_PORT_SIZE_AN		0x08
+#define XHDCP1X_PORT_SIZE_VH0		0x04
+#define XHDCP1X_PORT_SIZE_VH1		0x04
+#define XHDCP1X_PORT_SIZE_VH2		0x04
+#define XHDCP1X_PORT_SIZE_VH3		0x04
+#define XHDCP1X_PORT_SIZE_VH4		0x04
+#define XHDCP1X_PORT_SIZE_BCAPS		0x01
+#define XHDCP1X_PORT_SIZE_BSTATUS	0x01
+#define XHDCP1X_PORT_SIZE_BINFO		0x02
+#define XHDCP1X_PORT_SIZE_KSVFIFO	0x0F
+#define XHDCP1X_PORT_SIZE_AINFO		0x01
+#define XHDCP1X_PORT_SIZE_HDCP_RESET_KSV 0x40
+#define XHDCP1X_PORT_BIT_BSTATUS_READY		BIT(0)
+#define XHDCP1X_PORT_BIT_BSTATUS_RO_AVAILABLE	BIT(1)
+#define XHDCP1X_PORT_BIT_BSTATUS_LINK_FAILURE	BIT(2)
+#define XHDCP1X_PORT_BIT_BSTATUS_REAUTH_REQUEST	BIT(3)
+#define XHDCP1X_PORT_BIT_BCAPS_HDCP_CAPABLE	BIT(0)
+#define XHDCP1X_PORT_BIT_BCAPS_REPEATER		BIT(1)
+#define XHDCP1X_PORT_BIT_AINFO_REAUTH_ENABLE_IRQ	BIT(0)
+#define XHDCP1X_PORT_HDCP_RESET_KSV_RST		BIT(0)
+#define XHDCP1X_PORT_BINFO_DEV_CNT_MASK		GENMASK(6, 0)
+#define XHDCP1X_PORT_BINFO_DEV_CNT_ERR_SHIFT	7
+#define XHDCP1X_PORT_BINFO_DEPTH_ERR_SHIFT	11
+#define XHDCP1X_PORT_BINFO_DEPTH_SHIFT		8
+#define XHDCP1X_PORT_DEBUG_VAL			0xDEADBEEF
+#define XHDCP1X_PORT_SIZE_DEBUG			4
+#define XHDCP1X_PORT_SIZE_REGS_TO_RESET		14
+#define XHDCP1X_LANE_COUNT_VAL_1		1
+#define XHDCP1X_LANE_COUNT_VAL_2		2
+#define XHDCP1X_LANE_COUNT_VAL_4		4
+#define XHDCP1X_RX_CIPHER_REQUEST_RETRY		100
+/*
+ * HDCP1X PORT registers, please refer
+ * 'HDCP Specification Rev. 1.4' from DCP-LLC.
+ */
+#define XHDCP1X_PORT_HDMI_OFFSET_RO		0x08
+#define XHDCP1X_PORT_HDMI_OFFSET_AKSV		0x10
+#define XHDCP1X_PORT_HDMI_OFFSET_AN		0x18
+#define XHDCP1X_PORT_HDMI_OFFSET_BCAPS		0x40
+#define XHDCP1X_PORT_HDMI_OFFSET_BSTATUS	0x41
+#define XHDCP1X_PORT_HDMI_SIZE_BSTATUS		0x02
+#define XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE	BIT(12)
+#define XHDCP1X_PORT_BIT_BCAPS_HDMI		BIT(7)
+
+#define XHDCP1X_RI_UPDATE_MIN_DELAY		0x300
+#define XHDCP1X_RI_UPDATE_MAX_DELAY		0x400
+
+/*
+ * states of hdcp1x state machine, please refer
+ * 'HDCP on DisplayPort Specification Rev. 1.1' from DCP-LLC.
+ */
+enum xhdcp1x_rx_state {
+	XHDCP1X_STATE_B0 = 0,
+	XHDCP1X_STATE_B1 = 1,
+	XHDCP1X_STATE_B2 = 2,
+	XHDCP1X_STATE_B3 = 3,
+	XHDCP1X_RX_NUM_STATES = 4
+};
+
+/**
+ * struct xhdcp1x_rx_callbacks - Hdcp1x driver's callback handlers structure
+ * @rd_handler: Handler to read hdcp data through interface driver (DP/HDMI)
+ * @wr_handler: Handler to write hdcp data through interface driver (DP/HDMI)
+ * @notify_handler: Handler to push hdcp notifications to interface driver
+ */
+struct xhdcp1x_rx_callbacks {
+	int (*rd_handler)(void *interface_ref, u32 offset, u8 *buf, u32 size);
+	int (*wr_handler)(void *interface_ref, u32 offset, u8 *buf, u32 size);
+	void (*notify_handler)(void *interface_ref, u32 notification);
+};
+
+/**
+ * struct xhdcp1x_rx - HDCP1x driver structure
+ * @dev: Platfor structure
+ * @handlers: Callback handlers to interface driver
+ * @sm_work: state-machine worker
+ * @curr_state: Current authentication state
+ * @protocol: HDMI or DP
+ * @prev_state: Previous authentication state
+ * @cipher: Pointer to cipher driver instance
+ * @interface_ref: Pointer to interface driver instance
+ * @interface_base: Pointer to interface iomem base
+ * @pending_events: events that are set by ineterface driver
+ * @protocol: current protocol of Rx Video interface (None,HDMI or DP)
+ * @is_repeater: flag for repeater support
+ * @is_enabled: flag for HDCP module status
+ */
+struct xhdcp1x_rx {
+	struct device		*dev;
+	struct xhdcp1x_rx_callbacks handlers;
+	struct delayed_work	sm_work;
+	enum xhdcp1x_rx_state	curr_state;
+	enum xhdcp1x_rx_protocol	protocol;
+	enum xhdcp1x_rx_state	prev_state;
+	void			*cipher;
+	void			*interface_ref;
+	void __iomem		*interface_base;
+	u32			pending_events;
+	bool			is_repeater;
+	bool			is_enabled;
+};
+
+#ifdef DEBUG
+const char *state_names[XHDCP1X_RX_NUM_STATES] = {
+	"STATE_B0",
+	"STATE_B1",
+	"STATE_B2",
+	"STATE_B3"
+};
+
+/*
+ * State transitions
+ *    |	  B0	    B1	       B2	   B3
+ *----|-----------------------------------------
+ * B0 |  valid	   valid     invalid     invalid
+ *    |
+ * B1 |  valid     valid      valid      invalid
+ *    |
+ * B2 |  valid     valid      valid       valid
+ *    |
+ * B3 | invalid    valid     invalid     invalid
+ */
+static bool transition_table[XHDCP1X_RX_NUM_STATES][XHDCP1X_RX_NUM_STATES] = {
+		{1, 1, 0, 0},
+		{1, 1, 1, 0},
+		{1, 1, 1, 1},
+		{0, 0, 1, 0}
+	};
+#endif
+
+static enum xhdcp1x_rx_state xhdcp1x_state_B0(void *);
+static enum xhdcp1x_rx_state xhdcp1x_state_B1(void *);
+static enum xhdcp1x_rx_state xhdcp1x_state_B2(void *);
+static enum xhdcp1x_rx_state xhdcp1x_state_B3(void *);
+static void xhdcp1x_rx_run_statemachine(struct xhdcp1x_rx *hdcp1x);
+static void xhdcp1x_rx_process_aksv(struct xhdcp1x_rx *hdcp1x);
+static int xhdcp1x_rx_poll_for_computations(struct xhdcp1x_rx *hdcp1x);
+static void hdcp1x_rx_set_clr_bstatus(struct xhdcp1x_rx *hdcp1x, u8 mask,
+				      u8 set);
+static void xhdcp1x_rx_set_hdmimode(struct xhdcp1x_rx *hdcp1x, u8 set);
+
+static inline void xhdcp1x_buf_to_uint(u64 *dst, u8 *src, int length)
+{
+	if (length) {
+		int byte;
+
+		*dst = 0;
+		for (byte = length; byte >= 0; byte--) {
+			*dst <<= 8;
+			*dst  |= src[byte];
+		}
+	}
+}
+
+static inline void xhdcp1x_rx_reset_port(struct xhdcp1x_rx *hdcp1x)
+{
+	u8 buf[XHDCP1X_PORT_SIZE_REGS_TO_RESET] = {0};
+	u8 offset;
+
+	offset = (hdcp1x->protocol == XHDCP1X_HDMI) ? XHDCP1X_PORT_HDMI_OFFSET_RO :
+		  XHDCP1X_PORT_OFFSET_RO;
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    offset, buf, XHDCP1X_PORT_SIZE_REGS_TO_RESET);
+}
+
+static inline void xhdcp1x_rx_reset_bstatus(struct xhdcp1x_rx *hdcp1x)
+{
+	u8 buf = 0;
+	u8 offset, size;
+
+	if (hdcp1x->protocol == XHDCP1X_HDMI) {
+		offset = XHDCP1X_PORT_HDMI_OFFSET_BSTATUS;
+		size = XHDCP1X_PORT_HDMI_SIZE_BSTATUS;
+	} else {
+		offset = XHDCP1X_PORT_OFFSET_BSTATUS;
+		size = XHDCP1X_PORT_SIZE_BSTATUS;
+	}
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref, offset, &buf,
+				    size);
+}
+
+static inline void xhdcp1x_rx_reset_binfo(struct xhdcp1x_rx *hdcp1x)
+{
+	u8 buf[XHDCP1X_PORT_SIZE_BINFO] = {0};
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_OFFSET_BINFO, buf,
+				    XHDCP1X_PORT_SIZE_BINFO);
+}
+
+static inline void xhdcp1x_rx_reset_bcaps(struct xhdcp1x_rx *hdcp1x)
+{
+	u8 buf[XHDCP1X_PORT_SIZE_BCAPS] = {0};
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_OFFSET_BCAPS, buf,
+				    XHDCP1X_PORT_SIZE_BCAPS);
+}
+
+static inline void xhdcp1x_rx_init_debug_regs(struct xhdcp1x_rx *hdcp1x)
+{
+	u32 buf = XHDCP1X_PORT_DEBUG_VAL;
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_OFFSET_DBG, (u8 *)&buf,
+				    XHDCP1X_PORT_SIZE_DEBUG);
+}
+
+static inline void xhdcp1x_rx_read_aksv(struct xhdcp1x_rx *hdcp1x, u64 *value)
+{
+	u8 buf[XHDCP1X_PORT_SIZE_AKSV];
+	u8 offset;
+
+	offset = (hdcp1x->protocol == XHDCP1X_HDMI) ? XHDCP1X_PORT_HDMI_OFFSET_AKSV :
+		  XHDCP1X_PORT_OFFSET_AKSV;
+
+	hdcp1x->handlers.rd_handler(hdcp1x->interface_ref, offset, buf,
+				    XHDCP1X_PORT_SIZE_AKSV);
+	xhdcp1x_buf_to_uint(value, buf, XHDCP1X_PORT_SIZE_AKSV);
+}
+
+static inline void xhdcp1x_rx_read_an(struct xhdcp1x_rx *hdcp1x, u64 *value)
+{
+	u8 buf[XHDCP1X_PORT_SIZE_AN] = {0};
+	u8 offset;
+
+	offset = (hdcp1x->protocol == XHDCP1X_HDMI) ? XHDCP1X_PORT_HDMI_OFFSET_AN :
+		  XHDCP1X_PORT_OFFSET_AN;
+
+	hdcp1x->handlers.rd_handler(hdcp1x->interface_ref, offset, buf, XHDCP1X_PORT_SIZE_AN);
+	xhdcp1x_buf_to_uint(value, buf, XHDCP1X_PORT_SIZE_AN);
+}
+
+static inline void xhdcp1x_rx_reset_ksv_fifo(struct xhdcp1x_rx *hdcp1x)
+{
+	u32 ksv_ptr_reset;
+
+	hdcp1x->handlers.rd_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_HDCP_RESET_KSV,
+				    (u8 *)&ksv_ptr_reset,
+				    sizeof(ksv_ptr_reset));
+	ksv_ptr_reset |= XHDCP1X_PORT_HDCP_RESET_KSV_RST;
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_HDCP_RESET_KSV,
+				    (u8 *)&ksv_ptr_reset,
+				    sizeof(ksv_ptr_reset));
+	ksv_ptr_reset &= ~XHDCP1X_PORT_HDCP_RESET_KSV_RST;
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_HDCP_RESET_KSV,
+				    (u8 *)&ksv_ptr_reset,
+				    sizeof(ksv_ptr_reset));
+}
+
+static void xhdcp1x_sm_work_func(struct work_struct *work)
+{
+	struct xhdcp1x_rx *hdcp1x;
+
+	hdcp1x = container_of(work, struct xhdcp1x_rx, sm_work.work);
+	if (hdcp1x->pending_events)
+		xhdcp1x_rx_run_statemachine(hdcp1x);
+}
+
+/* function pointers declarations */
+static enum xhdcp1x_rx_state (*xhdcp1x_rx_state_table[])(void *) = {
+	xhdcp1x_state_B0,
+	xhdcp1x_state_B1,
+	xhdcp1x_state_B2,
+	xhdcp1x_state_B3
+};
+
+/*****************************************************************************/
+/**
+ * xhdcp1x_rx_init - Initialise HDCP1x driver instance
+ * @dev: Platform data
+ * @interface_ref: void pointer to interface driver instance
+ * @interface_base: Pointer to interface iomem base
+ * @is_repeater: flag for repeater support
+ * @protocol: flag for interface type, HDMI or DP
+ * This function instantiates the hdcp1x driver and initializes it.
+ *
+ * Return: void reference to hdcp1x driver instance on success, error otherwise
+ */
+void *xhdcp1x_rx_init(struct device *dev, void *interface_ref,
+		      void __iomem *interface_base, bool is_repeater,
+		      enum xhdcp1x_rx_protocol protocol)
+{
+	struct xhdcp1x_rx *hdcp1x;
+
+	if (!dev || !interface_ref || !interface_base)
+		return ERR_PTR(-EINVAL);
+
+	if (is_repeater) {
+		dev_info(dev, "Hdcp1x repeater functionality not supported\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	hdcp1x = devm_kzalloc(dev, sizeof(*hdcp1x), GFP_KERNEL);
+	if (!hdcp1x)
+		return ERR_PTR(-ENOMEM);
+
+	hdcp1x->dev = dev;
+	hdcp1x->interface_ref = interface_ref;
+	hdcp1x->interface_base = interface_base;
+	hdcp1x->is_repeater = is_repeater;
+
+	hdcp1x->protocol = protocol;
+	hdcp1x->is_enabled = false;
+	/* cipher initialization */
+	hdcp1x->cipher = xhdcp1x_cipher_init(dev, interface_base);
+	if (IS_ERR(hdcp1x->cipher))
+		return hdcp1x->cipher;
+
+	INIT_DELAYED_WORK(&hdcp1x->sm_work, xhdcp1x_sm_work_func);
+
+	return (void *)hdcp1x;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_init);
+
+/**
+ * xhdcp1x_rx_enable - Enable hdcp1x
+ * @ref: reference to hdcp1x instance
+ * @lane_count: count of active lanes in interface driver
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_enable(void *ref, u8 lane_count)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+	int ret;
+	u8 buf = 0, offset;
+
+	if (!hdcp1x)
+		return -EINVAL;
+
+	if (!hdcp1x->is_enabled)
+		return 0;
+
+	if (lane_count != XHDCP1X_LANE_COUNT_VAL_1 &&
+	    lane_count != XHDCP1X_LANE_COUNT_VAL_2 &&
+	    lane_count != XHDCP1X_LANE_COUNT_VAL_4) {
+		dev_info(hdcp1x->dev, "Invalid Lanecount\n");
+		return -EINVAL;
+	}
+
+	ret = xhdcp1x_cipher_set_num_lanes(hdcp1x->cipher, lane_count);
+	if (ret)
+		return ret;
+
+	xhdcp1x_rx_reset_port(hdcp1x);
+	xhdcp1x_rx_reset_bstatus(hdcp1x);
+	xhdcp1x_rx_init_debug_regs(hdcp1x);
+
+	offset = (hdcp1x->protocol == XHDCP1X_HDMI) ? XHDCP1X_PORT_HDMI_OFFSET_BCAPS :
+		  XHDCP1X_PORT_OFFSET_BCAPS;
+
+	buf |= XHDCP1X_PORT_BIT_BCAPS_HDCP_CAPABLE;
+
+	if (hdcp1x->is_repeater)
+		buf |= XHDCP1X_PORT_BIT_BCAPS_REPEATER;
+
+	if (hdcp1x->protocol == XHDCP1X_DP) {
+		xhdcp1x_rx_reset_binfo(hdcp1x);
+		xhdcp1x_rx_reset_bcaps(hdcp1x);
+		xhdcp1x_rx_set_hdmimode(hdcp1x, false);
+	} else {
+		buf |= XHDCP1X_PORT_BIT_BCAPS_HDMI;
+		xhdcp1x_rx_set_hdmimode(hdcp1x, true);
+	}
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    offset, &buf,
+				    XHDCP1X_PORT_SIZE_BCAPS);
+
+	hdcp1x->is_enabled = true;
+	ret = xhdcp1x_cipher_enable(hdcp1x->cipher);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_enable);
+
+/**
+ * xhdcp1x_rx_disable - Disable hdcp1x
+ * @ref: reference to hdcp1x instance
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_disable(void *ref)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+	int ret;
+
+	if (!hdcp1x)
+		return -EINVAL;
+
+	ret = xhdcp1x_cipher_disable(hdcp1x->cipher);
+	if (ret)
+		return ret;
+
+	if (hdcp1x->protocol == XHDCP1X_HDMI) {
+		xhdcp1x_rx_set_hdmimode(hdcp1x, false);
+		xhdcp1x_cipher_set_ri(hdcp1x->cipher, false);
+		xhdcp1x_rx_reset_bstatus(hdcp1x);
+		xhdcp1x_rx_reset_binfo(hdcp1x);
+		xhdcp1x_rx_reset_bcaps(hdcp1x);
+	}
+
+	hdcp1x->curr_state = XHDCP1X_STATE_B0;
+	hdcp1x->prev_state = XHDCP1X_STATE_B0;
+	hdcp1x->pending_events = 0;
+	hdcp1x->is_enabled = false;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_disable);
+
+/**
+ * xhdcp1x_rx_set_callback - register callback handlers of interface driver
+ * @ref: reference to hdcp1x instance
+ * @handler_type: type of the handler
+ * @handler: pointer to the callback handler
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_set_callback(void *ref, u32 handler_type, void *handler)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+
+	if (!hdcp1x || !handler)
+		return -EINVAL;
+
+	switch (handler_type) {
+	case XHDCP1X_RX_RD_HANDLER:
+		hdcp1x->handlers.rd_handler = handler;
+		break;
+	case XHDCP1X_RX_WR_HANDLER:
+		hdcp1x->handlers.wr_handler = handler;
+		break;
+	case XHDCP1X_RX_NOTIFICATION_HANDLER:
+		hdcp1x->handlers.notify_handler = handler;
+		break;
+	default:
+		dev_info(hdcp1x->dev, "wrong handler type\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_set_callback);
+
+/**
+ * xhdcp1x_rx_handle_intr - Handles the hdcp interrupts
+ * @ref: reference to hdcp1x instance
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_handle_intr(void *ref)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+	u32 interrupts;
+
+	if (!hdcp1x)
+		return -EINVAL;
+
+	if (xhdcp1x_cipher_get_interrupts(hdcp1x->cipher, &interrupts))
+		return -EIO;
+	if (interrupts)
+		xhdcp1x_rx_push_events(hdcp1x, XHDCP1X_RX_CIPHER_EVENT_RCVD);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_handle_intr);
+
+/**
+ * xhdcp1x_rx_push_events - Pushes events from interface driver to hdcp driver
+ * @ref: reference to hdcp1x instance
+ * @events: events that are pushed from interface driver
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_push_events(void *ref, u32 events)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+
+	if (!hdcp1x)
+		return -EINVAL;
+
+	if (events) {
+		hdcp1x->pending_events |= events;
+		schedule_delayed_work(&hdcp1x->sm_work, 0);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_push_events);
+
+/**
+ * xhdcp1x_rx_set_keyselect - Selects the keyvector form key management block
+ * @ref: reference to hdcp1x instance
+ * @keyselect: keyvector selection
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_set_keyselect(void *ref, u8 keyselect)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+
+	if (!hdcp1x)
+		return -EINVAL;
+
+	return xhdcp1x_cipher_set_keyselect(hdcp1x->cipher, keyselect);
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_set_keyselect);
+
+/**
+ * xhdcp1x_rx_load_bksv - loads the local ksv to hdcp port
+ * @ref: reference to hdcp1x instance
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp1x_rx_load_bksv(void *ref)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+	u8 buf[XHDCP1X_PORT_SIZE_BKSV];
+
+	if (!hdcp1x)
+		return -EINVAL;
+
+	if (xhdcp1x_cipher_load_bksv(hdcp1x->cipher, buf))
+		return -EAGAIN;
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    XHDCP1X_PORT_OFFSET_BKSV, buf,
+				    XHDCP1X_PORT_SIZE_BKSV);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xhdcp1x_rx_load_bksv);
+
+/********************** Static function definitions ***************************/
+static void xhdcp1x_rx_run_statemachine(struct xhdcp1x_rx *hdcp1x)
+{
+	enum xhdcp1x_rx_state new_state;
+
+	do {
+#ifdef DEBUG
+		if (!transition_table[hdcp1x->prev_state][hdcp1x->curr_state])
+			dev_info(hdcp1x->dev,
+				 "Invalid HDCP1X State transition %s -> %s\n",
+				 state_names[hdcp1x->prev_state],
+				 state_names[hdcp1x->curr_state]);
+#endif
+
+		new_state = xhdcp1x_rx_state_table[hdcp1x->curr_state](hdcp1x);
+
+		hdcp1x->prev_state = hdcp1x->curr_state;
+		hdcp1x->curr_state = new_state;
+	} while (hdcp1x->prev_state != hdcp1x->curr_state);
+}
+
+static enum xhdcp1x_rx_state xhdcp1x_state_B0(void *instance)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)instance;
+
+	/* Nothing to be done here, just wait for the Aksv */
+	if (hdcp1x->pending_events & XHDCP1X_RX_AKSV_RCVD)
+		return XHDCP1X_STATE_B1;
+	else
+		return XHDCP1X_STATE_B0;
+}
+
+static enum xhdcp1x_rx_state xhdcp1x_state_B1(void *instance)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)instance;
+
+	if (hdcp1x->pending_events & XHDCP1X_RX_AKSV_RCVD) {
+		xhdcp1x_rx_process_aksv(hdcp1x);
+		xhdcp1x_rx_poll_for_computations(hdcp1x);
+		hdcp1x->pending_events &= ~XHDCP1X_RX_AKSV_RCVD;
+
+		if (hdcp1x->protocol == XHDCP1X_HDMI)
+			return XHDCP1X_STATE_B3;
+		else
+			return XHDCP1X_STATE_B2;
+	}
+
+	return XHDCP1X_STATE_B1;
+}
+
+static int xhdcp1x_rx_update_ri(void *ref)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)ref;
+	u16 ri, retry = XHDCP1X_RX_CIPHER_REQUEST_RETRY;
+	u8 buf[4], offset;
+
+	while (!xhdcp1x_cipher_is_request_complete(hdcp1x->cipher) && retry--)
+		;
+	/* wait the requested amount of time to avoid cpu introduced delays */
+
+	/* This delay is not a specification recommended. This is added to
+	 * met/avoid any processor specific related delays.
+	 */
+	usleep_range(XHDCP1X_RI_UPDATE_MIN_DELAY,
+		     XHDCP1X_RI_UPDATE_MAX_DELAY);
+
+	if (!retry)
+		return -EAGAIN;
+
+	if (xhdcp1x_cipher_get_ri(hdcp1x->cipher, &ri))
+		return -EIO;
+
+	memcpy(buf, &ri, XHDCP1X_PORT_SIZE_RI);
+
+	offset = (hdcp1x->protocol == XHDCP1X_HDMI) ? XHDCP1X_PORT_HDMI_OFFSET_RO :
+		  XHDCP1X_PORT_OFFSET_RO;
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref,
+				    offset, buf, XHDCP1X_PORT_SIZE_RI);
+
+	return 0;
+}
+
+/* TODO: Need to cancel the workqueue of hdcp1x before disabling it */
+static enum xhdcp1x_rx_state xhdcp1x_state_B2(void *instance)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)instance;
+
+	if (hdcp1x->pending_events & XHDCP1X_RX_AKSV_RCVD)
+		return XHDCP1X_STATE_B1;
+
+	if (hdcp1x->pending_events & XHDCP1X_RX_RO_PRIME_READ_DONE) {
+		hdcp1x_rx_set_clr_bstatus(hdcp1x,
+					  XHDCP1X_PORT_BIT_BSTATUS_RO_AVAILABLE,
+					  0);
+		hdcp1x->pending_events &= ~XHDCP1X_RX_RO_PRIME_READ_DONE;
+		return XHDCP1X_STATE_B3;
+	}
+
+	if (hdcp1x->pending_events & XHDCP1X_RX_CIPHER_EVENT_RCVD) {
+		hdcp1x->pending_events &= ~XHDCP1X_RX_CIPHER_EVENT_RCVD;
+
+		if (hdcp1x->protocol == XHDCP1X_DP) {
+			if (xhdcp1x_cipher_is_linkintegrity_failed(hdcp1x->cipher)) {
+				hdcp1x_rx_set_clr_bstatus(hdcp1x,
+							  XHDCP1X_PORT_BIT_BSTATUS_LINK_FAILURE,
+							  1);
+
+				if (hdcp1x->handlers.notify_handler)
+					hdcp1x->handlers.notify_handler(hdcp1x->interface_ref,
+						XHDCP1X_RX_NOTIFY_SET_CP_IRQ);
+
+				xhdcp1x_cipher_disable(hdcp1x->cipher);
+				xhdcp1x_cipher_reset(hdcp1x->cipher);
+				xhdcp1x_cipher_enable(hdcp1x->cipher);
+
+				return XHDCP1X_STATE_B1;
+			}
+		}
+		if (!xhdcp1x_cipher_is_request_to_change_ri(hdcp1x->cipher)) {
+			xhdcp1x_rx_update_ri(hdcp1x);
+
+			return XHDCP1X_STATE_B2;
+		}
+	}
+
+	if (hdcp1x->prev_state == XHDCP1X_STATE_B3 &&
+	    hdcp1x->handlers.notify_handler)
+		hdcp1x->handlers.notify_handler(hdcp1x->interface_ref,
+						XHDCP1X_RX_NOTIFY_AUTHENTICATED);
+
+	return XHDCP1X_STATE_B2;
+}
+
+static enum xhdcp1x_rx_state xhdcp1x_state_B3(void *instance)
+{
+	struct xhdcp1x_rx *hdcp1x = (struct xhdcp1x_rx *)instance;
+
+	/*
+	 * For DP, the link integrity will be checked in cipher and
+	 * an interrupt will be raised if the integrity is failed. Here
+	 * it just required to enable the interrupts for link integrity
+	 * and go to state_B2(Authenticated)
+	 */
+	if (hdcp1x->protocol == XHDCP1X_DP)
+		xhdcp1x_cipher_set_link_state_check(hdcp1x->cipher, true);
+	else
+		xhdcp1x_cipher_set_ri(hdcp1x->cipher, true);
+
+	return XHDCP1X_STATE_B2;
+}
+
+static void xhdcp1x_rx_process_aksv(struct xhdcp1x_rx *hdcp1x)
+{
+	u64 value;
+
+	xhdcp1x_rx_reset_bstatus(hdcp1x);
+	xhdcp1x_rx_read_aksv(hdcp1x, &value);
+	if (xhdcp1x_cipher_set_remoteksv(hdcp1x->cipher, value))
+		dev_dbg(hdcp1x->dev, "Failed to configure Aksv into cipher\n");
+	xhdcp1x_rx_read_an(hdcp1x, &value);
+
+	/* Load the cipher B registers with An */
+	if (xhdcp1x_cipher_set_b(hdcp1x->cipher, value, hdcp1x->is_repeater))
+		dev_dbg(hdcp1x->dev, "Failed to configure An into cipher\n");
+}
+
+static int xhdcp1x_rx_poll_for_computations(struct xhdcp1x_rx *hdcp1x)
+{
+	u16 ro;
+	u16 retry = XHDCP1X_RX_CIPHER_REQUEST_RETRY;
+	u8 buf[4], offset;
+
+	while (!xhdcp1x_cipher_is_request_complete(hdcp1x->cipher) && retry--)
+		;
+
+	if (!retry)
+		return -EAGAIN;
+
+	if (xhdcp1x_cipher_get_ro(hdcp1x->cipher, &ro))
+		return -EIO;
+
+	memcpy(buf, &ro, XHDCP1X_PORT_SIZE_RO);
+
+	offset = (hdcp1x->protocol == XHDCP1X_HDMI) ? XHDCP1X_PORT_HDMI_OFFSET_RO :
+		  XHDCP1X_PORT_OFFSET_RO;
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref, offset, buf, XHDCP1X_PORT_SIZE_RO);
+
+	if (hdcp1x->protocol == XHDCP1X_DP) {
+		/* Reset the KSV FIFO read pointer to 0x6802C */
+		xhdcp1x_rx_reset_ksv_fifo(hdcp1x);
+
+		/* Update the Bstatus to indicate Ro' available */
+		hdcp1x_rx_set_clr_bstatus(hdcp1x, XHDCP1X_PORT_BIT_BSTATUS_RO_AVAILABLE,
+					  1);
+		if (hdcp1x->handlers.notify_handler)
+			hdcp1x->handlers.notify_handler(hdcp1x->interface_ref,
+							XHDCP1X_RX_NOTIFY_SET_CP_IRQ);
+	}
+
+	return 0;
+}
+
+static void hdcp1x_rx_set_clr_bstatus(struct xhdcp1x_rx *hdcp1x, u8 mask,
+				      u8 set)
+{
+	u8 val, offset, size;
+
+	if (hdcp1x->protocol == XHDCP1X_DP) {
+		offset = XHDCP1X_PORT_OFFSET_BSTATUS;
+		size = XHDCP1X_PORT_SIZE_BSTATUS;
+	} else {
+		offset = XHDCP1X_PORT_HDMI_OFFSET_BSTATUS;
+		size = XHDCP1X_PORT_HDMI_SIZE_BSTATUS;
+	}
+
+	hdcp1x->handlers.rd_handler(hdcp1x->interface_ref, offset, &val, size);
+
+	if (set)
+		val |= mask;
+	else
+		val &= ~mask;
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref, offset, &val, size);
+}
+
+static void xhdcp1x_rx_set_hdmimode(struct xhdcp1x_rx *hdcp1x,
+				    u8 set)
+{
+	u32 val;
+	u8 offset, size;
+
+	if (hdcp1x->protocol == XHDCP1X_DP) {
+		offset = XHDCP1X_PORT_OFFSET_BSTATUS;
+		size = XHDCP1X_PORT_SIZE_BSTATUS;
+	} else {
+		offset = XHDCP1X_PORT_HDMI_OFFSET_BSTATUS;
+		size = XHDCP1X_PORT_HDMI_SIZE_BSTATUS;
+	}
+
+	hdcp1x->handlers.rd_handler(hdcp1x->interface_ref, offset, (u8 *)&val, size);
+
+	if (set)
+		val |= XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE;
+	else
+		val &= ~XHDCP1X_PORT_BIT_BSTATUS_HDMI_MODE;
+
+	hdcp1x->handlers.wr_handler(hdcp1x->interface_ref, offset, (u8 *)&val, size);
+}
diff --git a/drivers/media/platform/xilinx/xilinx-hdcp1x-rx.h b/drivers/media/platform/xilinx/xilinx-hdcp1x-rx.h
new file mode 100644
index 000000000..f8ed13c1a
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdcp1x-rx.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx HDCP1X driver
+ *
+ * Copyright (C) 2022 Xilinx, Inc.
+ *
+ * Author: Jagadeesh Banisetti <jagadeesh.banisetti@xilinx.com>
+ */
+
+#ifndef __XILINX_HDCP1X_RX_H__
+#define __XILINX_HDCP1X_RX_H__
+
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+
+/* HDCP1X over a specified protocol */
+enum xhdcp1x_rx_protocol {
+	XHDCP1X_DP = 1,
+	XHDCP1X_HDMI = 2
+};
+
+enum xhdcp1x_rx_events {
+	XHDCP1X_RX_AKSV_RCVD = 0x01,
+	XHDCP1X_RX_RO_PRIME_READ_DONE = 0x02,
+	XHDCP1X_RX_CIPHER_EVENT_RCVD = 0x04
+	/* TODO: Add for HDMI events */
+};
+
+enum xhdcp1x_rx_notifications {
+	XHDCP1X_RX_NOTIFY_AUTHENTICATED = 1,
+	XHDCP1X_RX_NOTIFY_UN_AUTHENTICATED = 2,
+	XHDCP1X_RX_NOTIFY_SET_CP_IRQ = 3
+};
+
+enum xhdcp1x_rx_handler_type {
+	XHDCP1X_RX_RD_HANDLER = 1,
+	XHDCP1X_RX_WR_HANDLER = 2,
+	XHDCP1X_RX_NOTIFICATION_HANDLER = 3,
+};
+
+#if IS_ENABLED(CONFIG_VIDEO_XILINX_HDCP1X_RX)
+void *xhdcp1x_rx_init(struct device *dev, void *interface_ref,
+		      void __iomem *interface_base, bool is_repeater,
+		      enum xhdcp1x_rx_protocol protocol);
+int xhdcp1x_rx_enable(void *ref, u8 lane_count);
+int xhdcp1x_rx_disable(void *ref);
+int xhdcp1x_rx_set_callback(void *ref, u32 handler_type, void *handler);
+int xhdcp1x_rx_handle_intr(void *ref);
+int xhdcp1x_rx_push_events(void *ref, u32 events);
+int xhdcp1x_rx_set_keyselect(void *ref, u8 keyselect);
+int xhdcp1x_rx_load_bksv(void *ref);
+#else
+static inline void *xhdcp1x_rx_init(struct device *dev, void *interface_ref,
+				    void __iomem *interface_base, bool is_repeater)
+{
+	return ERR_PTR(-EINVAL);
+}
+
+static inline int xhdcp1x_rx_enable(void *ref, u8 lane_count)
+{
+	return -EINVAL;
+}
+
+static inline int xhdcp1x_rx_disable(void *ref)
+{
+	return -EINVAL;
+}
+
+static inline int xhdcp1x_rx_set_callback(void *ref, u32 handler_type, void *handler)
+{
+	return -EINVAL;
+}
+
+static inline int xhdcp1x_rx_handle_intr(void *ref)
+{
+	return -EINVAL;
+}
+
+static inline int xhdcp1x_rx_push_events(void *ref, u32 events)
+{
+	return -EINVAL;
+}
+
+static inline int xhdcp1x_rx_set_keyselect(void *ref, u8 keyselect)
+{
+	return -EINVAL;
+}
+
+static inline int xhdcp1x_rx_load_bksv(void *ref)
+{
+	return -EINVAL;
+}
+#endif /* CONFIG_VIDEO_XILINX_HDCP1X_RX */
+#endif /* __XILINX_HDCP1X_RX_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-hdcp2x-rx-crypt.c b/drivers/media/platform/xilinx/xilinx-hdcp2x-rx-crypt.c
new file mode 100644
index 000000000..0f926531a
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdcp2x-rx-crypt.c
@@ -0,0 +1,620 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx HDCP2X Cryptography driver
+ *
+ * Copyright (C) 2023, Advanced Micro Devices, Inc. All rights reserved.
+ *
+ * Author: Kunal Vasant Rane <kunal.rane@amd.com>
+ *
+ * This driver provides Xilinx HDCP 2X receiver cryptographic
+ * functionality.
+ *
+ * References:
+ *
+ * http://www.citi.umich.edu/projects/nfsv4/rfc/pkcs-1v2-1.pdf
+ * https://www.cryptrec.go.jp/cryptrec_03_spec_cypherlist_files/PDF/pkcs-1v2-12.pdf
+ * https://www.digital-cp.com/sites/default/files/HDCP%20on%20DisplayPort%20Specification%20Rev2_3.pdf
+ */
+
+#include <crypto/aes.h>
+#include <crypto/sha2.h>
+#include <linux/delay.h>
+#include <linux/xlnx/xlnx_hdcp_common.h>
+#include <linux/xlnx/xlnx_hdcp_rng.h>
+#include <linux/xlnx/xlnx_hdcp2x_cipher.h>
+#include <linux/xlnx/xlnx_timer.h>
+#include "xilinx-hdcp2x-rx.h"
+
+#define XHDCP2X_SHA256_SIZE		(256 / 8)
+#define XHDCP2X_RX_MP_SIZE_OF(a) (sizeof(a) / sizeof(u32))
+#define XHDCP2X_RX_SHA_SIZE		256
+#define XHDCP2X_RX_SHA_KEY_LENGTH	64
+#define XHDCP2X_RX_INNER_PADDING_BYTE	0x36
+#define XHDCP2X_RX_OUTER_PADDING_BYTE	0x5C
+#define XHDCP2X_NDIGITS			16
+#define XHDCP2X_NDIGITS_MULT		4
+
+/**
+ * xlnx_hdcp2x_rx_aes128_encrypt() - encrypts 16 bytes data with key of size 16 bytes
+ * @data: Input is the 16 byte plaintext
+ * @key: User supplied key
+ * @output: 16 byte cipher text
+ */
+static void xlnx_hdcp2x_rx_aes128_encrypt(const u8 *data, const u8 *key, u8 *output)
+{
+	struct crypto_aes_ctx ctx;
+
+	aes_expandkey(&ctx, key, 16);
+	aes_encrypt(&ctx, output, data);
+	memzero_explicit(&ctx, sizeof(ctx));
+}
+
+/**
+ * xhdcp2x_rx_calc_mont_nprime() - calculate Montgomery NPrime
+ * @ref: void pointer for passing dummy structure pointer.
+ * @nprime: pointer for nprimep.
+ * @n: pointer for privatekey.
+ * @ndigits: pointer for key size.
+ *
+ * The modulus N has a fixed size of k = 512bits and give k,
+ * r = 2^(k), and rinv is the modular inverse of r.
+ * reference:
+ * Analyzing and Comparing Montgomery Multiplication Algorithms
+ * IEEE Micro, 16(3):26-33,June 1996
+ * By: Cetin Koc, Tolga Acar, and Burton Kaliski
+ *
+ * Return: 0 on success, otherwise EINVAL.
+ */
+int xhdcp2x_rx_calc_mont_nprime(void *ref, u8 *nprime, const u8 *n, int ndigits)
+{
+	u32 n_i[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 nprime_i[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 r[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 rinv[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 t1[XHDCP2X_RX_P_SIZE] = {0};
+	u32 t2[XHDCP2X_RX_N_SIZE] = {0};
+
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)ref;
+
+	mp_conv_from_octets(n_i, XHDCP2X_RX_MP_SIZE_OF(n_i), n, XHDCP2X_NDIGITS_MULT * ndigits);
+
+	/* Step 1: R = 2^(NDigits*32) */
+	r[0] = 1;
+	mp_shift_left(r, r, 32 * ndigits, XHDCP2X_RX_MP_SIZE_OF(r));
+
+	/* Step 2: rinv = r^(-1) * mod(N) */
+	t1[0] = 0;
+	memcpy(t1, n_i, sizeof(n_i));
+	if (mp_mod_inv(rinv, r, t1, XHDCP2X_RX_MP_SIZE_OF(rinv))) {
+		dev_err(xhdcp2x_rx->dev, "Error: Failed rinv calculation");
+		return -EINVAL;
+	}
+
+	/* Step 3: NPrime = (r*rinv-1)/N */
+	mp_multiply(t1, r, rinv, 2 * ndigits);
+	t2[0] = 1;
+	mp_subtract(t1, t1, t2, XHDCP2X_RX_MP_SIZE_OF(t1));
+	mp_divide(nprime_i, t2, t1, XHDCP2X_RX_MP_SIZE_OF(nprime_i), (u32 *)n_i, ndigits);
+
+	/* Step 4: Sanity Check, R*Rinv - N*NPrime == 1 */
+	mp_multiply(t1, r, rinv, 2 * ndigits);
+	mp_multiply(t2, (u32 *)n_i, nprime_i, XHDCP2X_RX_MP_SIZE_OF(nprime_i));
+	mp_subtract(t1, t1, t2, XHDCP2X_RX_MP_SIZE_OF(t1));
+	memset(t2, 0, sizeof(t2));
+	t2[0] = 1;
+	if (!mp_equal(t1, t2, XHDCP2X_RX_MP_SIZE_OF(t1))) {
+		dev_err(xhdcp2x_rx->dev, "Error: Failed NPrime calculation");
+		return -EINVAL;
+	}
+
+	mp_conv_to_octets(nprime_i, ndigits, nprime, XHDCP2X_NDIGITS_MULT * ndigits);
+
+	return 0;
+}
+
+static void xhdcp2x_rx_xor(u8 *cout, const u8 *ain, const u8 *bin, u32 len)
+{
+	while (len--)
+		cout[len] = ain[len] ^ bin[len];
+}
+
+/**
+ * xhdcp2x_rx_pkcs1_mgf1()- calculate mgf1.
+ * @seed: pointer for input seed.
+ * @seedlen: input seedlen.
+ * @mask: input mask.
+ * @masklen: input masklen.
+ *
+ * Reference:
+ * https://www.cryptrec.go.jp/cryptrec_03_spec_cypherlist_files
+ * /PDF/pkcs-1v2-12.pdf
+ * Section: B.2.1
+ */
+static void xhdcp2x_rx_pkcs1_mgf1(const u8 *seed, const u32 seedlen, u8 *mask, u32 masklen)
+{
+	u8 hash[XHDCP2X_RX_HASH_SIZE] = {0};
+	u8 hash_data[XHDCP2X_RX_N_SIZE] = {0};
+	u8 t[XHDCP2X_RX_N_SIZE] = {0};
+	u32 c;
+
+	memcpy(hash_data, seed, seedlen);
+
+	for (c = 0; (c * XHDCP2X_RX_HASH_SIZE) < masklen; c++) {
+		u32 counter;
+
+		counter = ntohl(c);
+		memcpy(hash_data + seedlen, &counter, XHDCP2X_NDIGITS_MULT);
+		sha256(hash_data, seedlen + XHDCP2X_NDIGITS_MULT, hash);
+		memcpy(t + c * XHDCP2X_RX_HASH_SIZE, hash, XHDCP2X_RX_HASH_SIZE);
+	}
+	memcpy(mask, t, masklen);
+}
+
+/**
+ * xhdcp2x_rx_pkcs1_mont_mult_fios_init()- Initialize Montgomery core
+ * functions.
+ * @xhdcp2x_rx: structure pointer for HDCP2x.
+ * @n: pointer for exponentiation input.
+ * @nprime: pointer for nprime number.
+ * @ndigits: pointer for ndigits.
+ *
+ * Reference:
+ * Analyzing and Comparing Montgomery Multiplication Algorithms
+ * IEEE Micro, 16(3):26-33,June 1996
+ * By: Cetin Koc, Tolga Acar, and Burton Kaliski
+ *
+ * Return: 0 on success, otherwise ETIME
+ */
+static int xhdcp2x_rx_pkcs1_mont_mult_fios_init(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+						u32 *n, const u32 *nprime, int ndigits)
+{
+	u32 timeout = 1000; /* us */
+
+	while (xlnx_hdcp2x_mmult_is_ready(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst) == 0) {
+		if (timeout == 0) {
+			dev_err(xhdcp2x_rx->dev, "Error: MMULT core is not ready");
+			return -ETIME;
+		}
+
+		timeout--;
+		udelay(1);
+	}
+
+	xlnx_hdcp2x_mmult_write_type(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst, 0, (int *)n,
+				     ndigits, XHDCP2X_MMULT_N);
+	xlnx_hdcp2x_mmult_write_type(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst, 0, (int *)nprime,
+				     ndigits, XHDCP2X_MMULT_NPRIME);
+
+	return 0;
+}
+
+/**
+ * xhdcp2x_rx_pkcs1_mont_mult_fios()- calculate pkcs1 mont mult fios.
+ * @xhdcp2x_rx: HDCP structure pointer.
+ * @u: pointer for modulas multiplier.
+ * @a: pointer for modulas multiplier.
+ * @b: pointer for modulas multiplier.
+ * @ndigits: input for mmult register write.
+ *
+ * This function offers Modular multiplication operation required
+ * by RSA decryption.
+ *
+ * Return: 0 on success, otherwise return ETIME.
+ */
+static int xhdcp2x_rx_pkcs1_mont_mult_fios(struct xlnx_hdcp2x_config *xhdcp2x_rx, u32 *u,
+					   u32 *a, u32 *b, int ndigits)
+{
+	u32 timeout = 1000; /* us */
+
+	while (xlnx_hdcp2x_mmult_is_ready(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst) == 0) {
+		if (timeout == 0) {
+			dev_err(xhdcp2x_rx->dev, "Error: MMULT core is not ready");
+			return -ETIME;
+		}
+
+		timeout--;
+		udelay(1);
+	}
+
+	xlnx_hdcp2x_mmult_write_type(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst, 0, (int *)a,
+				     ndigits, XHDCP2X_MMULT_A);
+	xlnx_hdcp2x_mmult_write_type(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst, 0, (int *)b,
+				     ndigits, XHDCP2X_MMULT_B);
+	xlnx_hdcp2x_mmult_enable(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst);
+
+	while (xlnx_hdcp2x_mmult_is_done(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst) == 0) {
+		if (timeout == 0) {
+			dev_err(xhdcp2x_rx->dev, "Error: MMULT core is not done");
+			return -ETIME;
+		}
+
+		timeout--;
+		udelay(1);
+	}
+
+	xlnx_hdcp2x_mmult_read_u_words(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst, 0, (int *)u, ndigits);
+
+	return 0;
+}
+
+/*
+ * Modular exponentiation operation using the
+ * binary square and multiply method.
+ */
+static int xhdcp2x_rx_pkcs1_mont_exp(struct xlnx_hdcp2x_config *xhdcp2x_rx, u32 *c, u32 *a,
+				     u32 *e, u32 *n, const u32 *nprime, int ndigits)
+{
+	int offset;
+	u32 r[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 abar[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 xbar[XHDCP2X_RX_HASH_SIZE] = {0};
+
+	xhdcp2x_rx_pkcs1_mont_mult_fios_init(xhdcp2x_rx, n, nprime, ndigits);
+
+	r[0] = 1;
+	mp_shift_left(r, r, ndigits * XHDCP2X_RX_HASH_SIZE, XHDCP2X_RX_HASH_SIZE);
+	mp_modulo(xbar, r, XHDCP2X_RX_HASH_SIZE, n, ndigits);
+	mp_mod_mult(abar, a, xbar, n, 2 * ndigits);
+
+	for (offset = 32 * ndigits - 1; offset >= 0; offset--) {
+		xhdcp2x_rx_pkcs1_mont_mult_fios(xhdcp2x_rx, xbar, xbar, xbar, ndigits);
+		if (mp_get_bit(e, ndigits, offset) == 1)
+			xhdcp2x_rx_pkcs1_mont_mult_fios(xhdcp2x_rx, xbar,
+							xbar, abar, ndigits);
+	}
+
+	memset(r, 0, sizeof(r));
+	r[0] = 1;
+
+	xhdcp2x_rx_pkcs1_mont_mult_fios(xhdcp2x_rx, c, xbar, r, ndigits);
+
+	return 0;
+}
+
+/**
+ * xhdcp2x_rx_pkcs1_rsa_dp()- to calculate rsa.
+ * @xhdcp2x_rx: structure pointer for HDCP.
+ * @kpriv_rx: structure pointer for krpiv.
+ * @encrypted_message: pointer for encrypter_message.
+ * @message: pointer for encrypted message.
+ *
+ * RSADP implemented using the chinese remainder theorem
+ * reference: PKCS#1 v2.1, section 5.1.2
+ *
+ * Return: 0 on success, otherwise integer value.
+ */
+static int xhdcp2x_rx_pkcs1_rsa_dp(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+				   const struct xhdcp2x_rx_kpriv_rx *kpriv_rx,
+				   u8 *encrypted_message,
+				   u8 *message)
+{
+	u32 a[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 b[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 c[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 d[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 m1[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 m2[XHDCP2X_RX_HASH_SIZE] = {0};
+	u32 status = 0;
+
+	mp_conv_from_octets(a, XHDCP2X_RX_MP_SIZE_OF(a), kpriv_rx->p, XHDCP2X_RX_P_SIZE);
+	mp_conv_from_octets(b, XHDCP2X_RX_MP_SIZE_OF(b), kpriv_rx->dp, XHDCP2X_RX_P_SIZE);
+	mp_conv_from_octets(c, XHDCP2X_RX_MP_SIZE_OF(c), encrypted_message, XHDCP2X_RX_N_SIZE);
+	mp_conv_from_octets(d, XHDCP2X_RX_MP_SIZE_OF(d), xhdcp2x_rx->nprimep, XHDCP2X_RX_P_SIZE);
+	status = xhdcp2x_rx_pkcs1_mont_exp(xhdcp2x_rx, m1, c, b, a, d, XHDCP2X_NDIGITS);
+
+	mp_conv_from_octets(a, XHDCP2X_RX_MP_SIZE_OF(a), kpriv_rx->q, XHDCP2X_RX_P_SIZE);
+	mp_conv_from_octets(b, XHDCP2X_RX_MP_SIZE_OF(b), kpriv_rx->dq, XHDCP2X_RX_P_SIZE);
+	mp_conv_from_octets(d, XHDCP2X_RX_MP_SIZE_OF(d), xhdcp2x_rx->nprimeq, XHDCP2X_RX_P_SIZE);
+	status = xhdcp2x_rx_pkcs1_mont_exp(xhdcp2x_rx, m2, c, b, a, d, XHDCP2X_NDIGITS);
+	mp_conv_from_octets(a, XHDCP2X_RX_MP_SIZE_OF(a), kpriv_rx->p, XHDCP2X_RX_P_SIZE);
+	status = mp_subtract(d, m1, m2, XHDCP2X_RX_MP_SIZE_OF(d));
+	if (status) {
+		mp_add(m1, m1, a, XHDCP2X_RX_MP_SIZE_OF(m1));
+		mp_subtract(d, m1, m2, XHDCP2X_RX_MP_SIZE_OF(d));
+	}
+	mp_conv_from_octets(c, XHDCP2X_RX_MP_SIZE_OF(c), kpriv_rx->qinv, XHDCP2X_RX_P_SIZE);
+	status = mp_mod_mult(c, d, c, a, XHDCP2X_RX_HASH_SIZE);
+
+	mp_conv_from_octets(a, XHDCP2X_RX_MP_SIZE_OF(a), kpriv_rx->q, XHDCP2X_RX_P_SIZE);
+	status = mp_multiply(d, a, c, XHDCP2X_RX_P_SIZE / XHDCP2X_NDIGITS_MULT);
+	status = mp_add(c, m2, d, XHDCP2X_RX_HASH_SIZE);
+
+	mp_conv_to_octets(c, XHDCP2X_RX_MP_SIZE_OF(c), message, XHDCP2X_RX_N_SIZE);
+
+	return status;
+}
+
+/**
+ * xhdcp2x_rx_pkcs1_eme_oaep_decode()- function for oaep decode.
+ * @encoded_message: pointer for encoded message.
+ * @message: pointer for messagge.
+ * @message_len: pointer for message len.
+ *
+ * Eme oaep decoding. the label l is the empty stringg and underlying hash function is
+ * SHA256.
+ * reference: PKCS#1 v2.1 Section 7.1.2, part 3.
+ *
+ * Return: 0 on success, otherwise EINVAL.
+ */
+static int xhdcp2x_rx_pkcs1_eme_oaep_decode(u8 *encoded_message, u8 *message, int *message_len)
+{
+	u8 *masked_seed = NULL;
+	u8 l_hash[XHDCP2X_RX_HASH_SIZE] = {0};
+	u8 seed[XHDCP2X_RX_HASH_SIZE] = {0};
+	u8 *masked_db = NULL;
+	u8 db[XHDCP2X_RX_N_SIZE - XHDCP2X_RX_HASH_SIZE - 1] = {0};
+	u32 offset = XHDCP2X_RX_HASH_SIZE;
+	u32 status = 0;
+
+	/* l_hash is the empty string */
+	sha256(NULL, 0, l_hash);
+
+	/* Separate EM = Y || maskedSeed || maskedDB */
+	masked_seed = encoded_message + 1;
+	masked_db = encoded_message + 1 + XHDCP2X_RX_HASH_SIZE;
+
+	/* Generate seedMask = MGF(maskedDB, hLen) */
+	xhdcp2x_rx_pkcs1_mgf1(masked_db, XHDCP2X_RX_N_SIZE - XHDCP2X_RX_HASH_SIZE - 1,
+			      seed, XHDCP2X_RX_HASH_SIZE);
+
+	/* Generate seed = maskedSeed xor seedMask */
+	xhdcp2x_rx_xor(seed, masked_seed, seed, XHDCP2X_RX_HASH_SIZE);
+
+	/* Generate dbMask = MGF(seed, k-hLen-1) */
+	xhdcp2x_rx_pkcs1_mgf1(seed, XHDCP2X_RX_HASH_SIZE, db,
+			      XHDCP2X_RX_N_SIZE - XHDCP2X_RX_HASH_SIZE - 1);
+
+	/* Generate DB = maskedDB xor dbMask */
+	xhdcp2x_rx_xor(db, masked_db, db, XHDCP2X_RX_N_SIZE - XHDCP2X_RX_HASH_SIZE - 1);
+
+	if (*encoded_message)
+		status = 1;
+
+	if (memcmp(db, l_hash, XHDCP2X_RX_HASH_SIZE))
+		status = 1;
+
+	for (offset = XHDCP2X_RX_HASH_SIZE;
+		offset < (XHDCP2X_RX_N_SIZE - XHDCP2X_RX_HASH_SIZE - 1); offset++) {
+		if (db[offset] == 0x01)
+			break;
+		else if (db[offset])
+			status = 1;
+	}
+
+	if (status)
+		return -EINVAL;
+
+	*message_len = (XHDCP2X_RX_N_SIZE - XHDCP2X_RX_HASH_SIZE - 1) - (offset + 1);
+
+	memcpy(message, db + offset + 1, *message_len);
+
+	return 0;
+}
+
+/**
+ * xhdcp2x_rx_rsaes_oaep_decrypt()- function for oaep decrypt.
+ * @xhdcp2x_rx: structure pointer for HDCP.
+ * @kpriv_rx: structure pointer for kpriv_rx
+ * @encrypted_message: pointer for encrypted message.
+ * @message: pointer for message.
+ * @message_len: pointer for message length.
+ *
+ * RSAES-OAEP decrypt operation, decrypted using RSADP
+ * and decode using EME-OAEP.
+ *
+ * Return: 0 on success, otherwise EINVAL.
+ */
+int  xhdcp2x_rx_rsaes_oaep_decrypt(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+				   struct xhdcp2x_rx_kpriv_rx *kpriv_rx,
+				   u8 *encrypted_message, u8 *message, int *message_len)
+{
+	u8 em[XHDCP2X_RX_N_SIZE] = {0};
+	u32 status;
+
+	status = xhdcp2x_rx_pkcs1_rsa_dp(xhdcp2x_rx, kpriv_rx, encrypted_message,
+					 em);
+	if (status)
+		return -EINVAL;
+
+	status = xhdcp2x_rx_pkcs1_eme_oaep_decode(em, message, message_len);
+	if (status)
+		return -EINVAL;
+
+	return 0;
+}
+
+/*
+ * Computes the derived keys used during the HDCP2.2 authentication and
+ * key exchange.
+ * reference: HDCP2.2 section 2.7
+ */
+static void xhdcp2x_rx_compute_dkey(const u8 *rrx, const u8 *rtx, const u8 *km,
+				    const u8 *rn, u8 *ctr, u8 *dkey)
+{
+	u8 aes_iv[XHDCP2X_RX_AES_SIZE] = {0};
+	u8 aes_key[XHDCP2X_RX_AES_SIZE] = {0};
+
+	memcpy(aes_key, km, XHDCP2X_RX_AES_SIZE);
+
+	if (rn)
+		xhdcp2x_rx_xor(aes_key + XHDCP2X_RX_RN_SIZE, km + XHDCP2X_RX_RN_SIZE,
+			       rn, XHDCP2X_RX_RN_SIZE);
+
+	memcpy(aes_iv, rtx, XHDCP2X_RX_RTX_SIZE);
+
+	if (!ctr)
+		memcpy(&aes_iv[XHDCP2X_RX_RRX_SIZE], rrx, XHDCP2X_RX_RRX_SIZE);
+	else
+		xhdcp2x_rx_xor(aes_iv + XHDCP2X_RX_RTX_SIZE, rrx, ctr,
+			       XHDCP2X_RX_RRX_SIZE);
+
+	xlnx_hdcp2x_rx_aes128_encrypt(aes_iv, aes_key, dkey);
+}
+
+/**
+ * xlnx_hdcp2x_cmn_hmac_sha256_hash()- transform to HMAC sha256.
+ * @data: pointer for input data.
+ * @data_size: input data size.
+ * @key: pointer for key.
+ * @key_size: input key size.
+ * @hashed_data: pointer for hashed data.
+ *
+ * HMAC_SHA256 transform using SHA256 function
+ *
+ * Return: 0 on success, otherwise EINVAL.
+ */
+
+static int xlnx_hdcp2x_cmn_hmac_sha256_hash(const u8 *data, int data_size, const u8 *key,
+					    int key_size, u8  *hashed_data)
+{
+	u8 buffer_in[XHDCP2X_RX_SHA_SIZE] = {0};
+	u8 buffer_out[XHDCP2X_RX_SHA_SIZE] = {0};
+	u8 ktemp[XHDCP2X_SHA256_SIZE] = {0};
+	u8 ktemp2[XHDCP2X_SHA256_SIZE] = {0};
+	u8 ipad[XHDCP2X_RX_SHA_KEY_LENGTH + 1] = {0};
+	u8 opad[XHDCP2X_RX_SHA_KEY_LENGTH + 1] = {0};
+	int i;
+
+	if (data_size + XHDCP2X_RX_SHA_KEY_LENGTH > XHDCP2X_RX_SHA_SIZE)
+		return -EINVAL;
+
+	if (key_size > XHDCP2X_RX_SHA_KEY_LENGTH) {
+		sha256(key, key_size, ktemp);
+		key = ktemp;
+		key_size = XHDCP2X_SHA256_SIZE;
+	}
+
+	memcpy(ipad, key, key_size);
+	memcpy(opad, key, key_size);
+
+	for (i = 0; i < XHDCP2X_RX_SHA_KEY_LENGTH; i++) {
+		ipad[i] ^= XHDCP2X_RX_INNER_PADDING_BYTE;
+		opad[i] ^= XHDCP2X_RX_OUTER_PADDING_BYTE;
+	}
+
+	memcpy(buffer_in, ipad, XHDCP2X_RX_SHA_KEY_LENGTH);
+	memcpy(buffer_in + XHDCP2X_RX_SHA_KEY_LENGTH, data, data_size);
+	sha256(buffer_in, XHDCP2X_RX_SHA_KEY_LENGTH + data_size, ktemp2);
+
+	memcpy(buffer_out, opad, XHDCP2X_RX_SHA_KEY_LENGTH);
+	memcpy(buffer_out + XHDCP2X_RX_SHA_KEY_LENGTH, ktemp2, XHDCP2X_SHA256_SIZE);
+	sha256(buffer_out, XHDCP2X_RX_SHA_KEY_LENGTH + XHDCP2X_SHA256_SIZE, (u8 *)hashed_data);
+
+	return 0;
+}
+
+/**
+ * xhdcp2x_rx_compute_hprime() - compute hprime.
+ * @rrx: pointer for rrx.
+ * @rxcaps: pointer for rxcaps.
+ * @rtx: pointer for rtx.
+ * @txcaps: pointer for txcaps.dd
+ * @km: pointer for km.
+ * @hprime: pointer for hprime.
+ *
+ * Computes hprime used during HDCP2.2 authentication and key exchange.
+ * reference: HDCP v2.2, section 2.2.
+ */
+void xhdcp2x_rx_compute_hprime(const u8 *rrx, const u8 *rxcaps, const u8 *rtx
+		, const u8 *txcaps, const u8 *km, u8 *hprime)
+{
+	u8 hash_input[XHDCP2X_RX_RTX_SIZE + XHDCP2X_RX_RXCAPS_SIZE + XHDCP2X_RX_TXCAPS_SIZE];
+	int idx = 0;
+	u8 ctr[] = {[0 ... 6] = 0x00, [7] = 0x01};
+	u8 kd[2 * XHDCP2X_RX_AES_SIZE];
+
+	xhdcp2x_rx_compute_dkey(rrx, rtx, km, NULL, NULL, kd);
+	xhdcp2x_rx_compute_dkey(rrx, rtx, km, NULL, ctr, kd + XHDCP2X_RX_AES_SIZE);
+
+	memcpy(hash_input, rtx, XHDCP2X_RX_RTX_SIZE);
+	idx += XHDCP2X_RX_RTX_SIZE;
+	memcpy(&hash_input[idx], rxcaps, XHDCP2X_RX_RXCAPS_SIZE);
+	idx += XHDCP2X_RX_RXCAPS_SIZE;
+	memcpy(&hash_input[idx], txcaps, XHDCP2X_RX_TXCAPS_SIZE);
+
+	xlnx_hdcp2x_cmn_hmac_sha256_hash(hash_input
+			, sizeof(hash_input), kd, XHDCP2X_RX_KD_SIZE, hprime);
+}
+
+/**
+ * xhdcp2x_rx_compute_ekh()- compute ekh.
+ * @kpriv_rx: pointer for kpriv_rx.
+ * @km: pointer for km.
+ * @m: pointer for m.
+ * @ekh: pointer for ekh.
+ *
+ * Computes ekh used during HDCP2.2 authentication and key exchanges.
+ * reference: HDCP v2.2, section 2.2.1
+ */
+void xhdcp2x_rx_compute_ekh(const u8 *kpriv_rx, const u8 *km, const u8 *m, u8 *ekh)
+{
+	u8 kh[XHDCP2X_RX_HASH_SIZE];
+
+	sha256(kpriv_rx, sizeof(struct xhdcp2x_rx_kpriv_rx), kh);
+
+	xlnx_hdcp2x_rx_aes128_encrypt(m, kh + XHDCP2X_RX_EKH_SIZE, ekh);
+	xhdcp2x_rx_xor(ekh, ekh, km, XHDCP2X_RX_EKH_SIZE);
+}
+
+/**
+ * xhdcp2x_rx_compute_lprime()- compute lprime.
+ * @rn: pointer for rn.
+ * @km: pointer for km.
+ * @rrx: pointer for rrx.
+ * @rtx: pointer rtx.
+ * @lprime: pointer lprime.
+ *
+ * Computes lprime used during locality check.
+ * reference: HDCPv2.2, section 2.3
+ */
+void xhdcp2x_rx_compute_lprime(const u8 *rn, const u8 *km, const u8 *rrx,
+			       const u8 *rtx, u8 *lprime)
+{
+	u8 hash_key[XHDCP2X_RX_KD_SIZE] = {0};
+	u8 ctr[] = {[0 ... 6] = 0x00, [7] = 0x01};
+	u8 kd[2 * XHDCP2X_RX_AES_SIZE] = {0};
+
+	xhdcp2x_rx_compute_dkey(rrx, rtx, km, NULL, NULL, kd);
+	xhdcp2x_rx_compute_dkey(rrx, rtx, km, NULL, ctr, kd + XHDCP2X_RX_AES_SIZE);
+
+	memcpy(hash_key, kd, XHDCP2X_RX_KD_SIZE);
+
+	xhdcp2x_rx_xor(hash_key + (XHDCP2X_RX_KD_SIZE - XHDCP2X_RX_RRX_SIZE),
+		       kd + (XHDCP2X_RX_KD_SIZE - XHDCP2X_RX_RRX_SIZE),
+		       rrx, XHDCP2X_RX_RRX_SIZE);
+
+	xlnx_hdcp2x_cmn_hmac_sha256_hash(rn, XHDCP2X_RX_RN_SIZE,
+					 hash_key, XHDCP2X_RX_KD_SIZE, lprime);
+}
+
+/**
+ * xhdcp2x_rx_compute_ks()- compute ks.
+ * @rrx: pointer for rrx.
+ * @rtx: pointer for rtx.
+ * @km: pointer for km.
+ * @rn: pointer rn.
+ * @eks: pointer eks.
+ * @ks: pointer for ks.
+ *
+ * Computes Ks used during session key exchange
+ * reference: HDCP v2.2, section 2.4
+ */
+void xhdcp2x_rx_compute_ks(const u8 *rrx, const u8 *rtx, const u8 *km, const u8 *rn,
+			   const u8 *eks, u8 *ks)
+{
+	u8 dkey2[XHDCP2X_RX_KS_SIZE] = {0};
+	u8 ctr[] = {[0 ... 6] = 0x00, [7] = 0x02};
+
+	xhdcp2x_rx_compute_dkey(rrx, rtx, km, rn, ctr, dkey2);
+	memcpy(ks, dkey2, XHDCP2X_RX_KS_SIZE);
+	xhdcp2x_rx_xor(ks + XHDCP2X_RX_RRX_SIZE, ks + XHDCP2X_RX_RRX_SIZE,
+		       rrx, XHDCP2X_RX_RRX_SIZE);
+	xhdcp2x_rx_xor(ks, ks, eks, XHDCP2X_RX_KS_SIZE);
+}
+
+void xhdcp2x_rx_generate_random(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+				int num_octets, u8 *random_number_ptr)
+{
+	xlnx_hdcp2x_rng_get_random_number(&xhdcp2x_rx->xhdcp2x_hw.rng_inst,
+					  random_number_ptr, num_octets, num_octets);
+}
diff --git a/drivers/media/platform/xilinx/xilinx-hdcp2x-rx.c b/drivers/media/platform/xilinx/xilinx-hdcp2x-rx.c
new file mode 100644
index 000000000..a8bf08295
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdcp2x-rx.c
@@ -0,0 +1,1140 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx HDCP2X Protocol Driver
+ *
+ * Copyright (C) 2023, Advanced Micro Devices, Inc. All rights reserved.
+ *
+ * Author: Kunal Vasant Rane <kunal.rane@amd.com>
+ *
+ * This driver provides standard HDCP2X protocol specific functionalities.
+ * It consists of:
+ * - HDCP, Random number Generator, MMULT, Cipher and Timer core initialization
+ *   functions. Along with that it offers enable, disable and callback functionalities
+ *   HDCP2X RX driver.
+ *
+ * This driver still have Xilinx specific functionalities as it is not upstreamed now,
+ * it will be updated as more generic and standardized driver in the next upstream version.
+ *
+ * Reference :
+ * https://www.digital-cp.com/sites/default/files/HDCP%20on%20DisplayPort%20Specification%20Rev2_3.pdf
+ */
+
+#include <linux/xlnx/xlnx_hdcp_common.h>
+#include <linux/xlnx/xlnx_hdcp2x_cipher.h>
+#include <linux/xlnx/xlnx_hdcp_rng.h>
+#include <linux/xlnx/xlnx_timer.h>
+#include "xilinx-hdcp2x-rx.h"
+
+#define XHDCP2X_CIPHER_OFFSET		0x0000
+#define XHDCP2X_RNG_OFFSET		0x1000
+#define XHDCP2X_MMULT_OFFSET		0x2000
+#define XHDCP2X_TIMER_CLOCK_FREQ_HZ	99990001
+#define XHDCP2X_CLK_DIV			1000000
+#define XHDCP2X_CLK_MUL			1000
+#define XHDCP2X_PRIVATE_KEY_OFFSET	562
+#define XHDCP2X_PUBLIC_KEY_OFFSET	40
+#define XHDCP2X_RX_LC128_SIZE		16
+
+static enum xhdcp2x_rx_state xhdcp2x_state_B0(void *);
+static enum xhdcp2x_rx_state xhdcp2x_state_B1(void *);
+static enum xhdcp2x_rx_state xhdcp2x_state_B2(void *);
+static enum xhdcp2x_rx_state xhdcp2x_state_B3(void *);
+static enum xhdcp2x_rx_state xhdcp2x_state_B4(void *);
+static void xhdcp2x_rx_run_statemachine(struct xlnx_hdcp2x_config *hdcp2x);
+
+/*
+ * HDCP Receiver State Diagram available in
+ * HDCP2.9 specification. Section 2.9
+ * https://www.digital-cp.com/sites/default/files/
+ * HDCP%20Interface%20Independent%20Adaptation%20Specification%20Rev2_3.pdf
+ */
+static enum xhdcp2x_rx_state (*xhdcp2x_rx_state_table[])(void *) = {
+	xhdcp2x_state_B0,
+	xhdcp2x_state_B1,
+	xhdcp2x_state_B2,
+	xhdcp2x_state_B3,
+	xhdcp2x_state_B4
+};
+
+int xhdcp2x_rx_set_reauth_req(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	int status = 0;
+
+	xhdcp2x_rx->info.reauth_request_cnt++;
+
+	xhdcp2x_rx->info.reauth_req = 1;
+
+	if (xhdcp2x_rx->protocol == XHDCP2X_RX_DP) {
+		u8 rxstatus = RX_STATUS_REAUTH_REQ;
+
+		status = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+							 RX_STATUS_OFFSET, &rxstatus,
+							 1);
+		if (status < 0)
+			return -EINVAL;
+
+		xhdcp2x_rx->handlers.cp_irq_handler(xhdcp2x_rx->interface_ref);
+	}
+
+	return 0;
+}
+
+static void xhdcp2x_rx_run_statemachine(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	enum xhdcp2x_rx_state new_state;
+
+	do {
+		new_state = xhdcp2x_rx_state_table[xhdcp2x_rx->curr_state](xhdcp2x_rx);
+		xhdcp2x_rx->prev_state = xhdcp2x_rx->curr_state;
+		xhdcp2x_rx->curr_state = new_state;
+	} while (xhdcp2x_rx->prev_state != xhdcp2x_rx->curr_state);
+}
+
+static void xhdcp2x_sm_work_func(struct work_struct *work)
+{
+	struct xlnx_hdcp2x_config *xhdcp2x_rx;
+
+	xhdcp2x_rx = container_of(work, struct xlnx_hdcp2x_config, sm_work.work);
+	mutex_lock(&xhdcp2x_rx->hdcprx_mutex);
+
+	if (xhdcp2x_rx->info.msg_event)
+		xhdcp2x_rx_run_statemachine(xhdcp2x_rx);
+
+	mutex_unlock(&xhdcp2x_rx->hdcprx_mutex);
+}
+
+int *xhdcp2x_rx_init(struct device *dev, void *protocol_ref, void __iomem *xhdcp_base_address,
+		     enum xhdcp2x_rx_protocol protocol_rx, bool is_repeater, u8 lane_count)
+{
+	int status;
+	struct xlnx_hdcp2x_config *xhdcp2x_rx;
+
+	if (!dev || !protocol_ref || !xhdcp_base_address)
+		return ERR_PTR(-EINVAL);
+
+	if (is_repeater) {
+		dev_info(dev, "Hdcp2x repeater functionality not supported\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	xhdcp2x_rx = kzalloc(sizeof(*xhdcp2x_rx), GFP_KERNEL);
+	if (!xhdcp2x_rx)
+		return ERR_PTR(-ENOMEM);
+
+	xhdcp2x_rx->xhdcp2x_hw.hdcp2xcore_address = (void __iomem *)xhdcp_base_address;
+	xhdcp2x_rx->dev = dev;
+	xhdcp2x_rx->interface_ref = protocol_ref;
+	xhdcp2x_rx->interface_base = xhdcp_base_address;
+	xhdcp2x_rx->is_repeater = is_repeater ? 1 : 0;
+	xhdcp2x_rx->lane_count = lane_count;
+	xhdcp2x_rx->protocol = protocol_rx;
+	xhdcp2x_rx->rx_caps[0] = HDCP_2_2_RX_CAPS_VERSION_VAL;
+	xhdcp2x_rx->rx_caps[1] = 0x00;
+	xhdcp2x_rx->rx_caps[2] = (xhdcp2x_rx->mode == xhdcp2x_rx_receiver) ?
+				RXCAPS_HDCP_ENABLE :  RXCAPS_REPEATER;
+	xhdcp2x_rx->keys_loaded = 0;
+
+	xhdcp2x_rx->xhdcp2x_hw.rng_inst.rng_coreaddress =
+		xhdcp2x_rx->xhdcp2x_hw.hdcp2xcore_address + XHDCP2X_RNG_OFFSET;
+	xhdcp2x_rx->xhdcp2x_hw.mmult_inst.mmult_coreaddress =
+		xhdcp2x_rx->xhdcp2x_hw.hdcp2xcore_address + XHDCP2X_MMULT_OFFSET;
+	xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress =
+		xhdcp2x_rx->xhdcp2x_hw.hdcp2xcore_address + XHDCP2X_CIPHER_OFFSET;
+
+	status = xlnx_hdcp2x_rng_cfg_init(&xhdcp2x_rx->xhdcp2x_hw.rng_inst);
+	if (status < 0)
+		return ERR_PTR(-EINVAL);
+
+	status = xlnx_hdcp2x_mmult_cfginit(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst);
+	if (status < 0)
+		return ERR_PTR(-EINVAL);
+
+	status = xlnx_hdcp2x_cipher_cfg_init(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst);
+	if (status < 0)
+		return ERR_PTR(-EINVAL);
+
+	xlnx_hdcp2x_rx_cipher_init(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst);
+
+	mutex_init(&xhdcp2x_rx->hdcprx_mutex);
+
+	INIT_DELAYED_WORK(&xhdcp2x_rx->sm_work, xhdcp2x_sm_work_func);
+
+	return (void *)xhdcp2x_rx;
+}
+
+void *xhdcp2x_timer_init(struct device *dev, void __iomem *timer_base_address)
+{
+	struct xlnx_hdcp_timer_config *tmr_config;
+	int ret;
+
+	tmr_config = devm_kzalloc(dev, sizeof(*tmr_config), GFP_KERNEL);
+	if (!tmr_config)
+		return ERR_PTR(-ENOMEM);
+
+	tmr_config->hw_config.coreaddress = (void __iomem *)
+		timer_base_address;
+
+	tmr_config->hw_config.sys_clock_freq = XHDCP2X_TIMER_CLOCK_FREQ_HZ;
+
+	ret = xlnx_hdcp_tmrcntr_init(tmr_config);
+	if (ret < 0)
+		return ERR_PTR(-EINVAL);
+
+	return tmr_config;
+}
+
+void xhdcp2x_timer_attach(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+			  struct xlnx_hdcp_timer_config *tmrcntr)
+{
+	xhdcp2x_rx->tmr_config = *tmrcntr;
+
+	xlnx_hdcp_tmrcntr_set_options(&xhdcp2x_rx->tmr_config,
+				      XHDCP2X_RX_TMR_CNTR_0, XTC_AUTO_RELOAD_OPTION);
+	xlnx_hdcp_tmrcntr_set_options(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1,
+				      XTC_INT_MODE_OPTION | XTC_DOWN_COUNT_OPTION);
+}
+
+int xhdcp2x_rx_disable(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	int status = 0;
+
+	if (xhdcp2x_rx) {
+		status = xhdcp2x_rx_reset(xhdcp2x_rx);
+		if (!status)
+			return -EINVAL;
+	}
+
+	xhdcp2x_rx->curr_state = XHDCP2X_STATE_B0;
+	xhdcp2x_rx->prev_state = XHDCP2X_STATE_B0;
+	xhdcp2x_rx->info.msg_event = 0;
+
+	if (xhdcp2x_rx->info.authentication_status == XHDCP2X_RX_AUTHENTICATED) {
+		status = xhdcp2x_rx_set_reauth_req(xhdcp2x_rx);
+		if (!status)
+			return -EINVAL;
+	}
+
+	xlnx_hdcp2x_rng_disable(&xhdcp2x_rx->xhdcp2x_hw.rng_inst);
+	xlnx_hdcp2x_cipher_disable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+	xlnx_hdcp_tmrcntr_stop(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1);
+
+	xhdcp2x_rx->info.is_enabled = 0;
+
+	return 0;
+}
+
+int xhdcp2x_rx_reset(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	memset(&xhdcp2x_rx->msg_buffer, 0, sizeof(union xhdcp2x_rx_message));
+	xhdcp2x_rx->msg_size = 0;
+
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_UNAUTHENTICATED;
+	xhdcp2x_rx->info.is_no_storedkm = 0;
+	xhdcp2x_rx->info.reauth_req = 0;
+	xhdcp2x_rx->info.is_encrypted = 0;
+	xhdcp2x_rx->info.lc_init_attempts = 0;
+	xhdcp2x_rx->info.auth_request_cnt = 0;
+	xhdcp2x_rx->info.reauth_request_cnt = 0;
+	xhdcp2x_rx->info.link_error_cnt = 0;
+	xhdcp2x_rx->info.error_flag = XHDCP2X_RX_ERROR_FLAG_NONE;
+	xhdcp2x_rx->info.error_flag_sticky = XHDCP2X_RX_ERROR_FLAG_NONE;
+	xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B0_WAIT_AKEINIT;
+
+	xlnx_hdcp_tmrcntr_stop(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1);
+	xlnx_hdcp2x_cipher_disable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+
+	if (xhdcp2x_rx->handlers.notify_handler)
+		xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+						    XHDCP2X_RX_NOTIFY_UN_AUTHENTICATED);
+
+	return 0;
+}
+
+static int xhdcp2x_rx_set_rx_caps(struct xlnx_hdcp2x_config *xhdcp2x_rx, u8 enable)
+{
+	u8 rx_caps[RX_CAPS_SIZE] = {0};
+	u8 numwritten = 0;
+
+	if (enable)
+		memcpy(rx_caps, xhdcp2x_rx->rx_caps, RX_CAPS_SIZE);
+
+	numwritten = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+						     RX_CAPS_OFFSET, rx_caps, RX_CAPS_SIZE);
+
+	if (numwritten != RX_CAPS_SIZE)
+		return -EINVAL;
+
+	return 0;
+}
+
+int xhdcp2x_rx_enable(struct xlnx_hdcp2x_config *xhdcp2x_rx, u8 lane_count)
+{
+	int ret = 0;
+
+	xlnx_hdcp2x_rng_enable(&xhdcp2x_rx->xhdcp2x_hw.rng_inst);
+	xlnx_hdcp2x_mmult_enable(&xhdcp2x_rx->xhdcp2x_hw.mmult_inst);
+	xlnx_hdcp2x_cipher_enable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+	xlnx_hdcp2x_cipher_set_lanecount(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst,
+					 lane_count);
+	xhdcp2x_rx->info.is_enabled = 1;
+
+	ret = xhdcp2x_rx_set_rx_caps(xhdcp2x_rx, 1);
+	if (ret < 0)
+		return -EINVAL;
+
+	return ret;
+}
+
+int xhdcp2x_rx_set_callback(void *ref, u32 handler_type, void *callbackfunc)
+{
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)ref;
+
+	if (!xhdcp2x_rx || !callbackfunc)
+		return -EINVAL;
+
+	switch (handler_type) {
+	case (XHDCP2X_RX_HANDLER_DP_AUX_READ):
+		xhdcp2x_rx->handlers.rd_handler = callbackfunc;
+		break;
+
+	case (XHDCP2X_RX_HANDLER_DP_AUX_WRITE):
+		xhdcp2x_rx->handlers.wr_handler = callbackfunc;
+		break;
+
+	case (XHDCP2X_RX_HANDLER_DP_CP_IRQ_SET):
+		xhdcp2x_rx->handlers.cp_irq_handler = callbackfunc;
+		break;
+
+	case (XHDCP2X_RX_NOTIFICATION_HANDLER):
+		xhdcp2x_rx->handlers.notify_handler = callbackfunc;
+		break;
+	default:
+		dev_info(xhdcp2x_rx->dev, "wrong handler type\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xhdcp2x_rx_calc_nprime(struct xlnx_hdcp2x_config *xhdcp2x_rx, const u8 *private_key_ptr)
+{
+	int status = 0;
+	struct xhdcp2x_rx_kpriv_rx *privatekey = (struct xhdcp2x_rx_kpriv_rx *)private_key_ptr;
+
+	status = xhdcp2x_rx_calc_mont_nprime(xhdcp2x_rx->mmult, xhdcp2x_rx->nprimep,
+					     (u8 *)privatekey->p,
+					     XHDCP2X_RX_P_SIZE / XHDCP2X_KEY_SIZE);
+	if (status) {
+		dev_info(xhdcp2x_rx->dev, "Error: HDCP2X RX MMULT NPrimerP generation failed");
+		return status;
+	}
+
+	status = xhdcp2x_rx_calc_mont_nprime(xhdcp2x_rx->mmult, xhdcp2x_rx->nprimeq,
+					     (u8 *)privatekey->q,
+					     XHDCP2X_RX_P_SIZE / XHDCP2X_KEY_SIZE);
+	if (status) {
+		dev_info(xhdcp2x_rx->dev, "Error: HDCP2X RX MMULT NPrimeQ generation failed");
+		return status;
+	}
+
+	return status;
+}
+
+int xhdcp2x_rx_set_key(void *ref, void *xhdcp2x_lc128_key, void *xhdcp2x_private_key)
+{
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)ref;
+
+	int status = 0;
+
+	xhdcp2x_rx->lc128key = (u8 *)xhdcp2x_lc128_key;
+	xhdcp2x_rx->privatekeyptr = (u8 *)xhdcp2x_private_key;
+
+	xhdcp2x_rx->publiccertptr = xhdcp2x_private_key + XHDCP2X_PUBLIC_KEY_OFFSET;
+	xhdcp2x_rx->privatekeyptr = xhdcp2x_private_key + XHDCP2X_PRIVATE_KEY_OFFSET;
+
+	status = xhdcp2x_rx_calc_nprime(xhdcp2x_rx, xhdcp2x_private_key +
+					XHDCP2X_PRIVATE_KEY_OFFSET);
+
+	xlnx_hdcp2x_cipher_set_keys(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst,
+				    xhdcp2x_rx->lc128key,
+				    XHDCP2X_CIPHER_REG_LC128_1_OFFSET, XHDCP2X_RX_LC128_SIZE);
+
+	xhdcp2x_rx->keys_loaded = 1;
+
+	return status;
+}
+
+void xhdcp2x_rx_timer_handler(void *callbackref, u8 tmr_cnt_number)
+{
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)callbackref;
+
+	if (tmr_cnt_number == XHDCP2X_RX_TMR_CNTR_0)
+		return;
+
+	xhdcp2x_rx->info.timer_expired = 1;
+	xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_TIMER_EVENT;
+}
+
+void xhdcp2x_rx_set_stream_type(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	u8 buf[R_IV_SIZE] = {0};
+
+	xhdcp2x_rx->handlers.rd_handler(xhdcp2x_rx->interface_ref,
+					RX_STREAM_TYPE_OFFSET,
+					xhdcp2x_rx->param.streamidtype + 1,
+					RX_STREAM_TYPE_SIZE);
+
+	if (xhdcp2x_rx->param.streamidtype[1]) {
+		memcpy(buf, xhdcp2x_rx->param.riv, R_IV_SIZE);
+		buf[R_IV_SIZE - 1] ^= 0x01;
+		xlnx_hdcp2x_cipher_set_keys(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst,
+					    buf, XHDCP2X_CIPHER_REG_RIV_1_OFFSET, R_IV_SIZE);
+	}
+}
+
+/**
+ * xhdcp2x_rx_push_events - Pushes events from interface driver to HDCP driver
+ * @ref: reference to HDCP2X instance
+ * @events: events that are pushed from interface driver
+ *
+ * Return: 0 on success, error otherwise
+ */
+int xhdcp2x_rx_push_events(void *ref, u32 events)
+{
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)ref;
+
+	if (!xhdcp2x_rx)
+		return -EINVAL;
+
+	if (events) {
+		if (events == XHDCP2X_RX_DPCD_AKE_INIT_RCVD)
+			xhdcp2x_rx->info.msg_event = events;
+		else
+			xhdcp2x_rx->info.msg_event |= events;
+		schedule_delayed_work(&xhdcp2x_rx->sm_work, 0);
+	}
+
+	return 0;
+}
+
+static void xhdcp2x_rx_reset_params(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	memset(xhdcp2x_rx->param.km,		0, sizeof(xhdcp2x_rx->param.km));
+	memset(xhdcp2x_rx->param.ks,		0, sizeof(xhdcp2x_rx->param.ks));
+	memset(xhdcp2x_rx->param.rn,		0, sizeof(xhdcp2x_rx->param.rn));
+	memset(xhdcp2x_rx->param.ekh,		0, sizeof(xhdcp2x_rx->param.ekh));
+	memset(xhdcp2x_rx->param.riv,		0, sizeof(xhdcp2x_rx->param.riv));
+	memset(xhdcp2x_rx->param.rrx,		0, sizeof(xhdcp2x_rx->param.rrx));
+	memset(xhdcp2x_rx->param.rtx,		0, sizeof(xhdcp2x_rx->param.rtx));
+	memset(xhdcp2x_rx->param.rxcaps,	0, sizeof(xhdcp2x_rx->param.rxcaps));
+	memset(xhdcp2x_rx->param.txcaps,	0, sizeof(xhdcp2x_rx->param.txcaps));
+	memset(xhdcp2x_rx->param.hprime,	0, sizeof(xhdcp2x_rx->param.hprime));
+	memset(xhdcp2x_rx->param.lprime,	0, sizeof(xhdcp2x_rx->param.lprime));
+	memset(xhdcp2x_rx->param.vprime,	0, sizeof(xhdcp2x_rx->param.vprime));
+	memset(xhdcp2x_rx->param.seqnumm,	0, sizeof(xhdcp2x_rx->param.seqnumm));
+	memset(xhdcp2x_rx->param.streamidtype,	0, sizeof(xhdcp2x_rx->param.streamidtype));
+	memset(xhdcp2x_rx->param.mprime,	0, sizeof(xhdcp2x_rx->param.mprime));
+}
+
+static void xhdcp2x_rx_reset_after_error(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	int authentication_status = xhdcp2x_rx->info.authentication_status;
+
+	xlnx_hdcp2x_cipher_disable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+	xlnx_hdcp2x_cipher_enable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+
+	memset(&xhdcp2x_rx->msg_buffer, 0, sizeof(union xhdcp2x_rx_message));
+
+	xhdcp2x_rx->msg_size = 0;
+	xhdcp2x_rx->curr_state = XHDCP2X_STATE_B0;
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_UNAUTHENTICATED;
+	xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B0_WAIT_AKEINIT;
+	xhdcp2x_rx->info.is_no_storedkm = 0;
+	xhdcp2x_rx->info.is_encrypted = 0;
+	xhdcp2x_rx->info.lc_init_attempts = 0;
+
+	xhdcp2x_rx->info.timer_expired = 0;
+	xlnx_hdcp_tmrcntr_stop(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1);
+
+	xhdcp2x_rx_reset_params(xhdcp2x_rx);
+
+	if (authentication_status == XHDCP2X_RX_AUTHENTICATED) {
+		if (xhdcp2x_rx->handlers.notify_handler)
+			xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+							    XHDCP2X_RX_NOTIFY_UN_AUTHENTICATED);
+	}
+}
+
+static int xhdcp2x_rx_read_dpcd_msg(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	int size = 0;
+	u8 buf[XHDCP2X_RX_MAX_MESSAGE_SIZE] = {0};
+	u32 msg_event = xhdcp2x_rx->info.msg_event;
+
+	switch (msg_event) {
+	case XHDCP2X_RX_DPCD_AKE_INIT_RCVD:
+		size = xhdcp2x_rx->handlers.rd_handler(xhdcp2x_rx->interface_ref,
+		R_TX_OFFSET, buf, R_TX_SIZE + TX_CAPS_SIZE);
+
+		xhdcp2x_rx->msg_buffer[0] = XHDCP2X_RX_MSG_ID_AKEINIT;
+		memcpy(&xhdcp2x_rx->msg_buffer[1], buf,	R_TX_SIZE + TX_CAPS_SIZE);
+		size += 1;
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_DPCD_AKE_INIT_RCVD;
+		break;
+	case XHDCP2X_RX_DPCD_AKE_NO_STORED_KM_RCVD:
+		size = xhdcp2x_rx->handlers.rd_handler(xhdcp2x_rx->interface_ref,
+		E_KPUB_KM_OFFSET, buf, E_KPUB_KM_SIZE);
+
+		xhdcp2x_rx->msg_buffer[0] = XHDCP2X_RX_MSG_ID_AKENOSTOREDKM;
+		memcpy(&xhdcp2x_rx->msg_buffer[1], buf,	E_KPUB_KM_SIZE);
+		size += 1;
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_DPCD_AKE_NO_STORED_KM_RCVD;
+		break;
+	case XHDCP2X_RX_DPCD_AKE_STORED_KM_RCVD:
+		size = xhdcp2x_rx->handlers.rd_handler(xhdcp2x_rx->interface_ref,
+		E_KH_KM_OFFSET, buf, E_KH_KM_SIZE + M_SIZE);
+
+		xhdcp2x_rx->msg_buffer[0] = XHDCP2X_RX_MSG_ID_AKESTOREDKM;
+		memcpy(&xhdcp2x_rx->msg_buffer[1], buf,	E_KH_KM_SIZE + M_SIZE);
+		size += 1;
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_DPCD_AKE_STORED_KM_RCVD;
+		break;
+	case XHDCP2X_RX_DPCD_LC_INIT_RCVD:
+		size = xhdcp2x_rx->handlers.rd_handler(xhdcp2x_rx->interface_ref,
+		R_N_OFFSET, buf, R_N_SIZE);
+
+		xhdcp2x_rx->msg_buffer[0] = XHDCP2X_RX_MSG_ID_LCINIT;
+		memcpy(&xhdcp2x_rx->msg_buffer[1], buf,	R_N_SIZE);
+		size += 1;
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_DPCD_LC_INIT_RCVD;
+		break;
+	case XHDCP2X_RX_DPCD_SKE_SEND_EKS_RCVD:
+		size = xhdcp2x_rx->handlers.rd_handler(xhdcp2x_rx->interface_ref,
+		E_DKEY_KS_OFFSET, buf, E_DKEY_KS_SIZE + R_IV_SIZE);
+
+		xhdcp2x_rx->msg_buffer[0] = XHDCP2X_RX_MSG_ID_SKESENDEKS;
+		memcpy(&xhdcp2x_rx->msg_buffer[1], buf,	E_DKEY_KS_SIZE + R_IV_SIZE);
+		size += 1;
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_DPCD_SKE_SEND_EKS_RCVD;
+		break;
+	case XHDCP2X_RX_TIMER_EVENT:
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_TIMER_EVENT;
+		break;
+	default:
+		break;
+	}
+
+	return size;
+}
+
+static int xhdcp2x_rx_write_dpcd_msg(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	union xhdcp2x_rx_message buffer;
+	int bytes_written = 0, status = 0;
+
+	memcpy(&buffer, xhdcp2x_rx->msg_buffer, sizeof(union xhdcp2x_rx_message));
+
+	switch (buffer.msgid) {
+	case XHDCP2X_RX_MSG_ID_AKESENDCERT:
+		bytes_written = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+								CERT_RX_OFFSET,
+								buffer.ake_send_cert.certrx,
+								CERT_RX_SIZE + R_RX_SIZE +
+								RX_CAPS_SIZE);
+		if (bytes_written != CERT_RX_SIZE + R_RX_SIZE + RX_CAPS_SIZE)
+			status = -EINVAL;
+		break;
+	case XHDCP2X_RX_MSG_ID_AKESENDHPRIME:
+		bytes_written = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+								H_PRIME_OFFSET,
+								buffer.ake_send_hprime.hprime,
+								H_PRIME_SIZE);
+		if (bytes_written != H_PRIME_SIZE)
+			status = -EINVAL;
+		break;
+	case XHDCP2X_RX_MSG_ID_AKESENDPAIRINGINFO:
+		bytes_written = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+								E_KH_KM_PAIRING_OFFSET,
+								buffer.ake_send_hprime.hprime,
+								E_KH_KM_PAIRING_SIZE);
+		if (bytes_written != E_KH_KM_PAIRING_SIZE)
+			status = -EINVAL;
+		break;
+	case XHDCP2X_RX_MSG_ID_LCSENDLPRIME:
+		bytes_written = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+								L_PRIME_OFFSET,
+								buffer.lc_send_lprime.lprime,
+								L_PRIME_SIZE);
+		if (bytes_written != L_PRIME_SIZE)
+			status = -EINVAL;
+		break;
+	default:
+		status = -EINVAL;
+		break;
+	}
+
+	return status;
+}
+
+/*
+ * this function will become common function for both DP and HDMI interface
+ * for polling DPCD and DDC registers
+ */
+static int xhdcp2x_rx_poll_message(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	u32 size = 0;
+
+	if (xhdcp2x_rx->info.msg_event != XHDCP2X_RX_DPCD_FLAG_NONE)
+		size = xhdcp2x_rx_read_dpcd_msg(xhdcp2x_rx);
+
+	return size;
+}
+
+static int xhdcp2x_rx_process_message_ake_init(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx->curr_state = XHDCP2X_STATE_B0;
+	xhdcp2x_rx->prev_state = XHDCP2X_STATE_B0;
+	xhdcp2x_rx->info.msg_event = 0;
+
+	xhdcp2x_rx->info.auth_request_cnt++;
+
+	xlnx_hdcp2x_cipher_disable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+	xlnx_hdcp2x_cipher_enable(xhdcp2x_rx->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+
+	xlnx_hdcp_tmrcntr_reset(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_0);
+	xhdcp2x_rx->info.timer_expired = 0;
+	xlnx_hdcp_tmrcntr_stop(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1);
+
+	xhdcp2x_rx_reset_params(xhdcp2x_rx);
+
+	memcpy(xhdcp2x_rx->param.rtx, msgptr->ake_init.rtx, XHDCP2X_RX_RTX_SIZE);
+	memcpy(xhdcp2x_rx->param.txcaps, msgptr->ake_init.txcaps, XHDCP2X_RX_TXCAPS_SIZE);
+
+	if (!xhdcp2x_rx->info.authentication_status) {
+		if (xhdcp2x_rx->handlers.notify_handler)
+			xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+							    XHDCP2X_RX_NOTIFY_UN_AUTHENTICATED);
+	}
+
+	if (xhdcp2x_rx->info.authentication_status == XHDCP2X_RX_REAUTH_REQUESTED) {
+		if (xhdcp2x_rx->handlers.notify_handler)
+			xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+							    XHDCP2X_RX_NOTIFY_RE_AUTHENTICATE);
+	}
+
+	return 0;
+}
+
+static int xhdcp2x_rx_process_message_ake_nostoredkm(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	u32 size;
+	int status = 0;
+
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	status = xhdcp2x_rx_rsaes_oaep_decrypt(xhdcp2x_rx,
+					       (struct xhdcp2x_rx_kpriv_rx *)
+					       xhdcp2x_rx->privatekeyptr,
+					       msgptr->ake_no_storedkm.ekpubkm,
+					       xhdcp2x_rx->param.km,
+					       &size);
+
+	return (!status && size == XHDCP2X_RX_KM_SIZE) ? 0 : 1;
+}
+
+static int xhdcp2x_rx_process_message_ake_storedkm(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	int status = 0;
+
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx_compute_ekh(xhdcp2x_rx->privatekeyptr,
+			       msgptr->ake_storedkm.ekhkm, msgptr->ake_storedkm.m,
+			       xhdcp2x_rx->param.km);
+
+	return status;
+}
+
+static int xhdcp2x_rx_process_message_lcinit(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx->info.lc_init_attempts++;
+
+	memcpy(xhdcp2x_rx->param.rn, msgptr->lc_init.rn, XHDCP2X_RX_RN_SIZE);
+
+	return 0;
+}
+
+static int xhdcp2x_rx_process_message_ske_send_eks(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx_compute_ks(xhdcp2x_rx->param.rrx,
+			      xhdcp2x_rx->param.rtx, xhdcp2x_rx->param.km,
+			      xhdcp2x_rx->param.rn, msgptr->ske_sendeks.edkeyks,
+			      xhdcp2x_rx->param.ks);
+
+	memcpy(xhdcp2x_rx->param.riv, msgptr->ske_sendeks.riv, XHDCP2X_RX_RIV_SIZE);
+
+	xlnx_hdcp2x_cipher_set_keys(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst,
+				    xhdcp2x_rx->param.ks, XHDCP2X_CIPHER_REG_KS_1_OFFSET,
+				    XHDCP2X_RX_KS_SIZE);
+	xlnx_hdcp2x_cipher_set_keys(&xhdcp2x_rx->xhdcp2x_hw.cipher_inst,
+				    xhdcp2x_rx->param.riv, XHDCP2X_CIPHER_REG_RIV_1_OFFSET,
+				    XHDCP2X_RX_RIV_SIZE);
+
+	if (xhdcp2x_rx->handlers.notify_handler)
+		xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+						    XHDCP2X_RX_NOTIFY_SKE_SEND_EKS);
+
+	return 0;
+}
+
+static u8 xhdcp2x_rx_is_read_message_complete(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	if (xhdcp2x_rx->protocol == XHDCP2X_RX_DP) {
+		if (xhdcp2x_rx->info.sub_state ==
+			XHDCP2X_RX_STATE_B1_SEND_AKESENDPAIRINGINFO ||
+			xhdcp2x_rx->info.sub_state ==
+				XHDCP2X_RX_STATE_B1_WAIT_LCINIT) {
+			if (xhdcp2x_rx->info.msg_event &
+				XHDCP2X_RX_DPCD_HPRIME_READ_DONE_RCVD) {
+				xhdcp2x_rx->info.msg_event &=
+				~XHDCP2X_RX_DPCD_HPRIME_READ_DONE_RCVD;
+				return 1;
+			}
+			return 0;
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static int xhdcp2x_rx_send_message_ake_send_cert(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	int status = 0;
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	msgptr->ake_send_cert.msgid = XHDCP2X_RX_MSG_ID_AKESENDCERT;
+	memcpy(msgptr->ake_send_cert.rxcaps, xhdcp2x_rx->rx_caps, XHDCP2X_RX_RXCAPS_SIZE);
+
+	xhdcp2x_rx_generate_random(xhdcp2x_rx, XHDCP2X_RX_RRX_SIZE, msgptr->ake_send_cert.rrx);
+	memcpy(msgptr->ake_send_cert.certrx, xhdcp2x_rx->publiccertptr, XHDCP2X_RX_CERT_SIZE);
+
+	if (xhdcp2x_rx->protocol == XHDCP2X_RX_DP) {
+		status = xhdcp2x_rx_write_dpcd_msg(xhdcp2x_rx);
+		if (status < 0)
+			return -EINVAL;
+	}
+
+	memcpy(xhdcp2x_rx->param.rrx, msgptr->ake_send_cert.rrx, XHDCP2X_RX_RRX_SIZE);
+	memcpy(xhdcp2x_rx->param.rxcaps, msgptr->ake_send_cert.rxcaps, XHDCP2X_RX_RXCAPS_SIZE);
+
+	return status;
+}
+
+static int xhdcp2x_rx_send_message_ake_send_pairing_info(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	u8 m[XHDCP2X_RX_RTX_SIZE + XHDCP2X_RX_RRX_SIZE];
+	u8 ekhkm[XHDCP2X_RX_EKH_SIZE];
+	u8 rxstatus = RX_STATUS_PAIRING_AVAILABLE;
+	int status = 0;
+
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	memcpy(m, xhdcp2x_rx->param.rtx, XHDCP2X_RX_RTX_SIZE);
+	memcpy(m + XHDCP2X_RX_RTX_SIZE, xhdcp2x_rx->param.rrx, XHDCP2X_RX_RRX_SIZE);
+
+	xhdcp2x_rx_compute_ekh(xhdcp2x_rx->privatekeyptr, xhdcp2x_rx->param.km, m, ekhkm);
+
+	msgptr->ake_send_pairinginfo.msgid = XHDCP2X_RX_MSG_ID_AKESENDPAIRINGINFO;
+	memcpy(msgptr->ake_send_pairinginfo.ekhkm, ekhkm, XHDCP2X_RX_EKH_SIZE);
+
+	if (xhdcp2x_rx->protocol == XHDCP2X_RX_DP) {
+		status = xhdcp2x_rx_write_dpcd_msg(xhdcp2x_rx);
+		if (status < 0)
+			return -EINVAL;
+
+		status = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+							 RX_STATUS_OFFSET, &rxstatus, 1);
+		if (status < 0)
+			return -EINVAL;
+
+		xhdcp2x_rx->handlers.cp_irq_handler(xhdcp2x_rx->interface_ref);
+	}
+
+	memcpy(xhdcp2x_rx->param.ekh, ekhkm, XHDCP2X_RX_EKH_SIZE);
+
+	return status;
+}
+
+static int xhdcp2x_rx_send_message_ake_send_hprime(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	u8 rxstatus = RX_STATUS_H_PRIME_AVAILABLE;
+	int status = 0;
+
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx_compute_hprime(xhdcp2x_rx->param.rrx, xhdcp2x_rx->param.rxcaps,
+				  xhdcp2x_rx->param.rtx, xhdcp2x_rx->param.txcaps,
+				  xhdcp2x_rx->param.km,
+				  msgptr->ake_send_hprime.hprime);
+
+	msgptr->ake_send_hprime.msgid = XHDCP2X_RX_MSG_ID_AKESENDHPRIME;
+
+	if (xhdcp2x_rx->protocol == XHDCP2X_RX_DP) {
+		status = xhdcp2x_rx_write_dpcd_msg(xhdcp2x_rx);
+		if (status < 0)
+			return -EINVAL;
+
+		status = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+							 RX_STATUS_OFFSET, &rxstatus, 1);
+		if (status < 0)
+			return -EINVAL;
+
+		xhdcp2x_rx->handlers.cp_irq_handler(xhdcp2x_rx->interface_ref);
+	}
+
+	memcpy(xhdcp2x_rx->param.hprime, msgptr->ake_send_hprime.hprime, XHDCP2X_RX_HPRIME_SIZE);
+
+	return status;
+}
+
+static void xhdcp2x_rx_start_timer(struct xlnx_hdcp2x_config *xhdcp2x_rx, u32 timeout_msec
+		, u8 reason_id)
+{
+	u32 ticks = (u32)(xhdcp2x_rx->tmr_config.hw_config.sys_clock_freq /
+			XHDCP2X_CLK_DIV) * timeout_msec * XHDCP2X_CLK_MUL;
+
+	xhdcp2x_rx->info.timer_expired = 0;
+	xhdcp2x_rx->info.timer_reason_id = reason_id;
+	xhdcp2x_rx->info.timer_initial_ticks = ticks;
+
+	xlnx_hdcp_tmrcntr_set_reset_value(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1, ticks);
+	xlnx_hdcp_tmrcntr_start(&xhdcp2x_rx->tmr_config, XHDCP2X_RX_TMR_CNTR_1);
+}
+
+static int xhdcp2x_rx_send_message_lc_send_lprime(struct xlnx_hdcp2x_config *xhdcp2x_rx)
+{
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+	int status = 0;
+
+	xhdcp2x_rx_compute_lprime(xhdcp2x_rx->param.rn,
+				  xhdcp2x_rx->param.km, xhdcp2x_rx->param.rrx,
+				  xhdcp2x_rx->param.rtx, msgptr->lc_send_lprime.lprime);
+
+	msgptr->lc_send_lprime.msgid = XHDCP2X_RX_MSG_ID_LCSENDLPRIME;
+
+	if (xhdcp2x_rx->protocol == XHDCP2X_RX_DP) {
+		status = xhdcp2x_rx_write_dpcd_msg(xhdcp2x_rx);
+		if (status < 0)
+			return -EINVAL;
+	}
+
+	memcpy(xhdcp2x_rx->param.lprime, msgptr->lc_send_lprime.lprime, XHDCP2X_RX_LPRIME_SIZE);
+
+	return status;
+}
+
+static enum xhdcp2x_rx_state xhdcp2x_state_B0(void *instance)
+{
+	int status = 0;
+
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)instance;
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_UNAUTHENTICATED;
+
+	if (xhdcp2x_rx->info.error_flag) {
+		xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+		return XHDCP2X_STATE_B0;
+	}
+
+	xhdcp2x_rx->msg_size = xhdcp2x_rx_poll_message(xhdcp2x_rx);
+	if (xhdcp2x_rx->msg_size > 0) {
+		switch (msgptr->msgid) {
+		case XHDCP2X_RX_MSG_ID_AKEINIT:
+			if (xhdcp2x_rx->keys_loaded) {
+				status = xhdcp2x_rx_process_message_ake_init(xhdcp2x_rx);
+				if (!status)
+					return XHDCP2X_STATE_B1;
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		default:
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		}
+	}
+
+	return XHDCP2X_STATE_B0;
+}
+
+static enum xhdcp2x_rx_state xhdcp2x_state_B1(void *instance)
+{
+	int status = 0;
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)instance;
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_AUTHENTICATION_BUSY;
+
+	if (xhdcp2x_rx->info.error_flag) {
+		xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+		return XHDCP2X_STATE_B0;
+	}
+	xhdcp2x_rx->msg_size = xhdcp2x_rx_poll_message(xhdcp2x_rx);
+	if (xhdcp2x_rx->msg_size > 0) {
+		switch (msgptr->msgid) {
+		case XHDCP2X_RX_MSG_ID_AKEINIT:
+			if (xhdcp2x_rx->keys_loaded) {
+				status = xhdcp2x_rx_process_message_ake_init(xhdcp2x_rx);
+				if (!status) {
+					xhdcp2x_rx->info.sub_state =
+					XHDCP2X_RX_STATE_B1_SEND_AKESENDCERT;
+					break;
+				}
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		case XHDCP2X_RX_MSG_ID_AKENOSTOREDKM:
+			if (xhdcp2x_rx->info.sub_state == XHDCP2X_RX_STATE_B1_WAIT_AKEKM) {
+				status = xhdcp2x_rx_process_message_ake_nostoredkm(xhdcp2x_rx);
+				if (!status) {
+					xhdcp2x_rx->info.is_no_storedkm = 1;
+					xhdcp2x_rx->info.sub_state =
+					XHDCP2X_RX_STATE_B1_SEND_AKESENDHPRIME;
+					break;
+				}
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		case XHDCP2X_RX_MSG_ID_AKESTOREDKM:
+			if (xhdcp2x_rx->info.sub_state == XHDCP2X_RX_STATE_B1_WAIT_AKEKM) {
+				status = xhdcp2x_rx_process_message_ake_storedkm(xhdcp2x_rx);
+				if (!status) {
+					xhdcp2x_rx->info.is_no_storedkm = 0;
+					xhdcp2x_rx->info.sub_state =
+					XHDCP2X_RX_STATE_B1_SEND_AKESENDHPRIME;
+					break;
+				}
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		default:
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		}
+	}
+	switch (xhdcp2x_rx->info.sub_state) {
+	case XHDCP2X_RX_STATE_B1_SEND_AKESENDCERT:
+		if (xhdcp2x_rx_is_read_message_complete(xhdcp2x_rx)) {
+			if (xhdcp2x_rx->keys_loaded) {
+				status = xhdcp2x_rx_send_message_ake_send_cert(xhdcp2x_rx);
+				if (status < 0)
+					return -EINVAL;
+				xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B1_WAIT_AKEKM;
+			}
+		}
+		break;
+	case XHDCP2X_RX_STATE_B1_SEND_AKESENDHPRIME:
+		if (xhdcp2x_rx_is_read_message_complete(xhdcp2x_rx)) {
+			status = xhdcp2x_rx_send_message_ake_send_hprime(xhdcp2x_rx);
+			if (status < 0)
+				return -EINVAL;
+			if (xhdcp2x_rx->info.is_no_storedkm) {
+				xhdcp2x_rx->info.sub_state =
+				XHDCP2X_RX_STATE_B1_SEND_AKESENDPAIRINGINFO;
+			} else {
+				xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B1_WAIT_LCINIT;
+				return XHDCP2X_STATE_B2;
+			}
+		}
+		break;
+	case XHDCP2X_RX_STATE_B1_SEND_AKESENDPAIRINGINFO:
+		if (xhdcp2x_rx_is_read_message_complete(xhdcp2x_rx)) {
+			status = xhdcp2x_rx_send_message_ake_send_pairing_info(xhdcp2x_rx);
+			if (status < 0)
+				return -EINVAL;
+			xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B1_WAIT_LCINIT;
+			return XHDCP2X_STATE_B2;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return XHDCP2X_STATE_B1;
+}
+
+static enum xhdcp2x_rx_state xhdcp2x_state_B2(void *instance)
+{
+	int status = 0;
+
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)instance;
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_AUTHENTICATION_BUSY;
+
+	if (xhdcp2x_rx->info.error_flag) {
+		xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+		return XHDCP2X_STATE_B0;
+	}
+
+	xhdcp2x_rx_is_read_message_complete(xhdcp2x_rx);
+
+	xhdcp2x_rx->msg_size = xhdcp2x_rx_poll_message(xhdcp2x_rx);
+
+	if (xhdcp2x_rx->msg_size > 0) {
+		switch (msgptr->msgid) {
+		case XHDCP2X_RX_MSG_ID_AKEINIT:
+			if (xhdcp2x_rx->keys_loaded) {
+				status = xhdcp2x_rx_process_message_ake_init(xhdcp2x_rx);
+				if (!status) {
+					xhdcp2x_rx->info.sub_state =
+						XHDCP2X_RX_STATE_B1_SEND_AKESENDCERT;
+				return XHDCP2X_STATE_B1;
+				}
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		case XHDCP2X_RX_MSG_ID_LCINIT:
+			if (xhdcp2x_rx->info.sub_state ==
+					XHDCP2X_RX_STATE_B1_WAIT_LCINIT ||
+				xhdcp2x_rx->info.sub_state ==
+					XHDCP2X_RX_STATE_B2_WAIT_SKESENDEKS) {
+				if (xhdcp2x_rx->info.lc_init_attempts <= XHDCP2X_RX_MAX_LCINIT) {
+					status = xhdcp2x_rx_process_message_lcinit(xhdcp2x_rx);
+					if (!status) {
+						xhdcp2x_rx->info.sub_state =
+						XHDCP2X_RX_STATE_B2_SEND_LCSENDLPRIME;
+						break;
+					}
+				}
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		case XHDCP2X_RX_MSG_ID_SKESENDEKS:
+			if (xhdcp2x_rx->info.sub_state == XHDCP2X_RX_STATE_B2_WAIT_SKESENDEKS) {
+				xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B3_COMPUTE_KS;
+				return XHDCP2X_STATE_B3;
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		default:
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		}
+	}
+
+	switch (xhdcp2x_rx->info.sub_state) {
+	case XHDCP2X_RX_STATE_B2_SEND_LCSENDLPRIME:
+		if (xhdcp2x_rx_is_read_message_complete(xhdcp2x_rx)) {
+			status = xhdcp2x_rx_send_message_lc_send_lprime(xhdcp2x_rx);
+			if (status < 0)
+				return -EINVAL;
+
+		xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B2_WAIT_SKESENDEKS;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return XHDCP2X_STATE_B2;
+}
+
+static enum xhdcp2x_rx_state xhdcp2x_state_B3(void *instance)
+{
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)instance;
+
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_AUTHENTICATION_BUSY;
+
+	if (xhdcp2x_rx->info.error_flag) {
+		xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+		return XHDCP2X_STATE_B0;
+	}
+	xhdcp2x_rx_process_message_ske_send_eks(xhdcp2x_rx);
+
+	if (xhdcp2x_rx->mode == xhdcp2x_rx_receiver) {
+		xhdcp2x_rx->info.sub_state = XHDCP2X_RX_STATE_B4_AUTHENTICATED;
+		return XHDCP2X_STATE_B4;
+	}
+
+	return XHDCP2X_STATE_B3;
+}
+
+static enum xhdcp2x_rx_state xhdcp2x_state_B4(void *instance)
+{
+	int status = 0;
+	u8 rxstatus = 0;
+
+	struct xlnx_hdcp2x_config *xhdcp2x_rx = (struct xlnx_hdcp2x_config *)instance;
+	union xhdcp2x_rx_message *msgptr = (union xhdcp2x_rx_message *)xhdcp2x_rx->msg_buffer;
+
+	status = xhdcp2x_rx->handlers.wr_handler(xhdcp2x_rx->interface_ref,
+						 RX_STATUS_OFFSET, &rxstatus, 1);
+	if (status < 0)
+		return XHDCP2X_STATE_B0;
+
+	if (xhdcp2x_rx->curr_state != xhdcp2x_rx->prev_state) {
+		if (xhdcp2x_rx->handlers.notify_handler)
+			xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+							    XHDCP2X_RX_NOTIFY_AUTHENTICATED);
+
+		xhdcp2x_rx_start_timer(xhdcp2x_rx,
+				       XHDCP2X_RX_ENCRYPTION_STATUS_INTERVAL, 0);
+	}
+
+	if (xhdcp2x_rx->info.timer_expired) {
+		xhdcp2x_rx->info.msg_event &= ~XHDCP2X_RX_TIMER_EVENT;
+		status =
+		xlnx_hdcp2x_cipher_is_encrypted(xhdcp2x_rx
+						->xhdcp2x_hw.cipher_inst.cipher_coreaddress);
+		if (xhdcp2x_rx->info.is_encrypted != status) {
+			if (xhdcp2x_rx->handlers.notify_handler)
+				xhdcp2x_rx->handlers.notify_handler(xhdcp2x_rx->interface_ref,
+						       XHDCP2X_RX_NOTIFY_ENCRYPTION_DONE);
+		}
+		xhdcp2x_rx->info.is_encrypted = status;
+		xhdcp2x_rx_start_timer(xhdcp2x_rx, XHDCP2X_RX_ENCRYPTION_STATUS_INTERVAL, 0);
+	}
+
+	xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_AUTHENTICATED;
+
+	if (xhdcp2x_rx->info.error_flag) {
+		xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+		return XHDCP2X_STATE_B0;
+	} else if (xhdcp2x_rx->info.error_flag & XHDCP2X_RX_ERROR_FLAG_LINK_INTEGRITY) {
+		status = xhdcp2x_rx_set_reauth_req(xhdcp2x_rx);
+		if (status < 0)
+			return XHDCP2X_STATE_B0;
+
+		xhdcp2x_rx->info.authentication_status = XHDCP2X_RX_REAUTH_REQUESTED;
+	}
+	xhdcp2x_rx->msg_size = xhdcp2x_rx_poll_message(xhdcp2x_rx);
+
+	if (xhdcp2x_rx->msg_size > 0) {
+		switch (msgptr->msgid) {
+		case XHDCP2X_RX_MSG_ID_AKEINIT:
+			if (xhdcp2x_rx->keys_loaded) {
+				status = xhdcp2x_rx_process_message_ake_init(xhdcp2x_rx);
+				if (!status) {
+					xhdcp2x_rx->info.sub_state =
+						XHDCP2X_RX_STATE_B1_SEND_AKESENDCERT;
+					return XHDCP2X_STATE_B1;
+				}
+			}
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		default:
+			xhdcp2x_rx_reset_after_error(xhdcp2x_rx);
+			return XHDCP2X_STATE_B0;
+		}
+	}
+
+	return XHDCP2X_STATE_B4;
+}
diff --git a/drivers/media/platform/xilinx/xilinx-hdcp2x-rx.h b/drivers/media/platform/xilinx/xilinx-hdcp2x-rx.h
new file mode 100644
index 000000000..db4b71b92
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdcp2x-rx.h
@@ -0,0 +1,461 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx specific HDCP2X protocol driver.
+ *
+ * Copyright (C) 2023, Advanced Micro Devices, Inc. All rights reserved.
+ *
+ * Author: Kunal Vasant Rane <kunal.rane@amd.com>
+ */
+
+#ifndef __XILINX_HDCP2X_RX_H__
+#define __XILINX_HDCP2X_RX_H__
+
+#include <drm/display/drm_hdcp.h>
+#include <linux/platform_device.h>
+#include <linux/xlnx/xlnx_hdcp_rng.h>
+#include <linux/xlnx/xlnx_hdcp2x_mmult.h>
+#include <linux/xlnx/xlnx_hdcp2x_cipher.h>
+#include <linux/xlnx/xlnx_timer.h>
+
+#define XHDCP2X_RX_MAX_LCINIT			1024
+#define XHDCP2X_RX_MAX_MESSAGE_SIZE		534
+#define XHDCP2X_RX_CERT_SIZE			522
+#define XHDCP2X_RX_PRIVATEKEY_SIZE		320
+#define XHDCP2X_RX_LOG_BUFFER_SIZE		256
+#define XHDCP2X_RX_N_SIZE			128
+#define XHDCP2X_RX_P_SIZE			64
+#define XHDCP2X_RX_HASH_SIZE			32
+#define XHDCP2X_RX_KD_SIZE			32
+#define XHDCP2X_RX_HPRIME_SIZE			32
+#define XHDCP2X_RX_LPRIME_SIZE			32
+#define XHDCP2X_RX_MPRIME_SIZE			32
+#define XHDCP2X_RX_VPRIME_SIZE			32
+#define XHDCP2X_RX_MAX_DEVICE_COUNT		31
+#define XHDCP2X_RX_KM_SIZE			16
+#define XHDCP2X_RX_EKH_SIZE			16
+#define XHDCP2X_RX_KS_SIZE			16
+#define XHDCP2X_RX_AES_SIZE			16
+#define XHDCP2X_RX_LC128_SIZE			16
+#define XHDCP2X_RX_RN_SIZE			8
+#define XHDCP2X_RX_RIV_SIZE			8
+#define XHDCP2X_RX_RTX_SIZE			8
+#define XHDCP2X_RX_RRX_SIZE			8
+#define XHDCP2X_RX_RCVID_SIZE			5
+#define XHDCP2X_RX_MAX_DEPTH			4
+#define XHDCP2X_RX_TXCAPS_SIZE			3
+#define XHDCP2X_RX_RXCAPS_SIZE			3
+#define XHDCP2X_RX_SEQNUMM_SIZE			3
+#define XHDCP2X_RX_STREAMID_SIZE		2
+#define XHDCP2X_RX_TMR_CNTR_1			1
+#define XHDCP2X_RX_TMR_CNTR_0			0
+
+#define	HDCP_2_2_CERTRX			522
+#define HDCP_2_2_K_PRIV_RX_LEN		64
+#define	HDCP_2_2_TX_CAPS		3
+#define HDCP_2_2_CERTRX_RESERVED	2
+
+#define XHDCP2X_RX_ENCRYPTION_STATUS_INTERVAL	1000
+
+#define R_TX_OFFSET			0x000
+#define R_TX_SIZE			8
+#define TX_CAPS_OFFSET			0x008
+#define TX_CAPS_SIZE			3
+#define CERT_RX_OFFSET			0x00B
+#define CERT_RX_SIZE			522
+#define R_RX_OFFSET			0x215
+#define R_RX_SIZE			8
+#define RX_CAPS_OFFSET			0x21D
+#define RX_CAPS_SIZE			3
+#define E_KPUB_KM_OFFSET		0x220
+#define E_KPUB_KM_SIZE			128
+#define E_KH_KM_OFFSET			0x2A0
+#define E_KH_KM_SIZE			16
+#define R_N_OFFSET			0x2F0
+#define R_N_SIZE			8
+#define M_OFFSET			0x2B0
+#define M_SIZE				16
+#define H_PRIME_OFFSET			0x2C0
+#define H_PRIME_SIZE			32
+#define E_KH_KM_PAIRING_OFFSET		0x2E0
+#define E_KH_KM_PAIRING_SIZE		16
+#define L_PRIME_OFFSET			0x2F8
+#define L_PRIME_SIZE			32
+#define E_DKEY_KS_OFFSET		0x318
+#define E_DKEY_KS_SIZE			16
+#define R_IV_OFFSET			0x328
+#define R_IV_SIZE			8
+#define M_PRIME_OFFSET			0x473
+#define M_PRIME_SIZE			32
+#define RX_STATUS_OFFSET		0x493
+#define RX_STREAM_TYPE_OFFSET		0x494
+#define RX_STREAM_TYPE_SIZE		1
+
+#define RX_STATUS_LINK_INTEGRITY_FAILURE	0x10
+#define RX_STATUS_REAUTH_REQ			0x08
+#define RX_STATUS_PAIRING_AVAILABLE		0x04
+#define RX_STATUS_H_PRIME_AVAILABLE		0x02
+#define RXCAPS_HDCP_ENABLE			0x02
+#define RXCAPS_REPEATER				0x01
+#define XHDCP2X_KEY_SIZE			4
+
+enum xhdcp2x_rx_message_ids {
+	XHDCP2X_RX_MSG_ID_AKEINIT		= 0,
+	XHDCP2X_RX_MSG_ID_AKESENDCERT		= 1,
+	XHDCP2X_RX_MSG_ID_AKENOSTOREDKM		= 2,
+	XHDCP2X_RX_MSG_ID_AKESTOREDKM		= 3,
+	XHDCP2X_RX_MSG_ID_AKESENDHPRIME		= 4,
+	XHDCP2X_RX_MSG_ID_AKESENDPAIRINGINFO	= 5,
+	XHDCP2X_RX_MSG_ID_LCINIT		= 6,
+	XHDCP2X_RX_MSG_ID_LCSENDLPRIME		= 7,
+	XHDCP2X_RX_MSG_ID_SKESENDEKS		= 8,
+};
+
+enum xhdcp2x_rx_error_flags {
+	XHDCP2X_RX_ERROR_FLAG_NONE			= 0,
+	XHDCP2X_RX_ERROR_FLAG_MESSAGE_SIZ		= 1,
+	XHDCP2X_RX_ERROR_FLAG_FORCE_RESET		= 2,
+	XHDCP2X_RX_ERROR_FLAG_PROCESSING_AKEINIT	= 4,
+	XHDCP2X_RX_ERROR_FLAG_PROCESSING_AKENOSTOREDKM	= 8,
+	XHDCP2X_RX_ERROR_FLAG_PROCESSING_AKESTOREDKM	= 16,
+	XHDCP2X_RX_ERROR_FLAG_PROCESSING_LCINIT		= 32,
+	XHDCP2X_RX_ERROR_FLAG_PROCESSING_SKESENDEKS	= 64,
+	XHDCP2X_RX_ERROR_FLAG_LINK_INTEGRITY		= 512,
+	XHDCP2X_RX_ERROR_FLAG_MAX_LCINIT_ATTEMPTS	= 2048,
+};
+
+enum xhdcp2x_rx_dpcd_flag {
+	XHDCP2X_RX_DPCD_FLAG_NONE,
+	XHDCP2X_RX_DPCD_AKE_INIT_RCVD		= 0x001,
+	XHDCP2X_RX_DPCD_AKE_NO_STORED_KM_RCVD	= 0x002,
+	XHDCP2X_RX_DPCD_AKE_STORED_KM_RCVD	= 0x004,
+	XHDCP2X_RX_DPCD_LC_INIT_RCVD		= 0x008,
+	XHDCP2X_RX_DPCD_SKE_SEND_EKS_RCVD	= 0x010,
+	XHDCP2X_RX_DPCD_HPRIME_READ_DONE_RCVD	= 0x020,
+	XHDCP2X_RX_DPCD_PAIRING_DONE_RCVD	= 0x040,
+	XHDCP2X_RX_TIMER_EVENT			= 0x200,
+};
+
+struct xhdcp2x_rx_kpriv_rx {
+	u8 p[HDCP_2_2_K_PRIV_RX_LEN];
+	u8 q[HDCP_2_2_K_PRIV_RX_LEN];
+	u8 dp[HDCP_2_2_K_PRIV_RX_LEN];
+	u8 dq[HDCP_2_2_K_PRIV_RX_LEN];
+	u8 qinv[HDCP_2_2_K_PRIV_RX_LEN];
+};
+
+struct xhdcp2x_rx_kpub_rx {
+	u8 n[HDCP_2_2_E_KPUB_KM_LEN];
+	u8 e[HDCP_2_2_K_PUB_RX_EXP_E_LEN];
+};
+
+struct xhdcp2x_rx_certrx {
+	u8 receiverid[HDCP_2_2_RECEIVER_ID_LEN];
+	u8 kpubrx[HDCP_2_2_K_PUB_RX_LEN];
+	u8 reserved[HDCP_2_2_CERTRX_RESERVED];
+	u8 signature[HDCP_2_2_DCP_LLC_SIG_LEN];
+};
+
+struct xhdcp2x_rx_ake_init {
+	u8 msgid;
+	u8 rtx[HDCP_2_2_RTX_LEN];
+	u8 txcaps[HDCP_2_2_TX_CAPS];
+};
+
+struct xhdcp2x_rx_ake_send_cert {
+	u8 msgid;
+	u8 certrx[HDCP_2_2_CERTRX];
+	u8 rrx[HDCP_2_2_RRX_LEN];
+	u8 rxcaps[HDCP_2_2_RXCAPS_LEN];
+};
+
+struct xhdcp2x_rx_ake_no_stored_km {
+	u8 msgid;
+	u8 ekpubkm[HDCP_2_2_E_KPUB_KM_LEN];
+};
+
+struct xhdcp2x_rx_ake_stored_km {
+	u8 msgid;
+	u8 ekhkm[HDCP_2_2_E_KH_KM_LEN];
+	u8 m[HDCP_2_2_E_KH_KM_LEN];
+};
+
+struct xhdcp2x_rx_ake_send_hprime {
+	u8 msgid;
+	u8 hprime[HDCP_2_2_H_PRIME_LEN];
+};
+
+struct xhdcp2x_rx_ake_send_pairing_info {
+	u8 msgid;
+	u8 ekhkm[HDCP_2_2_E_KH_KM_LEN];
+};
+
+struct xhdcp2x_rx_lc_init {
+	u8 msgid;
+	u8 rn[HDCP_2_2_RN_LEN];
+};
+
+struct xhdcp2x_rx_lc_send_lprime {
+	u8 msgid;
+	u8 lprime[HDCP_2_2_L_PRIME_LEN];
+};
+
+struct xhdcp2x_rx_ske_send_eks {
+	u8 msgid;
+	u8 edkeyks[HDCP_2_2_E_DKEY_KS_LEN];
+	u8 riv[HDCP_2_2_RIV_LEN];
+};
+
+union xhdcp2x_rx_message {
+	u8 msgid;
+	struct xhdcp2x_rx_ake_init			ake_init;
+	struct xhdcp2x_rx_ake_send_cert			ake_send_cert;
+	struct xhdcp2x_rx_ake_no_stored_km		ake_no_storedkm;
+	struct xhdcp2x_rx_ake_stored_km			ake_storedkm;
+	struct xhdcp2x_rx_ake_send_hprime		ake_send_hprime;
+	struct xhdcp2x_rx_ake_send_pairing_info		ake_send_pairinginfo;
+	struct xhdcp2x_rx_lc_init			lc_init;
+	struct xhdcp2x_rx_lc_send_lprime		lc_send_lprime;
+	struct xhdcp2x_rx_ske_send_eks			ske_sendeks;
+};
+
+enum xdprxss_hdcp_protocol {
+	XDPRXSS_HDCP_NONE = 0,
+	XDPRXSS_HDCP_14 = 1,
+	XDPRXSS_HDCP_22 = 2,
+	XDPRXSS_HDCP_BOTH = 3
+};
+
+enum xhdcp2x_rx_protocol {
+	XHDCP2X_NONE = 0,
+	XHDCP2X_RX_DP = 1,
+	XHDCP2X_RX_HDMI = 2
+};
+
+enum xhdcp2x_rx_mode {
+	xhdcp2x_rx_receiver = 0,
+	xhdcp2x_rx_repeater = 1,
+	xhdcp2x_rx_converter = 2
+};
+
+struct xhdcp2x_rx_callbacks {
+	int (*rd_handler)(void *interface_ref, u32 offset, u8 *buf, u32 size);
+	int (*wr_handler)(void *interface_ref, u32 offset, u8 *buf, u32 size);
+	int (*cp_irq_handler)(void *interface_ref);
+	void (*notify_handler)(void *interface_ref, u32 notification);
+};
+
+enum xhdcp2x_rx_notification_type {
+	XHDCP2X_RX_NOTIFY_AUTHENTICATED = 1,
+	XHDCP2X_RX_NOTIFY_UN_AUTHENTICATED = 2,
+	XHDCP2X_RX_NOTIFY_RE_AUTHENTICATE = 3,
+	XHDCP2X_RX_NOTIFY_ENCRYPTION_DONE = 4,
+	XHDCP2X_RX_NOTIFY_SKE_SEND_EKS = 5
+
+};
+
+enum xhdcp2x_rx_handler_type {
+	XHDCP2X_RX_HANDLER_DP_AUX_READ = 1,
+	XHDCP2X_RX_HANDLER_DP_AUX_WRITE = 2,
+	XHDCP2X_RX_HANDLER_DP_CP_IRQ_SET = 3,
+	XHDCP2X_RX_NOTIFICATION_HANDLER = 4
+};
+
+/**
+ * struct xlnx_hdcp2x_hw - HDCP2X subsystem configuration structure
+ * @cipher_inst: HDCP2X cipher engine configuration
+ * @rng_inst: HDCP2X random number generator configuration
+ * @mmult_inst: HDCP2X montgomery multiplier configuration
+ * @hdcp2xcore_address: HDCP2X core address
+ * @hdcprx_mutex: mutex for hdcp state machine
+ * @rx_mode: HDCP receiver
+ * @protocol: Protocol type, DP or HDMI
+ */
+struct xlnx_hdcp2x_hw {
+	struct xlnx_hdcp2x_cipher_hw cipher_inst;
+	struct xlnx_hdcp2x_rng_hw rng_inst;
+	struct xlnx_hdcp2x_mmult_hw mmult_inst;
+	void __iomem *hdcp2xcore_address;
+/* mutex for hdcp state machine */
+	struct mutex hdcprx_mutex;
+	u8 rx_mode;
+	u8 protocol;
+};
+
+enum xhdcp2x_rx_state {
+	XHDCP2X_STATE_B0 = 0,
+	XHDCP2X_STATE_B1 = 1,
+	XHDCP2X_STATE_B2 = 2,
+	XHDCP2X_STATE_B3 = 3,
+	XHDCP2X_STATE_B4 = 4,
+	XHDCP2X_RX_NUM_STATES = 5
+};
+
+enum xhdcp2x_rx_state_type {
+	XHDCP2X_RX_STATE_UNDEFINED			= 0x000,
+	XHDCP2X_RX_STATE_B0_WAIT_AKEINIT		= 0xB00,
+	XHDCP2X_RX_STATE_B1_SEND_AKESENDCERT		= 0xB10,
+	XHDCP2X_RX_STATE_B1_WAIT_AKEKM			= 0xB11,
+	XHDCP2X_RX_STATE_B1_SEND_AKESENDHPRIME		= 0xB12,
+	XHDCP2X_RX_STATE_B1_SEND_AKESENDPAIRINGINFO	= 0xB13,
+	XHDCP2X_RX_STATE_B1_WAIT_LCINIT			= 0xB14,
+	XHDCP2X_RX_STATE_B2_SEND_LCSENDLPRIME		= 0xB20,
+	XHDCP2X_RX_STATE_B2_WAIT_SKESENDEKS		= 0xB21,
+	XHDCP2X_RX_STATE_B3_COMPUTE_KS			= 0xB30,
+	XHDCP2X_RX_STATE_B4_AUTHENTICATED		= 0xB40,
+	XHDCP2X_RX_STATE_INVALID
+};
+
+enum xhdcp2x_rx_authentication_type {
+	XHDCP2X_RX_UNAUTHENTICATED = 0,
+	XHDCP2X_RX_AUTHENTICATION_BUSY = 1,
+	XHDCP2X_RX_AUTHENTICATED = 2,
+	XHDCP2X_RX_REAUTH_REQUESTED = 3
+};
+
+struct xhdcp2x_rx_parameters {
+	u8 hprime[XHDCP2X_RX_HPRIME_SIZE];
+	u8 lprime[XHDCP2X_RX_LPRIME_SIZE];
+	u8 vprime[XHDCP2X_RX_VPRIME_SIZE];
+	u8 mprime[XHDCP2X_RX_MPRIME_SIZE];
+	u8 ekh[XHDCP2X_RX_EKH_SIZE];
+	u8 km[XHDCP2X_RX_KM_SIZE];
+	u8 ks[XHDCP2X_RX_KS_SIZE];
+	u8 rtx[R_TX_SIZE];
+	u8 rrx[R_RX_SIZE];
+	u8 rn[R_N_SIZE];
+	u8 riv[R_IV_SIZE];
+	u8 txcaps[XHDCP2X_RX_TXCAPS_SIZE];
+	u8 rxcaps[XHDCP2X_RX_RXCAPS_SIZE];
+	u8 seqnumm[XHDCP2X_RX_SEQNUMM_SIZE];
+	u8 streamidtype[XHDCP2X_RX_STREAMID_SIZE];
+};
+
+struct xhdcp2x_rx_info {
+	u32 error_flag;
+	u32 error_flag_sticky;
+	u32 timer_initial_ticks;
+	u32 seq_numv;
+	u32 auth_request_cnt;
+	u32 reauth_request_cnt;
+	u32 link_error_cnt;
+	u32 msg_event;
+	u16 lc_init_attempts;
+	u8 is_enabled;
+	u8 is_no_storedkm;
+	u8 reauth_req;
+	u8 timer_expired;
+	u8 timer_reason_id;
+	u8 has_stream_management_info;
+	u8 skipread;
+	u8 is_encrypted;
+	enum xhdcp2x_rx_state_type sub_state;
+	enum xhdcp2x_rx_state_type return_state;
+	enum xhdcp2x_rx_authentication_type authentication_status;
+};
+
+/**
+ * @dev: device information.
+ * @xhdcp2x_hw: HDCP2x hardware configuration.
+ * @info: information.
+ * @param: HDCP2x Rx parameters.
+ * @tmr_config: timer configuration.
+ * @sm_work: state machine workqueue.
+ * @hdcprx_mutex: mutex for hdcp state machine.
+ * @handlers: callback handlers.
+ * @nprimep: primep key size.
+ * @nprimeq: primeq key size.
+ * @rx_caps: rx caps.
+ * @msg_buffer: message buffer used during authentication.
+ * @lc128key: user shared key.
+ * @is_repeater: repeater functionality.
+ * @lane_count: number of protocol lanes.
+ * @publiccertptr: public certificate.
+ * @keys_loaded: user key status flag.
+ * @privatekeypre: private key provided by user.
+ * @msg_size: message size during authentication.
+ * @error_flags: error flags used during authentication.
+ * @protocol: Interface protocol HDMI or DP.
+ * @mode: different modes of operation for HDCP.
+ * @auth_status: status flag used by state machine.
+ * @hdcp_protocol: hdcp protocol support
+ * @curr_state: current state defined for state machine
+ * @prev_state: previous state defined for state machine
+ * @next_state: next state defined for state machine
+ * @interface_ref: Interface reference
+ * @interface_base: Interface base
+ */
+struct xlnx_hdcp2x_config {
+	struct device *dev;
+	struct xlnx_hdcp2x_hw xhdcp2x_hw;
+	struct xhdcp2x_rx_info info;
+	struct xhdcp2x_rx_parameters param;
+	struct xlnx_hdcp_timer_config tmr_config;
+	struct delayed_work sm_work;
+/* mutex for hdcp state machine */
+	struct mutex hdcprx_mutex;
+	struct xhdcp2x_rx_callbacks handlers;
+	u8 nprimep[XHDCP2X_RX_P_SIZE];
+	u8 nprimeq[XHDCP2X_RX_P_SIZE];
+	u8 rx_caps[XHDCP2X_RX_RXCAPS_SIZE];
+	u8 msg_buffer[XHDCP2X_RX_MAX_MESSAGE_SIZE];
+	u8 *lc128key;
+	u8 is_repeater;
+	u8 lane_count;
+	u8 *publiccertptr;
+	u8 keys_loaded;
+	const u8 *privatekeyptr;
+	int msg_size;
+	enum xhdcp2x_rx_error_flags error_flags;
+	enum xhdcp2x_rx_protocol protocol;
+	enum xhdcp2x_rx_mode mode;
+	enum xhdcp2x_rx_authentication_type auth_status;
+	enum xdprxss_hdcp_protocol hdcp_protocol;
+	enum xhdcp2x_rx_state curr_state;
+	enum xhdcp2x_rx_state prev_state;
+	enum xhdcp2x_rx_state next_state;
+	void *interface_ref;
+	void __iomem *interface_base;
+	void *mmult;
+};
+
+struct xlnx_hdcp_timer_config *xhdcp2x_rx_get_timer(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+
+u8 xhdcp2x_rx_get_content_stream_type(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+
+int *xhdcp2x_rx_init(struct device *dev, void *protocol_ref, void __iomem *hdcp_base_address,
+		     enum xhdcp2x_rx_protocol protocol_rx, bool is_repeater,
+		     u8 lane_count);
+int xhdcp2x_rx_enable(struct xlnx_hdcp2x_config *xhdcp2x_rx, u8 lane_count);
+int xhdcp2x_rx_disable(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+int xhdcp2x_rx_reset(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+int xhdcp2x_rx_poll(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+int xhdcp2x_rx_set_callback(void *ref, u32 handlertype, void *callback_func);
+int xhdcp2x_rx_rsaes_oaep_decrypt(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+				  struct xhdcp2x_rx_kpriv_rx *kprivrx,
+				  u8 *encryptedmessage, u8 *message, int *messagelen);
+int xhdcp2x_rx_push_events(void *ref, u32 events);
+int xhdcp2x_rx_set_key(void *ref, void *hdcp2x_lc128, void *hdcp2x_private);
+int xhdcp2x_rx_set_reauth_req(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+int xhdcp2x_rx_calc_mont_nprime(void *ref, u8 *nprime, const u8 *n, int ndigits);
+
+void xhdcp2x_rx_generate_random(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+				int num_octets, u8 *random_number_ptr);
+void xhdcp2x_timer_attach(struct xlnx_hdcp2x_config *xhdcp2x_rx,
+			  struct xlnx_hdcp_timer_config *tmrcntr);
+void *xhdcp2x_timer_init(struct device *dev, void __iomem *interface_base);
+void xhdcp2x_rx_timer_handler(void *callbackref, u8 tmrcntnumber);
+void xhdcp2x_rx_set_stream_type(struct xlnx_hdcp2x_config *xhdcp2x_rx);
+void xhdcp2x_rx_compute_hprime(const u8 *rrx, const u8 *rxcaps,
+			       const u8 *rtx,  const u8 *txcaps, const u8 *km, u8 *hprime);
+void xhdcp2x_rx_compute_ekh(const u8 *kprivrx, const u8 *km, const u8 *m, u8 *ekh);
+void xhdcp2x_rx_compute_lprime(const u8 *rn, const u8 *km, const u8 *rrx,
+			       const u8 *rtx, u8 *lprime);
+void xhdcp2x_rx_compute_ks(const u8 *rrx, const u8 *rtx, const u8 *km,
+			   const u8 *rn, const u8 *eks, u8 *ks);
+void xhdcp2x_rx_compute_vprime(const u8 *receiveridlist, u32 receiveridlistsize, const u8 *rxinfo,
+			       const u8 *seqnumv, const u8 *km, const u8 *rrx,
+			       const u8 *rtx, u8 *vprime);
+void xhdcp2x_rx_compute_mprime(const u8 *streamidtype, const u8 *seqnumm, const u8 *km,
+			       const u8 *rrx, const u8 *rtx, u8 *mprime);
+
+#endif /* __XILINX_HDCP2X_RX_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-hdmirx-hw.h b/drivers/media/platform/xilinx/xilinx-hdmirx-hw.h
new file mode 100644
index 000000000..4cc4ed4a9
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdmirx-hw.h
@@ -0,0 +1,729 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx HDMI 2.1 Rx Subsystem register map
+ *
+ * Copyright (c) 2021 Xilinx
+ * Author: Vishal Sagar <vishal.sagar@xilinx.com>
+ */
+
+#ifndef __XILINX_HDMIRX_HW_H__
+#define __XILINX_HDMIRX_HW_H__
+
+#include <linux/bits.h>
+#include <linux/io.h>
+
+/* VER (Version Interface) peripheral register offsets */
+#define HDMIRX_VER_BASE				0x0
+/* VER Identification */
+#define HDMIRX_VER_ID_OFFSET			((HDMIRX_VER_BASE) + (0 * 4))
+/* VER Version */
+#define HDMIRX_VER_VERSION_OFFSET		((HDMIRX_VER_BASE) + (1 * 4))
+/* VCKE System Counts */
+#define HDMIRX_VER_VCKE_SYS_CNT_OFFSET		((HDMIRX_VER_BASE) + (2 * 4))
+/* SR/SSB period error 0 counter */
+#define HDMIRX_VER_SR_SSB_ERR_CNT0_OFFSET	((HDMIRX_VER_BASE) + (3 * 4))
+/* SR/SSB period error 1 counter */
+#define HDMIRX_VER_SR_SSB_ERR_CNT1_OFFSET	((HDMIRX_VER_BASE) + (4 * 4))
+/* SR/SSB period error 2 counter */
+#define HDMIRX_VER_SR_SSB_ERR_CNT2_OFFSET	((HDMIRX_VER_BASE) + (5 * 4))
+/* SR/SSB period error 3 counter */
+#define HDMIRX_VER_SR_SSB_ERR_CNT3_OFFSET	((HDMIRX_VER_BASE) + (6 * 4))
+/* FRL word aligner tap select changed */
+#define HDMIRX_VER_DBG_STA_OFFSET		((HDMIRX_VER_BASE) + (7 * 4))
+/* FRL Map error */
+#define HDMIRX_VER_FRL_MAP_ERR_OFFSET		((HDMIRX_VER_BASE) + (8 * 4))
+
+/* PIO (Parallel Interface) peripheral register offsets */
+#define HDMIRX_PIO_BASE				(1 * 64)
+/* PIO Identification */
+#define HDMIRX_PIO_ID_OFFSET			((HDMIRX_PIO_BASE) + (0 * 4))
+/* PIO Control */
+#define HDMIRX_PIO_CTRL_OFFSET			((HDMIRX_PIO_BASE) + (1 * 4))
+/* PIO Control Set */
+#define HDMIRX_PIO_CTRL_SET_OFFSET		((HDMIRX_PIO_BASE) + (2 * 4))
+/* PIO Control Clear */
+#define HDMIRX_PIO_CTRL_CLR_OFFSET		((HDMIRX_PIO_BASE) + (3 * 4))
+/* PIO Status */
+#define HDMIRX_PIO_STA_OFFSET			((HDMIRX_PIO_BASE) + (4 * 4))
+/* PIO Out */
+#define HDMIRX_PIO_OUT_OFFSET			((HDMIRX_PIO_BASE) + (5 * 4))
+/* PIO Out Set */
+#define HDMIRX_PIO_OUT_SET_OFFSET		((HDMIRX_PIO_BASE) + (6 * 4))
+/* PIO Out Clear */
+#define HDMIRX_PIO_OUT_CLR_OFFSET		((HDMIRX_PIO_BASE) + (7 * 4))
+/* PIO Out Mask */
+#define HDMIRX_PIO_OUT_MSK_OFFSET		((HDMIRX_PIO_BASE) + (8 * 4))
+/* PIO In */
+#define HDMIRX_PIO_IN_OFFSET			((HDMIRX_PIO_BASE) + (9 * 4))
+/* PIO In Event */
+#define HDMIRX_PIO_IN_EVT_OFFSET		((HDMIRX_PIO_BASE) + (10 * 4))
+/* PIO In Event Rising Edge */
+#define HDMIRX_PIO_IN_EVT_RE_OFFSET		((HDMIRX_PIO_BASE) + (11 * 4))
+/* PIO In Event Falling Edge */
+#define HDMIRX_PIO_IN_EVT_FE_OFFSET		((HDMIRX_PIO_BASE) + (12 * 4))
+
+/* Timer peripheral register offsets */
+#define HDMIRX_TMR_BASE				(2 * 64)
+/* TMR Identification */
+#define HDMIRX_TMR_ID_OFFSET			((HDMIRX_TMR_BASE) + (0 * 4))
+/* TMR Control */
+#define HDMIRX_TMR_CTRL_OFFSET			((HDMIRX_TMR_BASE) + (1 * 4))
+/* TMR Control Register Set offset */
+#define HDMIRX_TMR_CTRL_SET_OFFSET		((HDMIRX_TMR_BASE) + (2 * 4))
+/* TMR Control Register Clear offset */
+#define HDMIRX_TMR_CTRL_CLR_OFFSET		((HDMIRX_TMR_BASE) + (3 * 4))
+/* TMR Status */
+#define HDMIRX_TMR_STA_OFFSET			((HDMIRX_TMR_BASE) + (4 * 4))
+/* TMR Counter */
+#define HDMIRX_TMR_1_CNT_OFFSET			((HDMIRX_TMR_BASE) + (5 * 4))
+/* TMR Counter */
+#define HDMIRX_TMR_2_CNT_OFFSET			((HDMIRX_TMR_BASE) + (6 * 4))
+/* TMR Counter */
+#define HDMIRX_TMR_3_CNT_OFFSET			((HDMIRX_TMR_BASE) + (7 * 4))
+/* TMR Counter */
+#define HDMIRX_TMR_4_CNT_OFFSET			((HDMIRX_TMR_BASE) + (8 * 4))
+
+/* Video Timing Detector (VTD) peripheral register offsets */
+#define HDMIRX_VTD_BASE				(3 * 64)
+/* VTD Identification */
+#define HDMIRX_VTD_ID_OFFSET			((HDMIRX_VTD_BASE) + (0 * 4))
+/* VTD Control */
+#define HDMIRX_VTD_CTRL_OFFSET			((HDMIRX_VTD_BASE) + (1 * 4))
+/* VTD Control Set */
+#define HDMIRX_VTD_CTRL_SET_OFFSET		((HDMIRX_VTD_BASE) + (2 * 4))
+/* VTD Control Clear */
+#define HDMIRX_VTD_CTRL_CLR_OFFSET		((HDMIRX_VTD_BASE) + (3 * 4))
+/* VTD Status */
+#define HDMIRX_VTD_STA_OFFSET			((HDMIRX_VTD_BASE) + (4 * 4))
+/* VTD Total Pixels */
+#define HDMIRX_VTD_TOT_PIX_OFFSET		((HDMIRX_VTD_BASE) + (5 * 4))
+/* VTD Active Pixels */
+#define HDMIRX_VTD_ACT_PIX_OFFSET		((HDMIRX_VTD_BASE) + (6 * 4))
+/* VTD Total Lines */
+#define HDMIRX_VTD_TOT_LIN_OFFSET		((HDMIRX_VTD_BASE) + (7 * 4))
+/* VTD Active Lines */
+#define HDMIRX_VTD_ACT_LIN_OFFSET		((HDMIRX_VTD_BASE) + (8 * 4))
+/* VTD Vertical Sync Width */
+#define HDMIRX_VTD_VSW_OFFSET			((HDMIRX_VTD_BASE) + (9 * 4))
+/* VTD Horizontal Sync Width */
+#define HDMIRX_VTD_HSW_OFFSET			((HDMIRX_VTD_BASE) + (10 * 4))
+/* VTD Vertical Front Porch */
+#define HDMIRX_VTD_VFP_OFFSET			((HDMIRX_VTD_BASE) + (11 * 4))
+/* VTD Vertical Back Porch */
+#define HDMIRX_VTD_VBP_OFFSET			((HDMIRX_VTD_BASE) + (12 * 4))
+/* VTD Horizontal Front Porch */
+#define HDMIRX_VTD_HFP_OFFSET			((HDMIRX_VTD_BASE) + (13 * 4))
+/* VTD Horizontal Back Porch */
+#define HDMIRX_VTD_HBP_OFFSET			((HDMIRX_VTD_BASE) + (14 * 4))
+
+/* DDC (Display Data Channel) peripheral register offsets */
+#define HDMIRX_DDC_BASE				(4 * 64)
+/* DDC Identification */
+#define HDMIRX_DDC_ID_OFFSET			((HDMIRX_DDC_BASE) + (0 * 4))
+/* DDC Control */
+#define HDMIRX_DDC_CTRL_OFFSET			((HDMIRX_DDC_BASE) + (1 * 4))
+/* DDC Control Register Set offset */
+#define HDMIRX_DDC_CTRL_SET_OFFSET		((HDMIRX_DDC_BASE) + (2 * 4))
+/* DDC Control Register Clear offset */
+#define HDMIRX_DDC_CTRL_CLR_OFFSET		((HDMIRX_DDC_BASE) + (3 * 4))
+/* DDC Status */
+#define HDMIRX_DDC_STA_OFFSET			((HDMIRX_DDC_BASE) + (4 * 4))
+/* DDC EDID Status */
+#define HDMIRX_DDC_EDID_STA_OFFSET		((HDMIRX_DDC_BASE) + (5 * 4))
+/* DDC HDCP Status */
+#define HDMIRX_DDC_HDCP_STA_OFFSET		((HDMIRX_DDC_BASE) + (6 * 4))
+/* DDC Read EDID segment pointer offset */
+#define HDMIRX_DDC_EDID_SP_OFFSET		((HDMIRX_DDC_BASE) + (8 * 4))
+/* DDC Read EDID write pointer offset */
+#define HDMIRX_DDC_EDID_WP_OFFSET		((HDMIRX_DDC_BASE) + (9 * 4))
+/* DDC Read EDID read pointer offset */
+#define HDMIRX_DDC_EDID_RP_OFFSET		((HDMIRX_DDC_BASE) + (10 * 4))
+/* DDC Read EDID data offset */
+#define HDMIRX_DDC_EDID_DATA_OFFSET		((HDMIRX_DDC_BASE) + (11 * 4))
+/* DDC Read HDCP address offset */
+#define HDMIRX_DDC_HDCP_ADDRESS_OFFSET		((HDMIRX_DDC_BASE) + (12 * 4))
+/* DDC Read HDCP data offset */
+#define HDMIRX_DDC_HDCP_DATA_OFFSET		((HDMIRX_DDC_BASE) + (13 * 4))
+
+/* Auxiliary (AUX) peripheral register offsets */
+#define HDMIRX_AUX_BASE				(5 * 64)
+/* AUX Identification */
+#define HDMIRX_AUX_ID_OFFSET			((HDMIRX_AUX_BASE) + (0 * 4))
+/* AUX Control */
+#define HDMIRX_AUX_CTRL_OFFSET			((HDMIRX_AUX_BASE) + (1 * 4))
+/* AUX Control Register Set offset */
+#define HDMIRX_AUX_CTRL_SET_OFFSET		((HDMIRX_AUX_BASE) + (2 * 4))
+/* AUX Control Register Clear offset */
+#define HDMIRX_AUX_CTRL_CLR_OFFSET		((HDMIRX_AUX_BASE) + (3 * 4))
+/* AUX Status */
+#define HDMIRX_AUX_STA_OFFSET			((HDMIRX_AUX_BASE) + (4 * 4))
+/* AUX Data */
+#define HDMIRX_AUX_DAT_OFFSET			((HDMIRX_AUX_BASE) + (5 * 4))
+/* AUX Flush Count */
+#define HDMIRX_AUX_FLUSH_CNT_OFFSET		((HDMIRX_AUX_BASE) + (6 * 4))
+
+/* Audio (AUD) peripheral register offsets */
+#define HDMIRX_AUD_BASE				(6 * 64)
+/* AUD Identification */
+#define HDMIRX_AUD_ID_OFFSET			((HDMIRX_AUD_BASE) + (0 * 4))
+/* AUD Control */
+#define HDMIRX_AUD_CTRL_OFFSET			((HDMIRX_AUD_BASE) + (1 * 4))
+/* AUD Control Register Set offset */
+#define HDMIRX_AUD_CTRL_SET_OFFSET		((HDMIRX_AUD_BASE) + (2 * 4))
+/* AUD Control Register Clear offset */
+#define HDMIRX_AUD_CTRL_CLR_OFFSET		((HDMIRX_AUD_BASE) + (3 * 4))
+/* AUD Status */
+#define HDMIRX_AUD_STA_OFFSET			((HDMIRX_AUD_BASE) + (4 * 4))
+/* AUD CTS */
+#define HDMIRX_AUD_CTS_OFFSET			((HDMIRX_AUD_BASE) + (5 * 4))
+/* AUD N */
+#define HDMIRX_AUD_N_OFFSET			((HDMIRX_AUD_BASE) + (6 * 4))
+/* AUD Flush Count */
+#define HDMIRX_AUD_FLUSH_CNT_OFFSET		((HDMIRX_AUD_BASE) + (7 * 4))
+
+/* Link Status (LNKSTA) peripheral register offsets */
+#define HDMIRX_LNKSTA_BASE			(7 * 64)
+/* LNKSTA Identification */
+#define HDMIRX_LNKSTA_ID_OFFSET			((HDMIRX_LNKSTA_BASE) + (0 * 4))
+/* LNKSTA Control */
+#define HDMIRX_LNKSTA_CTRL_OFFSET		((HDMIRX_LNKSTA_BASE) + (1 * 4))
+/* LNKSTA Control Register Set offset */
+#define HDMIRX_LNKSTA_CTRL_SET_OFFSET		((HDMIRX_LNKSTA_BASE) + (2 * 4))
+/* LNKSTA Control Register Clear offset */
+#define HDMIRX_LNKSTA_CTRL_CLR_OFFSET		((HDMIRX_LNKSTA_BASE) + (3 * 4))
+/* LNKSTA Status */
+#define HDMIRX_LNKSTA_STA_OFFSET		((HDMIRX_LNKSTA_BASE) + (4 * 4))
+/* LNKSTA Link Error Counter Channel 0 */
+#define HDMIRX_LNKSTA_LNK_ERR0_OFFSET		((HDMIRX_LNKSTA_BASE) + (5 * 4))
+/* LNKSTA Link Error Counter Channel 1 */
+#define HDMIRX_LNKSTA_LNK_ERR1_OFFSET		((HDMIRX_LNKSTA_BASE) + (6 * 4))
+/* LNKSTA Link Error Counter Channel 2 */
+#define HDMIRX_LNKSTA_LNK_ERR2_OFFSET		((HDMIRX_LNKSTA_BASE) + (7 * 4))
+/* Packet ECC Error */
+#define HDMIRX_LNKSTA_PKT_ECC_ERR_OFFSET	((HDMIRX_LNKSTA_BASE) + (8 * 4))
+/* Tri-byte Analyzer Timing */
+#define HDMIRX_LNKSTA_TRIB_ANLZ_TIM_OFFSET	((HDMIRX_LNKSTA_BASE) + (9 * 4))
+/* Tri-byte HBP_HS */
+#define HDMIRX_LNKSTA_TRIB_HBP_HS_OFFSET	((HDMIRX_LNKSTA_BASE) + (10 * 4))
+/* Tri-byte Analyzer Line Size */
+#define HDMIRX_LNKSTA_TRIB_ANLZ_LN_ACT_OFFSET	((HDMIRX_LNKSTA_BASE) + (11 * 4))
+
+/* Fixed Rate Link (FRL) peripheral register offsets */
+#define HDMIRX_FRL_BASE				(8 * 64)
+/* FRL Identification */
+#define HDMIRX_FRL_ID_OFFSET			((HDMIRX_FRL_BASE) + (0 * 4))
+/* FRL Control */
+#define HDMIRX_FRL_CTRL_OFFSET			((HDMIRX_FRL_BASE) + (1 * 4))
+/* FRL Control Register Set offset */
+#define HDMIRX_FRL_CTRL_SET_OFFSET		((HDMIRX_FRL_BASE) + (2 * 4))
+/* FRL Control Register Clear offset */
+#define HDMIRX_FRL_CTRL_CLR_OFFSET		((HDMIRX_FRL_BASE) + (3 * 4))
+/* FRL Status */
+#define HDMIRX_FRL_STA_OFFSET			((HDMIRX_FRL_BASE) + (4 * 4))
+/* FRL Video Clock  to VCKE Ratio */
+#define HDMIRX_FRL_VCLK_VCKE_RATIO_OFFSET	((HDMIRX_FRL_BASE) + (7 * 4))
+/* FRL Video Clock */
+#define HDMIRX_FRL_SCDC_OFFSET			((HDMIRX_FRL_BASE) + (8 * 4))
+/* FRL Total Data */
+#define HDMIRX_FRL_RATIO_TOT_OFFSET		((HDMIRX_FRL_BASE) + (9 * 4))
+/* FRL Total Active Data */
+#define HDMIRX_FRL_RATIO_ACT_OFFSET		((HDMIRX_FRL_BASE) + (10 * 4))
+/* Reed-Solomon FEC Counter Data */
+#define HDMIRX_FRL_RSFC_CNT_OFFSET		((HDMIRX_FRL_BASE) + (11 * 4))
+/* FRL Error Count Data */
+#define HDMIRX_FRL_ERR_CNT1_OFFSET		((HDMIRX_FRL_BASE) + (12 * 4))
+/* Video Lock Count Data */
+#define HDMIRX_FRL_VID_LOCK_CNT_OFFSET		((HDMIRX_FRL_BASE) + (13 * 4))
+
+/* VER (Version Interface) peripheral register masks and shift */
+/* FRL SR/SSB period error during training period mask */
+#define HDMIRX_SR_SSB_ERR1_MASK			GENMASK(15, 0)
+/* FRL SR/SSB period error during NON-training period mask */
+#define HDMIRX_SR_SSB_ERR2_MASK			GENMASK(31, 16)
+
+/* FRL Word aligner tap select changed all lanes mask */
+#define HDMIRX_DBG_STA_WA_TAP_CHGALL_MASK	GENMASK(3, 0)
+/* Word aligner tap select changed lane 0 mask */
+#define HDMIRX_DBG_STA_WA_TAP_CHG0_MASK		BIT(0)
+/* Word aligner tap select changed lane 1 mask */
+#define HDMIRX_DBG_STA_WA_TAP_CHG1_MASK		BIT(1)
+/* Word aligner tap select changed lane 2 mask */
+#define HDMIRX_DBG_STA_WA_TAP_CHG2_MASK		BIT(2)
+/* FRL Word aligner tap select changed lane 3 mask */
+#define HDMIRX_DBG_STA_WA_TAP_CHG3_MASK		BIT(3)
+/* FRL Word aligner tap select changed all lanes mask */
+#define HDMIRX_DBG_STA_WA_LOCK_CHGALL_MASK	GENMASK(7, 4)
+/* Word aligner tap select changed lane 0 mask */
+#define HDMIRX_DBG_STA_WA_LOCK_CHG0_MASK	BIT(4)
+/* Word aligner tap select changed lane 1 mask */
+#define HDMIRX_DBG_STA_WA_LOCK_CHG1_MASK	BIT(5)
+/* Word aligner tap select changed lane 2 mask */
+#define HDMIRX_DBG_STA_WA_LOCK_CHG2_MASK	BIT(6)
+/* FRL Word aligner tap select changed lane 3 mask */
+#define HDMIRX_DBG_STA_WA_LOCK_CHG3_MASK	BIT(7)
+/* FRL Word aligner tap select changed all lanes mask */
+#define HDMIRX_DBG_STA_SCRM_LOCK_CHGALL_MASK	GENMASK(11, 8)
+/* Word aligner tap select changed lane 0 mask */
+#define HDMIRX_DBG_STA_SCRM_LOCK_CHG0_MASK	BIT(8)
+/* Word aligner tap select changed lane 1 mask */
+#define HDMIRX_DBG_STA_SCRM_LOCK_CHG1_MASK	BIT(9)
+/* Word aligner tap select changed lane 2 mask */
+#define HDMIRX_DBG_STA_SCRM_LOCK_CHG2_MASK	BIT(10)
+/* FRL Word aligner tap select changed lane 3 mask */
+#define HDMIRX_DBG_STA_SCRM_LOCK_CHG3_MASK	BIT(11)
+/* FRL Word aligner tap select changed all lanes mask */
+#define HDMIRX_DBG_STA_LANE_LOCK_CHGALL_MASK	GENMASK(15, 12)
+/* Word aligner tap select changed lane 0 mask */
+#define HDMIRX_DBG_STA_LANE_LOCK_CHG0_MASK	BIT(12)
+/* Word aligner tap select changed lane 1 mask */
+#define HDMIRX_DBG_STA_LANE_LOCK_CHG1_MASK	BIT(13)
+/* Word aligner tap select changed lane 2 mask */
+#define HDMIRX_DBG_STA_LANE_LOCK_CHG2_MASK	BIT(14)
+/* FRL Word aligner tap select changed lane 3 mask */
+#define HDMIRX_DBG_STA_LANE_LOCK_CHG3_MASK	BIT(15)
+/* Word aligner tap select changed lane 0 mask */
+#define HDMIRX_DBG_STA_SKEW_LOCK_CHG_MASK	BIT(16)
+
+/* PIO peripheral Control register masks */
+/* PIO Control Run mask */
+#define HDMIRX_PIO_CTRL_RUN_MASK		BIT(0)
+/* PIO Control Interrupt Enable mask */
+#define HDMIRX_PIO_CTRL_IE_MASK			BIT(1)
+
+/* PIO peripheral Status register masks */
+/* PIO Status Interrupt mask */
+#define HDMIRX_PIO_STA_IRQ_MASK			BIT(0)
+/* PIO Status Event mask */
+#define HDMIRX_PIO_STA_EVT_MASK			BIT(1)
+
+/* PIO peripheral PIO Out register masks and shifts */
+/* PIO Out Reset mask */
+#define HDMIRX_PIO_OUT_RESET_MASK		BIT(0)
+/* PIO Out video enable mask */
+#define HDMIRX_PIO_OUT_LNK_EN_MASK		BIT(1)
+/* PIO Out video enable mask */
+#define HDMIRX_PIO_OUT_VID_EN_MASK		BIT(2)
+/* PIO Out Hot-Plug Detect mask */
+#define HDMIRX_PIO_OUT_HPD_MASK			BIT(3)
+/* PIO Out Deep Color mask */
+#define HDMIRX_PIO_OUT_DEEP_COLOR_MASK		GENMASK(5, 4)
+/* PIO Out Pixel Rate mask */
+#define HDMIRX_PIO_OUT_PIXEL_RATE_MASK		GENMASK(7, 6)
+/* PIO Out Sample Rate mask */
+#define HDMIRX_PIO_OUT_SAMPLE_RATE_MASK		GENMASK(9, 8)
+/* PIO Out Color Space mask */
+#define HDMIRX_PIO_OUT_COLOR_SPACE_MASK		GENMASK(11, 10)
+/* PIO Out Scrambler mask */
+#define HDMIRX_PIO_OUT_SCRM_MASK		BIT(12)
+/* PIO Out Pixel Phase mask */
+#define HDMIRX_PIO_OUT_PP_MASK			GENMASK(18, 16)
+/* PIO Out Axis Enable mask */
+#define HDMIRX_PIO_OUT_AXIS_EN_MASK		BIT(19)
+/* PIO Out Deep Color shift */
+#define HDMIRX_PIO_OUT_DEEP_COLOR_SHIFT		4
+/* PIO Out Pixel Rate Shift */
+#define HDMIRX_PIO_OUT_PIXEL_RATE_SHIFT		6
+/* PIO Out Sample Rate shift */
+#define HDMIRX_PIO_OUT_SAMPLE_RATE_SHIFT	8
+/* PIO Out Color Space shift */
+#define HDMIRX_PIO_OUT_COLOR_SPACE_SHIFT	10
+/* PIO Out Pixel Phase shift */
+#define HDMIRX_PIO_OUT_PP_SHIFT			16
+/* PIO Out Bridge_YUV420 mask */
+#define HDMIRX_PIO_OUT_BRIDGE_YUV420_MASK	BIT(29)
+/* PIO Out Bridge_Pixel drop mask */
+#define HDMIRX_PIO_OUT_BRIDGE_PIXEL_MASK	BIT(30)
+
+/* PIO Out INT_VRST mask */
+#define HDMIRX_PIO_OUT_INT_VRST_MASK		BIT(0)
+/* PIO Out INT_LRST mask */
+#define HDMIRX_PIO_OUT_INT_LRST_MASK		BIT(20)
+/* PIO Out EXT_VRST mask */
+#define HDMIRX_PIO_OUT_EXT_VRST_MASK		BIT(21)
+/* PIO Out EXT_SYSRST mask */
+#define HDMIRX_PIO_OUT_EXT_SYSRST_MASK		BIT(22)
+
+/* PIO peripheral PIO In register masks */
+/* PIO In cable detect mask */
+#define HDMIRX_PIO_IN_DET_MASK			BIT(0)
+/* PIO In link ready mask */
+#define HDMIRX_PIO_IN_LNK_RDY_MASK		BIT(1)
+/* PIO In video ready mask */
+#define HDMIRX_PIO_IN_VID_RDY_MASK		BIT(2)
+/* PIO In Mode mask */
+#define HDMIRX_PIO_IN_MODE_MASK			BIT(3)
+/* PIO In Scrambler lock 0 mask */
+#define HDMIRX_PIO_IN_SCRAMBLER_LOCK0_MASK	BIT(4)
+/* PIO In Scrambler lock 1 mask */
+#define HDMIRX_PIO_IN_SCRAMBLER_LOCK1_MASK	BIT(5)
+/* PIO In Scrambler lock 2 mask */
+#define HDMIRX_PIO_IN_SCRAMBLER_LOCK2_MASK	BIT(6)
+/* PIO In SCDC scrambler enable mask */
+#define HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK	BIT(7)
+/* PIO In SCDC TMDS clock ratio mask */
+#define HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK	BIT(8)
+/* PIO In alinger lock mask */
+#define HDMIRX_PIO_IN_ALIGNER_LOCK_MASK		BIT(9)
+/* PIO In bridge overflow mask */
+#define HDMIRX_PIO_IN_BRDG_OVERFLOW_MASK	BIT(10)
+
+/* Timer peripheral Control register masks */
+/* TMR Control Run mask */
+#define HDMIRX_TMR1_CTRL_RUN_MASK		BIT(0)
+/* TMR Control Interrupt Enable mask */
+#define HDMIRX_TMR1_CTRL_IE_MASK		BIT(1)
+/* TMR Control Run mask */
+#define HDMIRX_TMR2_CTRL_RUN_MASK		BIT(2)
+/* TMR Control Interrupt Enable mask */
+#define HDMIRX_TMR2_CTRL_IE_MASK		BIT(3)
+/* TMR Control Run mask */
+#define HDMIRX_TMR3_CTRL_RUN_MASK		BIT(4)
+/* TMR Control Interrupt Enable mask */
+#define HDMIRX_TMR3_CTRL_IE_MASK		BIT(5)
+/* TMR Control Run mask */
+#define HDMIRX_TMR4_CTRL_RUN_MASK		BIT(6)
+/* TMR Control Interrupt Enable mask */
+#define HDMIRX_TMR4_CTRL_IE_MASK		BIT(7)
+
+/* Timer peripheral Status register masks */
+/* TMR Status Interrupt mask */
+#define HDMIRX_TMR_STA_IRQ_MASK			BIT(0)
+/* TMR Status counter Event mask */
+#define HDMIRX_TMR1_STA_CNT_EVT_MASK		BIT(1)
+/* TMR Status counter Event mask */
+#define HDMIRX_TMR2_STA_CNT_EVT_MASK		BIT(3)
+/* TMR Status counter Event mask */
+#define HDMIRX_TMR3_STA_CNT_EVT_MASK		BIT(5)
+/* TMR Status counter Event mask */
+#define HDMIRX_TMR4_STA_CNT_EVT_MASK		BIT(7)
+
+/* Video timing detector peripheral Control register masks and shift */
+/* VTD Control Run mask */
+#define HDMIRX_VTD_CTRL_RUN_MASK		BIT(0)
+/* VTD Control Interrupt Enable mask */
+#define HDMIRX_VTD_CTRL_IE_MASK			BIT(1)
+/* VTD Control field polarity mask */
+#define HDMIRX_VTD_CTRL_FIELD_POL_MASK		BIT(2)
+/* VTD Control field polarity mask */
+#define HDMIRX_VTD_CTRL_SYNC_LOSS_MASK		BIT(3)
+/* VTD Control timebase shift */
+#define HDMIRX_VTD_CTRL_TIMEBASE_SHIFT		8
+/* VTD Control timebase mask */
+#define HDMIRX_VTD_CTRL_TIMERBASE_MASK		GENMASK(31, 8)
+
+#define HDMIRX_VTD_VF0_MASK			GENMASK(15, 0)
+#define HDMIRX_VTD_VF1_MASK			GENMASK(31, 16)
+
+/* Video timing detector peripheral Status register masks */
+/* VTD Status Interrupt mask */
+#define HDMIRX_VTD_STA_IRQ_MASK			BIT(0)
+/* VTD Status timebase event mask */
+#define HDMIRX_VTD_STA_TIMEBASE_EVT_MASK	BIT(1)
+/* VTD Status Vsync Polarity mask */
+#define HDMIRX_VTD_STA_VS_POL_MASK		BIT(3)
+/* VTD Status Hsync Polarity mask */
+#define HDMIRX_VTD_STA_HS_POL_MASK		BIT(4)
+/* VTD Status Format mask */
+#define HDMIRX_VTD_STA_FMT_MASK			BIT(5)
+/* VTD Status Sync Loss mask */
+#define HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK	BIT(6)
+
+/* DDC peripheral Control register masks */
+/* DDC Control Run mask */
+#define HDMIRX_DDC_CTRL_RUN_MASK		BIT(0)
+/* DDC Control Interrupt enable mask */
+#define HDMIRX_DDC_CTRL_IE_MASK			BIT(1)
+/* DDC Control EDID enable mask */
+#define HDMIRX_DDC_CTRL_EDID_EN_MASK		BIT(2)
+/* DDC Control SCDC enable mask */
+#define HDMIRX_DDC_CTRL_SCDC_EN_MASK		BIT(3)
+/* DDC Control HDCP enable mask */
+#define HDMIRX_DDC_CTRL_HDCP_EN_MASK		BIT(4)
+/* DDC Control SCDC clear mask */
+#define HDMIRX_DDC_CTRL_SCDC_CLR_MASK		BIT(5)
+/* DDC Control write message clear mask */
+#define HDMIRX_DDC_CTRL_WMSG_CLR_MASK		BIT(6)
+/* DDC Control read message clear mask */
+#define HDMIRX_DDC_CTRL_RMSG_CLR_MASK		BIT(7)
+/* DDC Control HDCP mode mask */
+#define HDMIRX_DDC_CTRL_HDCP_MODE_MASK		BIT(8)
+/* DDC Control SCDC Read Write Event mask */
+#define HDMIRX_DDC_CTRL_SCDC_RD_WR_EVT_EN_MASK	BIT(9)
+
+/* DDC peripheral Status register masks */
+/* DDC Status Interrupt mask */
+#define HDMIRX_DDC_STA_IRQ_MASK			BIT(0)
+/* DDC Status Event mask */
+#define HDMIRX_DDC_STA_EVT_MASK			BIT(1)
+/* DDC Status Busy mask */
+#define HDMIRX_DDC_STA_BUSY_MASK		BIT(2)
+/* DDC Status state of the SCL input mask */
+#define HDMIRX_DDC_STA_SCL_MASK			BIT(3)
+/* DDC Status state of the SDA input mask */
+#define HDMIRX_DDC_STA_SDA_MASK			BIT(4)
+/* DDC Status HDCP AKSV event mask */
+#define HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK	BIT(5)
+/* DDC Status HDCP write message buffer new event mask */
+#define HDMIRX_DDC_STA_HDCP_WMSG_NEW_EVT_MASK	BIT(6)
+/* DDC Status HDCP read message buffer end event mask */
+#define HDMIRX_DDC_STA_HDCP_RMSG_END_EVT_MASK	BIT(7)
+/* DDC Status HDCP read message buffer not completed event mask */
+#define HDMIRX_DDC_STA_HDCP_RMSG_NC_EVT_MASK	BIT(8)
+/* DDC Status HDCP 1.4 protocol flag */
+#define HDMIRX_DDC_STA_HDCP_1_PROT_MASK		BIT(9)
+/* DDC Status HDCP 2.2 protocol flag */
+#define HDMIRX_DDC_STA_HDCP_2_PROT_MASK		BIT(10)
+/* DDC Status HDCP 1.4 protocol event flag */
+#define HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK	BIT(11)
+/* DDC Status HDCP 2.2 protocol event flag */
+#define HDMIRX_DDC_STA_HDCP_2_PROT_EVT_MASK	BIT(12)
+/* DDC Status SCDC Read Write event flag */
+#define HDMIRX_DDC_STA_SCDC_RD_WR_EVT_MASK	BIT(13)
+/* DDC Status EDID words mask */
+#define HDMIRX_DDC_STA_EDID_WORDS_MASK		GENMASK(15, 0)
+/* DDC Status HDCP 2.2 write message buffer words mask */
+#define HDMIRX_DDC_STA_HDCP_WMSG_WORDS_MASK	GENMASK(10, 0)
+/* DDC Status HDCP 2.2 write message buffer empty mask */
+#define HDMIRX_DDC_STA_HDCP_WMSG_EP_MASK	BIT(11)
+/* DDC Status HDCP 2.2 read message buffer words mask */
+#define HDMIRX_DDC_STA_HDCP_RMSG_WORDS_MASK	GENMASK(26, 16)
+/* DDC Status HDCP 2.2 read message buffer empty mask */
+#define HDMIRX_DDC_STA_HDCP_RMSG_EP_MASK	BIT(27)
+
+/* AUX peripheral Control register masks */
+/* AUX Control Run mask */
+#define HDMIRX_AUX_CTRL_RUN_MASK		BIT(0)
+/* AUX Control Interrupt Enable mask */
+#define HDMIRX_AUX_CTRL_IE_MASK			BIT(1)
+
+/* AUX peripheral Status register masks and shifts */
+/* AUX Status Interrupt mask */
+#define HDMIRX_AUX_STA_IRQ_MASK			BIT(0)
+/* AUX Status New Packet mask */
+#define HDMIRX_AUX_STA_NEW_MASK			BIT(1)
+/* AUX Status New Packet mask */
+#define HDMIRX_AUX_STA_ERR_MASK			BIT(2)
+/* AUX Status AVI infoframe mask */
+#define HDMIRX_AUX_STA_AVI_MASK			BIT(3)
+/* AUX Status General control packet mask */
+#define HDMIRX_AUX_STA_GCP_MASK			BIT(4)
+/* AUX Status FIFO Empty mask */
+#define HDMIRX_AUX_STA_FIFO_EP_MASK		BIT(5)
+/* AUX Status FIFO Full mask */
+#define HDMIRX_AUX_STA_FIFO_FL_MASK		BIT(6)
+/* AUX Status Dynamic HDR event mask */
+#define HDMIRX_AUX_STA_DYN_HDR_EVT_MASK		BIT(20)
+/* AUX Status VRR CD mask */
+#define HDMIRX_AUX_STA_VRR_CD_EVT_MASK		BIT(21)
+/* AUX Status FSYNC CD mask */
+#define HDMIRX_AUX_STA_FSYNC_CD_EVT_MASK	BIT(22)
+/* AUX Status GCP ColorDepth mask */
+#define HDMIRX_AUX_STA_GCP_CD_EVT_MASK		BIT(25)
+/* AUX Status GCP avmute mask */
+#define HDMIRX_AUX_STA_GCP_AVMUTE_MASK		BIT(31)
+/* AUX Status AVI VIC mask */
+#define HDMIRX_AUX_STA_AVI_VIC_MASK		GENMASK(15, 8)
+/* AUX Status AVI colorspace mask */
+#define HDMIRX_AUX_STA_AVI_CS_MASK		GENMASK(17, 16)
+/* AUX Status GCP colordepth mask */
+#define HDMIRX_AUX_STA_GCP_CD_MASK		GENMASK(27, 26)
+/* AUX Status GCP pixel phase mask */
+#define HDMIRX_AUX_STA_GCP_PP_MASK		GENMASK(30, 28)
+
+/* Audio peripheral Control register masks */
+/* AUD Control Run mask */
+#define HDMIRX_AUD_CTRL_RUN_MASK		BIT(0)
+/* AUD Control Interrupt Enable mask */
+#define HDMIRX_AUD_CTRL_IE_MASK			BIT(1)
+/* AUD Control ACR Update Event Enable mask */
+#define HDMIRX_AUD_CTRL_ACR_UPD_EVT_EN_MASK	BIT(2)
+
+/* AUD peripheral Status register masks and shift */
+/* AUD Status Interrupt mask */
+#define HDMIRX_AUD_STA_IRQ_MASK			BIT(0)
+/* AUD Status Event mask */
+#define HDMIRX_AUD_STA_ACT_EVT_MASK		BIT(1)
+/* AUD Status Event mask */
+#define HDMIRX_AUD_STA_CH_EVT_MASK		BIT(2)
+/* AUD Status Active mask */
+#define HDMIRX_AUD_STA_ACT_MASK			BIT(3)
+/* AUD Status Audio channel mask */
+#define HDMIRX_AUD_STA_AUD_CH_MASK		GENMASK(5, 4)
+/* AUD Status Audio Format mask */
+#define HDMIRX_AUD_STA_AUD_FMT_MASK		GENMASK(8, 6)
+/* AUD Status ACR Update mask */
+#define HDMIRX_AUD_STA_ACR_UPD_MASK		BIT(9)
+
+/* Link Status (LNKSTA) peripheral Control register masks */
+/* LNKSTA Control Run mask */
+#define HDMIRX_LNKSTA_CTRL_RUN_MASK		BIT(0)
+/* LNKSTA Control Interrupt Enable mask */
+#define HDMIRX_LNKSTA_CTRL_IE_MASK		BIT(1)
+/* LNKSTA Control Error Clear mask */
+#define HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK		BIT(2)
+
+/* Link Status (LNKSTA) peripheral Status register masks */
+/* LNKSTA Status Interrupt mask */
+#define HDMIRX_LNKSTA_STA_IRQ_MASK		BIT(0)
+/* LNKSTA Status Maximum Errors mask */
+#define HDMIRX_LNKSTA_STA_ERR_MAX_MASK		BIT(1)
+#define HDMIRX_LNKSTA_STA_DCS_8CD_LOCK_MASK	BIT(2)
+#define HDMIRX_LNKSTA_STA_DCS_DEEP_LOCK_MASK	BIT(3)
+
+/* Tri-byte Analyzer register masks */
+/* Tri-byte analyzer timing changed count mask */
+#define HDMIRX_TRIB_ANLZ_TIM_CHGD_CNT_MASK	GENMASK(15, 0)
+/* Tri-byte analyzer timing vsync polarity mask */
+#define HDMIRX_TRIB_ANLZ_TIM_VS_POL_MASK	BIT(16)
+/* Tri-byte analyzer timing hsync polarity mask */
+#define HDMIRX_TRIB_ANLZ_TIM_HS_POL_MASK	BIT(17)
+
+/* Tri-byte Analyzer register masks */
+/* Tri-byte hsync size mask */
+#define HDMIRX_TRIB_HBP_HS_HS_SZ_MASK		GENMASK(15, 0)
+/* Tri-byte hbp size mask */
+#define HDMIRX_TRIB_HBP_HS_HBP_SZ_MASK		GENMASK(31, 16)
+
+/* Tri-byte Analyzer register masks */
+/* Tri-byte analyzer act size mask */
+#define HDMIRX_TRIB_ANLZ_LN_ACT_ACT_SZ_MASK	GENMASK(15, 0)
+/* Tri-byte analyzer line act mask */
+#define HDMIRX_TRIB_ANLZ_LN_ACT_LN_SZ_MASK	GENMASK(31, 16)
+
+/* FRL Control register masks */
+/* FRL Control Resetn mask */
+#define HDMIRX_FRL_CTRL_RSTN_MASK			BIT(0)
+/* FRL Control Interrupt Enable mask */
+#define HDMIRX_FRL_CTRL_IE_MASK				BIT(1)
+/* FRL Control Clock Ratio Update Event Enable mask */
+#define HDMIRX_FRL_CTRL_CLK_RATIO_UPD_EVT_EN_MASK	BIT(2)
+/* FRL Control Skew Event Enable mask */
+#define HDMIRX_FRL_CTRL_SKEW_EVT_EN_MASK		BIT(3)
+/* FRL Control FLT Clear mask */
+#define HDMIRX_FRL_CTRL_FLT_CLR_MASK			BIT(5)
+/* FRL Control FLT Threshold mask */
+#define HDMIRX_FRL_CTRL_FLT_THRES_MASK			GENMASK(13, 6)
+/* FRL Control FRL Rate Write Event Enable */
+#define HDMIRX_FRL_CTRL_FRL_RATE_WR_EVT_EN_MASK		BIT(14)
+/* FRL Control DPACK Reset mask */
+#define HDMIRX_FRL_CTRL_DPACK_RST_MASK			BIT(15)
+/* FRL Control DPACK Error Counter Clear mask */
+#define HDMIRX_FRL_CTRL_DPACK_ERR_CNT_CLR_MASK		BIT(16)
+/* FRL Control DPACK Auto Reset Disable mask */
+#define HDMIRX_FRL_CTRL_DPACK_AUTO_RST_DIS_MASK		BIT(17)
+/* FRL Control Video Lock Reset Disable Mask */
+#define HDMIRX_FRL_CTRL_VID_LOCK_RST_DIS_MASK		BIT(19)
+/* FRL PARS module reset */
+#define HDMIRX_FRL_CTRL_PARS_RST_MASK			BIT(21)
+/* FRL FEC module reset */
+#define HDMIRX_FRL_CTRL_FEC_RST_MASK			BIT(22)
+/* FRL MAP module reset */
+#define HDMIRX_FRL_CTRL_MAP_RST_MASK			BIT(23)
+/* FRL SKEW module reset */
+#define HDMIRX_FRL_CTRL_SKEW_RST_MASK			BIT(24)
+
+/* FRL Status register masks */
+/* FRL Status Interrupt mask */
+#define HDMIRX_FRL_STA_IRQ_MASK				BIT(0)
+/* FRL Status Event mask */
+#define HDMIRX_FRL_STA_EVT_MAS				BIT(1)
+/* FRL Status FLT Pattern Match event mask */
+#define HDMIRX_FRL_STA_FLT_PM_EVT_MASK			BIT(2)
+/* FRL Status FLT Pattern Match All Lanes mask */
+#define HDMIRX_FRL_STA_FLT_PM_ALLL_MASK			GENMASK(6, 3)
+/* FRL Status FLT Pattern MatchLane 0 mask */
+#define HDMIRX_FRL_STA_FLT_PM_L0_MASK			BIT(3)
+/* FRL Status FLT Pattern MatchLane 1 mask */
+#define HDMIRX_FRL_STA_FLT_PM_L1_MASK			BIT(4)
+/* FRL Status FLT Pattern MatchLane 2 mask */
+#define HDMIRX_FRL_STA_FLT_PM_L2_MASK			BIT(5)
+/* FRL Status FLT Pattern MatchLane 3 mask */
+#define HDMIRX_FRL_STA_FLT_PM_L3_MASK			BIT(6)
+/* FRL Status FLT Update event mask */
+#define HDMIRX_FRL_STA_FLT_UPD_EVT_MASK			BIT(7)
+/* FRL Status FRL Rate change event mask */
+#define HDMIRX_FRL_STA_RATE_EVT_MASK			BIT(8)
+/* FRL Status Lane Lock event mask */
+#define HDMIRX_FRL_STA_LANE_LOCK_EVT_MASK		BIT(9)
+/* FRL Status Clock Ratio Update event mask */
+#define HDMIRX_FRL_STA_CLK_RATIO_UPD_EVT_MASK		BIT(10)
+/* FRL Status Skew Lock event mask */
+#define HDMIRX_FRL_STA_SKEW_LOCK_EVT_MASK		BIT(11)
+/* FRL Status Lane Lock All Lanes mask */
+#define HDMIRX_FRL_STA_LANE_LOCK_ALLL_MASK		GENMASK(15, 12)
+/* FRL Status Lane Lock L0 mask */
+#define HDMIRX_FRL_STA_LANE_LOCK_L0_MASK		BIT(12)
+/* FRL Status Lane Lock L1 mask */
+#define HDMIRX_FRL_STA_LANE_LOCK_L1_MASK		BIT(13)
+/* FRL Status Lane Lock L2 mask */
+#define HDMIRX_FRL_STA_LANE_LOCK_L2_MASK		BIT(14)
+/* FRL Status Lane Lock L3 mask */
+#define HDMIRX_FRL_STA_LANE_LOCK_L3_MASK		BIT(15)
+/* FRL Status Aligner Lock All Lanes mask */
+#define HDMIRX_FRL_STA_WA_LOCK_ALLL_MASK		GENMASK(19, 16)
+/* FRL Status Aligner Lock L0 mask */
+#define HDMIRX_FRL_STA_WA_LOCK_L0_MASK			BIT(16)
+/* FRL Status Aligner Lock L1 mask */
+#define HDMIRX_FRL_STA_WA_LOCK_L1_MASK			BIT(17)
+/* FRL Status Aligner Lock L2 mask */
+#define HDMIRX_FRL_STA_WA_LOCK_L2_MASK			BIT(18)
+/* FRL Status Aligner Lock L3 mask */
+#define HDMIRX_FRL_STA_WA_LOCK_L3_MASK			BIT(19)
+/* FRL Status Scrambler All Lanes mask */
+#define HDMIRX_FRL_STA_SCRM_LOCK_ALLL_MASK		GENMASK(23, 20)
+/* FRL Status Scrambler Lock L0 mask */
+#define HDMIRX_FRL_STA_SCRM_LOCK_L0_MASK		BIT(20)
+/* FRL Status Scrambler Lock L1 mask */
+#define HDMIRX_FRL_STA_SCRM_LOCK_L1_MASK		BIT(21)
+/* FRL Status Scrambler Lock L2 mask */
+#define HDMIRX_FRL_STA_SCRM_LOCK_L2_MASK		BIT(22)
+/* FRL Status Scrambler Lock L3 mask */
+#define HDMIRX_FRL_STA_SCRM_LOCK_L3_MASK		BIT(23)
+/* FRL Status Skew Lock mask */
+#define HDMIRX_FRL_STA_SKEW_LOCK_MASK			BIT(24)
+/* FRL Status Video STR mask */
+#define HDMIRX_FRL_STA_STR_MASK				BIT(25)
+/* FRL Status Video Lock mask */
+#define HDMIRX_FRL_STA_VID_LOCK_MASK			BIT(26)
+/* FRL Status Mode mask */
+#define HDMIRX_FRL_STA_FRL_MODE_MASK			BIT(27)
+/* FRL Status Lanes mask */
+#define HDMIRX_FRL_STA_FRL_LANES_MASK			BIT(28)
+/* FRL Status Rate mask */
+#define HDMIRX_FRL_STA_FRL_RATE_MASK			GENMASK(31, 29)
+
+/* FRL Link Clock register masks */
+/* FRL Link Clock mask */
+#define HDMIRX_FRL_LNK_CLK_MASK		0xFFFFF
+/* FRL Video Clock mask */
+#define HDMIRX_FRL_VID_CLK_MASK		0xFFFFF
+
+/* FRL SCDC register masks */
+/* FRL SCDC Address mask */
+#define HDMIRX_FRL_SCDC_ADDR_MASK			GENMASK(7, 0)
+/* FRL SCDC Data mask */
+#define HDMIRX_FRL_SCDC_DAT_MASK			GENMASK(15, 8)
+/* FRL SCDC Data Shift */
+#define HDMIRX_FRL_SCDC_DAT_SHIFT			8
+/* FRL SCDC Write mask */
+#define HDMIRX_FRL_SCDC_WR_MASK				BIT(16)
+/* FRL SCDC Read mask */
+#define HDMIRX_FRL_SCDC_RD_MASK				BIT(17)
+/* FRL SCDC Ready mask */
+#define HDMIRX_FRL_SCDC_RDY_MASK			BIT(18)
+
+#define HDMIRX_FRL_RATIO_TOT_MASK	0xFFFFFF
+#define HDMIRX_FRL_RATIO_ACT_MASK	0xFFFFFF
+
+#define HDMIRX_FRL_ERR_CNT1_DPACK_ERR_CNT_MASK		GENMASK(31, 16)
+#define HDMIRX_FRL_ERR_CNT1_RSCC_ERR_CNT_MASK		GENMASK(15, 0)
+
+/* Peripheral ID and General shift values */
+/* 16 shift value */
+#define HDMIRX_SHIFT_16		16
+/* 16 bit mask value */
+#define HDMIRX_MASK_16		GENMASK(15, 0)
+/* PIO ID */
+#define HDMIRX_PIO_ID		0x2200
+
+#endif /* __XILINX_HDMIRX_HW_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-hdmirxss.c b/drivers/media/platform/xilinx/xilinx-hdmirxss.c
new file mode 100644
index 000000000..cb636d116
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hdmirxss.c
@@ -0,0 +1,4430 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx HDMI 2.1 Rx Subsystem driver
+ *
+ * Copyright (c) 2021 Xilinx
+ * Author: Vishal Sagar <vishal.sagar@xilinx.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/math64.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <media/media-entity.h>
+#include <media/v4l2-dv-timings.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-subdev.h>
+#include <linux/xilinx-hdmirxss.h>
+#include "xilinx-hdmirx-hw.h"
+#include "xilinx-hdcp1x-rx.h"
+
+#define XHDMI_MAX_LANES		(4)
+#define XEDID_BLOCKS_MAX	(10)
+#define XEDID_BLOCK_SIZE	(128)
+
+#define AXILITE_FREQ		clk_get_rate(xhdmi->clks[0].clk)
+#define TIME_10MS		(AXILITE_FREQ / 100)
+#define TIME_16MS		(AXILITE_FREQ * 10 / 625)
+#define TIME_200MS		(AXILITE_FREQ / 5)
+
+#define USLEEP_MIN_DELAY	10
+#define USLEEP_MAX_DELAY	20
+
+#define XHDMIRX_HPD_ENABLE_DELAY_MS		20
+
+#define MAX_VID_PROP_TRIES	7
+#define MAX_FIELDS		2
+#define COREPIXPERCLK		4
+#define MAX_FRL_RETRY		(256)
+#define DEFAULT_LTPTHRESHOLD	(150)
+
+/*
+ * Reference:
+ * https://www.xilinx.com/content/dam/xilinx/support/documents/ip_documentation/hdcp/v1_0/pg224-hdcp.pdf
+ */
+#define XHDMIRX_HDCP1X_REG_OFFSET		0x10000
+#define XHDCP1X_KEYMGMT_REG_VERSION		0x00
+#define XHDCP1X_KEYMGMT_REG_TYPE		0x04
+#define XHDCP1X_KEYMGMT_REG_CTRL		0x0C
+#define XHDCP1X_KEYMGMT_REG_TBL_CTRL		0x20
+#define XHDCP1X_KEYMGMT_REG_TBL_STATUS		0x24
+#define XHDCP1X_KEYMGMT_REG_TBL_ADDR		0x28
+#define XHDCP1X_KEYMGMT_REG_TBL_DAT_H		0x2C
+#define XHDCP1X_KEYMGMT_REG_TBL_DAT_L		0x30
+
+#define XHDCP1X_KEYMGMT_REG_CTRL_RST_MASK	BIT(31)
+#define XHDCP1X_KEYMGMT_REG_CTRL_DISABLE_MASK	GENMASK(31, 1)
+#define XHDCP1X_KEYMGMT_REG_CTRL_ENABLE_MASK	BIT(0)
+#define XHDCP1X_KEYMGMT_REG_TBL_STATUS_RETRY	0x400
+#define XHDCP1X_KEYMGMT_TBLID_0			0
+#define XHDCP1X_KEYS_SIZE			336
+#define XHDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK	BIT(0)
+#define XHDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK	BIT(1)
+#define XHDCP1X_KEYMGMT_REG_TBL_CTRL_EN_MASK	BIT(31)
+#define XHDCP1X_KEYMGMT_REG_TBL_STATUS_DONE_MASK	BIT(0)
+#define XHDCP1X_KEYMGMT_MAX_TBLS		8
+#define XHDCP1X_KEYMGMT_MAX_ROWS_PER_TBL	41
+
+#define XHDMIRX_HDCP_MAX_DDC_BYTES		0x100
+
+enum xhdmirx_stream_state {
+	XSTREAM_IDLE = 0,
+	XSTREAM_INIT = 1,
+	XSTREAM_LOCK = 2,
+	XSTREAM_ARM = 3,
+	XSTREAM_UP = 4,
+	XSTREAM_DOWN = 5,
+	XSTATE_FRL_LINK_TRAININIG = 6,
+	XSTREAM_MAX_STATE = 7,
+};
+
+enum xhdmirx_syncstatus {
+	XSYNCSTAT_SYNC_LOSS = 0,
+	XSYNCSTAT_SYNC_EST = 1,
+};
+
+enum xcolorspace {
+	XCS_RGB = 0,
+	XCS_YUV422 = 1,
+	XCS_YUV444 = 2,
+	XCS_YUV420 = 3,
+};
+
+enum xcolordepth {
+	XCD_8 = 8,
+	XCD_10 = 10,
+	XCD_12 = 12,
+	XCD_16 = 16,
+};
+
+/**
+ * struct xtiming - Timing struct
+ *
+ * @hact: Horizontal Active
+ * @htot: Horizontal Total
+ * @hbp: Horizontal Backporch
+ * @hfp: Horizontal Frontporch
+ * @hsw: Horizontal Syncwidth
+ * @vact: Vertical Active
+ * @vtot: Vertical Total
+ * @vfp: Vertical Frontporch
+ * @vbp: Vertical Backporch
+ * @vsw: Vertical Syncwidth
+ * @vsyncpol: Vertical polarity
+ * @hsyncpol: Horizontal polarity
+ */
+struct xtiming {
+	u16 hact;
+	u16 htot;
+	u16 hbp;
+	u16 hfp;
+	u16 hsw;
+	u16 vact;
+	u16 vtot[MAX_FIELDS];
+	u16 vfp[MAX_FIELDS];
+	u16 vbp[MAX_FIELDS];
+	u16 vsw[MAX_FIELDS];
+	u8 vsyncpol;
+	u8 hsyncpol;
+};
+
+/**
+ * struct xvideostream - Video stream structure
+ * @timing: stream timing struct
+ * @colorspace: color space of incoming stream RGB/YUV 444/422/420
+ * @colordepth: color depth 8/10/12/16 bpc
+ * @framerate: Frame rate of stream
+ * @isinterlaced: stream is interlaced or progressive
+ */
+struct xvideostream {
+	struct xtiming timing;
+	enum xcolorspace colorspace;
+	enum xcolordepth colordepth;
+	u32 framerate;
+	bool isinterlaced;
+};
+
+/* FRL SCDC Fields */
+enum xhdmi_frlscdcfieldtype {
+	XSCDCFIELD_SINK_VER = 0,
+	XSCDCFIELD_SOURCE_VER = 1,
+	XSCDCFIELD_CED_UPDATE = 2,
+	XSCDCFIELD_SOURCE_TEST_UPDATE = 3,
+	XSCDCFIELD_FRL_START = 4,
+	XSCDCFIELD_FLT_UPDATE = 5,
+	XSCDCFIELD_RSED_UPDATE = 6,
+	XSCDCFIELD_SCRAMBLER_EN = 7,
+	XSCDCFIELD_SCRAMBLER_STAT = 8,
+	XSCDCFIELD_FLT_NO_RETRAIN = 9,
+	XSCDCFIELD_FRL_RATE = 10,
+	XSCDCFIELD_FFE_LEVELS = 11,
+	XSCDCFIELD_FLT_NO_TIMEOUT = 12,
+	XSCDCFIELD_LNS_LOCK = 13,
+	XSCDCFIELD_FLT_READY = 14,
+	XSCDCFIELD_LN0_LTP_REQ = 15,
+	XSCDCFIELD_LN1_LTP_REQ = 16,
+	XSCDCFIELD_LN2_LTP_REQ = 17,
+	XSCDCFIELD_LN3_LTP_REQ = 18,
+	XSCDCFIELD_CH0_ERRCNT_LSB = 19,
+	XSCDCFIELD_CH0_ERRCNT_MSB = 20,
+	XSCDCFIELD_CH1_ERRCNT_LSB = 21,
+	XSCDCFIELD_CH1_ERRCNT_MSB = 22,
+	XSCDCFIELD_CH2_ERRCNT_LSB = 23,
+	XSCDCFIELD_CH2_ERRCNT_MSB = 24,
+	XSCDCFIELD_CED_CHECKSUM = 25,
+	XSCDCFIELD_CH3_ERRCNT_LSB = 26,
+	XSCDCFIELD_CH3_ERRCNT_MSB = 27,
+	XSCDCFIELD_RSCCNT_LSB = 28,
+	XSCDCFIELD_RSCCNT_MSB = 29,
+	XSCDCFIELD_SIZE = 30,
+};
+
+/* FRL Training States */
+enum xhdmi_frltrainingstate {
+	XFRLSTATE_LTS_L = 0,
+	XFRLSTATE_LTS_2 = 1,
+	XFRLSTATE_LTS_3_RATE_CH = 2,
+	XFRLSTATE_LTS_3_ARM_LNK_RDY = 3,
+	XFRLSTATE_LTS_3_ARM_VID_RDY = 4,
+	XFRLSTATE_LTS_3_LTP_DET = 5,
+	XFRLSTATE_LTS_3_TMR = 6,
+	XFRLSTATE_LTS_3 = 7,
+	XFRLSTATE_LTS_3_RDY = 8,
+	XFRLSTATE_LTS_P = 9,
+	XFRLSTATE_LTS_P_TIMEOUT = 10,
+	/* LTS:P (FRL_START = 1) */
+	XFRLSTATE_LTS_P_FRL_RDY = 11,
+	/* LTS:P (Skew Locked) */
+	XFRLSTATE_LTS_P_VID_RDY = 12,
+};
+
+/* LTP type */
+enum xhdmi_frlltptype {
+	XLTP_SUCCESS = 0,
+	XLTP_ALL_ONES = 1,
+	XLTP_ALL_ZEROES = 2,
+	XLTP_NYQUIST_CLOCK = 3,
+	XLTP_RXDDE_COMPLIANCE = 4,
+	XLTP_LFSR0 = 5,
+	XLTP_LFSR1 = 6,
+	XLTP_LFSR2 = 7,
+	XLTP_LFSR3 = 8,
+	XLTP_FFE_CHANGE = 0xE,
+	XLTP_RATE_CHANGE = 0xF,
+};
+
+union xhdmi_frlffeadjtype {
+	u32 data;
+	u8 byte[4];
+};
+
+union xhdmi_frlltp {
+	u32 data;
+	u8 byte[4];
+};
+
+struct xhdmi_frlscdcfield {
+	u8 offset;
+	u8 mask;
+	u8 shift;
+};
+
+static const struct xhdmi_frlscdcfield frlscdcfield[XSCDCFIELD_SIZE] = {
+	{0x01, 0xFF, 0},	/* XSCDCFIELD_SINK_VER */
+	{0x02, 0xFF, 0},	/* XSCDCFIELD_SOURCE_VER */
+	{0x10, 0x01, 1},	/* XSCDCFIELD_CED_UPDATE */
+	{0x10, 0x01, 3},	/* XSCDCFIELD_SOURCE_TEST_UPDATE */
+	{0x10, 0x01, 4},	/* XSCDCFIELD_FRL_START */
+	{0x10, 0x01, 5},	/* XSCDCFIELD_FLT_UPDATE */
+	{0x10, 0x01, 6},	/* XSCDCFIELD_RSED_UPDATE */
+	{0x20, 0x03, 0},	/* XSCDCFIELD_SCRAMBLER_EN */
+	{0x21, 0x01, 0},	/* XSCDCFIELD_SCRAMBLER_STAT */
+	{0x30, 0x01, 1},	/* XSCDCFIELD_FLT_NO_RETRAIN */
+	{0x31, 0x0F, 0},	/* XSCDCFIELD_FRL_RATE */
+	{0x31, 0x0F, 4},	/* XSCDCFIELD_FFE_LEVELS */
+	{0x35, 0x01, 5},	/* XSCDCFIELD_FLT_NO_TIMEOUT */
+	{0x40, 0x0F, 1},	/* XSCDCFIELD_LNS_LOCK */
+	{0x40, 0x01, 6},	/* XSCDCFIELD_FLT_READY */
+	{0x41, 0x0F, 0},	/* XSCDCFIELD_LN0_LTP_REQ */
+	{0x41, 0x0F, 4},	/* XSCDCFIELD_LN1_LTP_REQ */
+	{0x42, 0x0F, 0},	/* XSCDCFIELD_LN2_LTP_REQ */
+	{0x42, 0x0F, 4},	/* XSCDCFIELD_LN3_LTP_REQ */
+	{0x50, 0xFF, 0},	/* XSCDCFIELD_CH0_ERRCNT_LSB */
+	{0x51, 0xFF, 0},	/* XSCDCFIELD_CH0_ERRCNT_MSB */
+	{0x52, 0xFF, 0},	/* XSCDCFIELD_CH1_ERRCNT_LSB */
+	{0x53, 0xFF, 0},	/* XSCDCFIELD_CH1_ERRCNT_MSB */
+	{0x54, 0xFF, 0},	/* XSCDCFIELD_CH2_ERRCNT_LSB */
+	{0x55, 0xFF, 0},	/* XSCDCFIELD_CH2_ERRCNT_MSB */
+	{0x56, 0xFF, 0},	/* XSCDCFIELD_CED_CHECKSUM */
+	{0x57, 0xFF, 0},	/* XSCDCFIELD_CH3_ERRCNT_LSB */
+	{0x58, 0xFF, 0},	/* XSCDCFIELD_CH3_ERRCNT_MSB */
+	{0x59, 0xFF, 0},	/* XSCDCFIELD_RSCCNT_LSB */
+	{0x5A, 0xFF, 0},	/* XSCDCFIELD_RSCCNT_MSB */
+};
+
+/**
+ * struct xhdmirx_frl - FRL related structure
+ * @trainingstate: Fixed Rate Link State
+ * @timercnt: FRL timer
+ * @linerate: Current line rate from FRL rate
+ * @curfrlrate: Current FRL rate supported
+ * @lanes: Current number of lanes used
+ * @ffelevels: Number of supported FFE levels for current FRL rate
+ * @ffesuppflag: RX core's support for FFE levels
+ * @fltupdateasserted: Flag for FLT update asserted
+ * @ltp: LTP to be detected by the RX core and queried by source
+ * @defaultltp: LTP which will be used by Rx core for link training
+ * @laneffeadjreq: RxFFE for each lane
+ * @fltnotimeout: Flag for no timeout
+ * @fltnoretrain: Flag for no retrain
+ * @ltpmatchwaitcounts: counter for link training pattern match waiting
+ * @ltpmatchedcounts: counter for link training pattern matched
+ * @ltpmatchpollcounts: counter for link training pattern poll match
+ */
+struct xhdmirx_frl {
+	enum xhdmi_frltrainingstate trainingstate;
+	u32 timercnt;
+	u8 linerate;
+	u32 curfrlrate;
+	u8 lanes;
+	u8 ffelevels;
+	u8 ffesuppflag;
+	u8 fltupdateasserted;
+	union xhdmi_frlltp ltp;
+	union xhdmi_frlltp defaultltp;
+	union xhdmi_frlffeadjtype laneffeadjreq;
+	u8 fltnotimeout;
+	u8 fltnoretrain;
+	u8 ltpmatchwaitcounts;
+	u8 ltpmatchedcounts;
+	u8 ltpmatchpollcounts;
+};
+
+/*
+ * This is timeout period of LTS3 for different FFE levels (0 - 3)
+ * in milliseconds
+ */
+static const u16 frltimeoutlts3[4] = { 180, 90, 60, 45};
+
+/**
+ * struct xstream - Stream structure
+ * @video: video stream properties struct
+ * @frl: FRL related struct
+ * @state: streaming state
+ * @syncstatus: whether sync established or lost
+ * @pixelclk: Pixel clock
+ * @refclk: Reference clock from cable
+ * @cable_connected: Flag if HDMI cable is connected
+ * @isscrambled: Flag if stream is scrambled
+ * @vic: AVI vic code
+ * @getvidproptries: Number of tries to get video properties
+ * @ishdmi: whether hdmi or dvi
+ * @isfrl: FRL flag. 1 - FRL mode 0 - TMDS mode
+ */
+struct xstream {
+	struct xvideostream video;
+	struct xhdmirx_frl frl;
+	enum xhdmirx_stream_state state;
+	enum xhdmirx_syncstatus syncstatus;
+	u32 pixelclk;
+	u32 refclk;
+	bool cable_connected;
+	bool isscrambled;
+	u8 vic;
+	u8 getvidproptries;
+	u8 ishdmi;
+	u8 isfrl;
+};
+
+union xhdmi_auxheader {
+	u32 data;
+	u8 byte[4];
+};
+
+union xhdmi_auxdata {
+	u32 data[8];
+	u8 byte[32];
+};
+
+struct xhdmi_aux {
+	union xhdmi_auxheader header;
+	union xhdmi_auxdata data;
+};
+
+/**
+ * struct xhdmirx_state - HDMI Rx driver state
+ * @dev: Platform structure
+ * @regs: Base address
+ * @hdcp1x: Base address for HDCP 1.4 IP block
+ * @hdcp1x_keymgmt_base: Base address for HDCP 1.4 Key Management IP Block
+ * @sd: V4L2 subdev structure
+ * @pad: Media pad
+ * @mbus_fmt: Detected media bus format
+ * @dv_timings: Detected DV timings
+ * @stream: struct to save stream properties
+ * @aux: struct to save auxiliary packet
+ * @xhdmi_mutex: Mutex to prevent concurrent access to state structure
+ * @work_queue: Pointer to work queue for hot plug
+ * @delayed_work_enable_hotplug: Delayed work to enable hotplug
+ * @phy: array of phy structure pointers
+ * @clks: array of clocks
+ * @frlclkfreqkhz: FRL Clock Freq in KHz
+ * @vidclkfreqkhz: Video Clock Freq in KHz
+ * @intrstatus: Array to save the interrupt status registers
+ * @edid_user: User EDID
+ * @edid_user_blocks: Number of blocks in user EDID
+ * @edid_blocks_max: Max number of EDID blocks
+ * @edid_ram_size: EDID RAM size in IP configuration
+ * @hdcp1x_key: HDCP 1.4 Key
+ * @max_ppc: Maximum input pixels per clock from IP configuration
+ * @max_bpc: Maximum bit per component from IP configuration
+ * @max_frl_rate: Maximum FRL rate supported from IP configuration
+ * @hdmi_stream_up: hdmi stream is up or not
+ * @hdcp1x_key_available: flag to indicate HDCP 1.4 key is loaded properly
+ * @hdcp1x_prot_event: HDCP 1.4 prot event is detected from downstream
+ * @hdcp_enable: flag to indicate if HDCP protocol is enabled
+ * @is_hdcp1x_enabled: flag to indicate if HDCP 1.4 protocol is enabled
+ * @isstreamup: flag whether stream is up
+ */
+struct xhdmirx_state {
+	struct device *dev;
+	void __iomem *regs;
+	void   *hdcp1x;
+	struct regmap *hdcp1x_keymgmt_base;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt mbus_fmt;
+	struct v4l2_dv_timings dv_timings;
+	struct xstream stream;
+	struct xhdmi_aux aux;
+	/* mutex to prevent concurrent access to this structure */
+	struct mutex xhdmi_mutex;
+	struct workqueue_struct *work_queue;
+	struct delayed_work delayed_work_enable_hotplug;
+	struct phy *phy[XHDMI_MAX_LANES];
+	struct clk_bulk_data *clks;
+	u32 frlclkfreqkhz;
+	u32 vidclkfreqkhz;
+	u32 intrstatus[9];
+	u8 *edid_user;
+	int edid_user_blocks;
+	int edid_blocks_max;
+	u16 edid_ram_size;
+	u8 *hdcp1x_key;
+	u8 max_ppc;
+	u8 max_bpc;
+	u8 max_frl_rate;
+	u8 hdmi_stream_up;
+	bool hdcp1x_key_available;
+	bool hdcp1x_prot_event;
+	bool hdcp_enable;
+	bool is_hdcp1x_enabled;
+	bool isstreamup;
+};
+
+union hdcp1x_key_table {
+	u8 data_u8[XHDCP1X_KEYS_SIZE];
+	u64 data_u64[XHDCP1X_KEYS_SIZE / (sizeof(u64))];
+};
+
+static const char * const xhdmirx_clks[] = {
+	"s_axi_cpu_aclk", "frl_clk", "s_axis_video_aclk",
+};
+
+/*
+ * 187, 255 offset need to be updated for bandwidth and no. of lanes
+ * 12 Gbps @ 4 lanes => [187] = 0x63, [255] = 0x94
+ * 10 Gbps @ 4 lanes => [187] = 0x53, [255] = 0xA4
+ *  8 Gbps @ 4 lanes => [187] = 0x43, [255] = 0xB4
+ *  6 Gbps @ 4 lanes => [187] = 0x33, [255] = 0xC4
+ *  6 Gbps @ 3 lanes => [187] = 0x23, [255] = 0xD4
+ *  3 Gbps @ 4 lanes => [187] = 0x13, [255] = 0xE4
+ *  TMDS             => [187] = 0x03, [255] = 0xF4
+ */
+static const u8 xilinx_frl_edid[] = {
+	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
+	0x61, 0x98, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12,
+	0x17, 0x1D, 0x01, 0x03, 0x80, 0xA0, 0x5A, 0x78,
+	0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
+	0x0F, 0x50, 0x54, 0x21, 0x00, 0x00, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0xE8,
+	0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
+	0x8A, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E,
+	0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
+	0x58, 0x2C, 0x45, 0x00, 0x20, 0xC2, 0x31, 0x00,
+	0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
+	0x90, 0x0F, 0x8C, 0x3C, 0x00, 0x0A, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
+	0x00, 0x58, 0x49, 0x4C, 0x49, 0x4E, 0x58, 0x20,
+	0x48, 0x44, 0x4D, 0x49, 0x32, 0x31, 0x01, 0x53,
+
+	0x02, 0x03, 0x44, 0xF1, 0x56, 0xC4, 0xC3, 0xC2,
+	0xD4, 0xD3, 0xD2, 0xC1, 0x7F, 0x7E, 0x7D, 0xDB,
+	0xDA, 0x66, 0x65, 0x76, 0x75, 0x61, 0x60, 0x3F,
+	0x40, 0x10, 0x1F, 0x2C, 0x0F, 0x7F, 0x07, 0x5F,
+	0x7C, 0x01, 0x57, 0x06, 0x03, 0x67, 0x7E, 0x03,
+	0x6B, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x38, 0x3C,
+	0x20, 0x00, 0x20, 0x03, 0x67, 0xD8, 0x5D, 0xC4,
+	0x01, 0x78, 0x80, 0x63, 0xE4, 0x0F, 0x09, 0xCC,
+	0x00, 0xE2, 0x00, 0xCF, 0x08, 0xE8, 0x00, 0x30,
+	0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58, 0x8A, 0x00,
+	0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x04, 0x74,
+	0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
+	0x8A, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E,
+	0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
+	0x58, 0x2C, 0x45, 0x00, 0x20, 0xC2, 0x31, 0x00,
+	0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94
+};
+
+/* Event struct */
+static const struct v4l2_event xhdmi_ev_fmt = {
+	.type = V4L2_EVENT_SOURCE_CHANGE,
+	.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+};
+
+#define xhdmirx_piointr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_CTRL_CLR_OFFSET,\
+		    HDMIRX_PIO_CTRL_IE_MASK)
+#define xhdmirx_piointr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_CTRL_SET_OFFSET,\
+		    HDMIRX_PIO_CTRL_IE_MASK)
+
+#define xhdmirx_pio_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_CTRL_CLR_OFFSET,\
+		    HDMIRX_PIO_CTRL_RUN_MASK)
+#define xhdmirx_pio_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_CTRL_SET_OFFSET,\
+		    HDMIRX_PIO_CTRL_RUN_MASK)
+
+#define xhdmirx_tmr1_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR1_CTRL_RUN_MASK)
+#define xhdmirx_tmr1_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR1_CTRL_RUN_MASK)
+#define xhdmirx_tmr1intr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR1_CTRL_IE_MASK)
+#define xhdmirx_tmr1intr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR1_CTRL_IE_MASK)
+#define xhdmirx_tmr1_start(xhdmi, value) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_1_CNT_OFFSET, \
+		    value)
+#define xhdmirx_tmr1_getval(xhdmi) xhdmi_read(xhdmi, HDMIRX_TMR_1_CNT_OFFSET)
+
+#define xhdmirx_tmr2_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR2_CTRL_RUN_MASK)
+#define xhdmirx_tmr2_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR2_CTRL_RUN_MASK)
+#define xhdmirx_tmr2intr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR2_CTRL_IE_MASK)
+#define xhdmirx_tmr2intr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR2_CTRL_IE_MASK)
+#define xhdmirx_tmr2_start(xhdmi, value) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_2_CNT_OFFSET, \
+		    value)
+#define xhdmirx_tmr2_getval(xhdmi) xhdmi_read(xhdmi, HDMIRX_TMR_2_CNT_OFFSET)
+
+#define xhdmirx_tmr3_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR3_CTRL_RUN_MASK)
+#define xhdmirx_tmr3_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR3_CTRL_RUN_MASK)
+#define xhdmirx_tmr3intr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR3_CTRL_IE_MASK)
+#define xhdmirx_tmr3intr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR3_CTRL_IE_MASK)
+#define xhdmirx_tmr3_start(xhdmi, value) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_3_CNT_OFFSET, \
+		    value)
+#define xhdmirx_tmr3_getval(xhdmi) xhdmi_read(xhdmi, HDMIRX_TMR_3_CNT_OFFSET)
+
+#define xhdmirx_tmr4_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR4_CTRL_RUN_MASK)
+#define xhdmirx_tmr4_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR4_CTRL_RUN_MASK)
+#define xhdmirx_tmr4intr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_SET_OFFSET, \
+		    HDMIRX_TMR4_CTRL_IE_MASK)
+#define xhdmirx_tmr4intr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_CTRL_CLR_OFFSET, \
+		    HDMIRX_TMR4_CTRL_IE_MASK)
+#define xhdmirx_tmr4_start(xhdmi, value) \
+	xhdmi_write(xhdmi, HDMIRX_TMR_4_CNT_OFFSET, \
+		    value)
+#define xhdmirx_tmr4_getval(xhdmi) xhdmi_read(xhdmi, HDMIRX_TMR_4_CNT_OFFSET)
+
+#define xhdmirx_vtdintr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_VTD_CTRL_CLR_OFFSET, \
+		    HDMIRX_VTD_CTRL_IE_MASK)
+#define xhdmirx_vtdintr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_VTD_CTRL_SET_OFFSET, \
+		    HDMIRX_VTD_CTRL_IE_MASK)
+#define xhdmirx_vtd_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_VTD_CTRL_CLR_OFFSET, \
+		    HDMIRX_VTD_CTRL_RUN_MASK)
+#define xhdmirx_vtd_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_VTD_CTRL_SET_OFFSET, \
+		    HDMIRX_VTD_CTRL_RUN_MASK)
+
+#define xhdmirx_ddcintr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_CLR_OFFSET, \
+		    HDMIRX_DDC_CTRL_IE_MASK)
+#define xhdmirx_ddcintr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_SET_OFFSET, \
+		    HDMIRX_DDC_CTRL_IE_MASK)
+#define xhdmirx_ddc_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_CLR_OFFSET, \
+		    HDMIRX_DDC_CTRL_RUN_MASK)
+#define xhdmirx_ddc_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_SET_OFFSET, \
+		    HDMIRX_DDC_CTRL_RUN_MASK)
+#define xhdmirx_ddc_hdcp_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_SET_OFFSET, \
+		    HDMIRX_DDC_CTRL_HDCP_EN_MASK)
+#define xhdmirx_ddc_hdcp_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_CLR_OFFSET, \
+		    HDMIRX_DDC_CTRL_HDCP_EN_MASK)
+#define xhdmirx_ddc_hdcp14_mode(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_CLR_OFFSET, \
+		    HDMIRX_DDC_CTRL_HDCP_MODE_MASK)
+
+#define xhdmirx_auxintr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUX_CTRL_CLR_OFFSET, \
+		    HDMIRX_AUX_CTRL_IE_MASK)
+#define xhdmirx_auxintr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUX_CTRL_SET_OFFSET, \
+		    HDMIRX_AUX_CTRL_IE_MASK)
+#define xhdmirx_aux_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUX_CTRL_CLR_OFFSET, \
+		    HDMIRX_AUX_CTRL_RUN_MASK)
+#define xhdmirx_aux_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUX_CTRL_SET_OFFSET, \
+		    HDMIRX_AUX_CTRL_RUN_MASK)
+
+#define xhdmirx_audintr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUD_CTRL_CLR_OFFSET, \
+		    HDMIRX_AUD_CTRL_IE_MASK)
+#define xhdmirx_audintr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUD_CTRL_SET_OFFSET, \
+		    HDMIRX_AUD_CTRL_IE_MASK)
+#define xhdmirx_aud_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUD_CTRL_CLR_OFFSET, \
+		    HDMIRX_AUD_CTRL_RUN_MASK)
+#define xhdmirx_aud_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_AUD_CTRL_SET_OFFSET, \
+		    HDMIRX_AUD_CTRL_RUN_MASK)
+
+#define xhdmirx_lnkstaintr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_LNKSTA_CTRL_CLR_OFFSET, \
+		    HDMIRX_LNKSTA_CTRL_IE_MASK)
+#define xhdmirx_lnkstaintr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_LNKSTA_CTRL_SET_OFFSET, \
+		    HDMIRX_LNKSTA_CTRL_IE_MASK)
+#define xhdmirx_lnksta_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_LNKSTA_CTRL_CLR_OFFSET, \
+		    HDMIRX_LNKSTA_CTRL_RUN_MASK)
+#define xhdmirx_lnksta_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_LNKSTA_CTRL_SET_OFFSET, \
+		    HDMIRX_LNKSTA_CTRL_RUN_MASK)
+
+#define xhdmirx_frlintr_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_CLR_OFFSET, \
+		    HDMIRX_FRL_CTRL_IE_MASK)
+#define xhdmirx_frlintr_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_SET_OFFSET, \
+		    HDMIRX_FRL_CTRL_IE_MASK)
+#define xhdmirx_frl_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_SET_OFFSET, \
+		    HDMIRX_FRL_CTRL_RSTN_MASK)
+#define xhdmirx_frl_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_CLR_OFFSET, \
+		    HDMIRX_FRL_CTRL_RSTN_MASK)
+
+#define xhdmirx_setfrl_vclkvckeratio(xhdmi, val) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_VCLK_VCKE_RATIO_OFFSET, val)
+
+#define xhdmirx_skewlockevt_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_SET_OFFSET, \
+		    HDMIRX_FRL_CTRL_SKEW_EVT_EN_MASK)
+
+#define xhdmirx_skewlockevt_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_CLR_OFFSET, \
+		    HDMIRX_FRL_CTRL_SKEW_EVT_EN_MASK)
+
+#define xhdmirx_ddcscdc_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_SET_OFFSET, \
+		    HDMIRX_DDC_CTRL_SCDC_EN_MASK)
+
+#define xhdmirx_rxcore_vrst_assert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_INT_VRST_MASK)
+#define xhdmirx_rxcore_vrst_deassert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_INT_VRST_MASK)
+
+#define xhdmirx_rxcore_lrst_assert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_INT_LRST_MASK)
+#define xhdmirx_rxcore_lrst_deassert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_INT_LRST_MASK)
+
+#define xhdmirx_sysrst_assert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_EXT_SYSRST_MASK)
+#define xhdmirx_sysrst_deassert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_EXT_SYSRST_MASK)
+
+#define xhdmirx_ext_vrst_assert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_EXT_VRST_MASK)
+#define xhdmirx_ext_vrst_deassert(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_EXT_VRST_MASK)
+
+#define xhdmirx_link_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_LNK_EN_MASK)
+
+#define xhdmirx_link_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_LNK_EN_MASK)
+
+#define xhdmirx_video_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_VID_EN_MASK)
+
+#define xhdmirx_video_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_VID_EN_MASK)
+
+#define xhdmirx_axi4s_enable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET, \
+		    HDMIRX_PIO_OUT_AXIS_EN_MASK)
+
+#define xhdmirx_axi4s_disable(xhdmi) \
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET, \
+		    HDMIRX_PIO_OUT_AXIS_EN_MASK)
+
+#define xhdmirx_ddc_hdcp_set_data(xhdmi, value) \
+	xhdmi_write(xhdmirxss, \
+		    HDMIRX_DDC_HDCP_DATA_OFFSET, \
+		    value)
+
+#define xhdmirx_ddc_hdcp_set_address(xhdmi, value) \
+	xhdmi_write(xhdmi, \
+		    HDMIRX_DDC_HDCP_ADDRESS_OFFSET, value)
+
+#define xhdmirx_ddc_hdcp_get_data(xhdmi) \
+	xhdmi_read(xhdmi, \
+		   HDMIRX_DDC_HDCP_DATA_OFFSET)
+
+static void xhdmi_execfrlstate(struct xhdmirx_state *xhdmi);
+static void xhdmirx_set_hpd(struct xhdmirx_state *xhdmi, int enable);
+
+static inline int xhdmirxss_hdcp1x_keymgmt_reset(struct xhdmirx_state *state)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_CTRL, &data))
+		return -EIO;
+
+	data |= XHDCP1X_KEYMGMT_REG_CTRL_RST_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base,
+			       XHDCP1X_KEYMGMT_REG_CTRL, XHDCP1X_KEYMGMT_REG_CTRL_RST_MASK,
+			       data))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_CTRL, &data))
+		return -EIO;
+
+	data &= ~XHDCP1X_KEYMGMT_REG_CTRL_RST_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base, XHDCP1X_KEYMGMT_REG_CTRL,
+			       XHDCP1X_KEYMGMT_REG_CTRL_RST_MASK, data))
+		return -EIO;
+
+	return 0;
+}
+
+static inline int xhdmirxss_hdcp1x_keymgmt_enable(struct xhdmirx_state *state)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_CTRL, &data))
+		return -EIO;
+
+	data |= XHDCP1X_KEYMGMT_REG_CTRL_ENABLE_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base,
+			       XHDCP1X_KEYMGMT_REG_CTRL, XHDCP1X_KEYMGMT_REG_CTRL_ENABLE_MASK,
+			       data))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TBL_CTRL, &data))
+		return -EIO;
+
+	data |= XHDCP1X_KEYMGMT_REG_TBL_CTRL_EN_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base, XHDCP1X_KEYMGMT_REG_TBL_CTRL,
+			       XHDCP1X_KEYMGMT_REG_TBL_CTRL_EN_MASK, data))
+		return -EIO;
+
+	return 0;
+}
+
+static inline int xhdmirxss_hdcp1x_keymgmt_disable(struct xhdmirx_state *state)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_CTRL, &data))
+		return -EIO;
+
+	data &= XHDCP1X_KEYMGMT_REG_CTRL_DISABLE_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base, XHDCP1X_KEYMGMT_REG_CTRL,
+			       XHDCP1X_KEYMGMT_REG_CTRL_DISABLE_MASK, data))
+		return -EIO;
+
+	return 0;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_is_table_config_done(struct xhdmirx_state *state)
+{
+	int retry = XHDCP1X_KEYMGMT_REG_TBL_STATUS_RETRY;
+	u32 data;
+
+	while (retry) {
+		if (regmap_read(state->hdcp1x_keymgmt_base,
+				XHDCP1X_KEYMGMT_REG_TBL_STATUS, &data))
+			return 0;
+		if (!(data & XHDCP1X_KEYMGMT_REG_TBL_STATUS_DONE_MASK))
+			break;
+		retry--;
+
+		/* Not a specification recommendation, 10us delay is added
+		 * to avoid any of processor specific introduced delays.
+		 */
+		usleep_range(USLEEP_MIN_DELAY, USLEEP_MAX_DELAY);
+	}
+
+	return retry;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_table_read(struct xhdmirx_state *state,
+					       u8 table_id, u8 row_id, u64 *read_val)
+{
+	u64 temp;
+	u32 addr, data;
+
+	addr = row_id | (table_id << BITS_PER_BYTE);
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TBL_CTRL, &data))
+		return -EIO;
+
+	data &= ~XHDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK;
+	data |= XHDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base,
+			       XHDCP1X_KEYMGMT_REG_TBL_CTRL,
+			       XHDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK, data))
+		return -EIO;
+
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 XHDCP1X_KEYMGMT_REG_TBL_ADDR, addr))
+		return -EIO;
+
+	if (!xhdmirxss_hdcp1x_keymgmt_is_table_config_done(state))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TBL_DAT_H, &data))
+		return -EIO;
+
+	temp = (data << BITS_PER_BYTE) * sizeof(u32);
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TBL_DAT_L, &data))
+		return -EIO;
+
+	*read_val = temp | data;
+
+	return 0;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_table_write(struct xhdmirx_state *state,
+						u8 table_id, u8 row_id, u64 write_val)
+{
+	u32 addr, data;
+
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 XHDCP1X_KEYMGMT_REG_TBL_DAT_L,
+			 lower_32_bits(write_val)))
+		return -EIO;
+
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 XHDCP1X_KEYMGMT_REG_TBL_DAT_H,
+			 upper_32_bits(write_val)))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TBL_CTRL, &data))
+		return -EIO;
+
+	data &= ~XHDCP1X_KEYMGMT_REG_TBL_CTRL_RD_MASK;
+	data |= XHDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK;
+	if (regmap_update_bits(state->hdcp1x_keymgmt_base, XHDCP1X_KEYMGMT_REG_TBL_CTRL,
+			       XHDCP1X_KEYMGMT_REG_TBL_CTRL_WR_MASK, data))
+		return -EIO;
+
+	addr = (table_id << BITS_PER_BYTE) | row_id;
+	if (regmap_write(state->hdcp1x_keymgmt_base,
+			 XHDCP1X_KEYMGMT_REG_TBL_ADDR, addr))
+		return -EIO;
+
+	if (!xhdmirxss_hdcp1x_keymgmt_is_table_config_done(state))
+		return -EIO;
+
+	return 0;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_get_num_of_tables_rows(struct xhdmirx_state *state,
+							   u8 *num_tables,
+							   u8 *num_rows_per_table)
+{
+	u32 data;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TYPE, &data))
+		return -EIO;
+
+	if (data) {
+		*num_tables = (data >> 8) & 0xFF;
+		*num_rows_per_table = data & 0xFF;
+	} else {
+		*num_tables = XHDCP1X_KEYMGMT_MAX_TBLS;
+		*num_rows_per_table = XHDCP1X_KEYMGMT_MAX_ROWS_PER_TBL;
+	}
+
+	return 0;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_init_tables(struct xhdmirx_state *state)
+{
+	int ret = 0;
+	u8 num_tables, num_rows_per_table, table_id, row_id;
+
+	ret = xhdmirxss_hdcp1x_keymgmt_get_num_of_tables_rows(state, &num_tables,
+							      &num_rows_per_table);
+	if (ret) {
+		dev_err(state->dev, "Failed to get number of tables\n");
+		return ret;
+	}
+
+	for (table_id = 0; table_id < num_tables; table_id++)
+		for (row_id = 0; row_id < num_rows_per_table; row_id++)
+			if (xhdmirxss_hdcp1x_keymgmt_table_write(state, table_id,
+								 row_id, 0))
+				return -EIO;
+
+	return ret;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_load_keys(struct xhdmirx_state *state,
+					      union hdcp1x_key_table *key_table,
+					      u32 key_table_size)
+{
+	int ret = 0;
+	u8 row_id;
+
+	for (row_id = 0; row_id < (key_table_size / sizeof(u64)); row_id++)
+		if (xhdmirxss_hdcp1x_keymgmt_table_write(state, XHDCP1X_KEYMGMT_TBLID_0,
+							 row_id,
+							 key_table->data_u64[row_id]))
+			ret = -EIO;
+
+	return ret;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_verify_keys(struct xhdmirx_state *state,
+						union hdcp1x_key_table *key_table,
+						u32 key_table_size)
+{
+	u64 data;
+	int ret = 0;
+	u8 row_id;
+
+	for (row_id = 0; row_id < (key_table_size / sizeof(u64)); row_id++) {
+		data = 0;
+		xhdmirxss_hdcp1x_keymgmt_table_read(state, XHDCP1X_KEYMGMT_TBLID_0,
+						    row_id, &data);
+		if (data != key_table->data_u64[row_id]) {
+			dev_info(state->dev, "Key Verification Failed\n");
+			ret = -EIO;
+		}
+	}
+
+	dev_info(state->dev, "### Key Verification Done ###\n");
+
+	return ret;
+}
+
+static int xhdmirxss_hdcp1x_keymgmt_set_key(struct xhdmirx_state *state)
+{
+	union hdcp1x_key_table key_table;
+	int ret;
+	u32 version, type;
+	u8 index;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_VERSION, &version))
+		return -EIO;
+
+	if (regmap_read(state->hdcp1x_keymgmt_base,
+			XHDCP1X_KEYMGMT_REG_TYPE, &type))
+		return -EIO;
+
+	if (!version && !type) {
+		dev_err(state->dev, "HDCP1X keymgmt core is not present\n");
+		return -ENODEV;
+	}
+
+	ret = xhdmirxss_hdcp1x_keymgmt_reset(state);
+	if (ret) {
+		dev_err(state->dev, "Failed to reset HDCP1X keymgmt core\n");
+		return ret;
+	}
+
+	ret = xhdmirxss_hdcp1x_keymgmt_init_tables(state);
+	if (ret) {
+		dev_err(state->dev, "Failed to initialize HDCP1X keymgmt table ID's\n");
+		goto error;
+	}
+
+	ret = xhdmirxss_hdcp1x_keymgmt_disable(state);
+	if (ret) {
+		dev_err(state->dev, "Failed to disable HDCP1X keymgmt IP core\n");
+		goto error;
+	}
+
+	memcpy(key_table.data_u8, state->hdcp1x_key, XHDCP1X_KEYS_SIZE);
+
+	/* adjust the endian-ness to host order */
+	for (index = 0; index < XHDCP1X_KEYS_SIZE / sizeof(u64); index++)
+		key_table.data_u64[index] = be64_to_cpu(key_table.data_u64[index]);
+
+	ret = xhdmirxss_hdcp1x_keymgmt_load_keys(state, &key_table,
+						 XHDCP1X_KEYS_SIZE);
+	if (ret) {
+		dev_err(state->dev, "Failed to Load HDCP1X keys\n");
+		goto error;
+	}
+
+	ret = xhdmirxss_hdcp1x_keymgmt_verify_keys(state, &key_table,
+						   XHDCP1X_KEYS_SIZE);
+	if (ret) {
+		dev_err(state->dev, "Failed to Verify HDCP1X keys\n");
+		goto error;
+	}
+
+	ret = xhdmirxss_hdcp1x_keymgmt_enable(state);
+	if (ret) {
+		dev_err(state->dev, "Failed to enable HDCP1X keymanagement IP\n");
+		goto error;
+	}
+
+	return ret;
+
+error:
+	ret = xhdmirxss_hdcp1x_keymgmt_reset(state);
+	if (ret)
+		dev_err(state->dev, "Failed to reset HDCP1X keymgmt core\n");
+
+	return -EIO;
+}
+
+static int xhdmirxss_hdcp1x_key_write(struct xhdmirx_state *xhdmirxss,
+				      struct xhdmirxss_hdcp1x_keys_ioctl *hdcp_keys)
+{
+	int ret;
+
+	if (hdcp_keys->size != XHDCP1X_KEYS_SIZE)
+		return -EINVAL;
+
+	if (copy_from_user(xhdmirxss->hdcp1x_key,
+			   (const void __user *)hdcp_keys->keys,
+			   hdcp_keys->size))
+		return -EFAULT;
+
+	ret = xhdmirxss_hdcp1x_keymgmt_set_key(xhdmirxss);
+	if (ret < 0) {
+		dev_err(xhdmirxss->dev, " ERROR while loading keys\n");
+		return ret;
+	}
+
+	xhdmirxss->hdcp1x_key_available = true;
+	xhdcp1x_rx_set_keyselect(xhdmirxss->hdcp1x, 0);
+	xhdcp1x_rx_load_bksv(xhdmirxss->hdcp1x);
+	xhdcp1x_rx_enable(xhdmirxss->hdcp1x, XHDMI_MAX_LANES);
+	xhdmirx_set_hpd(xhdmirxss, 0);
+	/*
+	 * Wait a minimum time to toggle hot plug detect line to indicate to the
+	 * HDMI Tx about the change in HDMI RX.
+	 */
+	msleep(XHDMIRX_HPD_ENABLE_DELAY_MS);
+	xhdmirx_set_hpd(xhdmirxss, 1);
+
+	return ret;
+}
+
+static inline struct xhdmirx_state *to_xhdmirxssstate(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct xhdmirx_state, sd);
+}
+
+static long xhdmirxss_ioctl(struct v4l2_subdev *sd, u32 cmd, void *arg)
+{
+	struct xhdmirx_state *xhdmirxss = to_xhdmirxssstate(sd);
+
+	if (!xhdmirxss->hdcp_enable) {
+		dev_err(xhdmirxss->dev, "HDCP is not enabled in the system");
+		return -ENODEV;
+	}
+
+	if (xhdmirxss->hdcp1x_key_available) {
+		dev_info(xhdmirxss->dev, "HDCP1X keys are already loaded");
+		return -EPERM;
+	}
+
+	if (cmd == XILINX_HDMIRXSS_HDCP_KEY_WRITE)
+		return xhdmirxss_hdcp1x_key_write(xhdmirxss, arg);
+
+	return -EINVAL;
+}
+
+static irqreturn_t xhdmirxss_hdcp1x_irq_handler(int irq, void *dev_id)
+{
+	struct xhdmirx_state *state = (struct xhdmirx_state *)dev_id;
+
+	xhdcp1x_rx_handle_intr(state->hdcp1x);
+
+	return IRQ_HANDLED;
+}
+
+/* HDCP related code ends here */
+
+static inline u32 xhdmi_read(struct xhdmirx_state *xhdmi, u32 addr)
+{
+	return ioread32(xhdmi->regs + addr);
+}
+
+static inline void xhdmi_write(struct xhdmirx_state *xhdmi,
+			       u32 addr, u32 val)
+{
+	iowrite32(val, xhdmi->regs + addr);
+}
+
+static inline struct xhdmirx_state *to_xhdmirx_state(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xhdmirx_state, sd);
+}
+
+static inline u32 xhdmi_getfrlactivepixratio(struct xhdmirx_state *xhdmi)
+{
+	return xhdmi_read(xhdmi, HDMIRX_FRL_RATIO_ACT_OFFSET);
+}
+
+static inline u32 xhdmi_getfrltotalpixratio(struct xhdmirx_state *xhdmi)
+{
+	return xhdmi_read(xhdmi, HDMIRX_FRL_RATIO_TOT_OFFSET);
+}
+
+static u32 xhdmi_getpatternsmatchstatus(struct xhdmirx_state *xhdmi)
+{
+	u32 data = xhdmi_read(xhdmi, HDMIRX_FRL_STA_OFFSET);
+
+	return FIELD_GET(HDMIRX_FRL_STA_FLT_PM_ALLL_MASK, data);
+}
+
+/**
+ * xhdmirx_vtd_settimebase - Set the Video Timing Detector
+ *
+ * @xhdmi: pointer to driver state
+ * @count: count value to set the timer to.
+ */
+static inline void xhdmirx_vtd_settimebase(struct xhdmirx_state *xhdmi, u32 count)
+{
+	u32 val = xhdmi_read(xhdmi, HDMIRX_VTD_CTRL_OFFSET);
+
+	val &= ~HDMIRX_VTD_CTRL_TIMERBASE_MASK;
+	val |= FIELD_PREP(HDMIRX_VTD_CTRL_TIMERBASE_MASK, count);
+	xhdmi_write(xhdmi, HDMIRX_VTD_CTRL_OFFSET, val);
+}
+
+static u32 xhdmi_frlddcreadfield(struct xhdmirx_state *xhdmi, enum xhdmi_frlscdcfieldtype field)
+{
+	u32 data = 0xFFFFFFFF;
+	int i;
+
+	for (i = 0; i < MAX_FRL_RETRY; i++) {
+		data = xhdmi_read(xhdmi, HDMIRX_FRL_SCDC_OFFSET);
+		if (data & HDMIRX_FRL_SCDC_RDY_MASK)
+			break;
+	}
+
+	if (!(data & HDMIRX_FRL_SCDC_RDY_MASK)) {
+		dev_dbg_ratelimited(xhdmi->dev, "%s - scdc is not ready!", __func__);
+		return data;
+	}
+
+	data = HDMIRX_FRL_SCDC_ADDR_MASK & frlscdcfield[field].offset;
+	data |=	HDMIRX_FRL_SCDC_RD_MASK;
+
+	xhdmi_write(xhdmi, HDMIRX_FRL_SCDC_OFFSET, data);
+
+	for (i = 0; i < MAX_FRL_RETRY; i++) {
+		data = xhdmi_read(xhdmi, HDMIRX_FRL_SCDC_OFFSET);
+		if (data & HDMIRX_FRL_SCDC_RDY_MASK) {
+			data = data >> HDMIRX_FRL_SCDC_DAT_SHIFT;
+			return ((data >> frlscdcfield[field].shift) &
+				frlscdcfield[field].mask);
+		}
+	}
+
+	dev_dbg_ratelimited(xhdmi->dev, "%s - failed!", __func__);
+	return 0xFFFFFFFF;
+}
+
+static int xhdmi_frlddcwritefield(struct xhdmirx_state *xhdmi,
+				  enum xhdmi_frlscdcfieldtype field,
+				  u8 value)
+{
+	/* 256 byte FIFO but doubling to 512 tries for safety */
+	u32 data = 0, retrycount = 2 * MAX_FRL_RETRY;
+
+	if (frlscdcfield[field].mask != 0xFF)
+		data = xhdmi_frlddcreadfield(xhdmi, field);
+
+	if (data == 0xFFFFFFFF)
+		return -EINVAL;
+
+	do {
+		data = xhdmi_read(xhdmi, HDMIRX_FRL_SCDC_OFFSET);
+	} while (!(data & HDMIRX_FRL_SCDC_RDY_MASK) && retrycount--);
+
+	if (!retrycount)
+		return -EBUSY;
+
+	if (frlscdcfield[field].mask != 0xFF) {
+		data &= ~((frlscdcfield[field].mask <<
+			   frlscdcfield[field].shift) <<
+			  HDMIRX_FRL_SCDC_DAT_SHIFT);
+	} else {
+		data &= ~((u32)(HDMIRX_FRL_SCDC_DAT_MASK <<
+				HDMIRX_FRL_SCDC_DAT_SHIFT));
+	}
+
+	data &= ~((u32)HDMIRX_FRL_SCDC_ADDR_MASK);
+
+	data |= (((value & frlscdcfield[field].mask) <<
+		frlscdcfield[field].shift) <<
+		HDMIRX_FRL_SCDC_DAT_SHIFT) |
+		(frlscdcfield[field].offset & HDMIRX_FRL_SCDC_ADDR_MASK) |
+		HDMIRX_FRL_SCDC_WR_MASK;
+
+	xhdmi_write(xhdmi, HDMIRX_FRL_SCDC_OFFSET, data);
+
+	data = xhdmi_frlddcreadfield(xhdmi, field);
+	if (data != value) {
+		dev_err_ratelimited(xhdmi->dev, "field %u to write %u != written value %u",
+				    field, value, data);
+	}
+
+	return 0;
+}
+
+static inline void xhdmirx_scrambler_enable(struct xhdmirx_state *xhdmi)
+{
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET,
+		    HDMIRX_PIO_OUT_SCRM_MASK);
+	xhdmi->stream.isscrambled = true;
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_SCRAMBLER_STAT, 1);
+}
+
+static inline void xhdmirx_scrambler_disable(struct xhdmirx_state *xhdmi)
+{
+	xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET,
+		    HDMIRX_PIO_OUT_SCRM_MASK);
+	xhdmi->stream.isscrambled = false;
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_SCRAMBLER_STAT, 0);
+}
+
+static inline void xhdmirx_ddcscdc_clear(struct xhdmirx_state *xhdmi)
+{
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_SET_OFFSET,
+		    HDMIRX_DDC_CTRL_SCDC_CLR_MASK);
+	/* 50 ms sleep as this will be needed by IP core to clear FIFO */
+	usleep_range(50, 100);
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_CLR_OFFSET,
+		    HDMIRX_DDC_CTRL_SCDC_CLR_MASK);
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FLT_READY, 1);
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_SINK_VER, 1);
+}
+
+/**
+ * xhdmirx_disable_allintr - Disable all the interrupt sources
+ *
+ * @xhdmi: pointer to driver state
+ */
+static void xhdmirx_disable_allintr(struct xhdmirx_state *xhdmi)
+{
+	xhdmirx_piointr_disable(xhdmi);
+	xhdmirx_vtdintr_disable(xhdmi);
+	xhdmirx_ddcintr_disable(xhdmi);
+	xhdmirx_tmr1intr_disable(xhdmi);
+	xhdmirx_tmr2intr_disable(xhdmi);
+	xhdmirx_tmr3intr_disable(xhdmi);
+	xhdmirx_tmr4intr_disable(xhdmi);
+	xhdmirx_auxintr_disable(xhdmi);
+	xhdmirx_audintr_disable(xhdmi);
+	xhdmirx_frlintr_disable(xhdmi);
+	xhdmirx_lnkstaintr_disable(xhdmi);
+}
+
+/**
+ * xhdmirx_enable_allintr - Enable all the interrupt sources
+ *
+ * @xhdmi: pointer to driver state
+ */
+static void xhdmirx_enable_allintr(struct xhdmirx_state *xhdmi)
+{
+	xhdmirx_piointr_enable(xhdmi);
+	xhdmirx_vtdintr_enable(xhdmi);
+	xhdmirx_ddcintr_enable(xhdmi);
+	xhdmirx_tmr1intr_enable(xhdmi);
+	xhdmirx_tmr2intr_enable(xhdmi);
+	xhdmirx_tmr3intr_enable(xhdmi);
+	xhdmirx_tmr4intr_enable(xhdmi);
+	xhdmirx_auxintr_enable(xhdmi);
+	xhdmirx_frlintr_enable(xhdmi);
+	xhdmirx_lnkstaintr_enable(xhdmi);
+}
+
+/**
+ * xhdmirx1_bridgeyuv420 - Enable/disable YUV 420 in bridge
+ *
+ * @xhdmi: pointer to driver state
+ * @flag: Flag to set or clear the bit
+ */
+static void xhdmirx1_bridgeyuv420(struct xhdmirx_state *xhdmi, bool flag)
+{
+	if (flag)
+		xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET,
+			    HDMIRX_PIO_OUT_BRIDGE_YUV420_MASK);
+	else
+		xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET,
+			    HDMIRX_PIO_OUT_BRIDGE_YUV420_MASK);
+}
+
+/**
+ * xhdmirx1_bridgepixeldrop - Enable/Disable pixel drop in bridge
+ *
+ * @xhdmi: pointer to driver state
+ * @flag: Flag to set or clear
+ */
+static void xhdmirx1_bridgepixeldrop(struct xhdmirx_state *xhdmi, bool flag)
+{
+	if (flag)
+		xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET,
+			    HDMIRX_PIO_OUT_BRIDGE_PIXEL_MASK);
+	else
+		xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET,
+			    HDMIRX_PIO_OUT_BRIDGE_PIXEL_MASK);
+}
+
+/**
+ * xhdmirx1_start - Start the HDMI Rx by enabling the PIO
+ *
+ * @xhdmi: pointer to driver state
+ */
+static void xhdmirx1_start(struct xhdmirx_state *xhdmi)
+{
+	xhdmirx_pio_enable(xhdmi);
+	xhdmirx_piointr_enable(xhdmi);
+}
+
+/**
+ * xhdmirx1_stop - Stop the HDMI Rx by disabling the PIO
+ *
+ * @xhdmi: pointer to driver state
+ */
+static void xhdmirx1_stop(struct xhdmirx_state *xhdmi)
+{
+	xhdmirx_pio_disable(xhdmi);
+	xhdmirx_piointr_disable(xhdmi);
+}
+
+static void xhdmirx1_clearlinkstatus(struct xhdmirx_state *xhdmi)
+{
+	xhdmi_write(xhdmi, HDMIRX_LNKSTA_CTRL_SET_OFFSET, HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK);
+	xhdmi_write(xhdmi, HDMIRX_LNKSTA_CTRL_CLR_OFFSET, HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK);
+}
+
+/**
+ * xhdmirx_set_hpd - Toggle hot plug detect line
+ * @xhdmi: pointer to driver state
+ * @enable: Flag to assert or deassert the HPD line
+ *
+ * This function is used to toggle hot plug detect line to indicate to the
+ * HDMI Tx about change in HDMI Rx.
+ */
+static void xhdmirx_set_hpd(struct xhdmirx_state *xhdmi, int enable)
+{
+	if (enable)
+		xhdmi_write(xhdmi, HDMIRX_PIO_OUT_SET_OFFSET,
+			    HDMIRX_PIO_OUT_HPD_MASK);
+	else
+		xhdmi_write(xhdmi, HDMIRX_PIO_OUT_CLR_OFFSET,
+			    HDMIRX_PIO_OUT_HPD_MASK);
+}
+
+static inline bool xhdmirx1_isstreamconnected(struct xhdmirx_state *xhdmi)
+{
+	/* return the stream cable connected */
+	return xhdmi->stream.cable_connected;
+}
+
+/**
+ * xhdmirx1_gettmdsclkratio - Get the TMDS clock ratio
+ * @xhdmi: pointer to the driver state
+ *
+ * Return: TMDS clock ratio 0 or 1
+ */
+static u32 xhdmirx1_gettmdsclkratio(struct xhdmirx_state *xhdmi)
+{
+	u32 val;
+
+	val = xhdmi_read(xhdmi, HDMIRX_PIO_IN_OFFSET);
+	val = FIELD_GET(HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK, val);
+
+	dev_dbg(xhdmi->dev, "Get TMDS Clk Ratio = %u\n", val);
+	return val;
+}
+
+/**
+ * xhdmirx1_getavi_vic - Get the HDMI VIC id
+ * @xhdmi: pointer to driver state
+ *
+ * Return: Returns HDMI VIC id
+ */
+static u8 xhdmirx1_getavi_vic(struct xhdmirx_state *xhdmi)
+{
+	u32 val;
+
+	val = xhdmi_read(xhdmi, HDMIRX_AUX_STA_OFFSET);
+	val = FIELD_GET(HDMIRX_AUX_STA_AVI_VIC_MASK, val);
+
+	dev_dbg_ratelimited(xhdmi->dev, "Get AVI VIC = %u\n", val);
+	return (u8)val;
+}
+
+/**
+ * xhdmirx1_getavi_colorspace - Get the colorspace of the incoming stream
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Returns: Colorspace of stream
+ */
+static enum xcolorspace xhdmirx1_getavi_colorspace(struct xhdmirx_state *xhdmi)
+{
+	u32 val;
+	enum xcolorspace cs;
+
+	dev_dbg_ratelimited(xhdmi->dev, "Get avi colorspace ");
+	val = xhdmi_read(xhdmi, HDMIRX_AUX_STA_OFFSET);
+	switch (FIELD_GET(HDMIRX_AUX_STA_AVI_CS_MASK, val)) {
+	case 1:
+		cs = XCS_YUV422;
+		dev_dbg_ratelimited(xhdmi->dev, "YUV 422\n");
+		break;
+	case 2:
+		cs = XCS_YUV444;
+		dev_dbg_ratelimited(xhdmi->dev, "YUV 444\n");
+		break;
+	case 3:
+		cs = XCS_YUV420;
+		dev_dbg_ratelimited(xhdmi->dev, "YUV 420\n");
+		break;
+	default:
+		cs = XCS_RGB;
+		dev_dbg_ratelimited(xhdmi->dev, "RGB\n");
+		break;
+	}
+
+	return cs;
+}
+
+/**
+ * xhdmirx1_getgcp_colordepth - Get the color depth of the stream
+ *
+ * @xhdmi: pointer to the driver state
+ *
+ * Returns: colordepth or bits per component of incoming stream
+ */
+static enum xcolordepth xhdmirx1_getgcp_colordepth(struct xhdmirx_state *xhdmi)
+{
+	u32 val;
+	enum xcolordepth ret;
+
+	val = xhdmi_read(xhdmi, HDMIRX_AUX_STA_OFFSET);
+	switch (FIELD_GET(HDMIRX_AUX_STA_GCP_CD_MASK, val)) {
+	case 1:
+		ret = XCD_10;
+		break;
+	case 2:
+		ret = XCD_12;
+		break;
+	case 3:
+		ret = XCD_16;
+		break;
+	default:
+		ret = XCD_8;
+		break;
+	}
+
+	dev_dbg_ratelimited(xhdmi->dev, "get GCP colordepth %u\n", ret);
+
+	return ret;
+}
+
+/**
+ * xhdmirx1_get_video_properties - Get the incoming video stream properties
+ *
+ * @xhdmi: pointer to the driver state
+ *
+ * This function populates the video structure with color space and depth.
+ * If getvidproptries > MAX_VID_PROP_TRIES means incoming stream is DVI
+ *
+ * Returns: 0 on success or -1 on fail
+ */
+static int xhdmirx1_get_video_properties(struct xhdmirx_state *xhdmi)
+{
+	u32 status;
+
+	status = xhdmi_read(xhdmi, HDMIRX_AUX_STA_OFFSET);
+
+	if (status & HDMIRX_AUX_STA_AVI_MASK) {
+		xhdmi->stream.video.colorspace = xhdmirx1_getavi_colorspace(xhdmi);
+		xhdmi->stream.vic = xhdmirx1_getavi_vic(xhdmi);
+
+		if (xhdmi->stream.video.colorspace == XCS_YUV422)
+			xhdmi->stream.video.colordepth = XCD_12;
+		else
+			xhdmi->stream.video.colordepth =
+				xhdmirx1_getgcp_colordepth(xhdmi);
+		return 0;
+	}
+
+	if (xhdmi->stream.getvidproptries > MAX_VID_PROP_TRIES) {
+		xhdmi->stream.video.colorspace = XCS_RGB;
+		xhdmi->stream.vic = 0;
+		xhdmi->stream.video.colordepth = XCD_8;
+		return 0;
+	}
+
+	xhdmi->stream.getvidproptries++;
+	return -1;
+}
+
+/**
+ * xhdmirx1_get_vid_timing - Get the video timings of incoming stream
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function gets the timing information from the IP and checks it
+ * against the older value. If mismatch, it updates the video timing
+ * structure in the driver state.
+ *
+ * Returns: 0 on success or -1 on fail
+ */
+static int xhdmirx1_get_vid_timing(struct xhdmirx_state *xhdmi)
+{
+	u32 data;
+	u16 hact, hfp, hsw, hbp, htot;
+	u16 vact, vfp[MAX_FIELDS], vsw[MAX_FIELDS], vbp[MAX_FIELDS];
+	u16 vtot[MAX_FIELDS];
+	u8 match, yuv420_correction, isinterlaced;
+
+	if (xhdmi->stream.video.colorspace == XCS_YUV420)
+		yuv420_correction = 2;
+	else
+		yuv420_correction = 1;
+
+	htot = xhdmi_read(xhdmi, HDMIRX_VTD_TOT_PIX_OFFSET) * yuv420_correction;
+	hact = xhdmi_read(xhdmi, HDMIRX_VTD_ACT_PIX_OFFSET) * yuv420_correction;
+	hsw = xhdmi_read(xhdmi, HDMIRX_VTD_HSW_OFFSET) * yuv420_correction;
+	hfp = xhdmi_read(xhdmi, HDMIRX_VTD_HFP_OFFSET) * yuv420_correction;
+	hbp = xhdmi_read(xhdmi, HDMIRX_VTD_HBP_OFFSET) * yuv420_correction;
+
+	data = xhdmi_read(xhdmi, HDMIRX_VTD_TOT_LIN_OFFSET);
+	vtot[0] = FIELD_GET(HDMIRX_VTD_VF0_MASK, data);
+	vtot[1] = FIELD_GET(HDMIRX_VTD_VF1_MASK, data);
+
+	vact = xhdmi_read(xhdmi, HDMIRX_VTD_ACT_LIN_OFFSET);
+
+	data = xhdmi_read(xhdmi, HDMIRX_VTD_VFP_OFFSET);
+	vfp[0] = FIELD_GET(HDMIRX_VTD_VF0_MASK, data);
+	vfp[1] = FIELD_GET(HDMIRX_VTD_VF1_MASK, data);
+
+	data = xhdmi_read(xhdmi, HDMIRX_VTD_VSW_OFFSET);
+	vsw[0] = FIELD_GET(HDMIRX_VTD_VF0_MASK, data);
+	vsw[1] = FIELD_GET(HDMIRX_VTD_VF1_MASK, data);
+
+	data = xhdmi_read(xhdmi, HDMIRX_VTD_VBP_OFFSET);
+	vbp[0] = FIELD_GET(HDMIRX_VTD_VF0_MASK, data);
+	vbp[1] = FIELD_GET(HDMIRX_VTD_VF1_MASK, data);
+
+	data = xhdmi_read(xhdmi, HDMIRX_VTD_STA_OFFSET);
+	if (data & HDMIRX_VTD_STA_FMT_MASK)
+		isinterlaced = 1;
+	else
+		isinterlaced = 0;
+
+	match = 1;
+
+	if (!hact || !hfp || !hsw || !hbp || !htot || !vact ||
+	    !vtot[0] || !vfp[0] || !vbp[0] || !vsw[0])
+		match = 0;
+
+	if (isinterlaced && (!vfp[1] || !vsw[1] || !vbp[1] || !vtot[1]))
+		match = 0;
+
+	if (hact != xhdmi->stream.video.timing.hact ||
+	    htot != xhdmi->stream.video.timing.htot ||
+	    hfp != xhdmi->stream.video.timing.hfp ||
+	    hbp != xhdmi->stream.video.timing.hbp ||
+	    hsw != xhdmi->stream.video.timing.hsw ||
+	    vact != xhdmi->stream.video.timing.vact ||
+	    vtot[0] != xhdmi->stream.video.timing.vtot[0] ||
+	    vtot[1] != xhdmi->stream.video.timing.vtot[1] ||
+	    vfp[0] != xhdmi->stream.video.timing.vfp[0] ||
+	    vfp[1] != xhdmi->stream.video.timing.vfp[1] ||
+	    vbp[0] != xhdmi->stream.video.timing.vbp[0] ||
+	    vbp[1] != xhdmi->stream.video.timing.vbp[1] ||
+	    vsw[0] != xhdmi->stream.video.timing.vsw[0] ||
+	    vsw[1] != xhdmi->stream.video.timing.vsw[1])
+		match = 0;
+
+	if (vtot[0] != (vact + vfp[0] + vsw[0] + vbp[0]))
+		match = 0;
+
+	if (isinterlaced) {
+		if (vtot[1] != (vact + vfp[1] + vsw[1] + vbp[1]))
+			match = 0;
+	} else {
+		/* if field 1 is populated for progessive video */
+		if (vfp[1] | vbp[1] | vsw[1])
+			match = 0;
+	}
+
+	xhdmi->stream.video.timing.hact = hact;
+	xhdmi->stream.video.timing.htot = htot;
+	xhdmi->stream.video.timing.hfp = hfp;
+	xhdmi->stream.video.timing.hsw = hsw;
+	xhdmi->stream.video.timing.hbp = hbp;
+
+	xhdmi->stream.video.timing.vtot[0] = vtot[0];
+	xhdmi->stream.video.timing.vtot[1] = vtot[1];
+
+	xhdmi->stream.video.timing.vact = vact;
+	xhdmi->stream.video.timing.vfp[0] = vfp[0];
+	xhdmi->stream.video.timing.vfp[1] = vfp[1];
+	xhdmi->stream.video.timing.vsw[0] = vsw[0];
+	xhdmi->stream.video.timing.vsw[1] = vsw[1];
+	xhdmi->stream.video.timing.vbp[0] = vbp[0];
+	xhdmi->stream.video.timing.vbp[1] = vbp[1];
+
+	if (match) {
+		data = xhdmi_read(xhdmi, HDMIRX_VTD_STA_OFFSET);
+
+		if (data & HDMIRX_VTD_STA_FMT_MASK)
+			xhdmi->stream.video.isinterlaced = true;
+		else
+			xhdmi->stream.video.isinterlaced = false;
+
+		if (data & HDMIRX_VTD_STA_VS_POL_MASK)
+			xhdmi->stream.video.timing.vsyncpol = 1;
+		else
+			xhdmi->stream.video.timing.vsyncpol = 0;
+
+		if (data & HDMIRX_VTD_STA_HS_POL_MASK)
+			xhdmi->stream.video.timing.hsyncpol = 1;
+		else
+			xhdmi->stream.video.timing.hsyncpol = 0;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+/**
+ * xhdmirx1_setpixelclk - Calculate and save the pixel clock
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function calculates the pixel clock based on incoming stream
+ * reference clock and bits per component / color depth
+ */
+static void xhdmirx1_setpixelclk(struct xhdmirx_state *xhdmi)
+{
+	switch (xhdmi->stream.video.colordepth) {
+	case XCD_10:
+		xhdmi->stream.pixelclk = (xhdmi->stream.refclk << 2) / 5;
+		break;
+	case XCD_12:
+		xhdmi->stream.pixelclk = (xhdmi->stream.refclk << 1) / 3;
+		break;
+	case XCD_16:
+		xhdmi->stream.pixelclk = xhdmi->stream.refclk >> 1;
+		break;
+	default:
+		xhdmi->stream.pixelclk = xhdmi->stream.refclk;
+		break;
+	}
+
+	if (xhdmi->stream.video.colorspace == XCS_YUV422)
+		xhdmi->stream.pixelclk = xhdmi->stream.refclk;
+
+	dev_dbg(xhdmi->dev, "pixel clk = %u Hz ref clk = %u Hz\n",
+		xhdmi->stream.pixelclk, xhdmi->stream.refclk);
+}
+
+static int xhdmirx_phy_configure(struct xhdmirx_state *xhdmi,
+				 union phy_configure_opts *opts)
+{
+	int ret, i;
+
+	for (i = 0; i < XHDMI_MAX_LANES; i++) {
+		ret = phy_configure(xhdmi->phy[i], opts);
+		if (ret) {
+			dev_err(xhdmi->dev, "phy_configure error %d\n", ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static void phy_rxinit_cb(void *param)
+{
+	struct xhdmirx_state *xhdmi = (struct xhdmirx_state *)param;
+	union phy_configure_opts opts = {0};
+	u32 val;
+
+	/* Get TMDS clock ratio */
+	val = xhdmirx1_gettmdsclkratio(xhdmi);
+
+	opts.hdmi.tmdsclock_ratio_flag = 1;
+	opts.hdmi.tmdsclock_ratio = val;
+
+	/* set the TMDS clock ratio in phy */
+	xhdmirx_phy_configure(xhdmi, &opts);
+	dev_dbg(xhdmi->dev, "Phy RxInitCallback tmds clk ratio = %u\n", val);
+}
+
+static void phy_rxready_cb(void *param)
+{
+	struct xhdmirx_state *xhdmi = (struct xhdmirx_state *)param;
+	union phy_configure_opts opts = {0};
+	int ret;
+
+	opts.hdmi.rx_get_refclk = 1;
+	ret = xhdmirx_phy_configure(xhdmi, &opts);
+	if (ret) {
+		dev_err(xhdmi->dev, "Unable to get ref clk from phy %d\n", ret);
+		return;
+	}
+
+	xhdmi->stream.refclk = opts.hdmi.rx_refclk_hz;
+
+	/*
+	 * In case the TMDS Clock ratio is 1/40, the reference clock must be
+	 * compensated.
+	 */
+	if (xhdmirx1_gettmdsclkratio(xhdmi))
+		xhdmi->stream.refclk *= 4;
+
+	if (xhdmi->is_hdcp1x_enabled)
+		xhdcp1x_rx_disable(xhdmi->hdcp1x);
+
+	dev_dbg(xhdmi->dev, "Phy RxReadyCallback refclk = %u Hz\n", xhdmi->stream.refclk);
+}
+
+/**
+ * xhdmirx1_configbridgemode - Configure the bridge
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function configure the bridge for YUV420 and pixel drop
+ * based on whether the stream in interlaced, hdmi and colorspace is YUV420
+ */
+static void xhdmirx1_configbridgemode(struct xhdmirx_state *xhdmi)
+{
+	if (!xhdmi->stream.ishdmi && xhdmi->stream.video.isinterlaced) {
+		if (xhdmi->stream.video.timing.hact == 1440 &&
+		    (xhdmi->stream.video.timing.vact == 288 ||
+		     xhdmi->stream.video.timing.vact == 240)) {
+			xhdmirx1_bridgeyuv420(xhdmi, false);
+			xhdmirx1_bridgepixeldrop(xhdmi, true);
+		}
+	}
+
+	/* check aux info frame for pixel repetition and return */
+	if (xhdmi->stream.video.colorspace == XCS_YUV420) {
+		xhdmirx1_bridgepixeldrop(xhdmi, false);
+		xhdmirx1_bridgeyuv420(xhdmi, true);
+	} else {
+		/*
+		 * check if pixel repetition factor is 2
+		 * for ntsc pal support
+		 */
+		xhdmirx1_bridgeyuv420(xhdmi, false);
+		xhdmirx1_bridgepixeldrop(xhdmi, false);
+	}
+}
+
+/**
+ * xhdmirx1_get_mbusfmtcode - Update the media bus format
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function populates the media bus format in the mbus_fmt struct
+ * based on the colorspace and colordepth of the incoming stream.
+ */
+static void xhdmirx1_get_mbusfmtcode(struct xhdmirx_state *xhdmi)
+{
+	struct xvideostream *stream = &xhdmi->stream.video;
+
+	/* decode AVI Info frame and fill up above correctly */
+	switch (stream->colorspace) {
+	case XCS_YUV422:
+		switch (xhdmi->max_bpc) {
+		case XCD_8:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_UYVY8_1X16;
+			break;
+		case XCD_10:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_UYVY10_1X20;
+			break;
+		case XCD_12:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_UYVY12_1X24;
+			break;
+		case XCD_16:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_UYVY16_2X32;
+			break;
+		}
+		break;
+	case XCS_YUV444:
+		switch (xhdmi->max_bpc) {
+		case XCD_8:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_VUY8_1X24;
+			break;
+		case XCD_10:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_VUY10_1X30;
+			break;
+		case XCD_12:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_VUY12_1X36;
+			break;
+		case XCD_16:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_VUY16_1X48;
+			break;
+		}
+		break;
+	case XCS_YUV420:
+		switch (xhdmi->max_bpc) {
+		case XCD_8:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_VYYUYY8_1X24;
+			break;
+		case XCD_10:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_VYYUYY10_4X20;
+			break;
+		case XCD_12:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_UYYVYY12_4X24;
+			break;
+		case XCD_16:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_UYYVYY16_4X32;
+			break;
+		}
+		break;
+	case XCS_RGB:
+		switch (xhdmi->max_bpc) {
+		case XCD_8:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_RBG888_1X24;
+			break;
+		case XCD_10:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_RBG101010_1X30;
+			break;
+		case XCD_12:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_RBG121212_1X36;
+			break;
+		case XCD_16:
+			xhdmi->mbus_fmt.code = MEDIA_BUS_FMT_RBG161616_1X48;
+			break;
+		}
+		break;
+	}
+	dev_dbg_ratelimited(xhdmi->dev, "mbus_fmt code = 0x%08x\n",
+			    xhdmi->mbus_fmt.code);
+}
+
+/**
+ * rxstreamup - Update the dv timings and media bus format structs
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function is called when the stream is found to be up.
+ * This configures the bridge mode, media bus format struct, detected
+ * dv timings and generates source change event to user space.
+ */
+static void rxstreamup(struct xhdmirx_state *xhdmi)
+{
+	struct xvideostream *stream;
+
+	xhdmirx1_clearlinkstatus(xhdmi);
+	xhdmi->isstreamup = true;
+
+	xhdmirx1_configbridgemode(xhdmi);
+
+	/* enable clock forwarding */
+	stream = &xhdmi->stream.video;
+
+	/*
+	 * use v4l2_find_dv_timings_cea861_vic with avi info frame vic id
+	 * to get the std timings. For now we will get timing from IP.
+	 */
+	xhdmi->mbus_fmt.width = stream->timing.hact;
+	xhdmi->mbus_fmt.height = stream->timing.vact;
+
+	/*
+	 * For pixel repetition cases 1440x240@60,120,240 or
+	 * 1440x288@50,100,200, make width as half.
+	 */
+	if (stream->timing.hact == 1440 &&
+	    ((stream->timing.vact == 240 && (stream->framerate == 60 ||
+					     stream->framerate == 120 ||
+					     stream->framerate == 240)) ||
+	     (stream->timing.vact == 288 && (stream->framerate == 50 ||
+					     stream->framerate == 100 ||
+					     stream->framerate == 200))))
+		xhdmi->mbus_fmt.width /= 2;
+
+	if (stream->isinterlaced)
+		xhdmi->mbus_fmt.field = V4L2_FIELD_ALTERNATE;
+	else
+		xhdmi->mbus_fmt.field = V4L2_FIELD_NONE;
+
+	xhdmi->mbus_fmt.colorspace = V4L2_COLORSPACE_REC709;
+	xhdmi->mbus_fmt.ycbcr_enc = V4L2_YCBCR_ENC_709;
+	xhdmi->mbus_fmt.xfer_func = V4L2_XFER_FUNC_709;
+	xhdmi->mbus_fmt.quantization = V4L2_QUANTIZATION_DEFAULT;
+
+	xhdmirx1_get_mbusfmtcode(xhdmi);
+
+	xhdmi->dv_timings.type		= V4L2_DV_BT_656_1120;
+	xhdmi->dv_timings.bt.width	= stream->timing.hact;
+	xhdmi->dv_timings.bt.height	= stream->timing.vact;
+	xhdmi->dv_timings.bt.interlaced = !!stream->isinterlaced;
+	if (xhdmi->dv_timings.bt.interlaced)
+		xhdmi->dv_timings.bt.height *= 2;
+
+	xhdmi->dv_timings.bt.polarities = stream->timing.vsyncpol ?
+					  V4L2_DV_VSYNC_POS_POL : 0;
+	xhdmi->dv_timings.bt.polarities |= stream->timing.hsyncpol ?
+					   V4L2_DV_HSYNC_POS_POL : 0;
+	/* determine pixel clock */
+	xhdmi->dv_timings.bt.pixelclock = xhdmi->stream.pixelclk;
+
+	/*
+	 * Double pixel clock for YUV 420 TMDS / Tri-band packing
+	 * as per Sec 7.1 of HDMI 2.1 spec.
+	 */
+	if (xhdmi->stream.video.colorspace == XCS_YUV420)
+		xhdmi->dv_timings.bt.pixelclock *= 2;
+
+	if (stream->timing.hact == 1440 &&
+	    ((stream->timing.vact == 240 && (stream->framerate == 60 ||
+					     stream->framerate == 120 ||
+					     stream->framerate == 240)) ||
+	     (stream->timing.vact == 288 && (stream->framerate == 50 ||
+					     stream->framerate == 100 ||
+					     stream->framerate == 200)))) {
+		xhdmirx1_bridgeyuv420(xhdmi, false);
+		xhdmirx1_bridgepixeldrop(xhdmi, true);
+	}
+
+	xhdmi->dv_timings.bt.hfrontporch = stream->timing.hfp;
+	xhdmi->dv_timings.bt.hsync = stream->timing.hsw;
+	xhdmi->dv_timings.bt.hbackporch = stream->timing.hbp;
+	xhdmi->dv_timings.bt.vfrontporch = stream->timing.vfp[0];
+	xhdmi->dv_timings.bt.vsync = stream->timing.vsw[0];
+	xhdmi->dv_timings.bt.vbackporch = stream->timing.vbp[0];
+	xhdmi->dv_timings.bt.il_vfrontporch = stream->timing.vfp[1];
+	xhdmi->dv_timings.bt.il_vsync = stream->timing.vsw[1];
+	xhdmi->dv_timings.bt.il_vbackporch = stream->timing.vbp[1];
+	xhdmi->dv_timings.bt.standards = V4L2_DV_BT_STD_CEA861;
+	xhdmi->dv_timings.bt.flags = V4L2_DV_FL_IS_CE_VIDEO;
+
+	xhdmi->isstreamup = true;
+
+	v4l2_subdev_notify_event(&xhdmi->sd, &xhdmi_ev_fmt);
+
+	dev_dbg_ratelimited(xhdmi->dev, "mbus fmt width = %u height = %u code = 0x%08x\n",
+			    xhdmi->mbus_fmt.width, xhdmi->mbus_fmt.height, xhdmi->mbus_fmt.code);
+#ifdef DEBUG
+	v4l2_print_dv_timings("xilinx-hdmi-rx", "", &xhdmi->dv_timings, 1);
+#endif
+}
+
+/**
+ * rxstreaminit - Initialise the stream
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function is called to initialized the video phy
+ */
+static void rxstreaminit(struct xhdmirx_state *xhdmi)
+{
+	union phy_configure_opts cfg = {0};
+	struct xvideostream *vidstream = &xhdmi->stream.video;
+	u8 colordepth = (u8)xhdmi->stream.video.colordepth;
+
+	if (vidstream->colorspace == XCS_YUV422)
+		colordepth = (u8)XCD_8;
+
+	cfg.hdmi.ppc = COREPIXPERCLK;
+	cfg.hdmi.bpc = colordepth;
+	cfg.hdmi.cal_mmcm_param = 1;
+	xhdmirx_phy_configure(xhdmi, &cfg);
+}
+
+/**
+ * rxconnect - function called back in connect state
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function is called when driver state is in connect state.
+ * When the cable is connected / disconnected this function is called.
+ */
+static void rxconnect(struct xhdmirx_state *xhdmi)
+{
+	union phy_configure_opts phy_cfg = {0};
+
+	dev_dbg_ratelimited(xhdmi->dev, "%s - enter cable %s\n",
+			    __func__, xhdmi->stream.cable_connected ?
+			    "connected" : "disconnected");
+
+	if (xhdmirx1_isstreamconnected(xhdmi)) {
+		xhdmirx_set_hpd(xhdmi, 1);
+		phy_cfg.hdmi.ibufds = 1;
+		phy_cfg.hdmi.ibufds_en = 1;
+		xhdmirx_phy_configure(xhdmi, &phy_cfg);
+		xhdmirx_ext_vrst_assert(xhdmi);
+	} else {
+		xhdmirx_set_hpd(xhdmi, 0);
+
+		if (xhdmi->is_hdcp1x_enabled)
+			xhdcp1x_rx_disable(xhdmi->hdcp1x);
+
+		xhdmirx_scrambler_disable(xhdmi);
+
+		phy_cfg.hdmi.tmdsclock_ratio_flag = 1;
+		phy_cfg.hdmi.tmdsclock_ratio = 0;
+		xhdmirx_phy_configure(xhdmi, &phy_cfg);
+
+		phy_cfg.hdmi.ibufds = 1;
+		phy_cfg.hdmi.ibufds_en = 0;
+		xhdmirx_phy_configure(xhdmi, &phy_cfg);
+	}
+}
+
+/**
+ * tmdsconfig - Function to config the TMDS in the phy
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Function is used to configure the Phy in TMDS 2.0 or HDMI 2.1 config
+ */
+static void tmdsconfig(struct xhdmirx_state *xhdmi)
+{
+	union phy_configure_opts phy_cfg = {0};
+
+	phy_cfg.hdmi.config_hdmi20 = 1;
+	xhdmirx_phy_configure(xhdmi, &phy_cfg);
+	xhdmirx_setfrl_vclkvckeratio(xhdmi, 0);
+	dev_dbg_ratelimited(xhdmi->dev, "Set HDMI 2.0 phy");
+}
+
+static void frlconfig(struct xhdmirx_state *xhdmi)
+{
+	union phy_configure_opts phy_cfg = {0};
+	u64 linerate = xhdmi->stream.frl.linerate * (u64)(1e9);
+	u8 nchannels = xhdmi->stream.frl.lanes;
+
+	phy_cfg.hdmi.linerate = linerate;
+	phy_cfg.hdmi.nchannels = nchannels;
+	phy_cfg.hdmi.config_hdmi21 = 1;
+	xhdmirx_phy_configure(xhdmi, &phy_cfg);
+	dev_dbg_ratelimited(xhdmi->dev, "Set HDMI 2.1 phy");
+}
+
+static void phyresetcb(struct xhdmirx_state *xhdmi)
+{
+	union phy_configure_opts opts = {0};
+
+	xhdmi->stream.frl.ltpmatchpollcounts = 0;
+	xhdmi->stream.frl.ltpmatchwaitcounts = 0;
+
+	opts.hdmi.reset_gt = true;
+	xhdmirx_phy_configure(xhdmi, &opts);
+}
+
+/**
+ * streamdown - called on stream down event
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * This function is called on stream down event
+ */
+static void streamdown(struct xhdmirx_state *xhdmi)
+{
+	dev_dbg_ratelimited(xhdmi->dev, "%s - enter\n", __func__);
+
+	/* In TMDS mode */
+	if (!xhdmi->stream.isfrl) {
+		xhdmirx_rxcore_vrst_assert(xhdmi);
+		xhdmirx_rxcore_lrst_assert(xhdmi);
+	}
+	xhdmirx_sysrst_assert(xhdmi);
+	xhdmi->isstreamup = false;
+	if (xhdmi->is_hdcp1x_enabled)
+		xhdcp1x_rx_disable(xhdmi->hdcp1x);
+}
+
+static void xhdmirx1_clear(struct xhdmirx_state *xhdmi)
+{
+	/*
+	 * reset state to XSTREAM_DOWN
+	 * reset colorspace, depth, timing, ishdmi, isfrl, isinterlaced, vic
+	 * reset getvidpropcount, set frl state as lts_l
+	 * clear aux packet data
+	 * reset audio properties
+	 */
+	xhdmi->stream.state = XSTREAM_DOWN;
+	xhdmi->stream.ishdmi = false;
+	xhdmi->isstreamup = false;
+
+	xhdmi->stream.video.colorspace = XCS_RGB;
+	xhdmi->stream.video.isinterlaced = false;
+	xhdmi->stream.video.colordepth = XCD_8;
+	memset(&xhdmi->stream.video.timing, 0, sizeof(xhdmi->stream.video.timing));
+	xhdmi->stream.vic = 0;
+	xhdmi->stream.getvidproptries = 0;
+	memset(&xhdmi->dv_timings, 0, sizeof(xhdmi->dv_timings));
+	memset(&xhdmi->mbus_fmt, 0, sizeof(xhdmi->mbus_fmt));
+
+	xhdmi->stream.isfrl = false;
+	xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_L;
+
+	streamdown(xhdmi);
+}
+
+static int xhdmi_retrievefrlratelanes(struct xhdmirx_state *xhdmi)
+{
+	u32 data;
+	int ret = 0;
+
+	data = xhdmi_frlddcreadfield(xhdmi, XSCDCFIELD_FRL_RATE);
+	xhdmi->stream.frl.curfrlrate = data;
+
+	switch (data) {
+	case 6:
+		xhdmi->stream.frl.linerate = 12;
+		xhdmi->stream.frl.lanes = 4;
+		break;
+	case 5:
+		xhdmi->stream.frl.linerate = 10;
+		xhdmi->stream.frl.lanes = 4;
+		break;
+	case 4:
+		xhdmi->stream.frl.linerate = 8;
+		xhdmi->stream.frl.lanes = 4;
+		break;
+	case 3:
+		xhdmi->stream.frl.linerate = 6;
+		xhdmi->stream.frl.lanes = 4;
+		break;
+	case 2:
+		xhdmi->stream.frl.linerate = 6;
+		xhdmi->stream.frl.lanes = 3;
+		break;
+	case 1:
+		xhdmi->stream.frl.linerate = 3;
+		xhdmi->stream.frl.lanes = 3;
+		break;
+	default:
+		xhdmi->stream.frl.linerate = 0;
+		xhdmi->stream.frl.lanes = 0;
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static u32 xhdmi_getfrlltpdetection(struct xhdmirx_state *xhdmi, u8 lane)
+{
+	u32 data = 0;
+
+	if (lane < XHDMI_MAX_LANES)
+		data = xhdmi_frlddcreadfield(xhdmi, XSCDCFIELD_LN0_LTP_REQ + lane);
+	else
+		dev_dbg(xhdmi->dev, "RX:ERROR, Wrong lane is selected to get!");
+
+	return data;
+}
+
+static void xhdmi_setfrlltpdetection(struct xhdmirx_state *xhdmi, u8 lane,
+				     enum xhdmi_frlltptype ltp)
+{
+	u32 value = (u32)ltp;
+
+	if (lane < XHDMI_MAX_LANES)
+		xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_LN0_LTP_REQ + lane, value);
+	else
+		dev_dbg(xhdmi->dev, "RX:ERROR, Wrong lane is selected to set!");
+}
+
+static void xhdmi_frlfltupdate(struct xhdmirx_state *xhdmi, bool flag)
+{
+	u8 data = flag ? 1 : 0;
+
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FLT_UPDATE, data);
+	xhdmi->stream.frl.fltupdateasserted = flag;
+}
+
+static void xhdmi_resetfrlltpdetection(struct xhdmirx_state *xhdmi)
+{
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_SET_OFFSET, HDMIRX_FRL_CTRL_FLT_CLR_MASK);
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_CLR_OFFSET, HDMIRX_FRL_CTRL_FLT_CLR_MASK);
+}
+
+static void xhdmi_clearfrlltp(struct xhdmirx_state *xhdmi)
+{
+	u8 lanes;
+
+	for (lanes = 0; lanes < XHDMI_MAX_LANES; lanes++) {
+		xhdmi_setfrlltpdetection(xhdmi, lanes, XLTP_RATE_CHANGE);
+		xhdmi_resetfrlltpdetection(xhdmi);
+	}
+}
+
+static void xhdmi_setfrlltpthreshold(struct xhdmirx_state *xhdmi, u8 threshold)
+{
+	u32 data;
+
+	data = xhdmi_read(xhdmi, HDMIRX_FRL_CTRL_OFFSET);
+	data &= (~(u32)HDMIRX_FRL_CTRL_FLT_THRES_MASK);
+	data |= FIELD_PREP(HDMIRX_FRL_CTRL_FLT_THRES_MASK, threshold);
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_OFFSET, data);
+}
+
+static int xhdmi_configfrlltpdetection(struct xhdmirx_state *xhdmi)
+{
+	u32 data, configuredltp = 0;
+
+	data = xhdmi->stream.frl.fltupdateasserted;
+
+	/* flt_update not cleared */
+	if (data)
+		return -EINVAL;
+
+	/* check if source has read and cleared flt_update, false = cleared */
+	if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_RATE_CH &&
+	    xhdmi->stream.frl.curfrlrate > xhdmi->max_frl_rate) {
+		data = true;
+	} else if (xhdmi->stream.frl.curfrlrate <= xhdmi->max_frl_rate) {
+		u8 ln;
+
+		for (ln = 0; ln < XHDMI_MAX_LANES; ln++) {
+			configuredltp = xhdmi_getfrlltpdetection(xhdmi, ln);
+
+			/*
+			 * if the lane was previously configured as 0xe, it needs to be
+			 * configured back to the ltp to resume link training.
+			 */
+			if (configuredltp == 0xE) {
+				xhdmi->stream.frl.ltp.byte[ln] =
+					xhdmi->stream.frl.defaultltp.byte[ln];
+			}
+
+			/* check if the ltp data requires updating */
+			if (configuredltp != xhdmi->stream.frl.ltp.byte[ln]) {
+				xhdmi_setfrlltpdetection(xhdmi, ln,
+							 xhdmi->stream.frl.ltp.byte[ln]);
+				data = true;
+			}
+		}
+	}
+
+	/* no updates are made */
+	if (!data)
+		return -ENODATA;
+
+	dev_dbg(xhdmi->dev, "rx: ltpreq: %x %x %x %x",
+		xhdmi->stream.frl.ltp.byte[0], xhdmi->stream.frl.ltp.byte[1],
+		xhdmi->stream.frl.ltp.byte[2], xhdmi->stream.frl.ltp.byte[3]);
+
+	dev_dbg(xhdmi->dev, "assert flt_update (%d)",
+		xhdmirx_tmr1_getval(xhdmi));
+
+	xhdmi_frlfltupdate(xhdmi, true);
+	xhdmi_resetfrlltpdetection(xhdmi);
+	return 0;
+}
+
+static void xhdmi_setfrlratewrevent_en(struct xhdmirx_state *xhdmi)
+{
+	xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_SET_OFFSET,
+		    HDMIRX_FRL_CTRL_FRL_RATE_WR_EVT_EN_MASK);
+}
+
+static void xhdmi_frlreset(struct xhdmirx_state *xhdmi, u8 reset)
+{
+	if (reset) {
+		xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_CLR_OFFSET,
+			    HDMIRX_FRL_CTRL_RSTN_MASK);
+		xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_SINK_VER, 1);
+		xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_SCRAMBLER_EN, 0);
+	} else {
+		xhdmi_write(xhdmi, HDMIRX_FRL_CTRL_SET_OFFSET,
+			    HDMIRX_FRL_CTRL_RSTN_MASK);
+		xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FRL_RATE, 0);
+	}
+}
+
+static void xhdmirx_tmrstartms(struct xhdmirx_state *xhdmi, u32 milliseconds,
+			       u8 timerselect)
+{
+	u32 clockcycles = 0;
+
+	if (milliseconds)
+		clockcycles = AXILITE_FREQ / (1000 / milliseconds);
+
+	switch (timerselect) {
+	case 1:
+		xhdmirx_tmr1_start(xhdmi, clockcycles);
+		break;
+	case 2:
+		xhdmirx_tmr2_start(xhdmi, clockcycles);
+		break;
+	case 3:
+		xhdmirx_tmr3_start(xhdmi, clockcycles);
+		break;
+	case 4:
+		xhdmirx_tmr4_start(xhdmi, clockcycles);
+		break;
+	}
+}
+
+static void xhdmi_setfrltimer(struct xhdmirx_state *xhdmi, u32 milliseconds)
+{
+	/* frl uses timer1 */
+	xhdmirx_tmrstartms(xhdmi, milliseconds, 1);
+}
+
+static void xhdmi_phyresetpoll(struct xhdmirx_state *xhdmi)
+{
+	u8 data = xhdmi_getpatternsmatchstatus(xhdmi);
+
+	/* Polls every 4ms */
+	xhdmirx_tmrstartms(xhdmi, 4, 3);
+
+	/*
+	 * One or more lanes are patterns matched but the remaining
+	 * lanes failed to patterns matched within 4ms or no patterns
+	 * have been matched for up to 12ms, proceed to reset Phy
+	 */
+	if (xhdmi->stream.frl.ltpmatchwaitcounts >= 1 ||
+	    xhdmi->stream.frl.ltpmatchpollcounts >= 3) {
+		phyresetcb(xhdmi);
+		return;
+	}
+
+	/* Increments the wait counter */
+	xhdmi->stream.frl.ltpmatchpollcounts++;
+
+	/* If LTP on some of the lanes are successfully matched */
+	if (data && data !=
+		(xhdmi->stream.frl.lanes == 3 ? 0x7 : 0xf)) {
+		xhdmi->stream.frl.ltpmatchwaitcounts++;
+	}
+}
+
+static void xhdmirx_execfrlstate_ltsl(struct xhdmirx_state *xhdmi)
+{
+	dev_dbg(xhdmi->dev, "RX: LTS:L");
+
+	/* Clear HDMI variables */
+	xhdmirx1_clear(xhdmi);
+
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FLT_READY, 1);
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FRL_RATE, 0);
+
+	tmdsconfig(xhdmi);
+	/* FrlLtsLCallback is just a logging function */
+}
+
+static void xhdmirx_execfrlstate_lts2(struct xhdmirx_state *xhdmi)
+{
+	dev_dbg(xhdmi->dev, "RX: LTS:2");
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FLT_READY, 1);
+}
+
+static void xhdmirx_execfrlstate_lts3_ratechange(struct xhdmirx_state *xhdmi)
+{
+	int status;
+
+	xhdmi->stream.frl.timercnt = 0;
+	status = xhdmi_retrievefrlratelanes(xhdmi);
+
+	if (xhdmi->stream.frl.ffesuppflag)
+		xhdmi->stream.frl.ffelevels =
+			xhdmi_frlddcreadfield(xhdmi, XSCDCFIELD_FFE_LEVELS);
+	else
+		xhdmi->stream.frl.ffelevels = 0;
+
+	dev_dbg(xhdmi->dev, "RX: LTS:3 Rate Change");
+	/* FrlLts3Callback is just logging function */
+	xhdmi_frlfltupdate(xhdmi, false);
+
+	if (!status && xhdmi->stream.frl.linerate) {
+		int i;
+
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3_RATE_CH;
+		xhdmi->stream.state = XSTATE_FRL_LINK_TRAININIG;
+		xhdmi->stream.isfrl = true;
+		xhdmi->stream.ishdmi = true;
+		dev_dbg(xhdmi->dev, "RX: Rate: %d Lanes: %d Ffe_lvl: %d",
+			xhdmi->stream.frl.linerate, xhdmi->stream.frl.lanes,
+			xhdmi->stream.frl.ffelevels);
+
+		xhdmirx_rxcore_lrst_assert(xhdmi);
+		xhdmirx_rxcore_vrst_assert(xhdmi);
+		xhdmirx_ext_vrst_assert(xhdmi);
+		xhdmirx_sysrst_assert(xhdmi);
+
+		xhdmirx_vtd_disable(xhdmi);
+		xhdmi_resetfrlltpdetection(xhdmi);
+		xhdmi_clearfrlltp(xhdmi);
+		xhdmi_setfrltimer(xhdmi, frltimeoutlts3[xhdmi->stream.frl.ffelevels]);
+
+		for (i = 0; i < XHDMI_MAX_LANES; i++)
+			xhdmi->stream.frl.ltp.byte[i] =
+				xhdmi->stream.frl.defaultltp.byte[i];
+
+		xhdmi->stream.frl.ltpmatchedcounts = 0;
+		xhdmi->stream.frl.ltpmatchwaitcounts = 0;
+		xhdmi->stream.frl.ltpmatchpollcounts = 0;
+
+		frlconfig(xhdmi);
+
+		/* set a 4 ms on Timer 3 for PhyReset callback */
+		xhdmirx_tmr3_enable(xhdmi);
+		xhdmirx_tmrstartms(xhdmi, 4, 3);
+	} else {
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_L;
+		xhdmi_execfrlstate(xhdmi);
+		xhdmi->stream.state = XSTREAM_DOWN;
+	}
+}
+
+static void xhdmirx_execfrlstate_lts3_ltpdetected(struct xhdmirx_state *xhdmi)
+{
+	u8 data;
+
+	dev_dbg(xhdmi->dev, "RX: LTS:3 LTP Detected %d",
+		xhdmirx_tmr1_getval(xhdmi));
+
+	/* Make sure phy is reset at least once after the pattterns have matched */
+	if (!xhdmi->stream.frl.ltpmatchedcounts) {
+		xhdmi->stream.frl.ltpmatchedcounts++;
+		xhdmi->stream.frl.ltpmatchpollcounts = 0;
+		xhdmi->stream.frl.ltpmatchwaitcounts = 0;
+
+		phyresetcb(xhdmi);
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3;
+
+		dev_dbg(xhdmi->dev, "%s - fail", __func__);
+		return;
+	}
+
+	data = xhdmi_getpatternsmatchstatus(xhdmi);
+
+	if ((xhdmi->stream.frl.lanes == 3 ? 0x7 : 0xF) == data) {
+		/* disable timer 3 which triggers Phy reset */
+		xhdmirx_tmrstartms(xhdmi, 0, 3);
+		xhdmirx_tmr3_disable(xhdmi);
+
+		/* 0 = Link Training Passing */
+		xhdmi->stream.frl.ltp.data = 0x0;
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3_RDY;
+
+		/* FrlLtsPCallback is only a logging function */
+		dev_dbg(xhdmi->dev, "LTP_DET:MATCH");
+	} else {
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3;
+		dev_dbg(xhdmi->dev, "LTP_DET:FALSE:%x", data);
+	}
+}
+
+static void xhdmirx_execfrlstate_lts3_timer(struct xhdmirx_state *xhdmi)
+{
+	u8 data = xhdmi_getpatternsmatchstatus(xhdmi);
+
+	xhdmi->stream.frl.fltnoretrain =
+		xhdmi_frlddcreadfield(xhdmi, XSCDCFIELD_FLT_NO_RETRAIN);
+	xhdmi->stream.frl.timercnt = frltimeoutlts3[xhdmi->stream.frl.ffelevels];
+
+	if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P) {
+		dev_dbg(xhdmi->dev, "RX: LTS:P Lts3_Timer OUT FFE_LVL: %d",
+			xhdmi->stream.frl.ffelevels);
+	}
+
+	if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3 ||
+	    xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_TMR ||
+	    xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_RATE_CH ||
+	    xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_RDY) {
+		if (!xhdmi->stream.frl.fltnotimeout && !xhdmi->stream.frl.fltnoretrain) {
+			if (xhdmi->stream.frl.timercnt >
+			    (frltimeoutlts3[xhdmi->stream.frl.ffelevels] *
+			     xhdmi->stream.frl.ffelevels)) {
+				/* If LTPs are not detected on all active lanes */
+				if ((xhdmi->stream.frl.lanes == 3 ? 0x7 : 0xF) != data) {
+					/* Stop the timer which will initiate phy reset */
+					xhdmirx_tmrstartms(xhdmi, 0, 3);
+					xhdmi->stream.frl.ltp.byte[0] = 0xF;
+					xhdmi->stream.frl.ltp.byte[1] = 0xF;
+					xhdmi->stream.frl.ltp.byte[2] = 0xF;
+					xhdmi->stream.frl.ltp.byte[3] = 0xF;
+					/* FrlLts4Callback is just logging function */
+				}
+			} else if (xhdmi->stream.frl.ffesuppflag) {
+				u8 lanes;
+
+				for (lanes = 0; lanes < xhdmi->stream.frl.lanes; lanes++) {
+					/* if any lane is not passing by link training */
+					if (((data >> lanes) & 0x1) != 0x1) {
+						/* 0xE = Request to change TxFFE */
+						xhdmi->stream.frl.ltp.byte[lanes] = 0xE;
+						dev_dbg(xhdmi->dev, "RX: %d:0xE", lanes);
+					}
+				}
+				xhdmi_resetfrlltpdetection(xhdmi);
+				xhdmi_setfrltimer(xhdmi,
+						  frltimeoutlts3[xhdmi->stream.frl.ffelevels]);
+			}
+		}
+	}
+
+	if (xhdmi->stream.frl.trainingstate != XFRLSTATE_LTS_3_RDY)
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3;
+}
+
+static void xhdmirx_execfrlstate_lts3(struct xhdmirx_state *xhdmi)
+{
+	int status;
+
+	dev_dbg(xhdmi->dev, "RX: LTS:3 %d", xhdmirx_tmr1_getval(xhdmi));
+	dev_dbg(xhdmi->dev, "scdc flt update = %d",
+		xhdmi_frlddcreadfield(xhdmi, XSCDCFIELD_FLT_UPDATE));
+
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FRL_START, 0);
+
+	status = xhdmi_configfrlltpdetection(xhdmi);
+	if (!status) {
+		if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_RDY) {
+			xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_P;
+			dev_dbg(xhdmi->dev, "RX: LTP Pass");
+			/* Disable timer */
+			xhdmi_setfrltimer(xhdmi, 0);
+			status = 0;
+		} else if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_TMR) {
+		} else if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3) {
+		} else {
+			dev_dbg(xhdmi->dev, " --->ELSE");
+		}
+		status = 0;
+	} else if (status == -EINVAL) {
+		/*
+		 * source has not cleared FLT_update so sink should not update
+		 * FLT_req and FLT_update as to ensure proper data handshake
+		 */
+		dev_dbg(xhdmi->dev, "RX: LTS_3-->FLT_UPDATE not Cleared %d",
+			xhdmirx_tmr1_getval(xhdmi));
+	} else {
+		/* case of -ENODATA */
+		/*
+		 * Source has cleared FLT_update but no update from sink is required
+		 */
+	}
+}
+
+static void xhdmirx_execfrlstate_ltsp(struct xhdmirx_state *xhdmi)
+{
+	dev_dbg(xhdmi->dev, "RX: LTS:P");
+
+	if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P_FRL_RDY &&
+	    !xhdmi->stream.frl.fltupdateasserted) {
+		dev_dbg(xhdmi->dev, "RX: LTS: P_FRL_RDY");
+		xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FRL_START, 1);
+		dev_dbg(xhdmi->dev, "RX: FRL_START");
+		/* FrlStartCallback is just logging function */
+	}
+}
+
+static void xhdmirx_execfrlstate_ltsp_timeout(struct xhdmirx_state *xhdmi)
+{
+	dev_dbg(xhdmi->dev, "rx: lts:p timeout");
+	tmdsconfig(xhdmi);
+}
+
+static void xhdmi_execfrlstate(struct xhdmirx_state *xhdmi)
+{
+	dev_dbg(xhdmi->dev, "Rx : LTS :%u", xhdmi->stream.frl.trainingstate);
+
+	switch (xhdmi->stream.frl.trainingstate) {
+	case XFRLSTATE_LTS_L:
+		xhdmirx_execfrlstate_ltsl(xhdmi);
+		dev_dbg(xhdmi->dev, "---LTSL:");
+		break;
+
+	case XFRLSTATE_LTS_2:
+		xhdmirx_execfrlstate_lts2(xhdmi);
+		break;
+
+	case XFRLSTATE_LTS_3_RATE_CH:
+		xhdmirx_execfrlstate_lts3_ratechange(xhdmi);
+		/* Note : With some sources such as Realtek, the execution
+		 * of LTS3 state can be removed to check if the system still
+		 * works.
+		 */
+		xhdmirx_execfrlstate_lts3(xhdmi);
+		break;
+
+	case XFRLSTATE_LTS_3_ARM_LNK_RDY:
+	case XFRLSTATE_LTS_3_ARM_VID_RDY:
+		break;
+
+	case XFRLSTATE_LTS_3_LTP_DET:
+		xhdmirx_execfrlstate_lts3_ltpdetected(xhdmi);
+		xhdmirx_execfrlstate_lts3(xhdmi);
+		break;
+
+	case XFRLSTATE_LTS_3_TMR:
+		xhdmirx_execfrlstate_lts3_timer(xhdmi);
+		xhdmirx_execfrlstate_lts3(xhdmi);
+		break;
+
+	case XFRLSTATE_LTS_3:
+	case XFRLSTATE_LTS_3_RDY:
+		xhdmirx_execfrlstate_lts3(xhdmi);
+		break;
+
+	case XFRLSTATE_LTS_P:
+	case XFRLSTATE_LTS_P_FRL_RDY:
+	case XFRLSTATE_LTS_P_VID_RDY:
+		xhdmirx_execfrlstate_ltsp(xhdmi);
+		break;
+
+	case XFRLSTATE_LTS_P_TIMEOUT:
+		xhdmirx_execfrlstate_ltsp_timeout(xhdmi);
+		break;
+
+	default:
+		dev_err(xhdmi->dev, "RX:S:FRL_INVALID_STATE(%u)!",
+			xhdmi->stream.frl.trainingstate);
+		break;
+	}
+}
+
+static int xhdmirx_frlmodeenable(struct xhdmirx_state *xhdmi, u8 ltpthreshold,
+				 union xhdmi_frlltp defaultltp, u8 ffesuppflag)
+{
+	int i;
+
+	if (ffesuppflag > 1) {
+		dev_err(xhdmi->dev, "ffesuppflag can be 0 or 1 and not %u", ffesuppflag);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < XHDMI_MAX_LANES; i++) {
+		if (defaultltp.byte[i] < XLTP_LFSR0 ||
+		    defaultltp.byte[i] > XLTP_LFSR3) {
+			if (i == 3 && !defaultltp.byte[i])
+				break;
+
+			dev_err(xhdmi->dev, "invalid ltp byte %u for lane %u",
+				defaultltp.byte[i], i);
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; i < XHDMI_MAX_LANES; i++)
+		xhdmi->stream.frl.defaultltp.byte[i] = defaultltp.byte[i];
+
+	xhdmi->stream.frl.ffesuppflag = ffesuppflag;
+
+	xhdmi_setfrlltpthreshold(xhdmi, ltpthreshold);
+	xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_2;
+
+	xhdmi_execfrlstate(xhdmi);
+
+	return 0;
+}
+
+/**
+ * xhdmirx_pioint_handler - Function to handle the PIO interrupt
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Function to handle the PIO interrupt
+ */
+static void xhdmirx_pioint_handler(struct xhdmirx_state *xhdmi)
+{
+	u32 event, data;
+
+	event = xhdmi_read(xhdmi, HDMIRX_PIO_IN_EVT_OFFSET);
+	/* clear the PIO interrupts */
+	xhdmi_write(xhdmi, HDMIRX_PIO_IN_EVT_OFFSET, event);
+	data = xhdmi_read(xhdmi, HDMIRX_PIO_IN_OFFSET);
+
+	dev_dbg_ratelimited(xhdmi->dev, "pio int handler PIO IN - 0x%08x\n",
+			    data);
+
+	/* handle cable connect / disconnect */
+	if (event & HDMIRX_PIO_IN_DET_MASK) {
+		if (data & HDMIRX_PIO_IN_DET_MASK) {
+			/* cable connected */
+			xhdmi->stream.cable_connected = true;
+			xhdmi_frlreset(xhdmi, false);
+			xhdmi->stream.ishdmi = false;
+			xhdmi->stream.isfrl = false;
+			rxconnect(xhdmi);
+			tmdsconfig(xhdmi);
+		} else {
+			xhdmi->stream.cable_connected = false;
+			xhdmirx_ddcscdc_clear(xhdmi);
+			/* reset frl as true */
+			xhdmi_frlreset(xhdmi, true);
+			rxconnect(xhdmi);
+		}
+	}
+
+	if (event & HDMIRX_PIO_IN_LNK_RDY_MASK) {
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG) {
+			if (data & HDMIRX_PIO_IN_LNK_RDY_MASK) {
+				switch (xhdmi->stream.frl.trainingstate) {
+				case XFRLSTATE_LTS_3_RATE_CH:
+					xhdmi->stream.frl.trainingstate =
+						XFRLSTATE_LTS_3_ARM_LNK_RDY;
+					break;
+				case XFRLSTATE_LTS_3_ARM_VID_RDY:
+					xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3;
+					xhdmi_execfrlstate(xhdmi);
+					break;
+				default:
+					/* Link Ready Error callback */
+					dev_dbg_ratelimited(xhdmi->dev, "LNK_RDY 1 Error %d",
+							    xhdmi->stream.frl.trainingstate);
+					break;
+				}
+			} else {
+				dev_dbg(xhdmi->dev, "LNK_RDY:0");
+			}
+		} else if (xhdmi->stream.isfrl) {
+			/* Link Ready Error callback */
+			dev_dbg_ratelimited(xhdmi->dev, "LNK_RDY during FRL Link");
+		} else {
+			dev_dbg_ratelimited(xhdmi->dev, "LNK_RDY TMDS");
+			xhdmi->stream.state = XSTREAM_IDLE;
+			dev_dbg_ratelimited(xhdmi->dev, "pio lnk rdy state = XSTREAM_IDLE");
+			/* start 10 ms timer */
+			xhdmirx_tmr1_start(xhdmi, TIME_10MS);
+		}
+	}
+
+	if (event & HDMIRX_PIO_IN_VID_RDY_MASK) {
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG) {
+			if (data & HDMIRX_PIO_IN_VID_RDY_MASK) {
+				switch (xhdmi->stream.frl.trainingstate) {
+				case XFRLSTATE_LTS_3_RATE_CH:
+					xhdmi->stream.frl.trainingstate =
+						XFRLSTATE_LTS_3_ARM_VID_RDY;
+					break;
+				case XFRLSTATE_LTS_3_ARM_LNK_RDY:
+					xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3;
+					xhdmi_execfrlstate(xhdmi);
+					break;
+				default:
+					/* video ready error */
+					dev_dbg_ratelimited(xhdmi->dev, "VID_RDY 1 Error! %d",
+							    xhdmi->stream.frl.trainingstate);
+					break;
+				}
+			} else {
+				dev_dbg_ratelimited(xhdmi->dev, "VID_RDY:0");
+			}
+		} else if (xhdmi->stream.isfrl) {
+			/* video ready error */
+			dev_err_ratelimited(xhdmi->dev, "VID_RDY during FRL Link fail!");
+		} else {
+			/* Ready */
+			if (data & HDMIRX_PIO_IN_VID_RDY_MASK) {
+				if (xhdmi->stream.state == XSTREAM_INIT) {
+					dev_dbg_ratelimited(xhdmi->dev, "pio vid rdy state = XSTREAM_INIT\n");
+					/* Toggle Rx Core reset */
+					xhdmirx_rxcore_vrst_assert(xhdmi);
+					xhdmirx_rxcore_vrst_deassert(xhdmi);
+
+					/* Toggle bridge reset */
+					xhdmirx_ext_vrst_assert(xhdmi);
+					xhdmirx_sysrst_assert(xhdmi);
+					xhdmirx_ext_vrst_deassert(xhdmi);
+					xhdmirx_sysrst_deassert(xhdmi);
+
+					xhdmi->stream.state = XSTREAM_ARM;
+					/* start 200 ms timer */
+					xhdmirx_tmr1_start(xhdmi, TIME_200MS);
+				}
+			} else {
+				/* Stream Down */
+				xhdmirx_rxcore_vrst_assert(xhdmi);
+				xhdmirx_rxcore_lrst_assert(xhdmi);
+
+				xhdmirx1_clear(xhdmi);
+
+				xhdmirx_aux_disable(xhdmi);
+				xhdmirx_aud_disable(xhdmi);
+				xhdmirx_vtd_disable(xhdmi);
+				xhdmirx_link_disable(xhdmi);
+				xhdmirx_video_enable(xhdmi);
+				xhdmirx_axi4s_disable(xhdmi);
+
+				xhdmi->stream.state = XSTREAM_DOWN;
+				dev_dbg_ratelimited(xhdmi->dev, "pio vid rdy state = XSTREAM_DOWN\n");
+
+				xhdmi_write(xhdmi, HDMIRX_VTD_CTRL_CLR_OFFSET,
+					    HDMIRX_VTD_CTRL_SYNC_LOSS_MASK);
+
+				streamdown(xhdmi);
+				xhdmi->hdmi_stream_up = 0;
+			}
+		}
+	}
+
+	if (event & HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK) {
+		dev_dbg_ratelimited(xhdmi->dev, "scrambler intr\n");
+		if (data & HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK)
+			xhdmirx_scrambler_enable(xhdmi);
+		else
+			xhdmirx_scrambler_disable(xhdmi);
+	}
+
+	if (xhdmi->stream.state != XSTATE_FRL_LINK_TRAININIG &&
+	    (event & HDMIRX_PIO_IN_MODE_MASK) && !xhdmi->stream.isfrl) {
+		if (data & HDMIRX_PIO_IN_MODE_MASK)
+			xhdmi->stream.ishdmi = true;
+		else /* DVI */
+			xhdmi->stream.ishdmi = false;
+
+		if (xhdmi->stream.state == XSTREAM_UP ||
+		    xhdmi->stream.state == XSTREAM_LOCK) {
+			/* up or lock state */
+			xhdmirx1_clear(xhdmi);
+			xhdmi->stream.state = XSTREAM_IDLE;
+			dev_dbg_ratelimited(xhdmi->dev, "state = XSTREAM_UP or LOCK\n");
+			/* 10 ms timer */
+			xhdmirx_tmr1_start(xhdmi, TIME_10MS);
+		}
+		/* modecall back does nothing */
+	}
+
+	if (event & HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK)
+		dev_dbg_ratelimited(xhdmi->dev, "scdc tmds clock ratio interrupt\n");
+
+	if (event & HDMIRX_PIO_IN_BRDG_OVERFLOW_MASK)
+		dev_dbg_ratelimited(xhdmi->dev, "bridge overflow interrupt\n");
+}
+
+/**
+ * xhdmirx_tmrint_handler - Function to handle the timer interrupt
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Function to handle the timer interrupt
+ */
+static void xhdmirx_tmrint_handler(struct xhdmirx_state *xhdmi)
+{
+	u32 status;
+
+	status = xhdmi_read(xhdmi, HDMIRX_TMR_STA_OFFSET);
+
+	dev_dbg_ratelimited(xhdmi->dev, "%s - timer int status reg = 0x%08x\n",
+			    __func__, status);
+
+	if (status & HDMIRX_TMR1_STA_CNT_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_TMR_STA_OFFSET,
+			    HDMIRX_TMR1_STA_CNT_EVT_MASK);
+
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG) {
+			switch (xhdmi->stream.frl.trainingstate) {
+			case XFRLSTATE_LTS_L:
+				xhdmi_execfrlstate(xhdmi);
+				break;
+			case XFRLSTATE_LTS_P:
+				fallthrough;
+			case XFRLSTATE_LTS_P_FRL_RDY:
+				fallthrough;
+			case XFRLSTATE_LTS_P_VID_RDY:
+				fallthrough;
+			case XFRLSTATE_LTS_3_RDY:
+				break;
+			default:
+				xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3_TMR;
+				xhdmi_execfrlstate(xhdmi);
+				break;
+			}
+			return;
+		}
+
+		if (xhdmi->stream.state == XSTREAM_IDLE) {
+			dev_dbg_ratelimited(xhdmi->dev, "state = XSTREAM_IDLE isfrl = %d trainingstate = %d",
+					    xhdmi->stream.isfrl, xhdmi->stream.frl.trainingstate);
+
+			if (!xhdmi->stream.isfrl ||
+			    (xhdmi->stream.isfrl &&
+			     xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P_VID_RDY)) {
+				xhdmirx_aux_enable(xhdmi);
+				/* enable audio */
+				/* release the internal vrst & lrst */
+				xhdmirx_rxcore_vrst_deassert(xhdmi);
+				xhdmirx_rxcore_lrst_deassert(xhdmi);
+				xhdmirx_link_enable(xhdmi);
+
+				xhdmi->stream.state = XSTREAM_INIT;
+				xhdmi->stream.getvidproptries = 0;
+			}
+			xhdmirx_tmr1_start(xhdmi, TIME_200MS);
+
+		} else if (xhdmi->stream.state == XSTREAM_INIT) {
+			dev_dbg_ratelimited(xhdmi->dev, "state = XSTREAM_INIT\n");
+			/* get video properties */
+			if (xhdmirx1_get_video_properties(xhdmi)) {
+				/* failed to get video properties */
+				xhdmirx_tmr1_start(xhdmi, TIME_200MS);
+			} else {
+				xhdmirx1_setpixelclk(xhdmi);
+
+				if (xhdmi->stream.isfrl) {
+					dev_dbg_ratelimited(xhdmi->dev, "Virtual Vid_Rdy: XSTREAM_INIT");
+
+					/* Toggle video reset for HDMI Rx core */
+					xhdmirx_rxcore_vrst_assert(xhdmi);
+					xhdmirx_rxcore_vrst_deassert(xhdmi);
+
+					/* Toggle bridge reset */
+					xhdmirx_ext_vrst_assert(xhdmi);
+					xhdmirx_sysrst_assert(xhdmi);
+
+					xhdmirx_ext_vrst_deassert(xhdmi);
+					xhdmirx_sysrst_deassert(xhdmi);
+
+					xhdmi->stream.state = XSTREAM_ARM;
+					xhdmirx_tmr1_start(xhdmi, TIME_200MS);
+				} else {
+					rxstreaminit(xhdmi);
+				}
+			}
+
+		} else if (xhdmi->stream.state == XSTREAM_ARM) {
+			dev_dbg(xhdmi->dev, "%s - state = XSTREAM_ARM\n", __func__);
+			xhdmirx_vtd_enable(xhdmi);
+			xhdmirx_vtdintr_enable(xhdmi);
+
+			/* 16 ms timer count is already loaded in VTD */
+			xhdmi->stream.state = XSTREAM_LOCK;
+		}
+	}
+
+	if (status & HDMIRX_TMR2_STA_CNT_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_TMR_STA_OFFSET,
+			    HDMIRX_TMR2_STA_CNT_EVT_MASK);
+	}
+
+	if (status & HDMIRX_TMR3_STA_CNT_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_TMR_STA_OFFSET,
+			    HDMIRX_TMR3_STA_CNT_EVT_MASK);
+		xhdmi_phyresetpoll(xhdmi);
+	}
+
+	if (status & HDMIRX_TMR4_STA_CNT_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_TMR_STA_OFFSET,
+			    HDMIRX_TMR4_STA_CNT_EVT_MASK);
+		/* currently unused */
+	}
+}
+
+/**
+ * xhdmirx_vtdint_handler - Function to handle the VTD interrupt
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Function to handle the video timing detector interrupt
+ */
+static void xhdmirx_vtdint_handler(struct xhdmirx_state *xhdmi)
+{
+	u32 status;
+	u32 totalpixfrlratio = 0, activepixfrlratio = 0;
+	u64 vidclk = 0;
+
+	status = xhdmi_read(xhdmi, HDMIRX_VTD_STA_OFFSET);
+
+	if (status & HDMIRX_VTD_STA_TIMEBASE_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_VTD_STA_OFFSET,
+			    HDMIRX_VTD_STA_TIMEBASE_EVT_MASK);
+		dev_dbg_ratelimited(xhdmi->dev, "vtd intr\n");
+
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG)
+			return;
+
+		if (xhdmi->stream.state == XSTREAM_LOCK) {
+			int ret;
+			u32 divisor, dividend;
+
+			dev_dbg_ratelimited(xhdmi->dev, "%s - state = XSTREAM_LOCK\n", __func__);
+			/* Get video timings */
+			ret = xhdmirx1_get_vid_timing(xhdmi);
+
+			if (!ret) {
+				if (xhdmi->stream.isfrl) {
+					u32 val;
+
+					val = xhdmi_getfrlactivepixratio(xhdmi);
+					activepixfrlratio = DIV_ROUND_CLOSEST(val, 1000);
+
+					val = xhdmi_getfrltotalpixratio(xhdmi);
+					totalpixfrlratio = DIV_ROUND_CLOSEST(val, 1000);
+
+					vidclk = activepixfrlratio *
+						 DIV_ROUND_CLOSEST(xhdmi->frlclkfreqkhz, 100);
+					vidclk = DIV_ROUND_CLOSEST_ULL(vidclk, totalpixfrlratio);
+					xhdmi->stream.refclk = vidclk * 100000;
+					if (xhdmirx1_get_video_properties(xhdmi))
+						dev_err_ratelimited(xhdmi->dev, "Failed get video properties!");
+				}
+
+				xhdmirx1_setpixelclk(xhdmi);
+
+				if (xhdmi->stream.isfrl) {
+					u32 remainder;
+
+					vidclk = (xhdmi->stream.pixelclk / 100000) / COREPIXPERCLK;
+					vidclk = div64_u64(xhdmi->vidclkfreqkhz, vidclk);
+					vidclk = div_u64_rem(vidclk, 100, &remainder);
+					if (remainder >= 50)
+						vidclk++;
+
+					xhdmirx_setfrl_vclkvckeratio(xhdmi, vidclk);
+				}
+
+				/* calculate framerate */
+				divisor = xhdmi->stream.video.timing.vtot[0];
+				divisor *= xhdmi->stream.video.timing.htot;
+				dividend = xhdmi->stream.pixelclk;
+				if (xhdmi->stream.video.colorspace == XCS_YUV420)
+					dividend <<= 1;
+				xhdmi->stream.video.framerate =
+					DIV_ROUND_CLOSEST(dividend, divisor);
+
+				/* enable AXI stream output */
+				xhdmirx_axi4s_enable(xhdmi);
+
+				xhdmi->stream.state = XSTREAM_UP;
+				xhdmi->stream.syncstatus = XSYNCSTAT_SYNC_EST;
+
+				rxstreamup(xhdmi);
+
+				xhdmi->hdmi_stream_up = 1;
+			}
+		} else if (xhdmi->stream.state == XSTREAM_UP) {
+			int ret;
+
+			dev_dbg_ratelimited(xhdmi->dev, "%s - state = XSTREAM_UP\n", __func__);
+			ret = xhdmirx1_get_vid_timing(xhdmi);
+			if (!ret) {
+				if (xhdmi->stream.syncstatus == XSYNCSTAT_SYNC_LOSS) {
+					xhdmi->stream.syncstatus = XSYNCSTAT_SYNC_EST;
+					/* call syncloss callback */
+				}
+			} else {
+				if (!xhdmi->stream.isfrl) {
+					/* in tmds mode just set state to lock */
+					xhdmi->stream.state = XSTREAM_LOCK;
+				} else {
+					/* need to do frl mode */
+					xhdmirx_rxcore_lrst_assert(xhdmi);
+					xhdmirx_rxcore_lrst_deassert(xhdmi);
+					xhdmirx_aux_disable(xhdmi);
+
+					streamdown(xhdmi);
+
+					/* switch to bursty vcke generation */
+					xhdmirx_setfrl_vclkvckeratio(xhdmi, 0);
+					xhdmi->stream.state = XSTREAM_INIT;
+					xhdmirx_aux_enable(xhdmi);
+					xhdmirx_tmr1_start(xhdmi, TIME_200MS);
+				}
+			}
+		}
+	} else if (status & HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_VTD_STA_OFFSET,
+			    HDMIRX_VTD_STA_SYNC_LOSS_EVT_MASK);
+
+		if (xhdmi->stream.state == XSTREAM_UP)
+			xhdmi->stream.syncstatus = XSYNCSTAT_SYNC_LOSS;
+		dev_dbg(xhdmi->dev, "%s - Sync Loss event\n", __func__);
+	}
+}
+
+/**
+ * xhdmirx_auxint_handler - Function to handle the AUX interrupt
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Function to handle the AUX packets interrupt
+ */
+static void xhdmirx_auxint_handler(struct xhdmirx_state *xhdmi)
+{
+	u32 status;
+
+	status = xhdmi_read(xhdmi, HDMIRX_AUX_STA_OFFSET);
+	dev_dbg_ratelimited(xhdmi->dev, "aux intr\n");
+
+	if (status & HDMIRX_AUX_STA_DYN_HDR_EVT_MASK) {
+		dev_dbg_ratelimited(xhdmi->dev, "aux dyn intr\n");
+		xhdmi_write(xhdmi, HDMIRX_AUX_STA_OFFSET,
+			    HDMIRX_AUX_STA_DYN_HDR_EVT_MASK);
+	}
+
+	if (status & HDMIRX_AUX_STA_VRR_CD_EVT_MASK) {
+		dev_dbg_ratelimited(xhdmi->dev, "aux VRR intr\n");
+		xhdmi_write(xhdmi, HDMIRX_AUX_STA_OFFSET,
+			    HDMIRX_AUX_STA_VRR_CD_EVT_MASK);
+	}
+
+	if (status & HDMIRX_AUX_STA_FSYNC_CD_EVT_MASK) {
+		dev_dbg_ratelimited(xhdmi->dev, "aux fsync intr\n");
+		xhdmi_write(xhdmi, HDMIRX_AUX_STA_OFFSET,
+			    HDMIRX_AUX_STA_FSYNC_CD_EVT_MASK);
+	}
+
+	if (status & HDMIRX_AUX_STA_GCP_CD_EVT_MASK) {
+		dev_dbg_ratelimited(xhdmi->dev, "aux gcp intr\n");
+		xhdmi_write(xhdmi, HDMIRX_AUX_STA_OFFSET,
+			    HDMIRX_AUX_STA_GCP_CD_EVT_MASK);
+
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG)
+			return;
+
+		if (status & HDMIRX_AUX_STA_GCP_MASK) {
+			xhdmi->stream.video.colordepth = xhdmirx1_getgcp_colordepth(xhdmi);
+
+			if (xhdmi->stream.isfrl) {
+				dev_dbg_ratelimited(xhdmi->dev, "FRL Mode Stream Down");
+				xhdmirx_aux_disable(xhdmi);
+				streamdown(xhdmi);
+				xhdmirx_aux_enable(xhdmi);
+				xhdmi->stream.state = XSTREAM_INIT;
+				xhdmirx_tmr1_start(xhdmi, TIME_200MS);
+			}
+		}
+	}
+
+	if (status & HDMIRX_AUX_STA_NEW_MASK) {
+		int i;
+
+		dev_dbg_ratelimited(xhdmi->dev, "aux new packet intr\n");
+		xhdmi_write(xhdmi, HDMIRX_AUX_STA_OFFSET,
+			    HDMIRX_AUX_STA_NEW_MASK);
+
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG)
+			return;
+
+		if (!xhdmi->stream.isfrl)
+			xhdmi->stream.ishdmi = true;
+
+		xhdmi->aux.header.data = xhdmi_read(xhdmi,
+						    HDMIRX_AUX_DAT_OFFSET);
+		for (i = 0; i < 8; i++)
+			xhdmi->aux.data.data[i] =
+				xhdmi_read(xhdmi, HDMIRX_AUX_DAT_OFFSET);
+		/* aux call back */
+	}
+
+	if (status & HDMIRX_AUX_STA_ERR_MASK) {
+		dev_dbg_ratelimited(xhdmi->dev, "aux err intr\n");
+		xhdmi_write(xhdmi, HDMIRX_AUX_STA_OFFSET,  HDMIRX_AUX_STA_ERR_MASK);
+		if (xhdmi->stream.state == XSTATE_FRL_LINK_TRAININIG)
+			return;
+		/* link error call back */
+	}
+}
+
+/**
+ * xhdmirx_frlint_handler - Function to handle the FRL interrupt
+ *
+ * @xhdmi: pointer to driver state
+ *
+ * Function to handle the FRL interrupts
+ */
+static void xhdmirx_frlint_handler(struct xhdmirx_state *xhdmi)
+{
+	u32 data;
+	u8 streamdownflag = false;
+
+	data = xhdmi_read(xhdmi, HDMIRX_FRL_STA_OFFSET);
+	dev_dbg_ratelimited(xhdmi->dev, "FRL intr");
+
+	if (data & HDMIRX_FRL_STA_RATE_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_FRL_STA_OFFSET, HDMIRX_FRL_STA_RATE_EVT_MASK);
+		/* TODO disable Dynamic HDR */
+		streamdown(xhdmi);
+		xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3_RATE_CH;
+		xhdmi_execfrlstate(xhdmi);
+	}
+
+	if (data & HDMIRX_FRL_STA_FLT_UPD_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_FRL_STA_OFFSET, HDMIRX_FRL_STA_FLT_UPD_EVT_MASK);
+		xhdmi->stream.frl.fltupdateasserted = false;
+		dev_dbg_ratelimited(xhdmi->dev, "RX: INTR FLT_UP cleared %d",
+				    xhdmirx_tmr1_getval(xhdmi));
+		switch (xhdmi->stream.frl.trainingstate) {
+		case XFRLSTATE_LTS_P:
+			fallthrough;
+		case XFRLSTATE_LTS_3_RDY:
+			fallthrough;
+		case XFRLSTATE_LTS_3_ARM_VID_RDY:
+			fallthrough;
+		case XFRLSTATE_LTS_3_ARM_LNK_RDY:
+			fallthrough;
+		case XFRLSTATE_LTS_P_FRL_RDY:
+			break;
+		default:
+			xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3;
+			break;
+		}
+		xhdmi_execfrlstate(xhdmi);
+	}
+
+	/* Link training pattern has matched for all the active lanes */
+	if (data & HDMIRX_FRL_STA_FLT_PM_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_FRL_STA_OFFSET, HDMIRX_FRL_STA_FLT_PM_EVT_MASK);
+		dev_dbg_ratelimited(xhdmi->dev, "RX: INTR LTP_DET");
+		if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3 ||
+		    xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_3_LTP_DET) {
+			xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_3_LTP_DET;
+			xhdmi_execfrlstate(xhdmi);
+		}
+	}
+
+	if (data & HDMIRX_FRL_STA_LANE_LOCK_EVT_MASK) {
+		u8 temp = xhdmi_frlddcreadfield(xhdmi, XSCDCFIELD_LNS_LOCK);
+
+		xhdmi_write(xhdmi, HDMIRX_FRL_STA_OFFSET, HDMIRX_FRL_STA_LANE_LOCK_EVT_MASK);
+
+		if (((xhdmi->stream.frl.lanes == 3 ? 0x7 : 0xF) == temp) &&
+		    xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P) {
+			dev_dbg_ratelimited(xhdmi->dev, "LTS_P_FRL_RDY");
+			xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_P_FRL_RDY;
+			dev_dbg_ratelimited(xhdmi->dev, "RX: INTR FRL_START");
+			xhdmi_execfrlstate(xhdmi);
+		}
+	}
+
+	if (data & HDMIRX_FRL_STA_SKEW_LOCK_EVT_MASK) {
+		xhdmi_write(xhdmi, HDMIRX_FRL_STA_OFFSET, HDMIRX_FRL_STA_SKEW_LOCK_EVT_MASK);
+
+		if (xhdmi_read(xhdmi, HDMIRX_FRL_STA_OFFSET) & HDMIRX_FRL_STA_SKEW_LOCK_MASK) {
+			if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P_VID_RDY) {
+				streamdownflag = true;
+				dev_dbg_ratelimited(xhdmi->dev, "skew lock err 1 occurred!");
+			} else {
+				/* Skew has locked. No actions needed */
+				dev_dbg_ratelimited(xhdmi->dev, "skew lock occurred!");
+			}
+
+			xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_P_VID_RDY;
+		} else {
+			if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P_FRL_RDY) {
+				streamdownflag = true;
+			} else if (xhdmi->stream.frl.trainingstate != XFRLSTATE_LTS_3_RATE_CH) {
+				/*
+				 * unexpected skew lock event is true only when it is not caused by
+				 * rate change request.
+				 */
+				dev_dbg_ratelimited(xhdmi->dev, "skew lock err 2 occurred!");
+			}
+
+			if (xhdmi->stream.frl.trainingstate == XFRLSTATE_LTS_P_VID_RDY)
+				xhdmi->stream.frl.trainingstate = XFRLSTATE_LTS_P_FRL_RDY;
+		}
+
+		if (streamdownflag) {
+			xhdmirx_rxcore_lrst_assert(xhdmi);
+			xhdmirx_rxcore_vrst_assert(xhdmi);
+			xhdmirx_ext_vrst_assert(xhdmi);
+			xhdmirx_sysrst_assert(xhdmi);
+
+			xhdmirx_vtd_disable(xhdmi);
+			/* TODO Dynamic HDR disable */
+			streamdown(xhdmi);
+		}
+
+		switch (xhdmi->stream.frl.trainingstate) {
+		case XFRLSTATE_LTS_P_FRL_RDY:
+			xhdmi->stream.state = XSTREAM_DOWN;
+			break;
+		case XFRLSTATE_LTS_P_VID_RDY:
+			/* set stream status to idle */
+			xhdmi->stream.state = XSTREAM_IDLE;
+			/* Load timer for 10 ms */
+			xhdmirx_tmr1_start(xhdmi, TIME_10MS);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static irqreturn_t xhdmirx_irq_handler(int irq, void *param)
+{
+	struct xhdmirx_state *xhdmi = (struct xhdmirx_state *)param;
+
+	/* read status registers */
+	xhdmi->intrstatus[0] = xhdmi_read(xhdmi, HDMIRX_PIO_STA_OFFSET) &
+				HDMIRX_PIO_STA_IRQ_MASK;
+	xhdmi->intrstatus[1] = xhdmi_read(xhdmi, HDMIRX_TMR_STA_OFFSET) &
+				HDMIRX_TMR_STA_IRQ_MASK;
+	xhdmi->intrstatus[2] = xhdmi_read(xhdmi, HDMIRX_VTD_STA_OFFSET) &
+				HDMIRX_VTD_STA_IRQ_MASK;
+	xhdmi->intrstatus[3] = xhdmi_read(xhdmi, HDMIRX_DDC_STA_OFFSET) &
+				HDMIRX_DDC_STA_IRQ_MASK;
+	xhdmi->intrstatus[4] = xhdmi_read(xhdmi, HDMIRX_AUX_STA_OFFSET) &
+				HDMIRX_AUX_STA_IRQ_MASK;
+	xhdmi->intrstatus[5] = xhdmi_read(xhdmi, HDMIRX_AUD_STA_OFFSET) &
+				HDMIRX_AUD_STA_IRQ_MASK;
+	xhdmi->intrstatus[6] = xhdmi_read(xhdmi, HDMIRX_LNKSTA_STA_OFFSET) &
+				HDMIRX_LNKSTA_STA_IRQ_MASK;
+	xhdmi->intrstatus[7] = xhdmi_read(xhdmi, HDMIRX_FRL_STA_OFFSET) &
+				HDMIRX_FRL_STA_IRQ_MASK;
+
+	xhdmi->intrstatus[8] = xhdmi_read(xhdmi, HDMIRX_DDC_STA_OFFSET);
+	xhdmi_write(xhdmi, HDMIRX_DDC_STA_OFFSET, xhdmi->intrstatus[8]);
+	/* mask interrupt request */
+	xhdmirx_disable_allintr(xhdmi);
+
+	/* call bottom-half */
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t xhdmirx_irq_thread(int irq, void *param)
+{
+	struct xhdmirx_state *xhdmi = (struct xhdmirx_state *)param;
+
+	if (xhdmi->intrstatus[0])
+		xhdmirx_pioint_handler(xhdmi);
+	if (xhdmi->intrstatus[1])
+		xhdmirx_tmrint_handler(xhdmi);
+	if (xhdmi->intrstatus[2])
+		xhdmirx_vtdint_handler(xhdmi);
+	if (xhdmi->intrstatus[3])
+		xhdmi_write(xhdmi, HDMIRX_DDC_STA_OFFSET, xhdmi->intrstatus[3]);
+	if (xhdmi->intrstatus[4])
+		xhdmirx_auxint_handler(xhdmi);
+	if (xhdmi->intrstatus[5])
+		xhdmi_write(xhdmi, HDMIRX_AUD_STA_OFFSET, xhdmi->intrstatus[5]);
+	if (xhdmi->intrstatus[6])
+		xhdmi_write(xhdmi, HDMIRX_LNKSTA_STA_OFFSET, xhdmi->intrstatus[6]);
+	if (xhdmi->intrstatus[7])
+		xhdmirx_frlint_handler(xhdmi);
+	if (xhdmi->intrstatus[8])
+		xhdmi_write(xhdmi, HDMIRX_DDC_STA_OFFSET, xhdmi->intrstatus[8]);
+	if (xhdmi->intrstatus[8] & HDMIRX_DDC_STA_HDCP_1_PROT_EVT_MASK)
+		xhdmi->hdcp1x_prot_event = true;
+
+	if (xhdmi->intrstatus[8] & HDMIRX_DDC_STA_HDCP_AKSV_EVT_MASK) {
+		if (xhdmi->hdcp1x_prot_event && xhdmi->hdcp1x_key_available) {
+			xhdcp1x_rx_enable(xhdmi->hdcp1x, XHDMI_MAX_LANES);
+			xhdcp1x_rx_push_events(xhdmi->hdcp1x, XHDCP1X_RX_AKSV_RCVD);
+		}
+	}
+	xhdmirx_enable_allintr(xhdmi);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xhdmirx_load_edid - Function to load the user EDID
+ *
+ * @xhdmi: pointer to driver state
+ * @edid: buffer pointer to user EDID
+ * @length: Length of buffer
+ *
+ * Returns: 0 on success else -EINVAL
+ */
+static int xhdmirx_load_edid(struct xhdmirx_state *xhdmi, u8 *edid, int length)
+{
+	u32 wordcount;
+	int i;
+
+	wordcount = xhdmi_read(xhdmi, HDMIRX_DDC_EDID_STA_OFFSET);
+	wordcount &= 0xFFFF;
+
+	if (wordcount < length) {
+		dev_err(xhdmi->dev, "fail as length > edid wc!\n");
+		return -EINVAL;
+	}
+
+	xhdmi_write(xhdmi, HDMIRX_DDC_EDID_WP_OFFSET, 0);
+
+	for (i = 0; i < length; i++)
+		xhdmi_write(xhdmi, HDMIRX_DDC_EDID_DATA_OFFSET, edid[i]);
+
+	xhdmi_write(xhdmi, HDMIRX_DDC_CTRL_SET_OFFSET,
+		    HDMIRX_DDC_CTRL_EDID_EN_MASK);
+
+	return 0;
+}
+
+static void xhdmirx_reset(struct xhdmirx_state *xhdmi)
+{
+	/* assert resets */
+	xhdmirx_rxcore_vrst_assert(xhdmi);
+	xhdmirx_rxcore_lrst_assert(xhdmi);
+	xhdmirx_sysrst_assert(xhdmi);
+
+	/* deassert resets */
+	xhdmirx_sysrst_deassert(xhdmi);
+	xhdmirx_rxcore_lrst_deassert(xhdmi);
+	xhdmirx_rxcore_vrst_deassert(xhdmi);
+}
+
+static void xhdmirx_init(struct xhdmirx_state *xhdmi)
+{
+	u32 mask;
+
+	xhdmirx1_clear(xhdmi);
+	xhdmi->stream.frl.fltnoretrain = false;
+	xhdmi->stream.frl.fltnotimeout = false;
+
+	xhdmirx_frlintr_disable(xhdmi);
+	xhdmi_frlreset(xhdmi, true);
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_SINK_VER, 1);
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FRL_RATE, 0);
+
+	xhdmirx_pio_disable(xhdmi);
+	xhdmirx_tmr1_disable(xhdmi);
+	xhdmirx_tmr2_disable(xhdmi);
+	xhdmirx_tmr3_disable(xhdmi);
+	xhdmirx_tmr4_disable(xhdmi);
+	xhdmirx_vtd_disable(xhdmi);
+	xhdmirx_ddc_disable(xhdmi);
+	xhdmirx_aux_disable(xhdmi);
+	xhdmirx_aud_disable(xhdmi);
+	xhdmirx_lnksta_disable(xhdmi);
+	xhdmirx_piointr_disable(xhdmi);
+	xhdmirx_tmr1intr_disable(xhdmi);
+	xhdmirx_tmr2intr_disable(xhdmi);
+	xhdmirx_tmr3intr_disable(xhdmi);
+	xhdmirx_tmr4intr_disable(xhdmi);
+	xhdmirx_vtdintr_disable(xhdmi);
+	xhdmirx_ddcintr_disable(xhdmi);
+
+	xhdmirx_ddcscdc_clear(xhdmi);
+	xhdmirx_set_hpd(xhdmi, 0);
+
+	if (xhdmi->is_hdcp1x_enabled)
+		xhdmirx_ddc_hdcp_disable(xhdmi);
+
+	/* Rising edge mask */
+	mask = 0;
+	mask |= HDMIRX_PIO_IN_BRDG_OVERFLOW_MASK;
+	mask |= HDMIRX_PIO_IN_DET_MASK;
+	mask |= HDMIRX_PIO_IN_LNK_RDY_MASK;
+	mask |= HDMIRX_PIO_IN_VID_RDY_MASK;
+	mask |= HDMIRX_PIO_IN_MODE_MASK;
+	mask |= HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK;
+	mask |= HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK;
+	xhdmi_write(xhdmi, HDMIRX_PIO_IN_EVT_RE_OFFSET, mask);
+
+	mask = 0;
+	mask |= HDMIRX_PIO_IN_DET_MASK;
+	mask |= HDMIRX_PIO_IN_VID_RDY_MASK;
+	mask |= HDMIRX_PIO_IN_MODE_MASK;
+	mask |= HDMIRX_PIO_IN_SCDC_SCRAMBLER_ENABLE_MASK;
+	mask |= HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK;
+	xhdmi_write(xhdmi, HDMIRX_PIO_IN_EVT_FE_OFFSET, mask);
+
+	xhdmirx_tmr1_enable(xhdmi);
+	xhdmirx_tmr2_enable(xhdmi);
+	xhdmirx_tmr3_enable(xhdmi);
+	xhdmirx_tmr4_enable(xhdmi);
+	xhdmirx_tmr1intr_enable(xhdmi);
+	xhdmirx_tmr2intr_enable(xhdmi);
+	xhdmirx_tmr3intr_enable(xhdmi);
+	xhdmirx_tmr4intr_enable(xhdmi);
+
+	xhdmirx_skewlockevt_enable(xhdmi);
+
+	/* set VTD for 200 ms different from bare metal's 16ms */
+	xhdmirx_vtd_settimebase(xhdmi, TIME_200MS);
+
+	xhdmirx_ddc_enable(xhdmi);
+	xhdmirx_ddcscdc_enable(xhdmi);
+
+	if (xhdmi->is_hdcp1x_enabled) {
+		xhdmirx_ddc_hdcp_enable(xhdmi);
+		xhdmirx_ddc_hdcp14_mode(xhdmi);
+	}
+	xhdmirx_auxintr_enable(xhdmi);
+	xhdmirx_lnksta_enable(xhdmi);
+
+	xhdmi_frlreset(xhdmi, false);
+	xhdmirx_frlintr_enable(xhdmi);
+	xhdmi->stream.frl.defaultltp.byte[0] = XLTP_LFSR0;
+	xhdmi->stream.frl.defaultltp.byte[1] = XLTP_LFSR1;
+	xhdmi->stream.frl.defaultltp.byte[2] = XLTP_LFSR2;
+	xhdmi->stream.frl.defaultltp.byte[3] = XLTP_LFSR3;
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FLT_READY, 1);
+	xhdmi_frlddcwritefield(xhdmi, XSCDCFIELD_FRL_RATE, 0);
+	xhdmi_setfrlratewrevent_en(xhdmi);
+
+	/* FRL EDID */
+	xhdmirx_load_edid(xhdmi, (u8 *)&xilinx_frl_edid,
+			  sizeof(xilinx_frl_edid));
+	xhdmirx_reset(xhdmi);
+}
+
+static void print_dt_clk_err_msg(struct xhdmirx_state *xhdmi, u8 isfrlclk, const char *range)
+{
+	dev_err(xhdmi->dev, "The %s port is driven by a clock outside the valid range (%s MHz)",
+		isfrlclk ? "frl_clk" : "vid_clk", range);
+}
+
+static int xhdmirx_parse_of(struct xhdmirx_state *xhdmi)
+{
+	struct device_node *node = xhdmi->dev->of_node;
+	struct device *dev = xhdmi->dev;
+	int ret;
+
+	ret = of_property_read_u16(node, "xlnx,edid-ram-size",
+				   &xhdmi->edid_ram_size);
+	if (ret) {
+		dev_err(dev, "xlnx,edid-ram-size property not found.\n");
+		return ret;
+	}
+
+	if (xhdmi->edid_ram_size != 256 && xhdmi->edid_ram_size != 512 &&
+	    xhdmi->edid_ram_size != 1024 && xhdmi->edid_ram_size != 4096) {
+		dev_err(dev, "invalid edid ram size %d in dt\n",
+			xhdmi->edid_ram_size);
+		return -EINVAL;
+	}
+
+	xhdmi->edid_blocks_max = xhdmi->edid_ram_size / XEDID_BLOCK_SIZE;
+
+	ret = of_property_read_u8(node, "xlnx,input-pixels-per-clock",
+				  &xhdmi->max_ppc);
+	if (ret) {
+		dev_err(dev, "xlnx,input-pixels-per-clock property not found.\n");
+		return ret;
+	}
+
+	if (xhdmi->max_ppc != 4 && xhdmi->max_ppc != 8) {
+		dev_err(dev, "dt pixels per clock %d  is invalid.\n",
+			xhdmi->max_ppc);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u8(node, "xlnx,max-bits-per-component",
+				  &xhdmi->max_bpc);
+	if (ret) {
+		dev_err(dev, "xlnx,max-bit-per-component property not found.\n");
+		return ret;
+	}
+
+	if (xhdmi->max_bpc != 8 && xhdmi->max_bpc != 10 &&
+	    xhdmi->max_bpc != 12 && xhdmi->max_bpc != 16) {
+		dev_err(dev, "dt max bits per component %d is invalid.\n",
+			xhdmi->max_bpc);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u8(node, "xlnx,max-frl-rate",
+				  &xhdmi->max_frl_rate);
+	if (ret) {
+		dev_err(dev, "xlnx,max-frl-rate property not found.\n");
+		return ret;
+	}
+
+	if (xhdmi->max_frl_rate != 4 && xhdmi->max_frl_rate != 5 &&
+	    xhdmi->max_frl_rate != 6) {
+		dev_err(dev, "dt max frl rate %d is invalid.\n", xhdmi->max_frl_rate);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,frl-clk-freq-khz",
+				   &xhdmi->frlclkfreqkhz);
+	if (ret) {
+		dev_err(dev, "frl clk freq khz property not found!");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,vid-clk-freq-khz",
+				   &xhdmi->vidclkfreqkhz);
+	if (ret) {
+		dev_err(dev, "video clk freq khz property not found!");
+		return ret;
+	}
+
+	/* HDCP specific code starts here */
+
+	xhdmi->hdcp_enable = of_property_read_bool(node, "xlnx,include-hdcp");
+	if (xhdmi->hdcp_enable) {
+		xhdmi->is_hdcp1x_enabled = of_property_read_bool(node, "xlnx,include-hdcp-1-4");
+		if (!xhdmi->is_hdcp1x_enabled)
+			dev_info(xhdmi->dev, "HDMI:HDCP 1.4 is not enabled\n");
+		else
+			dev_info(xhdmi->dev, "HDMI:HDCP 1.4 is enabled\n");
+	}
+
+	/* HDCP specific code ends here */
+	switch (xhdmi->max_frl_rate) {
+	case 6:
+		/* 12G @ 4 Lanes */
+		if (xhdmi->frlclkfreqkhz < 449000 || xhdmi->frlclkfreqkhz > 451000) {
+			print_dt_clk_err_msg(xhdmi, 1, "449-451");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 399000 || xhdmi->vidclkfreqkhz > 401000) {
+			print_dt_clk_err_msg(xhdmi, 0, "399-401");
+			ret = -EINVAL;
+		}
+		break;
+	case 5:
+		/* 10G @ 4 Lanes */
+		if (xhdmi->frlclkfreqkhz < 379000 || xhdmi->frlclkfreqkhz > 381000) {
+			print_dt_clk_err_msg(xhdmi, 1, "379-381");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 374000 || xhdmi->vidclkfreqkhz > 376000) {
+			print_dt_clk_err_msg(xhdmi, 0, "374-376");
+			ret = -EINVAL;
+		}
+		break;
+	case 4:
+		/* 8G @ 4 Lanes */
+		if (xhdmi->frlclkfreqkhz < 324000 || xhdmi->frlclkfreqkhz > 326000) {
+			print_dt_clk_err_msg(xhdmi, 1, "324-326");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 299000 || xhdmi->vidclkfreqkhz > 301000) {
+			print_dt_clk_err_msg(xhdmi, 0, "299-301");
+			ret = -EINVAL;
+		}
+		break;
+	case 3:
+		/* 6G @ 4 Lanes */
+		if (xhdmi->frlclkfreqkhz < 249000 || xhdmi->frlclkfreqkhz > 251000) {
+			print_dt_clk_err_msg(xhdmi, 1, "249-251");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 224000 || xhdmi->vidclkfreqkhz > 226000) {
+			print_dt_clk_err_msg(xhdmi, 0, "224-226");
+			ret = -EINVAL;
+		}
+		break;
+	case 2:
+		/* 6G @ 4 Lanes */
+		if (xhdmi->frlclkfreqkhz < 199000 || xhdmi->frlclkfreqkhz > 201000) {
+			print_dt_clk_err_msg(xhdmi, 1, "199-201");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 174000 || xhdmi->vidclkfreqkhz > 176000) {
+			print_dt_clk_err_msg(xhdmi, 0, "174-176");
+			ret = -EINVAL;
+		}
+		break;
+	case 1:
+		/* 3G @ 3 Lanes */
+		if (xhdmi->frlclkfreqkhz < 149000 || xhdmi->frlclkfreqkhz > 151000) {
+			print_dt_clk_err_msg(xhdmi, 1, "149-151");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 149000 || xhdmi->vidclkfreqkhz > 151000) {
+			print_dt_clk_err_msg(xhdmi, 0, "149-151");
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		/* TMDS */
+		if (xhdmi->frlclkfreqkhz < 149000 || xhdmi->frlclkfreqkhz > 151000) {
+			print_dt_clk_err_msg(xhdmi, 1, "149-151");
+			ret = -EINVAL;
+		}
+		if (xhdmi->vidclkfreqkhz < 149000 || xhdmi->vidclkfreqkhz > 151000) {
+			print_dt_clk_err_msg(xhdmi, 0, "149-151");
+			ret = -EINVAL;
+		}
+	}
+
+	return ret;
+}
+
+static void xhdmirx_phy_release(struct xhdmirx_state *xhdmi)
+{
+	int i, ret;
+
+	for (i = 0; i < XHDMI_MAX_LANES; i++) {
+		ret = phy_exit(xhdmi->phy[i]);
+		if (ret)
+			dev_err(xhdmi->dev, "fail to exit phy(%d) %d\n", i, ret);
+
+		xhdmi->phy[i] = NULL;
+	}
+}
+
+/**
+ * xhdmirx_dv_timings_cap - function to get the dv timings capabilities
+ *
+ * @subdev: pointer to v4l2 subdev
+ * @cap: Pointer to capable DV timings
+ *
+ * Returns: 0 on success else -EINVAL
+ */
+static int xhdmirx_dv_timings_cap(struct v4l2_subdev *subdev,
+				  struct v4l2_dv_timings_cap *cap)
+{
+	if (cap->pad != 0)
+		return -EINVAL;
+
+	cap->type = V4L2_DV_BT_656_1120;
+	cap->bt.max_width = 4096;
+	cap->bt.max_height = 2160;
+	cap->bt.min_pixelclock = 25000000;
+	cap->bt.max_pixelclock = 297000000;
+	cap->bt.standards = V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+		V4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT;
+	cap->bt.capabilities = V4L2_DV_BT_CAP_PROGRESSIVE |
+		V4L2_DV_BT_CAP_INTERLACED | V4L2_DV_BT_CAP_REDUCED_BLANKING |
+		V4L2_DV_BT_CAP_CUSTOM;
+
+	return 0;
+}
+
+/**
+ * xhdmirx_get_edid - function to get the EDID set currently
+ *
+ * @subdev: pointer to v4l2 subdev structure
+ * @edid: pointer to v4l2 edid structure to be filled to return
+ *
+ * This function returns the current EDID set in the HDMI Rx
+ *
+ * Returns: 0 on success else -EINVAL
+ */
+static int xhdmirx_get_edid(struct v4l2_subdev *subdev, struct v4l2_edid *edid)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(subdev);
+	int do_copy = 1;
+
+	if (edid->pad > 0)
+		return -EINVAL;
+
+	if (edid->start_block != 0)
+		return -EINVAL;
+
+	/* caller is only interested in the size of the EDID? */
+	if (edid->start_block == 0 && edid->blocks == 0)
+		do_copy = 0;
+
+	mutex_lock(&xhdmi->xhdmi_mutex);
+	/* user EDID active? */
+	if (xhdmi->edid_user_blocks) {
+		if (do_copy)
+			memcpy(edid->edid, xhdmi->edid_user,
+			       128 * (u16)xhdmi->edid_user_blocks);
+		edid->blocks = xhdmi->edid_user_blocks;
+	} else {
+		if (do_copy)
+			memcpy(edid->edid, &xilinx_frl_edid[0], sizeof(xilinx_frl_edid));
+		edid->blocks = sizeof(xilinx_frl_edid) / 128;
+	}
+	mutex_unlock(&xhdmi->xhdmi_mutex);
+
+	return 0;
+}
+
+static void xhdmirx_delayed_work_enable_hotplug(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct xhdmirx_state *xhdmi = container_of(dwork,
+						       struct xhdmirx_state,
+						       delayed_work_enable_hotplug);
+
+	xhdmirx_set_hpd(xhdmi, 1);
+}
+
+/**
+ * xhdmirx_set_edid - function to set the user EDID
+ *
+ * @subdev: pointer to v4l2 subdev structure
+ * @edid: pointer to v4l2 edid structure to be set
+ *
+ * This function sets the user EDID in the HDMI Rx
+ *
+ * Returns: 0 on success else -EINVAL or -E2BIG
+ */
+static int xhdmirx_set_edid(struct v4l2_subdev *subdev, struct v4l2_edid *edid)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(subdev);
+	int ret = 0;
+
+	if (edid->pad > 0)
+		return -EINVAL;
+
+	if (edid->start_block != 0)
+		return -EINVAL;
+
+	if (edid->blocks > xhdmi->edid_blocks_max) {
+		/* notify caller of how many EDID blocks this driver supports */
+		edid->blocks = xhdmi->edid_blocks_max;
+		return -E2BIG;
+	}
+
+	mutex_lock(&xhdmi->xhdmi_mutex);
+
+	xhdmi->edid_user_blocks = edid->blocks;
+
+	/* Disable hotplug and I2C access to EDID RAM from DDC port */
+	cancel_delayed_work_sync(&xhdmi->delayed_work_enable_hotplug);
+	xhdmirx_set_hpd(xhdmi, 0);
+
+	if (edid->blocks) {
+		memcpy(xhdmi->edid_user, edid->edid, 128 * edid->blocks);
+		ret = xhdmirx_load_edid(xhdmi, (u8 *)&xhdmi->edid_user,
+					128 * xhdmi->edid_user_blocks);
+		if (!ret)
+			/* enable hotplug after 100 ms */
+			queue_delayed_work(xhdmi->work_queue,
+					   &xhdmi->delayed_work_enable_hotplug,
+					   HZ / 10);
+	} else {
+		dev_dbg(xhdmi->dev, "edid->blocks = 0\n");
+	}
+
+	mutex_unlock(&xhdmi->xhdmi_mutex);
+
+	return ret;
+}
+
+static int xhdmirx_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(subdev);
+
+	dev_dbg(xhdmi->dev, "s_stream : enable %d\n", enable);
+	return 0;
+}
+
+/**
+ * xhdmirx_g_input_status - Gets the current link status
+ *
+ * @sd: pointer to v4l2 subdev struct
+ * @status: Pointer to status to be returned
+ *
+ * This function returns the link status. This is called and checked for
+ * before querying the dv timings.
+ *
+ * Returns: 0 on success else Link status
+ */
+static int xhdmirx_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(sd);
+
+	if (!xhdmi->hdmi_stream_up)
+		*status = V4L2_IN_ST_NO_SYNC | V4L2_IN_ST_NO_SIGNAL;
+	else
+		*status = 0;
+
+	dev_dbg_ratelimited(xhdmi->dev, "g_input_statue = 0x%08x\n", *status);
+
+	return 0;
+}
+
+/**
+ * xhdmirx_query_dv_timings - Gets the current incoming dv timings
+ *
+ * @subdev: pointer to v4l2 subdev
+ * @timings: pointer to the dv timings to be filled and returned
+ *
+ * This function returns the incoming stream's dv timings
+ *
+ * Returns: 0 on success else -ENOLINK
+ */
+static int xhdmirx_query_dv_timings(struct v4l2_subdev *subdev,
+				    struct v4l2_dv_timings *timings)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(subdev);
+
+	if (!xhdmi->hdmi_stream_up) {
+		dev_dbg(xhdmi->dev, "failed as no link\n");
+		return -ENOLINK;
+	}
+
+	v4l2_print_dv_timings(xhdmi->sd.name, "xhdmirx_query_dv_timing: ",
+			      &xhdmi->dv_timings, true);
+
+	*timings = xhdmi->dv_timings;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__xhdmirx_get_pad_format_ptr(struct xhdmirx_state *xhdmi,
+			     struct v4l2_subdev_state *sd_state,
+			     unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		dev_dbg(xhdmi->dev, "%s V4L2_SUBDEV_FORMAT_TRY\n", __func__);
+		return v4l2_subdev_get_try_format(&xhdmi->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		dev_dbg(xhdmi->dev, "%s V4L2_SUBDEV_FORMAT_ACTIVE\n", __func__);
+		return &xhdmi->mbus_fmt;
+	default:
+		return NULL;
+	}
+}
+
+/**
+ * xhdmirx_set_format - Set the format to the pad
+ *
+ * @subdev: pointer to the v4l2 subdev struct
+ * @sd_state: pointer to subdev state
+ * @fmt: pointer to format structure
+ *
+ * This function will update the fmt structure passed to
+ * the current incoming stream format.
+ *
+ * Returns: 0 on success else -EINVAL
+ */
+static int xhdmirx_set_format(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(subdev);
+
+	if (fmt->pad > 0)
+		return -EINVAL;
+
+	fmt->format = xhdmi->mbus_fmt;
+	return 0;
+}
+
+/**
+ * xhdmirx_get_format - Function to get pad format
+ *
+ * @subdev: pointer to v4l2 subdev struct
+ * @sd_state: pointer to subdev state
+ * @fmt: pointer to the subdev format structure
+ *
+ * The fmt structure is updated based on incoming stream format.
+ *
+ * Returns: 0 on success else -EINVAL
+ */
+static int xhdmirx_get_format(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(subdev);
+	struct v4l2_mbus_framefmt *gfmt;
+
+	if (fmt->pad > 0)
+		return -EINVAL;
+
+	/* copy either try or currently-active (i.e. detected) format to caller */
+	gfmt = __xhdmirx_get_pad_format_ptr(xhdmi, sd_state, fmt->pad,
+					    fmt->which);
+	if (!gfmt)
+		return -EINVAL;
+
+	dev_dbg(xhdmi->dev, "width %d height %d code %d\n",
+		gfmt->width, gfmt->height, gfmt->code);
+
+	fmt->format = *gfmt;
+	return 0;
+}
+
+static int xhdmirx_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+				   struct v4l2_event_subscription *sub)
+{
+	struct xhdmirx_state *xhdmi = to_xhdmirx_state(sd);
+	int rc = 0;
+
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		rc = v4l2_src_change_event_subdev_subscribe(sd, fh, sub);
+		dev_dbg(xhdmi->dev, "subscribed to V4L2_EVENT_SOURCE_CHANGE = %d\n", rc);
+		break;
+	default:
+		dev_dbg(xhdmi->dev, "subscribe_event() default: -EINVAL\n");
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+static const struct v4l2_subdev_video_ops xvideo_ops = {
+	.s_stream		= xhdmirx_s_stream,
+	.query_dv_timings	= xhdmirx_query_dv_timings,
+	.g_input_status		= xhdmirx_g_input_status,
+};
+
+static const struct v4l2_subdev_core_ops xcore_ops = {
+	.subscribe_event	= xhdmirx_subscribe_event,
+	.unsubscribe_event	= v4l2_event_subdev_unsubscribe,
+	/*
+	 * This ioctl is used to load HDCP keys for Data encryption.
+	 */
+	.ioctl                  = xhdmirxss_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops xpad_ops = {
+	.get_edid		= xhdmirx_get_edid,
+	.set_edid		= xhdmirx_set_edid,
+	.dv_timings_cap		= xhdmirx_dv_timings_cap,
+	.get_fmt		= xhdmirx_get_format,
+	.set_fmt		= xhdmirx_set_format,
+};
+
+static const struct v4l2_subdev_ops xhdmirx_ops = {
+	.pad = &xpad_ops,
+	.video = &xvideo_ops,
+	.core = &xcore_ops,
+};
+
+static const struct media_entity_operations xmedia_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int xhdmirx_probe_load_edid(struct xhdmirx_state *xhdmi)
+{
+	const struct firmware *fw_edid;
+	const char *fw_edid_name = "xilinx/xilinx-hdmi-rx-edid.bin";
+	u8 *edidbufptr = (u8 *)&xilinx_frl_edid;
+	int edidsize = sizeof(xilinx_frl_edid);
+
+	/* retrieve EDID */
+	if (!request_firmware(&fw_edid, fw_edid_name, xhdmi->dev)) {
+		int blocks = fw_edid->size / 128;
+
+		if (blocks == 0 || blocks > xhdmi->edid_blocks_max ||
+		    (fw_edid->size % 128)) {
+			dev_err(xhdmi->dev, "%s must be n * 128 bytes, with 1 <= n <= %d, using Xilinx built-in EDID instead.\n",
+				fw_edid_name, xhdmi->edid_blocks_max);
+		} else {
+			memcpy(xhdmi->edid_user, fw_edid->data, 128 * blocks);
+			xhdmi->edid_user_blocks = blocks;
+			edidbufptr = xhdmi->edid_user;
+			edidsize = xhdmi->edid_user_blocks * 128;
+		}
+		release_firmware(fw_edid);
+	}
+
+	if (edidbufptr == xhdmi->edid_user)
+		dev_info(xhdmi->dev, "Loading firmware edid\n");
+	else
+		dev_info(xhdmi->dev, "Loading Xilinx default edid\n");
+
+	return xhdmirx_load_edid(xhdmi, edidbufptr, edidsize);
+}
+
+static int xhdmirx_hdcp1x_ddc_rd_handler(void *ref, u32 offset, u8 *buff,
+					 u32 buff_size)
+{
+	struct xhdmirx_state *xhdmirxss = (struct xhdmirx_state *)ref;
+	u32 bytes_left = buff_size;
+	u8 *read_buff = buff;
+
+	/* Truncate if necessary */
+	if ((buff_size + offset) > XHDMIRX_HDCP_MAX_DDC_BYTES)
+		buff_size = XHDMIRX_HDCP_MAX_DDC_BYTES - offset;
+
+	/* Write the offset */
+	xhdmirx_ddc_hdcp_set_address(xhdmirxss, offset);
+
+	/* Read the buffer */
+	while (bytes_left-- > 0)
+		*read_buff++ = xhdmirx_ddc_hdcp_get_data(xhdmirxss);
+
+	return (int)buff_size;
+}
+
+static int xhdmirx_hdcp1x_ddc_wr_handler(void *ref, u32 offset, u8 *buff,
+					 u32 buff_size)
+{
+	struct xhdmirx_state *xhdmirxss = (struct xhdmirx_state *)ref;
+	u32 bytes_left = buff_size;
+	const u8 *write_buff = buff;
+
+	/* Truncate if necessary */
+	if ((buff_size + offset) > XHDMIRX_HDCP_MAX_DDC_BYTES)
+		buff_size = XHDMIRX_HDCP_MAX_DDC_BYTES - offset;
+
+	/* Write the offset */
+	xhdmirx_ddc_hdcp_set_address(xhdmirxss, offset);
+
+	/* Write the buffer */
+	while (bytes_left-- > 0)
+		xhdmirx_ddc_hdcp_set_data(xhdmirxss, *write_buff++);
+
+	return (int)buff_size;
+}
+
+static void xhdmirx_hdcp1x_notification_handler(void *ref, u32 notification)
+{
+	struct xhdmirx_state *xhdmirxss = (struct xhdmirx_state *)ref;
+
+	switch (notification) {
+	case XHDCP1X_RX_NOTIFY_AUTHENTICATED:
+		dev_info(xhdmirxss->dev, "HDCP1X Rx Authenticated\n");
+		break;
+	case XHDCP1X_RX_NOTIFY_UN_AUTHENTICATED:
+		dev_info(xhdmirxss->dev, "HDCP1X Rx Un-Authenticated\n");
+		break;
+	default:
+		dev_info(xhdmirxss->dev, "Undefined HDCP Notification\n");
+		break;
+	}
+}
+
+static int xhdmirx_register_hdcp1x_dev(struct xhdmirx_state *xhdmirxss)
+{
+	xhdmirxss->hdcp1x = xhdcp1x_rx_init(xhdmirxss->dev, xhdmirxss,
+					    xhdmirxss->regs + XHDMIRX_HDCP1X_REG_OFFSET,
+					    0, XHDCP1X_HDMI);
+
+	if (IS_ERR(xhdmirxss->hdcp1x)) {
+		dev_err(xhdmirxss->dev, "failed to initialize HDCP1X\n");
+		return PTR_ERR(xhdmirxss->hdcp1x);
+	}
+
+	xhdmirxss->hdcp1x_key = devm_kzalloc(xhdmirxss->dev, XHDCP1X_KEYS_SIZE,
+					     GFP_KERNEL);
+	if (!xhdmirxss->hdcp1x_key)
+		return -ENOMEM;
+
+	xhdcp1x_rx_set_callback(xhdmirxss->hdcp1x, XHDCP1X_RX_RD_HANDLER,
+				xhdmirx_hdcp1x_ddc_rd_handler);
+	xhdcp1x_rx_set_callback(xhdmirxss->hdcp1x, XHDCP1X_RX_WR_HANDLER,
+				xhdmirx_hdcp1x_ddc_wr_handler);
+	xhdcp1x_rx_set_callback(xhdmirxss->hdcp1x,
+				XHDCP1X_RX_NOTIFICATION_HANDLER,
+				xhdmirx_hdcp1x_notification_handler);
+
+	return 0;
+}
+
+static int xhdmirx_hdcp_init(struct xhdmirx_state *xhdmi)
+{
+	int irq, ret = 0;
+
+	if (!(xhdmi->hdcp_enable || xhdmi->is_hdcp1x_enabled))
+		return 0;
+
+	xhdmi->hdcp1x_keymgmt_base =
+		syscon_regmap_lookup_by_phandle(xhdmi->dev->of_node, "xlnx,hdcp1x_keymgmt");
+	if (IS_ERR(xhdmi->hdcp1x_keymgmt_base)) {
+		dev_err(xhdmi->dev, "couldn't map HDCP1X Keymgmt registers\n");
+		return -ENODEV;
+	}
+
+	ret = xhdmirx_register_hdcp1x_dev(xhdmi);
+	if (ret < 0) {
+		dev_err(xhdmi->dev, "HDMI RX HDCP1X init failed\n");
+		return -EINVAL;
+	}
+
+	irq = irq_of_parse_and_map(xhdmi->dev->of_node, 1);
+	ret = devm_request_irq(xhdmi->dev, irq,
+			       xhdmirxss_hdcp1x_irq_handler,
+			       IRQF_SHARED, "hdmirxss_hdcp1x", xhdmi);
+	if (ret) {
+		dev_err(xhdmi->dev, "ERR: HDCP1X interrupt registration failed!\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int xhdmirx_probe(struct platform_device *pdev)
+{
+	struct xhdmirx_state *xhdmi;
+	struct v4l2_subdev *sd;
+	struct resource *res;
+	union phy_configure_opts phy_cfg = {0};
+	int i, ret, irq, num_clks;
+
+	xhdmi = devm_kzalloc(&pdev->dev, sizeof(*xhdmi), GFP_KERNEL);
+	if (!xhdmi)
+		return -ENOMEM;
+
+	xhdmi->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, xhdmi);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xhdmi->regs = devm_ioremap_resource(xhdmi->dev, res);
+	if (IS_ERR(xhdmi->regs))
+		return PTR_ERR(xhdmi->regs);
+
+	xhdmi->edid_user = devm_kzalloc(xhdmi->dev,
+					XEDID_BLOCKS_MAX * XEDID_BLOCK_SIZE,
+					GFP_KERNEL);
+	if (!xhdmi->edid_user)
+		return -ENOMEM;
+
+	num_clks = ARRAY_SIZE(xhdmirx_clks);
+	xhdmi->clks = devm_kcalloc(xhdmi->dev, num_clks,
+				   sizeof(*xhdmi->clks), GFP_KERNEL);
+	if (!xhdmi->clks)
+		return -ENOMEM;
+
+	for (i = 0; i < num_clks; i++)
+		xhdmi->clks[i].id = xhdmirx_clks[i];
+
+	ret = devm_clk_bulk_get(xhdmi->dev, num_clks, xhdmi->clks);
+	if (ret)
+		return ret;
+
+	ret = clk_bulk_prepare_enable(num_clks, xhdmi->clks);
+	if (ret)
+		return ret;
+
+	mutex_init(&xhdmi->xhdmi_mutex);
+	xhdmi->work_queue = create_singlethread_workqueue("xilinx-hdmi-rx-wq");
+	if (!xhdmi->work_queue) {
+		dev_err(xhdmi->dev, "fail to create work queue!\n");
+		ret = -EINVAL;
+		goto mutex_err;
+	}
+	INIT_DELAYED_WORK(&xhdmi->delayed_work_enable_hotplug,
+			  xhdmirx_delayed_work_enable_hotplug);
+
+	xhdmirx_init(xhdmi);
+	xhdmirx_disable_allintr(xhdmi);
+
+	ret = xhdmirx_frlmodeenable(xhdmi, DEFAULT_LTPTHRESHOLD,
+				    xhdmi->stream.frl.defaultltp, true);
+	if (ret) {
+		dev_err(xhdmi->dev, "Failed to enable FRL mode %d", ret);
+		goto wrkq_err;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(xhdmi->dev, "get irq failed %d\n", irq);
+		ret = -EINVAL;
+		goto wrkq_err;
+	}
+
+	ret = devm_request_threaded_irq(xhdmi->dev, irq, xhdmirx_irq_handler,
+					xhdmirx_irq_thread, IRQF_ONESHOT,
+					dev_name(xhdmi->dev), xhdmi);
+	if (ret) {
+		dev_err(xhdmi->dev, "failed to register irq handler %d\n", ret);
+		goto wrkq_err;
+	}
+
+	ret = xhdmirx_parse_of(xhdmi);
+	if (ret)
+		goto wrkq_err;
+
+	for (i = 0; i < XHDMI_MAX_LANES; i++) {
+		char phy_name[16];
+
+		snprintf(phy_name, sizeof(phy_name), "hdmi-phy%d", i);
+		xhdmi->phy[i] = devm_phy_get(xhdmi->dev, phy_name);
+		if (IS_ERR(xhdmi->phy[i])) {
+			ret = PTR_ERR(xhdmi->phy[i]);
+			xhdmi->phy[i] = NULL;
+			dev_err_probe(xhdmi->dev, ret, "failed to get phy lane %s index %d\n",
+				      phy_name, i);
+			goto phy_err;
+		}
+
+		ret = phy_init(xhdmi->phy[i]);
+		if (ret) {
+			dev_err(xhdmi->dev, "failed to init phy lane %d\n", i);
+			goto phy_err;
+		}
+	}
+
+	sd = &xhdmi->sd;
+	v4l2_subdev_init(sd, &xhdmirx_ops);
+	sd->dev = xhdmi->dev;
+	strscpy(sd->name, dev_name(xhdmi->dev), sizeof(sd->name));
+	sd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	sd->entity.ops = &xmedia_ops;
+	v4l2_set_subdevdata(sd, xhdmi);
+	xhdmi->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&sd->entity, 1, &xhdmi->pad);
+	if (ret < 0) {
+		dev_err(xhdmi->dev, "failed to init media %d\n", ret);
+		goto phy_err;
+	}
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(xhdmi->dev, "failed to register v4l subdev %d\n", ret);
+		goto media_err;
+	}
+
+	ret = xhdmirx_probe_load_edid(xhdmi);
+	if (ret) {
+		dev_err(xhdmi->dev, "failed to load edid\n");
+		goto v4lsd_reg_err;
+	}
+
+	/* register phy callbacks */
+	phy_cfg.hdmi.phycb = 1;
+	phy_cfg.hdmi.hdmiphycb.cb = phy_rxinit_cb;
+	phy_cfg.hdmi.hdmiphycb.data = (void *)xhdmi;
+	phy_cfg.hdmi.hdmiphycb.type = RX_INIT_CB;
+	dev_dbg(xhdmi->dev, "config phy rxinit cb\n");
+	xhdmirx_phy_configure(xhdmi, &phy_cfg);
+
+	phy_cfg.hdmi.phycb = 1;
+	phy_cfg.hdmi.hdmiphycb.cb = phy_rxready_cb;
+	phy_cfg.hdmi.hdmiphycb.data = (void *)xhdmi;
+	phy_cfg.hdmi.hdmiphycb.type = RX_READY_CB;
+	dev_dbg(xhdmi->dev, "config phy rxready cb\n");
+	xhdmirx_phy_configure(xhdmi, &phy_cfg);
+
+	phy_cfg.hdmi.config_hdmi20 = 1;
+	dev_dbg(xhdmi->dev, "set phy to hdmi20\n");
+	xhdmirx_phy_configure(xhdmi, &phy_cfg);
+
+	xhdmirx_enable_allintr(xhdmi);
+
+	xhdmirx1_start(xhdmi);
+
+	ret = xhdmirx_hdcp_init(xhdmi);
+	if (ret) {
+		dev_err(xhdmi->dev, "failed to initialize HDCP\n");
+		goto hdcp_error;
+	}
+
+	dev_info(xhdmi->dev, "driver probe successful\n");
+
+	return 0;
+
+hdcp_error:
+	xhdmirx1_stop(xhdmi);
+	xhdmirx_disable_allintr(xhdmi);
+v4lsd_reg_err:
+	v4l2_async_unregister_subdev(sd);
+media_err:
+	media_entity_cleanup(&sd->entity);
+phy_err:
+	xhdmirx_phy_release(xhdmi);
+wrkq_err:
+	cancel_delayed_work(&xhdmi->delayed_work_enable_hotplug);
+	destroy_workqueue(xhdmi->work_queue);
+mutex_err:
+	mutex_destroy(&xhdmi->xhdmi_mutex);
+	clk_bulk_disable_unprepare(num_clks, xhdmi->clks);
+
+	return ret;
+}
+
+static int xhdmirx_remove(struct platform_device *pdev)
+{
+	struct xhdmirx_state *xhdmi = platform_get_drvdata(pdev);
+	struct v4l2_subdev *sd = &xhdmi->sd;
+	int num_clks = ARRAY_SIZE(xhdmirx_clks);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	xhdmirx_phy_release(xhdmi);
+	cancel_delayed_work(&xhdmi->delayed_work_enable_hotplug);
+	destroy_workqueue(xhdmi->work_queue);
+	mutex_destroy(&xhdmi->xhdmi_mutex);
+	clk_bulk_disable_unprepare(num_clks, xhdmi->clks);
+
+	dev_info(xhdmi->dev, "driver removed successfully\n");
+	return 0;
+}
+
+static const struct of_device_id xhdmirx_of_id_table[] = {
+	{ .compatible = "xlnx,v-hdmi-rxss1-1.1" },
+	{ .compatible = "xlnx,v-hdmi-rxss1-1.2" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, xhdmirx_of_id_table);
+
+static struct platform_driver xhdmirx_driver = {
+	.driver = {
+		.name		= "xlnx-hdmi21rxss",
+		.of_match_table	= xhdmirx_of_id_table,
+	},
+	.probe			= xhdmirx_probe,
+	.remove			= xhdmirx_remove,
+};
+
+module_platform_driver(xhdmirx_driver);
+
+MODULE_AUTHOR("Vishal Sagar <vishal.sagar@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx HDMI 2.1 Rx Subsystem Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-hls-common.h b/drivers/media/platform/xilinx/xilinx-hls-common.h
new file mode 100644
index 000000000..8ecc3cfb8
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hls-common.h
@@ -0,0 +1,36 @@
+/*
+ * Xilinx HLS common header
+ *
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Radhey Shyam Pandey <radheys@xilinx.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __XILINX_HLS_COMMON_H__
+#define __XILINX_HLS_COMMON_H__
+
+#include <linux/bitops.h>
+
+#define XHLS_DEF_WIDTH                          1920
+#define XHLS_DEF_HEIGHT                         1080
+
+#define XHLS_REG_CTRL_DONE                      BIT(1)
+#define XHLS_REG_CTRL_IDLE                      BIT(2)
+#define XHLS_REG_CTRL_READY                     BIT(3)
+#define XHLS_REG_CTRL_AUTO_RESTART              BIT(7)
+#define XHLS_REG_GIE                            0x04
+#define XHLS_REG_GIE_GIE                        BIT(0)
+#define XHLS_REG_IER                            0x08
+#define XHLS_REG_IER_DONE                       BIT(0)
+#define XHLS_REG_IER_READY                      BIT(1)
+#define XHLS_REG_ISR                            0x0c
+#define XHLS_REG_ISR_DONE                       BIT(0)
+#define XHLS_REG_ISR_READY                      BIT(1)
+#define XHLS_REG_ROWS                           0x10
+#define XHLS_REG_COLS                           0x18
+
+#endif /* __XILINX_HLS_COMMON_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-hls.c b/drivers/media/platform/xilinx/xilinx-hls.c
new file mode 100644
index 000000000..2ac96fd76
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hls.c
@@ -0,0 +1,505 @@
+/*
+ * Xilinx HLS Core
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/xilinx-hls.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-hls-common.h"
+#include "xilinx-vip.h"
+
+/**
+ * struct xhls_device - Xilinx HLS Core device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @compatible: first DT compatible string for the device
+ * @formats: active V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: format information corresponding to the pads active formats
+ * @model: additional description of IP implementation if available
+ * @ctrl_handler: control handler
+ * @user_mem: user portion of the register space
+ * @user_mem_size: size of the user portion of the register space
+ */
+struct xhls_device {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+
+	const char *compatible;
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *model;
+
+	void __iomem *user_mem;
+	size_t user_mem_size;
+};
+
+static inline struct xhls_device *to_hls(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xhls_device, xvip.subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * Controls
+ */
+
+static const struct v4l2_ctrl_config xhls_model_ctrl = {
+	.id	= V4L2_CID_XILINX_HLS_MODEL,
+	.name	= "HLS Model",
+	.type	= V4L2_CTRL_TYPE_STRING,
+	.step	= 1,
+	.flags	= V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static int xhls_create_controls(struct xhls_device *xhls)
+{
+	struct v4l2_ctrl_config model = xhls_model_ctrl;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	model.max = strlen(xhls->compatible);
+	model.min = model.max;
+
+	ret = v4l2_ctrl_handler_init(&xhls->ctrl_handler, 1);
+	if (ret) {
+		dev_err(xhls->xvip.dev,
+			"failed to initializing controls (%d)\n", ret);
+		return ret;
+	}
+
+	ctrl = v4l2_ctrl_new_custom(&xhls->ctrl_handler, &model, NULL);
+
+	if (xhls->ctrl_handler.error || !ctrl) {
+		dev_err(xhls->xvip.dev, "failed to add controls\n");
+		v4l2_ctrl_handler_free(&xhls->ctrl_handler);
+		return xhls->ctrl_handler.error;
+	}
+
+	v4l2_ctrl_s_ctrl_string(ctrl, xhls->compatible);
+
+	xhls->xvip.subdev.ctrl_handler = &xhls->ctrl_handler;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Core Operations
+ */
+
+static int xhls_user_read(struct xhls_device *xhls,
+			  struct xilinx_axi_hls_registers *regs)
+{
+	unsigned int i;
+	u32 offset;
+	u32 value;
+
+	if (regs->num_regs >= xhls->user_mem_size / 4)
+		return -EINVAL;
+
+	for (i = 0; i < regs->num_regs; ++i) {
+		if (copy_from_user(&offset, &regs->regs[i].offset,
+				   sizeof(offset)))
+			return -EFAULT;
+
+		if (offset >= xhls->user_mem_size || offset & 3)
+			return -EINVAL;
+
+		value = ioread32(xhls->user_mem + offset);
+
+		if (copy_to_user(&regs->regs[i].value, &value, sizeof(value)))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int xhls_user_write(struct xhls_device *xhls,
+			   struct xilinx_axi_hls_registers *regs)
+{
+	struct xilinx_axi_hls_register reg;
+	unsigned int i;
+
+	if (regs->num_regs >= xhls->user_mem_size / 4)
+		return -EINVAL;
+
+	for (i = 0; i < regs->num_regs; ++i) {
+		if (copy_from_user(&reg, &regs->regs[i], sizeof(reg)))
+			return -EFAULT;
+
+		if (reg.offset >= xhls->user_mem_size || reg.offset & 3)
+			return -EINVAL;
+
+		iowrite32(reg.value, xhls->user_mem + reg.offset);
+	}
+
+	return 0;
+}
+
+static long xhls_ioctl(struct v4l2_subdev *subdev, unsigned int cmd, void *arg)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+
+	switch (cmd) {
+	case XILINX_AXI_HLS_READ:
+		return xhls_user_read(xhls, arg);
+	case XILINX_AXI_HLS_WRITE:
+		return xhls_user_write(xhls, arg);
+	}
+
+	return -ENOTTY;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xhls_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format = &xhls->formats[XVIP_PAD_SINK];
+
+	if (!enable) {
+		xvip_write(&xhls->xvip, XVIP_CTRL_CONTROL, 0);
+		return 0;
+	}
+
+	xvip_write(&xhls->xvip, XHLS_REG_COLS, format->width);
+	xvip_write(&xhls->xvip, XHLS_REG_ROWS, format->height);
+
+	xvip_write(&xhls->xvip, XVIP_CTRL_CONTROL,
+		   XHLS_REG_CTRL_AUTO_RESTART | XVIP_CTRL_CONTROL_SW_ENABLE);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+__xhls_get_pad_format(struct xhls_device *xhls,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xhls->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xhls->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xhls_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xhls_get_pad_format(xhls, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xhls_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xhls_get_pad_format(xhls, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	xvip_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad. */
+	format = __xhls_get_pad_format(xhls, sd_state, XVIP_PAD_SOURCE,
+					 fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	xvip_set_format_size(format, fmt);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+static int xhls_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xhls_device *xhls = to_hls(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xhls->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SOURCE);
+	*format = xhls->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xhls_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops xhls_core_ops = {
+	.ioctl = xhls_ioctl,
+};
+
+static struct v4l2_subdev_video_ops xhls_video_ops = {
+	.s_stream = xhls_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xhls_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xhls_get_format,
+	.set_fmt = xhls_set_format,
+};
+
+static struct v4l2_subdev_ops xhls_ops = {
+	.core   = &xhls_core_ops,
+	.video  = &xhls_video_ops,
+	.pad    = &xhls_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xhls_internal_ops = {
+	.open = xhls_open,
+	.close = xhls_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xhls_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static void xhls_init_formats(struct xhls_device *xhls)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize default and active formats */
+	format = &xhls->default_formats[XVIP_PAD_SINK];
+	format->code = xhls->vip_formats[XVIP_PAD_SINK]->code;
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	format->width = xvip_read(&xhls->xvip, XHLS_REG_COLS);
+	format->height = xvip_read(&xhls->xvip, XHLS_REG_ROWS);
+
+	xhls->formats[XVIP_PAD_SINK] = *format;
+
+	format = &xhls->default_formats[XVIP_PAD_SOURCE];
+	*format = xhls->default_formats[XVIP_PAD_SINK];
+	format->code = xhls->vip_formats[XVIP_PAD_SOURCE]->code;
+
+	xhls->formats[XVIP_PAD_SOURCE] = *format;
+}
+
+static int xhls_parse_of(struct xhls_device *xhls)
+{
+	struct device *dev = xhls->xvip.dev;
+	struct device_node *node = xhls->xvip.dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id;
+	int ret;
+
+	ret = of_property_read_string(node, "compatible", &xhls->compatible);
+	if (ret < 0)
+		return -EINVAL;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct xvip_video_format *vip_format;
+
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "no reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "invalid reg in DT");
+				return -EINVAL;
+			}
+
+			xhls->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	return 0;
+}
+
+static int xhls_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xhls_device *xhls;
+	struct resource *mem;
+	int ret;
+
+	xhls = devm_kzalloc(&pdev->dev, sizeof(*xhls), GFP_KERNEL);
+	if (!xhls)
+		return -ENOMEM;
+
+	xhls->xvip.dev = &pdev->dev;
+
+	ret = xhls_parse_of(xhls);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xhls->xvip);
+	if (ret < 0)
+		return ret;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	xhls->user_mem = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(xhls->user_mem))
+		return PTR_ERR(xhls->user_mem);
+	xhls->user_mem_size = resource_size(mem);
+
+	/* Reset and initialize the core */
+	xvip_reset(&xhls->xvip);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xhls->xvip.subdev;
+	v4l2_subdev_init(subdev, &xhls_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xhls_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xhls);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	xhls_init_formats(xhls);
+
+	xhls->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xhls->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xhls_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, xhls->pads);
+	if (ret < 0)
+		goto error;
+
+	ret = xhls_create_controls(xhls);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xhls);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(xhls->xvip.dev, "device %s found\n", xhls->compatible);
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&xhls->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xhls->xvip);
+	return ret;
+}
+
+static int xhls_remove(struct platform_device *pdev)
+{
+	struct xhls_device *xhls = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xhls->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xhls->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xhls->xvip);
+
+	return 0;
+}
+
+static const struct of_device_id xhls_of_id_table[] = {
+	{ .compatible = "xlnx,v-hls" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xhls_of_id_table);
+
+static struct platform_driver xhls_driver = {
+	.driver = {
+		.name = "xilinx-hls",
+		.of_match_table = xhls_of_id_table,
+	},
+	.probe = xhls_probe,
+	.remove = xhls_remove,
+};
+
+module_platform_driver(xhls_driver);
+
+MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_DESCRIPTION("Xilinx HLS Core Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-isppipeline.c b/drivers/media/platform/xilinx/xilinx-isppipeline.c
new file mode 100644
index 000000000..00837fe31
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-isppipeline.c
@@ -0,0 +1,671 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 - 2023, Advanced Micro Devices, Inc.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+
+#include "xilinx-gamma-correction.h"
+#include "xilinx-vip.h"
+
+#define XISP_AP_CTRL_REG		(0x0)
+#define XISP_WIDTH_REG			(0x10)
+#define XISP_HEIGHT_REG			(0x18)
+#define XISP_MODE_REG			(0x20)
+#define XISP_INPUT_BAYER_FORMAT_REG	(0x28)
+#define XISP_RGAIN_REG			(0x30)
+#define XISP_BGAIN_REG			(0x38)
+#define XISP_PAWB_REG			(0x54)
+#define XISP_GAMMA_RED_REG		(0x800)
+#define XISP_GAMMA_BLUE_REG		(0x900)
+#define XISP_GAMMA_GREEN_REG		(0xA00)
+
+#define XISP_MAX_HEIGHT			(4320)
+#define XISP_MAX_WIDTH			(8192)
+#define XISP_MIN_HEIGHT			(64)
+#define XISP_MIN_WIDTH			(64)
+#define XISP_GAMMA_LUT_LEN		(64)
+#define XISP_NO_OF_PADS			(2)
+
+#define XISP_RESET_DEASSERT		(0)
+#define XISP_RESET_ASSERT		(1)
+#define XISP_START			BIT(0)
+#define XISP_AUTO_RESTART		BIT(7)
+#define XISP_STREAM_ON			(XISP_AUTO_RESTART | XISP_START)
+
+enum xisp_bayer_format {
+	XISP_RGGB = 0,
+	XISP_GRBG,
+	XISP_GBRG,
+	XISP_BGGR,
+};
+
+/*
+ * struct xisp_dev - Xilinx ISP pipeline device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats
+ * @ctrl_handler: V4L2 Control Handler
+ * @bayer_fmt: IP or Hardware specific video format
+ * @rst_gpio: GPIO reset line to bring ISP pipeline out of reset
+ * @npads: number of pads
+ * @max_width: Maximum width supported by this instance
+ * @max_height: Maximum height supported by this instance
+ * @rgain: Expected red gain
+ * @bgain: Expected blue gain
+ * @mode_reg: Track if AWB is enabled or not
+ * @pawb: Expected threshold
+ * @red_lut: Pointer to the gamma coefficient as per the Red Gamma control
+ * @green_lut: Pointer to the gamma coefficient as per the Green Gamma control
+ * @blue_lut: Pointer to the gamma coefficient as per the Blue Gamma control
+ * @gamma_table: Pointer to the table containing various gamma values
+ */
+struct xisp_dev {
+	struct xvip_device xvip;
+	struct media_pad pads[XISP_NO_OF_PADS];
+	struct v4l2_mbus_framefmt formats[XISP_NO_OF_PADS];
+	struct v4l2_ctrl_handler ctrl_handler;
+	enum xisp_bayer_format bayer_fmt;
+	struct gpio_desc *rst_gpio;
+	u16 npads;
+	u16 max_width;
+	u16 max_height;
+	u16 rgain;
+	u16 bgain;
+	bool mode_reg;
+	u16 pawb;
+	const u32 *red_lut;
+	const u32 *green_lut;
+	const u32 *blue_lut;
+	const u32 **gamma_table;
+};
+
+static inline struct xisp_dev *to_xisp(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xisp_dev, xvip.subdev);
+}
+
+/*
+ * xisp_set_lut_entries - Write to a field in ISP pipeline registers
+ *
+ * @xisp:	The xisp_dev
+ * @lut:	The value to write
+ * @lut_base:	The field to write to
+ *
+ * This function allows writing to gamma lut array.
+ */
+
+static void xisp_set_lut_entries(struct xisp_dev *xisp, const u32 *lut, const u32 lut_base)
+{
+	int itr;
+	u32 lut_offset;
+
+	lut_offset = lut_base;
+
+	for (itr = 0; itr < XISP_GAMMA_LUT_LEN; itr = itr + 1) {
+		xvip_write(&xisp->xvip, lut_offset, lut[itr]);
+		lut_offset += 4;
+	}
+}
+
+static void select_gamma(u32 value, const u32 **coeff, const u32 **xgamma_curves)
+{
+	*coeff = *(xgamma_curves + value - 1);
+}
+
+static int xisp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct xisp_dev *xisp =
+		container_of(ctrl->handler,
+			     struct xisp_dev, ctrl_handler);
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_ISP_RED_GAIN:
+		xisp->rgain = ctrl->val;
+		xvip_write(&xisp->xvip, XISP_RGAIN_REG, xisp->rgain);
+		break;
+	case V4L2_CID_XILINX_ISP_BLUE_GAIN:
+		xisp->bgain = ctrl->val;
+		xvip_write(&xisp->xvip, XISP_BGAIN_REG, xisp->bgain);
+		break;
+	case V4L2_CID_XILINX_ISP_AWB:
+		xisp->mode_reg = ctrl->val;
+		xvip_write(&xisp->xvip, XISP_MODE_REG, xisp->mode_reg);
+		break;
+	case V4L2_CID_XILINX_ISP_THRESHOLD:
+		xisp->pawb = ctrl->val;
+		xvip_write(&xisp->xvip, XISP_PAWB_REG, xisp->pawb);
+		break;
+	case V4L2_CID_XILINX_ISP_RED_GAMMA:
+		select_gamma(ctrl->val, &xisp->red_lut, xisp->gamma_table);
+		dev_dbg(xisp->xvip.dev, "Setting Red Gamma to %d.%d",
+			ctrl->val / 10, ctrl->val % 10);
+		xisp_set_lut_entries(xisp, xisp->red_lut, XISP_GAMMA_RED_REG);
+		break;
+	case V4L2_CID_XILINX_ISP_GREEN_GAMMA:
+		select_gamma(ctrl->val, &xisp->green_lut, xisp->gamma_table);
+		dev_dbg(xisp->xvip.dev, "Setting Green Gamma to %d.%d",
+			ctrl->val / 10, ctrl->val % 10);
+		xisp_set_lut_entries(xisp, xisp->green_lut, XISP_GAMMA_GREEN_REG);
+		break;
+	case V4L2_CID_XILINX_ISP_BLUE_GAMMA:
+		select_gamma(ctrl->val, &xisp->blue_lut, xisp->gamma_table);
+		dev_dbg(xisp->xvip.dev, "Setting Blue Gamma to %d.%d",
+			ctrl->val / 10, ctrl->val % 10);
+		xisp_set_lut_entries(xisp, xisp->blue_lut, XISP_GAMMA_BLUE_REG);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops xisp_ctrl_ops = {
+	.s_ctrl = xisp_s_ctrl,
+};
+
+static struct v4l2_ctrl_config xisp_ctrls[] = {
+	/* Red Gain*/
+	{
+		.ops = &xisp_ctrl_ops,
+		.id = V4L2_CID_XILINX_ISP_RED_GAIN,
+		.name = "red_gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 65535,
+		.step = 1,
+		.def = 100,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Blue Gain */
+	{
+		.ops = &xisp_ctrl_ops,
+		.id = V4L2_CID_XILINX_ISP_BLUE_GAIN,
+		.name = "blue_gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 65535,
+		.step = 1,
+		.def = 350,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* AWB Enable */
+	{
+		.ops = &xisp_ctrl_ops,
+		.id =  V4L2_CID_XILINX_ISP_AWB,
+		.name = "awb_en",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 1,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* THRESHOLD */
+	{
+		.ops = &xisp_ctrl_ops,
+		.id =  V4L2_CID_XILINX_ISP_THRESHOLD,
+		.name = "threshold",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 65535,
+		.step = 1,
+		.def = 512,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Red Gamma */
+	{
+		.ops = &xisp_ctrl_ops,
+		.id = V4L2_CID_XILINX_ISP_RED_GAMMA,
+		.name = "red_gamma",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 40,
+		.step = 1,
+		.def = 20,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Green Gamma */
+	{
+		.ops = &xisp_ctrl_ops,
+		.id = V4L2_CID_XILINX_ISP_GREEN_GAMMA,
+		.name = "green_gamma",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 40,
+		.step = 1,
+		.def = 15,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Blue Gamma */
+	{
+		.ops = &xisp_ctrl_ops,
+		.id = V4L2_CID_XILINX_ISP_BLUE_GAMMA,
+		.name = "blue_gamma",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 40,
+		.step = 1,
+		.def = 20,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+};
+
+static struct v4l2_mbus_framefmt
+*__xisp_get_pad_format(struct xisp_dev *xisp,
+			struct v4l2_subdev_state *sd_state,
+			unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *get_fmt;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		get_fmt = v4l2_subdev_get_try_format(&xisp->xvip.subdev,
+						     sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		get_fmt = &xisp->formats[pad];
+		break;
+	default:
+		get_fmt = NULL;
+		break;
+	}
+
+	return get_fmt;
+}
+
+/*
+ * xisp_reset - Reset ISP pipeline IP
+ */
+static void xisp_reset(struct xisp_dev *xisp)
+{
+	/* reset ip */
+	gpiod_set_value_cansleep(xisp->rst_gpio, XISP_RESET_ASSERT);
+	udelay(1);
+	gpiod_set_value_cansleep(xisp->rst_gpio, XISP_RESET_DEASSERT);
+}
+
+static int xisp_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xisp_dev *xisp = to_xisp(subdev);
+
+	if (!enable) {
+		dev_dbg(xisp->xvip.dev, "%s : Off", __func__);
+		xisp_reset(xisp);
+		return 0;
+	}
+
+	xvip_write(&xisp->xvip, XISP_WIDTH_REG, xisp->formats[XVIP_PAD_SINK].width);
+	xvip_write(&xisp->xvip, XISP_HEIGHT_REG, xisp->formats[XVIP_PAD_SINK].height);
+	xvip_write(&xisp->xvip, XISP_INPUT_BAYER_FORMAT_REG, xisp->bayer_fmt);
+	xvip_write(&xisp->xvip, XISP_RGAIN_REG, xisp->rgain);
+	xvip_write(&xisp->xvip, XISP_BGAIN_REG, xisp->bgain);
+	xvip_write(&xisp->xvip, XISP_MODE_REG, xisp->mode_reg);
+	xvip_write(&xisp->xvip, XISP_PAWB_REG, xisp->pawb);
+	xisp_set_lut_entries(xisp, xisp->red_lut, XISP_GAMMA_RED_REG);
+	xisp_set_lut_entries(xisp, xisp->green_lut, XISP_GAMMA_GREEN_REG);
+	xisp_set_lut_entries(xisp, xisp->blue_lut, XISP_GAMMA_BLUE_REG);
+
+	/* Start ISP pipeline IP */
+	xvip_write(&xisp->xvip, XISP_AP_CTRL_REG, XISP_STREAM_ON);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops xisp_video_ops = {
+	.s_stream = xisp_s_stream,
+};
+
+static int xisp_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xisp_dev *xisp = to_xisp(subdev);
+	struct v4l2_mbus_framefmt *get_fmt;
+
+	get_fmt = __xisp_get_pad_format(xisp, sd_state, fmt->pad, fmt->which);
+	if (!get_fmt)
+		return -EINVAL;
+
+	fmt->format = *get_fmt;
+
+	return 0;
+}
+
+static bool
+xisp_get_bayer_format(struct xisp_dev *xisp, u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+	case MEDIA_BUS_FMT_SRGGB16_1X16:
+		xisp->bayer_fmt = XISP_RGGB;
+		break;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG16_1X16:
+		xisp->bayer_fmt = XISP_GRBG;
+		break;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGBRG16_1X16:
+		xisp->bayer_fmt = XISP_GBRG;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SBGGR16_1X16:
+		xisp->bayer_fmt = XISP_BGGR;
+		break;
+	default:
+		dev_dbg(xisp->xvip.dev, "Unsupported format for Sink Pad");
+		return false;
+	}
+
+	return true;
+}
+
+static int xisp_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xisp_dev *xisp = to_xisp(subdev);
+	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *__propagate;
+
+	__format = __xisp_get_pad_format(xisp, sd_state, fmt->pad, fmt->which);
+	if (!__format)
+		return -EINVAL;
+
+	/* Propagate to Source Pad */
+	__propagate = __xisp_get_pad_format(xisp, sd_state,
+					    XVIP_PAD_SOURCE, fmt->which);
+	if (!__propagate)
+		return -EINVAL;
+
+	*__format = fmt->format;
+
+	__format->width = clamp_t(unsigned int, fmt->format.width,
+				  XISP_MIN_WIDTH, xisp->max_width);
+	__format->height = clamp_t(unsigned int, fmt->format.height,
+				   XISP_MIN_HEIGHT, xisp->max_height);
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		if (__format->code != MEDIA_BUS_FMT_RBG888_1X24 &&
+		    __format->code != MEDIA_BUS_FMT_RBG101010_1X30 &&
+		    __format->code != MEDIA_BUS_FMT_RBG121212_1X36 &&
+		    __format->code != MEDIA_BUS_FMT_RBG161616_1X48) {
+			dev_dbg(xisp->xvip.dev,
+				"%s : Unsupported source media bus code format",
+				__func__);
+			__format->code = MEDIA_BUS_FMT_RBG888_1X24;
+		}
+	}
+
+	if (fmt->pad == XVIP_PAD_SINK) {
+		if (!xisp_get_bayer_format(xisp, __format->code)) {
+			dev_dbg(xisp->xvip.dev,
+				"Unsupported Sink Pad Media format, defaulting to RGGB");
+			__format->code = MEDIA_BUS_FMT_SRGGB10_1X10;
+		}
+	}
+
+	/* Always propagate Sink image size to Source */
+	__propagate->width  = __format->width;
+	__propagate->height = __format->height;
+
+	fmt->format = *__format;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops xisp_pad_ops = {
+	.get_fmt = xisp_get_format,
+	.set_fmt = xisp_set_format,
+};
+
+static const struct v4l2_subdev_ops xisp_ops = {
+	.video = &xisp_video_ops,
+	.pad = &xisp_pad_ops,
+};
+
+static const struct media_entity_operations xisp_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int xisp_parse_of(struct xisp_dev *xisp)
+{
+	struct device *dev = xisp->xvip.dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	int rval;
+
+	rval = of_property_read_u16(node, "xlnx,max-height",
+				    &xisp->max_height);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,max-height property!");
+		return -EINVAL;
+	}
+
+	if (xisp->max_height > XISP_MAX_HEIGHT ||
+	    xisp->max_height < XISP_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u16(node, "xlnx,max-width",
+				    &xisp->max_width);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,max-width property!");
+		return -EINVAL;
+	}
+
+	if (xisp->max_width > XISP_MAX_WIDTH ||
+	    xisp->max_width < XISP_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u16(node, "xlnx,rgain",
+				    &xisp->rgain);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,rgain!");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u16(node, "xlnx,bgain",
+				    &xisp->bgain);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,bgain!");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u16(node, "xlnx,pawb",
+				    &xisp->pawb);
+	if (rval < 0) {
+		dev_err(dev, "missing xlnx,pawb!");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_bool(node, "xlnx,mode-reg");
+	if (rval)
+		xisp->mode_reg = of_property_read_bool(node, "xlnx,mode-reg");
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		endpoint = of_get_next_child(port, NULL);
+		if (!endpoint) {
+			dev_err(dev, "No port at\n");
+			return -EINVAL;
+		}
+
+		/* Count the number of ports. */
+		xisp->npads++;
+	}
+
+	/* validate number of ports */
+	if (xisp->npads > XISP_NO_OF_PADS) {
+		dev_err(dev, "invalid number of ports %u\n", xisp->npads);
+		return -EINVAL;
+	}
+
+	xisp->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(xisp->rst_gpio)) {
+		if (PTR_ERR(xisp->rst_gpio) != -EPROBE_DEFER)
+			dev_err(dev, "Reset GPIO not setup in DT");
+		return PTR_ERR(xisp->rst_gpio);
+	}
+
+	return 0;
+}
+
+static int xisp_probe(struct platform_device *pdev)
+{
+	struct xisp_dev *xisp;
+	struct v4l2_subdev *subdev;
+	int rval, itr;
+
+	xisp = devm_kzalloc(&pdev->dev, sizeof(*xisp), GFP_KERNEL);
+	if (!xisp)
+		return -ENOMEM;
+
+	xisp->xvip.dev = &pdev->dev;
+
+	rval = xisp_parse_of(xisp);
+	if (rval < 0)
+		return rval;
+
+	rval = xvip_init_resources(&xisp->xvip);
+	if (rval)
+		return -EIO;
+
+	/* Reset ISP pipeline IP */
+	xisp_reset(xisp);
+
+	/* Init V4L2 subdev */
+	subdev = &xisp->xvip.subdev;
+	v4l2_subdev_init(subdev, &xisp_ops);
+	subdev->dev = &pdev->dev;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	xisp->gamma_table = xgamma_curves;
+
+	/*
+	 * Sink Pad can be any Bayer format.
+	 * Default Sink Pad format is RGGB.
+	 */
+	xisp->formats[XVIP_PAD_SINK].field = V4L2_FIELD_NONE;
+	xisp->formats[XVIP_PAD_SINK].colorspace = V4L2_COLORSPACE_SRGB;
+	xisp->formats[XVIP_PAD_SINK].width = XISP_MIN_WIDTH;
+	xisp->formats[XVIP_PAD_SINK].height = XISP_MIN_HEIGHT;
+	xisp->formats[XVIP_PAD_SINK].code = MEDIA_BUS_FMT_SRGGB10_1X10;
+
+	/* Source Pad has a fixed media bus format of RGB */
+	xisp->formats[XVIP_PAD_SOURCE].field = V4L2_FIELD_NONE;
+	xisp->formats[XVIP_PAD_SOURCE].colorspace = V4L2_COLORSPACE_SRGB;
+	xisp->formats[XVIP_PAD_SOURCE].width = XISP_MIN_WIDTH;
+	xisp->formats[XVIP_PAD_SOURCE].height = XISP_MIN_HEIGHT;
+	xisp->formats[XVIP_PAD_SOURCE].code = MEDIA_BUS_FMT_RBG888_1X24;
+
+	xisp->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xisp->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Init Media Entity */
+	subdev->entity.ops = &xisp_media_ops;
+	rval = media_entity_pads_init(&subdev->entity, XISP_NO_OF_PADS, xisp->pads);
+	if (rval < 0)
+		goto media_error;
+
+	/* V4L2 Controls */
+	v4l2_ctrl_handler_init(&xisp->ctrl_handler, ARRAY_SIZE(xisp_ctrls));
+	for (itr = 0; itr < ARRAY_SIZE(xisp_ctrls); itr++) {
+		v4l2_ctrl_new_custom(&xisp->ctrl_handler,
+				     &xisp_ctrls[itr], NULL);
+	}
+
+	if (xisp->ctrl_handler.error) {
+		dev_err(&pdev->dev, "Failed to add V4L2 controls");
+		rval = xisp->ctrl_handler.error;
+		goto ctrl_error;
+	}
+
+	subdev->ctrl_handler = &xisp->ctrl_handler;
+	rval = v4l2_ctrl_handler_setup(&xisp->ctrl_handler);
+	if (rval < 0) {
+		dev_err(&pdev->dev, "Failed to setup control handler");
+		goto  ctrl_error;
+	}
+
+	platform_set_drvdata(pdev, xisp);
+	rval = v4l2_async_register_subdev(subdev);
+	if (rval < 0) {
+		dev_err(&pdev->dev, "failed to register subdev");
+		goto ctrl_error;
+	}
+
+	dev_dbg(&pdev->dev, "Xilinx Video ISP Pipeline Probe Successful");
+	return 0;
+
+ctrl_error:
+	v4l2_ctrl_handler_free(&xisp->ctrl_handler);
+media_error:
+	xvip_cleanup_resources(&xisp->xvip);
+
+	return rval;
+}
+
+static int xisp_remove(struct platform_device *pdev)
+{
+	struct xisp_dev *xisp = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xisp->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xisp->xvip);
+
+	return 0;
+}
+
+static const struct of_device_id xisp_of_id_table[] = {
+	{.compatible = "xlnx,isppipeline-1.0"},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, xisp_of_id_table);
+
+static struct platform_driver xisp_driver = {
+	.driver = {
+		.name = "xilinx-isppipeline",
+		.of_match_table = xisp_of_id_table,
+	},
+	.probe = xisp_probe,
+	.remove = xisp_remove,
+
+};
+
+module_platform_driver(xisp_driver);
+MODULE_DESCRIPTION("Xilinx Video ISP Pipeline IP Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/xilinx/xilinx-m2m.c b/drivers/media/platform/xilinx/xilinx-m2m.c
new file mode 100644
index 000000000..fa2fc882f
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-m2m.c
@@ -0,0 +1,2219 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx V4L2 mem2mem driver
+ *
+ * Copyright (C) 2017-2018 Xilinx, Inc.
+ *
+ * Author: Satish Kumar Nagireddy <satish.nagireddy.nagireddy@xilinx.com>
+ */
+
+#include <drm/drm_fourcc.h>
+#include <linux/delay.h>
+#include <linux/dma/xilinx_frmbuf.h>
+#include <linux/lcm.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "xilinx-vip.h"
+
+#define XVIP_M2M_NAME		"xilinx-mem2mem"
+#define XVIP_M2M_DEFAULT_FMT	V4L2_PIX_FMT_RGB24
+
+/* Minimum and maximum widths are expressed in bytes */
+#define XVIP_M2M_MIN_WIDTH	1U
+#define XVIP_M2M_MAX_WIDTH	65535U
+#define XVIP_M2M_MIN_HEIGHT	1U
+#define XVIP_M2M_MAX_HEIGHT	8191U
+
+#define XVIP_M2M_DEF_WIDTH	1920
+#define XVIP_M2M_DEF_HEIGHT	1080
+
+#define XVIP_M2M_PAD_SINK	1
+#define XVIP_M2M_PAD_SOURCE	0
+
+/**
+ * struct xvip_graph_entity - Entity in the video graph
+ * @list: list entry in a graph entities list
+ * @node: the entity's DT node
+ * @entity: media entity, from the corresponding V4L2 subdev
+ * @asd: subdev asynchronous registration information
+ * @subdev: V4L2 subdev
+ * @streaming: status of the V4L2 subdev if streaming or not
+ */
+struct xvip_graph_entity {
+	struct list_head list;
+	struct device_node *node;
+	struct media_entity *entity;
+
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev *subdev;
+	bool streaming;
+};
+
+/**
+ * struct xvip_pipeline - Xilinx Video IP pipeline structure
+ * @pipe: media pipeline
+ * @lock: protects the pipeline @stream_count
+ * @use_count: number of DMA engines using the pipeline
+ * @stream_count: number of DMA engines currently streaming
+ * @num_dmas: number of DMA engines in the pipeline
+ * @xdev: Composite device the pipe belongs to
+ */
+struct xvip_pipeline {
+	struct media_pipeline pipe;
+
+	/* protects the pipeline @stream_count */
+	struct mutex lock;
+	unsigned int use_count;
+	unsigned int stream_count;
+
+	unsigned int num_dmas;
+	struct xvip_m2m_dev *xdev;
+};
+
+struct xventity_list {
+	struct list_head list;
+	struct media_entity *entity;
+};
+
+/**
+ * struct xvip_m2m_dev - Xilinx Video mem2mem device structure
+ * @v4l2_dev: V4L2 device
+ * @dev: (OF) device
+ * @media_dev: media device
+ * @notifier: V4L2 asynchronous subdevs notifier
+ * @entities: entities in the graph as a list of xvip_graph_entity
+ * @num_subdevs: number of subdevs in the pipeline
+ * @lock: This is to protect mem2mem context structure data
+ * @queued_lock: This is to protect video buffer information
+ * @dma: Video DMA channels
+ * @m2m_dev: V4L2 mem2mem device structure
+ * @v4l2_caps: V4L2 capabilities of the whole device
+ */
+struct xvip_m2m_dev {
+	struct v4l2_device v4l2_dev;
+	struct device *dev;
+
+	struct media_device media_dev;
+	struct v4l2_async_notifier notifier;
+	struct list_head entities;
+	unsigned int num_subdevs;
+
+	/* Protects to m2m context data */
+	struct mutex lock;
+
+	/* Protects vb2_v4l2_buffer data */
+	spinlock_t queued_lock;
+	struct xvip_m2m_dma *dma;
+	struct v4l2_m2m_dev *m2m_dev;
+	u32 v4l2_caps;
+};
+
+static inline struct xvip_pipeline *to_xvip_pipeline(struct media_entity *e)
+{
+	return container_of(media_entity_pipeline(e), struct xvip_pipeline, pipe);
+}
+
+/**
+ * struct xvip_m2m_dma - Video DMA channel
+ * @video: V4L2 video device associated with the DMA channel
+ * @xdev: composite mem2mem device the DMA channels belongs to
+ * @chan_tx: DMA engine channel for MEM2DEV transfer
+ * @chan_rx: DMA engine channel for DEV2MEM transfer
+ * @outfmt: active V4L2 OUTPUT port pixel format
+ * @capfmt: active V4L2 CAPTURE port pixel format
+ * @r: crop rectangle parameters
+ * @outinfo: format information corresponding to the active @outfmt
+ * @capinfo: format information corresponding to the active @capfmt
+ * @align: transfer alignment required by the DMA channel (in bytes)
+ * @crop: boolean flag to indicate if crop is requested
+ * @pads: media pads for the video M2M device entity
+ * @pipe: pipeline belonging to the DMA channel
+ */
+struct xvip_m2m_dma {
+	struct video_device video;
+	struct xvip_m2m_dev *xdev;
+	struct dma_chan *chan_tx;
+	struct dma_chan *chan_rx;
+	struct v4l2_format outfmt;
+	struct v4l2_format capfmt;
+	struct v4l2_rect r;
+	const struct xvip_video_format *outinfo;
+	const struct xvip_video_format *capinfo;
+	u32 align;
+	bool crop;
+
+	struct media_pad pads[2];
+	struct xvip_pipeline pipe;
+};
+
+/**
+ * struct xvip_m2m_ctx - VIPP mem2mem context
+ * @fh: V4L2 file handler
+ * @xdev: composite mem2mem device the DMA channels belongs to
+ * @xt: dma interleaved template for dma configuration
+ * @sgl: data chunk structure for dma_interleaved_template
+ */
+struct xvip_m2m_ctx {
+	struct v4l2_fh fh;
+	struct xvip_m2m_dev *xdev;
+	struct dma_interleaved_template xt;
+	struct data_chunk sgl[1];
+};
+
+static inline struct xvip_m2m_ctx *file2ctx(struct file *file)
+{
+	return container_of(file->private_data, struct xvip_m2m_ctx, fh);
+}
+
+static struct v4l2_subdev *
+xvip_dma_remote_subdev(struct media_pad *local, u32 *pad)
+{
+	struct media_pad *remote;
+
+	remote = media_pad_remote_pad_first(local);
+	if (!remote || !is_media_entity_v4l2_subdev(remote->entity))
+		return NULL;
+
+	if (pad)
+		*pad = remote->index;
+
+	return media_entity_to_v4l2_subdev(remote->entity);
+}
+
+static int xvip_dma_verify_format(struct xvip_m2m_dma *dma)
+{
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *subdev;
+	int ret;
+	int width, height;
+
+	subdev = xvip_dma_remote_subdev(&dma->pads[XVIP_PAD_SOURCE], &fmt.pad);
+	if (!subdev)
+		return -EPIPE;
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+	if (ret < 0)
+		return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+	if (dma->outinfo->code != fmt.format.code)
+		return -EINVAL;
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(dma->outfmt.type)) {
+		width = dma->outfmt.fmt.pix_mp.width;
+		height = dma->outfmt.fmt.pix_mp.height;
+	} else {
+		width = dma->outfmt.fmt.pix.width;
+		height = dma->outfmt.fmt.pix.height;
+	}
+
+	if (width != fmt.format.width || height != fmt.format.height)
+		return -EINVAL;
+
+	return 0;
+}
+
+#define to_xvip_dma(vdev)	container_of(vdev, struct xvip_m2m_dma, video)
+/* -----------------------------------------------------------------------------
+ * Pipeline Stream Management
+ */
+
+/**
+ * xvip_subdev_set_streaming - Find and update streaming status of subdev
+ * @xdev: Composite video device
+ * @subdev: V4L2 sub-device
+ * @enable: enable/disable streaming status
+ *
+ * Walk the xvip graph entities list and find if subdev is present. Returns
+ * streaming status of subdev and update the status as requested
+ *
+ * Return: streaming status (true or false) if successful or warn_on if subdev
+ * is not present and return false
+ */
+static bool xvip_subdev_set_streaming(struct xvip_m2m_dev *xdev,
+				      struct v4l2_subdev *subdev, bool enable)
+{
+	struct xvip_graph_entity *entity;
+
+	list_for_each_entry(entity, &xdev->entities, list)
+		if (entity->node == subdev->dev->of_node) {
+			bool status = entity->streaming;
+
+			entity->streaming = enable;
+			return status;
+		}
+
+	WARN(1, "Should never get here\n");
+	return false;
+}
+
+static int xvip_entity_start_stop(struct xvip_m2m_dev *xdev,
+				  struct media_entity *entity, bool start)
+{
+	struct v4l2_subdev *subdev;
+	bool is_streaming;
+	int ret = 0;
+
+	dev_dbg(xdev->dev, "%s entity %s\n",
+		start ? "Starting" : "Stopping", entity->name);
+	subdev = media_entity_to_v4l2_subdev(entity);
+
+	/* This is to maintain list of stream on/off devices */
+	is_streaming = xvip_subdev_set_streaming(xdev, subdev, start);
+
+	/*
+	 * start or stop the subdev only once in case if they are
+	 * shared between sub-graphs
+	 */
+	if (start && !is_streaming) {
+		/* power-on subdevice */
+		ret = v4l2_subdev_call(subdev, core, s_power, 1);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(xdev->dev,
+				"s_power on failed on subdev\n");
+			xvip_subdev_set_streaming(xdev, subdev, 0);
+			return ret;
+		}
+
+		/* stream-on subdevice */
+		ret = v4l2_subdev_call(subdev, video, s_stream, 1);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(xdev->dev,
+				"s_stream on failed on subdev\n");
+			v4l2_subdev_call(subdev, core, s_power, 0);
+			xvip_subdev_set_streaming(xdev, subdev, 0);
+		}
+	} else if (!start && is_streaming) {
+		/* stream-off subdevice */
+		ret = v4l2_subdev_call(subdev, video, s_stream, 0);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(xdev->dev,
+				"s_stream off failed on subdev\n");
+			xvip_subdev_set_streaming(xdev, subdev, 1);
+		}
+
+		/* power-off subdevice */
+		ret = v4l2_subdev_call(subdev, core, s_power, 0);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			dev_err(xdev->dev,
+				"s_power off failed on subdev\n");
+	}
+
+	return ret;
+}
+
+/**
+ * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
+ * @xdev: Composite video device
+ * @dma: xvip dma
+ * @start: Start (when true) or stop (when false) the pipeline
+ *
+ * Walk the entities chain starting @dma and start or stop all of them
+ *
+ * Return: 0 if successful, or the return value of the failed video::s_stream
+ * operation otherwise.
+ */
+static int xvip_pipeline_start_stop(struct xvip_m2m_dev *xdev,
+				    struct xvip_m2m_dma *dma, bool start)
+{
+	struct media_graph graph;
+	struct media_entity *entity = &dma->video.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct xventity_list *temp, *_temp;
+	LIST_HEAD(ent_list);
+	int ret = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	/* Walk the graph to locate the subdev nodes */
+	ret = media_graph_walk_init(&graph, mdev);
+	if (ret)
+		goto error;
+
+	media_graph_walk_start(&graph, entity);
+
+	/* get the list of entities */
+	while ((entity = media_graph_walk_next(&graph))) {
+		struct xventity_list *ele;
+
+		/* We want to stream on/off only subdevs */
+		if (!is_media_entity_v4l2_subdev(entity))
+			continue;
+
+		/* Maintain the pipeline sequence in a list */
+		ele = kzalloc(sizeof(*ele), GFP_KERNEL);
+		if (!ele) {
+			ret = -ENOMEM;
+			goto error;
+		}
+
+		ele->entity = entity;
+		list_add(&ele->list, &ent_list);
+	}
+
+	if (start) {
+		list_for_each_entry_safe(temp, _temp, &ent_list, list) {
+			/* Enable all subdevs from sink to source */
+			ret = xvip_entity_start_stop(xdev, temp->entity, start);
+			if (ret < 0) {
+				dev_err(xdev->dev, "ret = %d for entity %s\n",
+					ret, temp->entity->name);
+				break;
+			}
+		}
+	} else {
+		list_for_each_entry_safe_reverse(temp, _temp, &ent_list, list)
+			/* Enable all subdevs from source to sink */
+			xvip_entity_start_stop(xdev, temp->entity, start);
+	}
+
+	list_for_each_entry_safe(temp, _temp, &ent_list, list) {
+		list_del(&temp->list);
+		kfree(temp);
+	}
+
+error:
+	mutex_unlock(&mdev->graph_mutex);
+	media_graph_walk_cleanup(&graph);
+	return ret;
+}
+
+/**
+ * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
+ * @pipe: The pipeline
+ * @on: Turn the stream on when true or off when false
+ *
+ * The pipeline is shared between all DMA engines connect at its input and
+ * output. While the stream state of DMA engines can be controlled
+ * independently, pipelines have a shared stream state that enable or disable
+ * all entities in the pipeline. For this reason the pipeline uses a streaming
+ * counter that tracks the number of DMA engines that have requested the stream
+ * to be enabled. This will walk the graph starting from each DMA and enable or
+ * disable the entities in the path.
+ *
+ * When called with the @on argument set to true, this function will increment
+ * the pipeline streaming count. If the streaming count reaches the number of
+ * DMA engines in the pipeline it will enable all entities that belong to the
+ * pipeline.
+ *
+ * Similarly, when called with the @on argument set to false, this function will
+ * decrement the pipeline streaming count and disable all entities in the
+ * pipeline when the streaming count reaches zero.
+ *
+ * Return: 0 if successful, or the return value of the failed video::s_stream
+ * operation otherwise. Stopping the pipeline never fails. The pipeline state is
+ * not updated when the operation fails.
+ */
+static int xvip_pipeline_set_stream(struct xvip_pipeline *pipe, bool on)
+{
+	struct xvip_m2m_dev *xdev;
+	struct xvip_m2m_dma *dma;
+	int ret = 0;
+
+	mutex_lock(&pipe->lock);
+	xdev = pipe->xdev;
+	dma = xdev->dma;
+
+	if (on) {
+		ret = xvip_pipeline_start_stop(xdev, dma, true);
+		if (ret < 0)
+			goto done;
+		pipe->stream_count++;
+	} else {
+		if (--pipe->stream_count == 0)
+			xvip_pipeline_start_stop(xdev, dma, false);
+	}
+
+done:
+	mutex_unlock(&pipe->lock);
+	return ret;
+}
+
+static int xvip_pipeline_validate(struct xvip_pipeline *pipe,
+				  struct xvip_m2m_dma *start)
+{
+	struct media_graph graph;
+	struct media_entity *entity = &start->video.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	unsigned int num_inputs = 0;
+	unsigned int num_outputs = 0;
+	int ret;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	/* Walk the graph to locate the video nodes. */
+	ret = media_graph_walk_init(&graph, mdev);
+	if (ret) {
+		mutex_unlock(&mdev->graph_mutex);
+		return ret;
+	}
+
+	media_graph_walk_start(&graph, entity);
+
+	while ((entity = media_graph_walk_next(&graph))) {
+		if (entity->function != MEDIA_ENT_F_IO_V4L)
+			continue;
+
+		num_outputs++;
+		num_inputs++;
+	}
+
+	mutex_unlock(&mdev->graph_mutex);
+
+	media_graph_walk_cleanup(&graph);
+
+	/* We need at least one DMA to proceed */
+	if (num_outputs == 0 && num_inputs == 0)
+		return -EPIPE;
+
+	pipe->num_dmas = num_inputs + num_outputs;
+	pipe->xdev = start->xdev;
+
+	return 0;
+}
+
+static void __xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
+{
+	pipe->num_dmas = 0;
+}
+
+/**
+ * xvip_pipeline_cleanup - Cleanup the pipeline after streaming
+ * @pipe: the pipeline
+ *
+ * Decrease the pipeline use count and clean it up if we were the last user.
+ */
+static void xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
+{
+	mutex_lock(&pipe->lock);
+
+	/* If we're the last user clean up the pipeline. */
+	if (--pipe->use_count == 0)
+		__xvip_pipeline_cleanup(pipe);
+
+	mutex_unlock(&pipe->lock);
+}
+
+/**
+ * xvip_pipeline_prepare - Prepare the pipeline for streaming
+ * @pipe: the pipeline
+ * @dma: DMA engine at one end of the pipeline
+ *
+ * Validate the pipeline if no user exists yet, otherwise just increase the use
+ * count.
+ *
+ * Return: 0 if successful or -EPIPE if the pipeline is not valid.
+ */
+static int xvip_pipeline_prepare(struct xvip_pipeline *pipe,
+				 struct xvip_m2m_dma *dma)
+{
+	int ret;
+
+	mutex_lock(&pipe->lock);
+
+	/* If we're the first user validate and initialize the pipeline. */
+	if (pipe->use_count == 0) {
+		ret = xvip_pipeline_validate(pipe, dma);
+		if (ret < 0) {
+			__xvip_pipeline_cleanup(pipe);
+			goto done;
+		}
+	}
+
+	pipe->use_count++;
+	ret = 0;
+
+done:
+	mutex_unlock(&pipe->lock);
+	return ret;
+}
+
+static void xvip_m2m_dma_callback_mem2dev(void *data)
+{
+}
+
+static void xvip_m2m_dma_callback(void *data)
+{
+	struct xvip_m2m_ctx *ctx = data;
+	struct xvip_m2m_dev *xdev = ctx->xdev;
+	struct vb2_v4l2_buffer *src_vb, *dst_vb;
+
+	spin_lock(&xdev->queued_lock);
+	src_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+	dst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+
+	dst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;
+	dst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;
+	dst_vb->flags |=
+		src_vb->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;
+	dst_vb->timecode = src_vb->timecode;
+
+	v4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);
+	v4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);
+	v4l2_m2m_job_finish(xdev->m2m_dev, ctx->fh.m2m_ctx);
+	spin_unlock(&xdev->queued_lock);
+}
+
+/*
+ * Queue operations
+ */
+
+static int xvip_m2m_queue_setup(struct vb2_queue *vq,
+				u32 *nbuffers, u32 *nplanes,
+				u32 sizes[], struct device *alloc_devs[])
+{
+	struct xvip_m2m_ctx *ctx = vb2_get_drv_priv(vq);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct v4l2_format *f;
+	const struct xvip_video_format *info;
+	u32 i;
+
+	if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		f = &dma->outfmt;
+		info = dma->outinfo;
+	} else {
+		f = &dma->capfmt;
+		info = dma->capinfo;
+	}
+
+	if (*nplanes) {
+		if (*nplanes != f->fmt.pix_mp.num_planes)
+			return -EINVAL;
+
+		for (i = 0; i < *nplanes; i++) {
+			if (sizes[i] < f->fmt.pix_mp.plane_fmt[i].sizeimage)
+				return -EINVAL;
+		}
+	} else {
+		*nplanes = info->buffers;
+		for (i = 0; i < info->buffers; i++)
+			sizes[i] = f->fmt.pix_mp.plane_fmt[i].sizeimage;
+	}
+
+	return 0;
+}
+
+static int xvip_m2m_buf_prepare(struct vb2_buffer *vb)
+{
+	struct xvip_m2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct v4l2_format *f;
+	const struct xvip_video_format *info;
+	u32 i;
+
+	if (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		f = &dma->outfmt;
+		info = dma->outinfo;
+	} else {
+		f = &dma->capfmt;
+		info = dma->capinfo;
+	}
+
+	for (i = 0; i < info->buffers; i++) {
+		if (vb2_plane_size(vb, i) <
+			f->fmt.pix_mp.plane_fmt[i].sizeimage) {
+			dev_err(ctx->xdev->dev,
+				"insufficient plane size (%u < %u)\n",
+				(u32)vb2_plane_size(vb, i),
+				f->fmt.pix_mp.plane_fmt[i].sizeimage);
+			return -EINVAL;
+		}
+
+		vb2_set_plane_payload(vb, i,
+				      f->fmt.pix_mp.plane_fmt[i].sizeimage);
+	}
+
+	return 0;
+}
+
+static void xvip_m2m_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct xvip_m2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+}
+
+static void xvip_m2m_stop_streaming(struct vb2_queue *q)
+{
+	struct xvip_m2m_ctx *ctx = vb2_get_drv_priv(q);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct xvip_pipeline *pipe = to_xvip_pipeline(&dma->video.entity);
+	struct vb2_v4l2_buffer *vbuf;
+
+	dma->crop = false;
+	if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		dmaengine_terminate_sync(dma->chan_tx);
+	else
+		dmaengine_terminate_sync(dma->chan_rx);
+
+	if (ctx->xdev->num_subdevs) {
+		/* Stop the pipeline. */
+		xvip_pipeline_set_stream(pipe, false);
+
+		/* Cleanup the pipeline and mark it as being stopped. */
+		xvip_pipeline_cleanup(pipe);
+		media_pipeline_stop(dma->video.entity.pads);
+	}
+
+	for (;;) {
+		if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+			vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+		else
+			vbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+
+		if (!vbuf)
+			return;
+
+		spin_lock(&ctx->xdev->queued_lock);
+		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
+		spin_unlock(&ctx->xdev->queued_lock);
+	}
+}
+
+static int xvip_m2m_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct xvip_m2m_ctx *ctx = vb2_get_drv_priv(q);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct xvip_m2m_dev *xdev = ctx->xdev;
+	struct xvip_pipeline *pipe;
+	int ret;
+
+	if (!xdev->num_subdevs)
+		return 0;
+
+	pipe = media_entity_pipeline(&dma->video.entity)
+	     ? to_xvip_pipeline(&dma->video.entity) : &dma->pipe;
+
+	ret = media_pipeline_start(dma->video.entity.pads, &pipe->pipe);
+	if (ret < 0)
+		goto error;
+
+	/* Verify that the configured format matches the output of the
+	 * connected subdev.
+	 */
+	ret = xvip_dma_verify_format(dma);
+	if (ret < 0)
+		goto error_stop;
+
+	ret = xvip_pipeline_prepare(pipe, dma);
+	if (ret < 0)
+		goto error_stop;
+
+	/* Start the pipeline. */
+	ret = xvip_pipeline_set_stream(pipe, true);
+	if (ret < 0)
+		goto error_stop;
+
+	return 0;
+error_stop:
+	media_pipeline_stop(dma->video.entity.pads);
+
+error:
+	xvip_m2m_stop_streaming(q);
+
+	return ret;
+}
+
+static const struct vb2_ops m2m_vb2_ops = {
+	.queue_setup = xvip_m2m_queue_setup,
+	.buf_prepare = xvip_m2m_buf_prepare,
+	.buf_queue = xvip_m2m_buf_queue,
+	.start_streaming = xvip_m2m_start_streaming,
+	.stop_streaming = xvip_m2m_stop_streaming,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+};
+
+static int xvip_m2m_queue_init(void *priv, struct vb2_queue *src_vq,
+			       struct vb2_queue *dst_vq)
+{
+	struct xvip_m2m_ctx *ctx = priv;
+	int ret;
+
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	src_vq->drv_priv = ctx;
+	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	src_vq->ops = &m2m_vb2_ops;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->dev = ctx->xdev->v4l2_dev.dev;
+
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	dst_vq->drv_priv = ctx;
+	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	dst_vq->ops = &m2m_vb2_ops;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->dev = ctx->xdev->v4l2_dev.dev;
+
+	return vb2_queue_init(dst_vq);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 ioctls
+ */
+
+static int
+xvip_dma_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
+{
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	strlcpy(cap->driver, XVIP_M2M_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, XVIP_M2M_NAME, sizeof(cap->card));
+	strlcpy(cap->bus_info, XVIP_M2M_NAME, sizeof(cap->card));
+
+	return 0;
+}
+
+static int
+xvip_m2m_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)
+{
+	struct xvip_m2m_ctx *ctx = file2ctx(file);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	const struct xvip_video_format *fmtinfo;
+	const struct xvip_video_format *fmt;
+	struct v4l2_subdev *subdev;
+	struct v4l2_subdev_format v4l_fmt;
+	struct xvip_m2m_dev *xdev = ctx->xdev;
+	u32 i, fmt_cnt, *fmts;
+	int ret;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		ret = xilinx_xdma_get_v4l2_vid_fmts(dma->chan_rx,
+						    &fmt_cnt, &fmts);
+	else
+		ret = xilinx_xdma_get_v4l2_vid_fmts(dma->chan_tx,
+						    &fmt_cnt, &fmts);
+	if (ret)
+		return ret;
+
+	if (f->index >= fmt_cnt)
+		return -EINVAL;
+
+	if (!xdev->num_subdevs) {
+		fmt = xvip_get_format_by_fourcc(fmts[f->index]);
+		if (IS_ERR(fmt))
+			return PTR_ERR(fmt);
+
+		f->pixelformat = fmt->fourcc;
+		return 0;
+	}
+
+	if (f->index > 0)
+		return -EINVAL;
+
+	/* Establish media pad format */
+	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		subdev = xvip_dma_remote_subdev(&dma->pads[XVIP_PAD_SOURCE],
+						&v4l_fmt.pad);
+	else
+		subdev = xvip_dma_remote_subdev(&dma->pads[XVIP_PAD_SINK],
+						&v4l_fmt.pad);
+	if (!subdev)
+		return -EPIPE;
+
+	v4l_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &v4l_fmt);
+	if (ret < 0)
+		return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+	for (i = 0; i < fmt_cnt; i++) {
+		fmt = xvip_get_format_by_fourcc(fmts[i]);
+		if (IS_ERR(fmt))
+			return PTR_ERR(fmt);
+
+		if (fmt->code == v4l_fmt.format.code)
+			break;
+	}
+
+	if (i >= fmt_cnt)
+		return -EINVAL;
+
+	fmtinfo = xvip_get_format_by_fourcc(fmts[i]);
+	f->pixelformat = fmtinfo->fourcc;
+
+	return 0;
+}
+
+static int xvip_m2m_get_fmt(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct xvip_m2m_ctx *ctx = file2ctx(file);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct vb2_queue *vq;
+
+	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
+	if (!vq)
+		return -EINVAL;
+
+	if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		f->fmt.pix_mp = dma->outfmt.fmt.pix_mp;
+	else
+		f->fmt.pix_mp = dma->capfmt.fmt.pix_mp;
+
+	return 0;
+}
+
+static int __xvip_m2m_try_fmt(struct xvip_m2m_ctx *ctx, struct v4l2_format *f)
+{
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	const struct xvip_video_format *info;
+	struct v4l2_pix_format_mplane *pix_mp;
+	struct v4l2_plane_pix_format *plane_fmt;
+	u32 align, min_width, max_width;
+	u32 bpl, min_bpl, max_bpl;
+	u32 padding_factor_nume, padding_factor_deno;
+	u32 bpl_nume, bpl_deno;
+	u32 i, plane_width, plane_height;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *subdev;
+	struct xvip_m2m_dev *xdev = ctx->xdev;
+	int ret;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&
+	    f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	if (xdev->num_subdevs) {
+		if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+			subdev = xvip_dma_remote_subdev
+				(&dma->pads[XVIP_PAD_SOURCE], &fmt.pad);
+		else
+			subdev = xvip_dma_remote_subdev
+				(&dma->pads[XVIP_PAD_SINK], &fmt.pad);
+
+		if (!subdev)
+			return -EPIPE;
+
+		fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+		if (ret < 0)
+			return -EINVAL;
+	}
+
+	pix_mp = &f->fmt.pix_mp;
+	plane_fmt = pix_mp->plane_fmt;
+	info = xvip_get_format_by_fourcc(f->fmt.pix_mp.pixelformat);
+	if (info) {
+		if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+			dma->outinfo = info;
+		else
+			dma->capinfo = info;
+	} else {
+		info = xvip_get_format_by_fourcc(XVIP_M2M_DEFAULT_FMT);
+	}
+
+	if (xdev->num_subdevs) {
+		if (info->code != fmt.format.code ||
+		    fmt.format.width != pix_mp->width ||
+		    fmt.format.height != pix_mp->height) {
+			dev_err(xdev->dev, "Failed to set format\n");
+			dev_info(xdev->dev,
+				 "Reqed Code = %d, Width = %d, Height = %d\n",
+				 info->code, pix_mp->width, pix_mp->height);
+			dev_info(xdev->dev,
+				 "Subdev Code = %d, Width = %d, Height = %d",
+				 fmt.format.code, fmt.format.width,
+				 fmt.format.height);
+			return -EINVAL;
+		}
+	}
+
+	xvip_width_padding_factor(info->fourcc, &padding_factor_nume,
+				  &padding_factor_deno);
+	xvip_bpl_scaling_factor(info->fourcc, &bpl_nume, &bpl_deno);
+
+	/*
+	 * V4L2 specification suggests the driver corrects the format struct
+	 * if any of the dimensions is unsupported
+	 */
+	align = lcm(dma->align, info->bpp >> 3);
+	min_width = roundup(XVIP_M2M_MIN_WIDTH, align);
+	max_width = rounddown(XVIP_M2M_MAX_WIDTH, align);
+	pix_mp->width = clamp(pix_mp->width, min_width, max_width);
+	pix_mp->height = clamp(pix_mp->height, XVIP_M2M_MIN_HEIGHT,
+			       XVIP_M2M_MAX_HEIGHT);
+
+	/*
+	 * Clamp the requested bytes per line value. If the maximum
+	 * bytes per line value is zero, the module doesn't support
+	 * user configurable line sizes. Override the requested value
+	 * with the minimum in that case.
+	 */
+	max_bpl = rounddown(XVIP_M2M_MAX_WIDTH, align);
+
+	if (info->buffers == 1) {
+		/* Handling contiguous data with mplanes */
+		min_bpl = (pix_mp->width * info->bpl_factor *
+			   padding_factor_nume * bpl_nume) /
+			   (padding_factor_deno * bpl_deno);
+		min_bpl = roundup(min_bpl, align);
+		bpl = roundup(plane_fmt[0].bytesperline, align);
+		plane_fmt[0].bytesperline = clamp(bpl, min_bpl, max_bpl);
+
+		if (info->num_planes == 1) {
+			/* Single plane formats */
+			plane_fmt[0].sizeimage = plane_fmt[0].bytesperline *
+						 pix_mp->height;
+		} else {
+			/* Multi plane formats in contiguous buffer*/
+			plane_fmt[0].sizeimage =
+				DIV_ROUND_UP(plane_fmt[0].bytesperline *
+					     pix_mp->height *
+					     info->bpp, 8);
+		}
+	} else {
+		/* Handling non-contiguous data with mplanes */
+		for (i = 0; i < info->num_planes; i++) {
+			plane_width = pix_mp->width / (i ? info->hsub : 1);
+			plane_height = pix_mp->height / (i ? info->vsub : 1);
+			min_bpl = (plane_width * info->bpl_factor *
+				   padding_factor_nume * bpl_nume) /
+				   (padding_factor_deno * bpl_deno);
+			min_bpl = roundup(min_bpl, align);
+			bpl = rounddown(plane_fmt[i].bytesperline, align);
+			plane_fmt[i].bytesperline = clamp(bpl, min_bpl,
+							  max_bpl);
+			plane_fmt[i].sizeimage = plane_fmt[i].bytesperline *
+						 plane_height;
+		}
+	}
+
+	return 0;
+}
+
+static int xvip_m2m_try_fmt(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct xvip_m2m_ctx *ctx = file2ctx(file);
+	int ret;
+
+	ret = __xvip_m2m_try_fmt(ctx, f);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int xvip_m2m_set_fmt(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct xvip_m2m_ctx *ctx = file2ctx(file);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct vb2_queue *vq;
+	int ret;
+
+	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
+	if (!vq)
+		return -EINVAL;
+
+	if (vb2_is_busy(vq)) {
+		v4l2_err(&ctx->xdev->v4l2_dev, "%s queue busy\n", __func__);
+		return -EBUSY;
+	}
+
+	ret = __xvip_m2m_try_fmt(ctx, f);
+	if (ret < 0)
+		return ret;
+
+	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		dma->outfmt.fmt.pix_mp = f->fmt.pix_mp;
+	else
+		dma->capfmt.fmt.pix_mp = f->fmt.pix_mp;
+
+	return 0;
+}
+
+static int
+xvip_m2m_g_selection(struct file *file, void *fh, struct v4l2_selection *s)
+{
+	struct xvip_m2m_ctx *ctx = file2ctx(file);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	int ret = 0;
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_COMPOSE:
+		ret = -ENOTTY;
+		break;
+	case V4L2_SEL_TGT_CROP:
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = dma->r.width;
+		s->r.height = dma->r.height;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int
+xvip_m2m_s_selection(struct file *file, void *fh, struct v4l2_selection *s)
+{
+	struct xvip_m2m_ctx *ctx = file2ctx(file);
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	u32 min_width, max_width;
+	int ret = 0;
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_COMPOSE:
+		ret = -ENOTTY;
+		break;
+	case V4L2_SEL_TGT_CROP:
+		if (s->r.width > dma->outfmt.fmt.pix_mp.width ||
+		    s->r.height > dma->outfmt.fmt.pix_mp.height ||
+		    s->r.top != 0 || s->r.left != 0)
+			return -EINVAL;
+
+		dma->crop = true;
+		min_width = roundup(XVIP_M2M_MIN_WIDTH, dma->align);
+		max_width = rounddown(XVIP_M2M_MAX_WIDTH, dma->align);
+		dma->r.width = clamp(s->r.width, min_width, max_width);
+		dma->r.height = s->r.height;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ioctl_ops xvip_m2m_ioctl_ops = {
+	.vidioc_querycap		= xvip_dma_querycap,
+
+	.vidioc_enum_fmt_vid_cap	= xvip_m2m_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane	= xvip_m2m_get_fmt,
+	.vidioc_try_fmt_vid_cap_mplane	= xvip_m2m_try_fmt,
+	.vidioc_s_fmt_vid_cap_mplane	= xvip_m2m_set_fmt,
+
+	.vidioc_enum_fmt_vid_out	= xvip_m2m_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane	= xvip_m2m_get_fmt,
+	.vidioc_try_fmt_vid_out_mplane	= xvip_m2m_try_fmt,
+	.vidioc_s_fmt_vid_out_mplane	= xvip_m2m_set_fmt,
+	.vidioc_s_selection		= xvip_m2m_s_selection,
+	.vidioc_g_selection		= xvip_m2m_g_selection,
+
+	.vidioc_reqbufs			= v4l2_m2m_ioctl_reqbufs,
+	.vidioc_querybuf		= v4l2_m2m_ioctl_querybuf,
+	.vidioc_qbuf			= v4l2_m2m_ioctl_qbuf,
+	.vidioc_dqbuf			= v4l2_m2m_ioctl_dqbuf,
+	.vidioc_prepare_buf		= v4l2_m2m_ioctl_prepare_buf,
+	.vidioc_create_bufs		= v4l2_m2m_ioctl_create_bufs,
+	.vidioc_expbuf			= v4l2_m2m_ioctl_expbuf,
+
+	.vidioc_streamon		= v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff		= v4l2_m2m_ioctl_streamoff,
+};
+
+/*
+ * File operations
+ */
+static int xvip_m2m_open(struct file *file)
+{
+	struct xvip_m2m_dev *xdev = video_drvdata(file);
+	struct xvip_m2m_ctx *ctx = NULL;
+	int ret;
+
+	ctx = devm_kzalloc(xdev->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+	ctx->xdev = xdev;
+
+	ctx->fh.m2m_ctx = v4l2_m2m_ctx_init(xdev->m2m_dev, ctx,
+					    &xvip_m2m_queue_init);
+	if (IS_ERR(ctx->fh.m2m_ctx)) {
+		ret = PTR_ERR(ctx->fh.m2m_ctx);
+		v4l2_fh_exit(&ctx->fh);
+		return ret;
+	}
+
+	v4l2_fh_add(&ctx->fh);
+	dev_info(xdev->dev, "Created instance %p, m2m_ctx: %p\n", ctx,
+		 ctx->fh.m2m_ctx);
+	return 0;
+}
+
+static int xvip_m2m_release(struct file *file)
+{
+	struct xvip_m2m_ctx *ctx = file->private_data;
+
+	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
+	return 0;
+}
+
+static u32 xvip_m2m_poll(struct file *file,
+			 struct poll_table_struct *wait)
+{
+	struct xvip_m2m_ctx *ctx = file->private_data;
+	int ret;
+
+	mutex_lock(&ctx->xdev->lock);
+	ret = v4l2_m2m_poll(file, ctx->fh.m2m_ctx, wait);
+	mutex_unlock(&ctx->xdev->lock);
+
+	return ret;
+}
+
+static int xvip_m2m_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct xvip_m2m_ctx *ctx = file->private_data;
+
+	return v4l2_m2m_mmap(file, ctx->fh.m2m_ctx, vma);
+}
+
+/*
+ * mem2mem callbacks
+ */
+
+static int xvip_m2m_job_ready(void *priv)
+{
+	struct xvip_m2m_ctx *ctx = priv;
+
+	if ((v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) > 0) &&
+	    (v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) > 0))
+		return 1;
+
+	return 0;
+}
+
+static void xvip_m2m_job_abort(void *priv)
+{
+	struct xvip_m2m_ctx *ctx = priv;
+
+	/* Will cancel the transaction in the next interrupt handler */
+	v4l2_m2m_job_finish(ctx->xdev->m2m_dev, ctx->fh.m2m_ctx);
+}
+
+static void xvip_m2m_prep_submit_dev2mem_desc(struct xvip_m2m_ctx *ctx,
+					      struct vb2_v4l2_buffer *dst_buf)
+{
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct xvip_m2m_dev *xdev = ctx->xdev;
+	struct dma_async_tx_descriptor *desc;
+	dma_addr_t p_out;
+	const struct xvip_video_format *info;
+	struct v4l2_pix_format_mplane *pix_mp;
+	u32 padding_factor_nume, padding_factor_deno;
+	u32 bpl_nume, bpl_deno;
+	u32 luma_size;
+	u32 flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
+	enum operation_mode mode = DEFAULT;
+	u32 bpl, dst_width, dst_height;
+
+	p_out = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);
+
+	if (!p_out) {
+		dev_err(xdev->dev,
+			"Acquiring kernel pointer to buffer failed\n");
+		return;
+	}
+
+	ctx->xt.dir = DMA_DEV_TO_MEM;
+	ctx->xt.src_sgl = false;
+	ctx->xt.dst_sgl = true;
+	ctx->xt.dst_start = p_out;
+
+	pix_mp = &dma->capfmt.fmt.pix_mp;
+	bpl = pix_mp->plane_fmt[0].bytesperline;
+	if (dma->crop) {
+		dst_width = dma->r.width;
+		dst_height = dma->r.height;
+	} else {
+		dst_width = pix_mp->width;
+		dst_height = pix_mp->height;
+	}
+
+	info = dma->capinfo;
+	xilinx_xdma_set_mode(dma->chan_rx, mode);
+	xilinx_xdma_v4l2_config(dma->chan_rx, pix_mp->pixelformat);
+	xvip_width_padding_factor(pix_mp->pixelformat, &padding_factor_nume,
+				  &padding_factor_deno);
+	xvip_bpl_scaling_factor(pix_mp->pixelformat, &bpl_nume, &bpl_deno);
+
+	ctx->xt.frame_size = info->num_planes;
+	ctx->sgl[0].size = (dst_width * info->bpl_factor *
+			    padding_factor_nume * bpl_nume) /
+			    (padding_factor_deno * bpl_deno);
+	ctx->sgl[0].icg = bpl - ctx->sgl[0].size;
+	ctx->xt.numf = dst_height;
+
+	/*
+	 * dst_icg is the number of bytes to jump after last luma addr
+	 * and before first chroma addr
+	 */
+	ctx->sgl[0].src_icg = 0;
+
+	if (info->buffers == 1) {
+		/* Handling contiguous data with mplanes */
+		ctx->sgl[0].dst_icg = 0;
+		if (dma->crop)
+			ctx->sgl[0].dst_icg = bpl *
+					      (pix_mp->height - dst_height);
+	} else {
+		/* Handling non-contiguous data with mplanes */
+		if (info->buffers == 2) {
+			dma_addr_t chroma_cap =
+			vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 1);
+			luma_size = pix_mp->plane_fmt[0].bytesperline *
+				    ctx->xt.numf;
+			if (chroma_cap > p_out)
+				ctx->sgl[0].dst_icg = chroma_cap - p_out -
+						      luma_size;
+			}
+	}
+
+	desc = dmaengine_prep_interleaved_dma(dma->chan_rx, &ctx->xt, flags);
+	if (!desc) {
+		dev_err(xdev->dev, "Failed to prepare DMA rx transfer\n");
+		return;
+	}
+
+	desc->callback = xvip_m2m_dma_callback;
+	desc->callback_param = ctx;
+	dmaengine_submit(desc);
+	dma_async_issue_pending(dma->chan_rx);
+}
+
+static void xvip_m2m_prep_submit_mem2dev_desc(struct xvip_m2m_ctx *ctx,
+					      struct vb2_v4l2_buffer *src_buf)
+{
+	struct xvip_m2m_dma *dma = ctx->xdev->dma;
+	struct xvip_m2m_dev *xdev = ctx->xdev;
+	struct dma_async_tx_descriptor *desc;
+	dma_addr_t p_in;
+	const struct xvip_video_format *info;
+	struct v4l2_pix_format_mplane *pix_mp;
+	u32 padding_factor_nume, padding_factor_deno;
+	u32 bpl_nume, bpl_deno;
+	u32 luma_size;
+	u32 flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
+	enum operation_mode mode = DEFAULT;
+	u32 bpl, src_width, src_height;
+
+	p_in = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);
+
+	if (!p_in) {
+		dev_err(xdev->dev,
+			"Acquiring kernel pointer to buffer failed\n");
+		return;
+	}
+
+	ctx->xt.dir = DMA_MEM_TO_DEV;
+	ctx->xt.src_sgl = true;
+	ctx->xt.dst_sgl = false;
+	ctx->xt.src_start = p_in;
+
+	pix_mp = &dma->outfmt.fmt.pix_mp;
+	bpl = pix_mp->plane_fmt[0].bytesperline;
+	if (dma->crop) {
+		src_width = dma->r.width;
+		src_height = dma->r.height;
+	} else {
+		src_width = pix_mp->width;
+		src_height = pix_mp->height;
+	}
+
+	info = dma->outinfo;
+	xilinx_xdma_set_mode(dma->chan_tx, mode);
+	xilinx_xdma_v4l2_config(dma->chan_tx, pix_mp->pixelformat);
+	xvip_width_padding_factor(pix_mp->pixelformat, &padding_factor_nume,
+				  &padding_factor_deno);
+	xvip_bpl_scaling_factor(pix_mp->pixelformat, &bpl_nume, &bpl_deno);
+
+	ctx->xt.frame_size = info->num_planes;
+	ctx->sgl[0].size = (src_width * info->bpl_factor *
+			    padding_factor_nume * bpl_nume) /
+			    (padding_factor_deno * bpl_deno);
+	ctx->sgl[0].icg = bpl - ctx->sgl[0].size;
+	ctx->xt.numf = src_height;
+
+	/*
+	 * src_icg is the number of bytes to jump after last luma addr
+	 * and before first chroma addr
+	 */
+	ctx->sgl[0].dst_icg = 0;
+
+	if (info->buffers == 1) {
+		/* Handling contiguous data with mplanes */
+		ctx->sgl[0].src_icg = 0;
+		if (dma->crop)
+			ctx->sgl[0].src_icg = bpl *
+					      (pix_mp->height - src_height);
+	} else {
+		/* Handling non-contiguous data with mplanes */
+		if (info->buffers == 2) {
+			dma_addr_t chroma_out =
+			vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 1);
+			luma_size = bpl * ctx->xt.numf;
+			if (chroma_out > p_in)
+				ctx->sgl[0].src_icg = chroma_out - p_in -
+						      luma_size;
+			}
+	}
+
+	desc = dmaengine_prep_interleaved_dma(dma->chan_tx, &ctx->xt, flags);
+	if (!desc) {
+		dev_err(xdev->dev, "Failed to prepare DMA tx transfer\n");
+		return;
+	}
+
+	desc->callback = xvip_m2m_dma_callback_mem2dev;
+	desc->callback_param = ctx;
+	dmaengine_submit(desc);
+	dma_async_issue_pending(dma->chan_tx);
+}
+
+/**
+ * xvip_m2m_device_run - prepares and starts the device
+ *
+ * @priv: Instance private data
+ *
+ * This simulates all the immediate preparations required before starting
+ * a device. This will be called by the framework when it decides to schedule
+ * a particular instance.
+ */
+static void xvip_m2m_device_run(void *priv)
+{
+	struct xvip_m2m_ctx *ctx = priv;
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+
+	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+	dst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);
+
+	/* Prepare and submit mem2dev transaction */
+	xvip_m2m_prep_submit_mem2dev_desc(ctx, src_buf);
+
+	/* Prepare and submit dev2mem transaction */
+	xvip_m2m_prep_submit_dev2mem_desc(ctx, dst_buf);
+}
+
+static const struct v4l2_file_operations xvip_m2m_fops = {
+	.owner		= THIS_MODULE,
+	.open		= xvip_m2m_open,
+	.release	= xvip_m2m_release,
+	.poll		= xvip_m2m_poll,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap		= xvip_m2m_mmap,
+};
+
+static struct video_device xvip_m2m_videodev = {
+	.name		= XVIP_M2M_NAME,
+	.fops		= &xvip_m2m_fops,
+	.ioctl_ops	= &xvip_m2m_ioctl_ops,
+	.release	= video_device_release_empty,
+	.vfl_dir	= VFL_DIR_M2M,
+	.device_caps	= V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING,
+	.vfl_type	= VFL_TYPE_VIDEO,
+};
+
+static const struct v4l2_m2m_ops xvip_m2m_ops = {
+	.device_run	= xvip_m2m_device_run,
+	.job_ready	= xvip_m2m_job_ready,
+	.job_abort	= xvip_m2m_job_abort,
+};
+
+/*
+ * This function is taken from the framework
+ * video_register_media_controller() function
+ */
+static int xvideo_register_media_controller(struct video_device *vdev)
+{
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	u32 intf_type;
+	int ret;
+
+	/*
+	 * Modified this by removing the condition for VFL_DIR_M2M
+	 * to ensure that the video entity is created.
+	 */
+	if (!vdev->v4l2_dev->mdev)
+		return 0;
+
+	vdev->entity.obj_type = MEDIA_ENTITY_TYPE_VIDEO_DEVICE;
+	vdev->entity.function = MEDIA_ENT_F_UNKNOWN;
+
+	switch (vdev->vfl_type) {
+	case VFL_TYPE_VIDEO:
+		intf_type = MEDIA_INTF_T_V4L_VIDEO;
+		vdev->entity.function = MEDIA_ENT_F_IO_V4L;
+		break;
+	case VFL_TYPE_VBI:
+		intf_type = MEDIA_INTF_T_V4L_VBI;
+		vdev->entity.function = MEDIA_ENT_F_IO_VBI;
+		break;
+	case VFL_TYPE_SDR:
+		intf_type = MEDIA_INTF_T_V4L_SWRADIO;
+		vdev->entity.function = MEDIA_ENT_F_IO_SWRADIO;
+		break;
+	case VFL_TYPE_TOUCH:
+		intf_type = MEDIA_INTF_T_V4L_TOUCH;
+		vdev->entity.function = MEDIA_ENT_F_IO_V4L;
+		break;
+	case VFL_TYPE_RADIO:
+		intf_type = MEDIA_INTF_T_V4L_RADIO;
+		/*
+		 * Radio doesn't have an entity at the V4L2 side to represent
+		 * radio input or output. Instead, the audio input/output goes
+		 * via either physical wires or ALSA.
+		 */
+		break;
+	case VFL_TYPE_SUBDEV:
+		intf_type = MEDIA_INTF_T_V4L_SUBDEV;
+		/* Entity will be created via v4l2_device_register_subdev() */
+		break;
+	default:
+		return 0;
+	}
+
+	if (vdev->entity.function != MEDIA_ENT_F_UNKNOWN) {
+		vdev->entity.name = vdev->name;
+
+		/* Needed just for backward compatibility with legacy MC API */
+		vdev->entity.info.dev.major = VIDEO_MAJOR;
+		vdev->entity.info.dev.minor = vdev->minor;
+
+		ret = media_device_register_entity(vdev->v4l2_dev->mdev,
+						   &vdev->entity);
+		if (ret < 0) {
+			pr_warn("%s: media_device_register_entity failed\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	vdev->intf_devnode = media_devnode_create(vdev->v4l2_dev->mdev,
+						  intf_type,
+						  0, VIDEO_MAJOR,
+						  vdev->minor);
+	if (!vdev->intf_devnode) {
+		media_device_unregister_entity(&vdev->entity);
+		return -ENOMEM;
+	}
+
+	if (vdev->entity.function != MEDIA_ENT_F_UNKNOWN) {
+		struct media_link *link;
+
+		link = media_create_intf_link(&vdev->entity,
+					      &vdev->intf_devnode->intf,
+					      MEDIA_LNK_FL_ENABLED |
+					      MEDIA_LNK_FL_IMMUTABLE);
+		if (!link) {
+			media_devnode_remove(vdev->intf_devnode);
+			media_device_unregister_entity(&vdev->entity);
+			return -ENOMEM;
+		}
+	}
+
+	/* FIXME: how to create the other interface links? */
+
+#endif
+	/* This is added from __video_register_device() */
+
+	/* Part 6: Activate this minor. The char device can now be used. */
+	set_bit(V4L2_FL_REGISTERED, &vdev->flags);
+
+	return 0;
+}
+
+static int xvip_m2m_dma_init(struct xvip_m2m_dma *dma)
+{
+	struct xvip_m2m_dev *xdev;
+	struct v4l2_pix_format_mplane *pix_mp;
+	int ret;
+
+	xdev = dma->xdev;
+	mutex_init(&xdev->lock);
+	mutex_init(&dma->pipe.lock);
+	spin_lock_init(&xdev->queued_lock);
+
+	/* Format info on capture port - NV12 is the default format */
+	dma->capinfo = xvip_get_format_by_fourcc(XVIP_M2M_DEFAULT_FMT);
+	pix_mp = &dma->capfmt.fmt.pix_mp;
+	pix_mp->pixelformat = dma->capinfo->fourcc;
+
+	pix_mp->field = V4L2_FIELD_NONE;
+	pix_mp->width = XVIP_M2M_DEF_WIDTH;
+	pix_mp->height = XVIP_M2M_DEF_HEIGHT;
+	pix_mp->plane_fmt[0].bytesperline = pix_mp->width *
+					    dma->capinfo->bpl_factor;
+	pix_mp->plane_fmt[0].sizeimage =
+			DIV_ROUND_UP(pix_mp->plane_fmt[0].bytesperline *
+				     pix_mp->height * dma->capinfo->bpp, 8);
+
+	/* Format info on output port - NV12 is the default format */
+	dma->outinfo = xvip_get_format_by_fourcc(XVIP_M2M_DEFAULT_FMT);
+	pix_mp = &dma->capfmt.fmt.pix_mp;
+	pix_mp->pixelformat = dma->outinfo->fourcc;
+	pix_mp->field = V4L2_FIELD_NONE;
+	pix_mp->width = XVIP_M2M_DEF_WIDTH;
+	pix_mp->height = XVIP_M2M_DEF_HEIGHT;
+	pix_mp->plane_fmt[0].bytesperline = pix_mp->width *
+					    dma->outinfo->bpl_factor;
+	pix_mp->plane_fmt[0].sizeimage =
+			DIV_ROUND_UP(pix_mp->plane_fmt[0].bytesperline *
+				     pix_mp->height * dma->outinfo->bpp, 8);
+
+	/* DMA channels for mem2mem */
+	dma->chan_tx = dma_request_chan(xdev->dev, "tx");
+	if (IS_ERR(dma->chan_tx)) {
+		ret = PTR_ERR(dma->chan_tx);
+		if (ret != -EPROBE_DEFER)
+			dev_err(xdev->dev, "mem2mem DMA tx channel not found");
+
+		return ret;
+	}
+
+	dma->chan_rx = dma_request_chan(xdev->dev, "rx");
+	if (IS_ERR(dma->chan_rx)) {
+		ret = PTR_ERR(dma->chan_rx);
+		if (ret != -EPROBE_DEFER)
+			dev_err(xdev->dev, "mem2mem DMA rx channel not found");
+
+		goto tx;
+	}
+
+	dma->align = BIT(dma->chan_tx->device->copy_align);
+
+	/* Video node */
+	dma->video = xvip_m2m_videodev;
+	dma->video.v4l2_dev = &xdev->v4l2_dev;
+	dma->video.lock = &xdev->lock;
+
+	dma->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	dma->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&dma->video.entity, 2, dma->pads);
+	if (ret < 0)
+		goto error;
+
+	ret = video_register_device(&dma->video, VFL_TYPE_VIDEO, -1);
+	if (ret < 0) {
+		dev_err(xdev->dev, "Failed to register mem2mem video device\n");
+		goto tx_rx;
+	}
+
+	ret = xvideo_register_media_controller(&dma->video);
+	if (ret < 0) {
+		dev_err(xdev->dev, "Failed to register media controller\n");
+		goto unreg_video;
+	}
+
+	video_set_drvdata(&dma->video, dma->xdev);
+	return 0;
+
+unreg_video:
+	video_unregister_device(&dma->video);
+tx_rx:
+	dma_release_channel(dma->chan_rx);
+tx:
+	dma_release_channel(dma->chan_tx);
+error:
+	return ret;
+}
+
+static void xvip_m2m_dma_deinit(struct xvip_m2m_dma *dma)
+{
+	if (video_is_registered(&dma->video))
+		video_unregister_device(&dma->video);
+
+	mutex_destroy(&dma->pipe.lock);
+	mutex_destroy(&dma->xdev->lock);
+	dma_release_channel(dma->chan_tx);
+	dma_release_channel(dma->chan_rx);
+}
+
+static int xvip_m2m_dma_alloc_init(struct xvip_m2m_dev *xdev)
+{
+	struct xvip_m2m_dma *dma = NULL;
+	int ret;
+
+	dma = devm_kzalloc(xdev->dev, sizeof(*dma), GFP_KERNEL);
+	if (!dma)
+		return -ENOMEM;
+
+	dma->xdev = xdev;
+	xdev->dma = dma;
+
+	ret = xvip_m2m_dma_init(xdev->dma);
+	if (ret) {
+		dev_err(xdev->dev, "DMA initialization failed\n");
+		devm_kfree(xdev->dev, dma);
+		xdev->dma = NULL;
+		return ret;
+	}
+
+	xdev->v4l2_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+static void xvip_composite_v4l2_cleanup(struct xvip_m2m_dev *xdev)
+{
+	v4l2_device_unregister(&xdev->v4l2_dev);
+	media_device_unregister(&xdev->media_dev);
+	media_device_cleanup(&xdev->media_dev);
+}
+
+static int xvip_composite_v4l2_init(struct xvip_m2m_dev *xdev)
+{
+	int ret;
+
+	xdev->media_dev.dev = xdev->dev;
+	strlcpy(xdev->media_dev.model, "Xilinx Video M2M Composite Device",
+		sizeof(xdev->media_dev.model));
+	xdev->media_dev.hw_revision = 0;
+
+	media_device_init(&xdev->media_dev);
+
+	xdev->v4l2_dev.mdev = &xdev->media_dev;
+	ret = v4l2_device_register(xdev->dev, &xdev->v4l2_dev);
+	if (ret < 0) {
+		dev_err(xdev->dev, "V4L2 device registration failed (%d)\n",
+			ret);
+		media_device_cleanup(&xdev->media_dev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct xvip_graph_entity *
+xvip_graph_find_entity(struct xvip_m2m_dev *xdev,
+		       const struct device_node *node)
+{
+	struct xvip_graph_entity *entity;
+
+	list_for_each_entry(entity, &xdev->entities, list) {
+		if (entity->node == node)
+			return entity;
+	}
+
+	return NULL;
+}
+
+static int xvip_graph_build_one(struct xvip_m2m_dev *xdev,
+				struct xvip_graph_entity *entity)
+{
+	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+	struct media_entity *local = entity->entity;
+	struct media_entity *remote;
+	struct media_pad *local_pad;
+	struct media_pad *remote_pad;
+	struct xvip_graph_entity *ent;
+	struct v4l2_fwnode_link link;
+	struct device_node *ep = NULL;
+	struct device_node *next;
+	int ret = 0;
+
+	dev_dbg(xdev->dev, "creating links for entity %s\n", local->name);
+
+	while (1) {
+		/* Get the next endpoint and parse its link. */
+		next = of_graph_get_next_endpoint(entity->node, ep);
+		if (!next)
+			break;
+
+		ep = next;
+
+		dev_dbg(xdev->dev, "processing endpoint %pOF\n", ep);
+
+		ret = v4l2_fwnode_parse_link(of_fwnode_handle(ep), &link);
+		if (ret < 0) {
+			dev_err(xdev->dev, "failed to parse link for %pOF\n",
+				ep);
+			continue;
+		}
+
+		/* Skip sink ports, they will be processed from the other end of
+		 * the link.
+		 */
+		if (link.local_port >= local->num_pads) {
+			dev_err(xdev->dev, "invalid port number %u for %pOF\n",
+				link.local_port,
+				to_of_node(link.local_node));
+			v4l2_fwnode_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		local_pad = &local->pads[link.local_port];
+
+		if (local_pad->flags & MEDIA_PAD_FL_SINK) {
+			dev_dbg(xdev->dev, "skipping sink port %pOF:%u\n",
+				to_of_node(link.local_node),
+				link.local_port);
+			v4l2_fwnode_put_link(&link);
+			continue;
+		}
+
+		/* Skip DMA engines, they will be processed separately. */
+		if (link.remote_node == of_fwnode_handle(xdev->dev->of_node)) {
+			dev_dbg(xdev->dev, "skipping DMA port %pOF:%u\n",
+				to_of_node(link.local_node),
+				link.local_port);
+			v4l2_fwnode_put_link(&link);
+			continue;
+		}
+
+		/* Find the remote entity. */
+		ent = xvip_graph_find_entity(xdev,
+					     to_of_node(link.remote_node));
+		if (!ent) {
+			dev_err(xdev->dev, "no entity found for %pOF\n",
+				to_of_node(link.remote_node));
+			v4l2_fwnode_put_link(&link);
+			ret = -ENODEV;
+			break;
+		}
+
+		remote = ent->entity;
+
+		if (link.remote_port >= remote->num_pads) {
+			dev_err(xdev->dev, "invalid port number %u on %pOF\n",
+				link.remote_port, to_of_node(link.remote_node));
+			v4l2_fwnode_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		remote_pad = &remote->pads[link.remote_port];
+
+		v4l2_fwnode_put_link(&link);
+
+		/* Create the media link. */
+		dev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",
+			local->name, local_pad->index,
+			remote->name, remote_pad->index);
+
+		ret = media_create_pad_link(local, local_pad->index,
+					    remote, remote_pad->index,
+					    link_flags);
+		if (ret < 0) {
+			dev_err(xdev->dev,
+				"failed to create %s:%u -> %s:%u link\n",
+				local->name, local_pad->index,
+				remote->name, remote_pad->index);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int xvip_graph_parse_one(struct xvip_m2m_dev *xdev,
+				struct device_node *node)
+{
+	struct xvip_graph_entity *entity;
+	struct device_node *remote;
+	struct device_node *ep = NULL;
+	int ret = 0;
+
+	dev_dbg(xdev->dev, "parsing node %pOF\n", node);
+
+	while (1) {
+		ep = of_graph_get_next_endpoint(node, ep);
+		if (!ep)
+			break;
+
+		dev_dbg(xdev->dev, "handling endpoint %pOF %s\n",
+			ep, ep->name);
+
+		remote = of_graph_get_remote_port_parent(ep);
+		if (!remote) {
+			ret = -EINVAL;
+			break;
+		}
+		dev_dbg(xdev->dev, "Remote endpoint %pOF %s\n",
+			remote, remote->name);
+
+		/* Skip entities that we have already processed. */
+		if (remote == xdev->dev->of_node ||
+		    xvip_graph_find_entity(xdev, remote)) {
+			of_node_put(remote);
+			continue;
+		}
+
+		entity = devm_kzalloc(xdev->dev, sizeof(*entity), GFP_KERNEL);
+		if (!entity) {
+			of_node_put(remote);
+			ret = -ENOMEM;
+			break;
+		}
+
+		entity->node = remote;
+		entity->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		entity->asd.match.fwnode = of_fwnode_handle(remote);
+		list_add_tail(&entity->list, &xdev->entities);
+		xdev->num_subdevs++;
+	}
+
+	of_node_put(ep);
+	return ret;
+}
+
+static int xvip_graph_parse(struct xvip_m2m_dev *xdev)
+{
+	struct xvip_graph_entity *entity;
+	int ret;
+
+	/*
+	 * Walk the links to parse the full graph. Start by parsing the
+	 * composite node and then parse entities in turn. The list_for_each
+	 * loop will handle entities added at the end of the list while walking
+	 * the links.
+	 */
+	ret = xvip_graph_parse_one(xdev, xdev->dev->of_node);
+	if (ret < 0)
+		return 0;
+
+	list_for_each_entry(entity, &xdev->entities, list) {
+		ret = xvip_graph_parse_one(xdev, entity->node);
+		if (ret < 0)
+			break;
+	}
+
+	return ret;
+}
+
+static int xvip_graph_build_dma(struct xvip_m2m_dev *xdev)
+{
+	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+	struct device_node *node = xdev->dev->of_node;
+	struct media_entity *source;
+	struct media_entity *sink;
+	struct media_pad *source_pad;
+	struct media_pad *sink_pad;
+	struct xvip_graph_entity *ent;
+	struct v4l2_fwnode_link link;
+	struct device_node *ep = NULL;
+	struct device_node *next;
+	struct xvip_m2m_dma *dma = xdev->dma;
+	int ret = 0;
+
+	dev_dbg(xdev->dev, "creating links for DMA engines\n");
+
+	while (1) {
+		/* Get the next endpoint and parse its link. */
+		next = of_graph_get_next_endpoint(node, ep);
+		if (!next)
+			break;
+
+		ep = next;
+
+		dev_dbg(xdev->dev, "processing endpoint %pOF\n", ep);
+
+		ret = v4l2_fwnode_parse_link(of_fwnode_handle(ep), &link);
+		if (ret < 0) {
+			dev_err(xdev->dev, "failed to parse link for %pOF\n",
+				ep);
+			continue;
+		}
+
+		dev_dbg(xdev->dev, "creating link for DMA engine %s\n",
+			dma->video.name);
+
+		/* Find the remote entity. */
+		ent = xvip_graph_find_entity(xdev,
+					     to_of_node(link.remote_node));
+		if (!ent) {
+			dev_err(xdev->dev, "no entity found for %pOF\n",
+				to_of_node(link.remote_node));
+			v4l2_fwnode_put_link(&link);
+			ret = -ENODEV;
+			break;
+		}
+		if (link.remote_port >= ent->entity->num_pads) {
+			dev_err(xdev->dev, "invalid port number %u on %pOF\n",
+				link.remote_port,
+				to_of_node(link.remote_node));
+			v4l2_fwnode_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		dev_dbg(xdev->dev, "Entity %s %s\n", ent->node->name,
+			ent->node->full_name);
+		dev_dbg(xdev->dev, "port number %u on %pOF\n",
+			link.remote_port, to_of_node(link.remote_node));
+		dev_dbg(xdev->dev, "local port number %u on %pOF\n",
+			link.local_port, to_of_node(link.local_node));
+
+		if (link.local_port == XVIP_PAD_SOURCE) {
+			source = &dma->video.entity;
+			source_pad = &dma->pads[XVIP_PAD_SOURCE];
+			sink = ent->entity;
+			sink_pad = &sink->pads[XVIP_PAD_SINK];
+
+		} else {
+			source = ent->entity;
+			source_pad = &source->pads[XVIP_PAD_SOURCE];
+			sink = &dma->video.entity;
+			sink_pad = &dma->pads[XVIP_PAD_SINK];
+		}
+
+		v4l2_fwnode_put_link(&link);
+
+		/* Create the media link. */
+		dev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",
+			source->name, source_pad->index,
+			sink->name, sink_pad->index);
+
+		ret = media_create_pad_link(source, source_pad->index,
+					    sink, sink_pad->index,
+					    link_flags);
+		if (ret < 0) {
+			dev_err(xdev->dev,
+				"failed to create %s:%u -> %s:%u link\n",
+				source->name, source_pad->index,
+				sink->name, sink_pad->index);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)
+{
+	struct xvip_m2m_dev *xdev =
+		container_of(notifier, struct xvip_m2m_dev, notifier);
+	struct xvip_graph_entity *entity;
+	int ret;
+
+	dev_dbg(xdev->dev, "notify complete, all subdevs registered\n");
+
+	/* Create links for every entity. */
+	list_for_each_entry(entity, &xdev->entities, list) {
+		ret = xvip_graph_build_one(xdev, entity);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Create links for DMA channels. */
+	ret = xvip_graph_build_dma(xdev);
+	if (ret < 0)
+		return ret;
+
+	ret = v4l2_device_register_subdev_nodes(&xdev->v4l2_dev);
+	if (ret < 0)
+		dev_err(xdev->dev, "failed to register subdev nodes\n");
+
+	return media_device_register(&xdev->media_dev);
+}
+
+static int xvip_graph_notify_bound(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *subdev,
+				   struct v4l2_async_subdev *asd)
+{
+	struct xvip_m2m_dev *xdev =
+		container_of(notifier, struct xvip_m2m_dev, notifier);
+	struct xvip_graph_entity *entity;
+
+	/* Locate the entity corresponding to the bound subdev and store the
+	 * subdev pointer.
+	 */
+	list_for_each_entry(entity, &xdev->entities, list) {
+		if (entity->node != subdev->dev->of_node)
+			continue;
+
+		if (entity->subdev) {
+			dev_err(xdev->dev, "duplicate subdev for node %pOF\n",
+				entity->node);
+			return -EINVAL;
+		}
+
+		dev_dbg(xdev->dev, "subdev %s bound\n", subdev->name);
+		entity->entity = &subdev->entity;
+		entity->subdev = subdev;
+		return 0;
+	}
+
+	dev_err(xdev->dev, "no entity for subdev %s\n", subdev->name);
+	return -EINVAL;
+}
+
+static const struct v4l2_async_notifier_operations xvip_graph_notify_ops = {
+	.bound = xvip_graph_notify_bound,
+	.complete = xvip_graph_notify_complete,
+};
+
+static void xvip_graph_cleanup(struct xvip_m2m_dev *xdev)
+{
+	struct xvip_graph_entity *entityp;
+	struct xvip_graph_entity *entity;
+
+	if (xdev->dma)
+		xvip_m2m_dma_deinit(xdev->dma);
+	v4l2_async_nf_cleanup(&xdev->notifier);
+	v4l2_async_nf_unregister(&xdev->notifier);
+
+	list_for_each_entry_safe(entity, entityp, &xdev->entities, list) {
+		of_node_put(entity->node);
+		list_del(&entity->list);
+	}
+}
+
+static int xvip_graph_init(struct xvip_m2m_dev *xdev)
+{
+	struct xvip_graph_entity *entity;
+	int ret;
+
+	/* Init the DMA channels. */
+	ret = xvip_m2m_dma_alloc_init(xdev);
+	if (ret < 0) {
+		dev_err(xdev->dev, "DMA initialization failed\n");
+		goto done;
+	}
+
+	/* Parse the graph to extract a list of subdevice DT nodes. */
+	ret = xvip_graph_parse(xdev);
+	if (ret < 0) {
+		dev_err(xdev->dev, "graph parsing failed\n");
+		goto done;
+	}
+	dev_dbg(xdev->dev, "Number of subdev = %d\n", xdev->num_subdevs);
+
+	if (!xdev->num_subdevs) {
+		dev_err(xdev->dev, "no subdev found in graph\n");
+		goto done;
+	}
+
+	/* Register the subdevices notifier. */
+	list_for_each_entry(entity, &xdev->entities, list) {
+		ret = __v4l2_async_nf_add_subdev(&xdev->notifier,
+						 &entity->asd);
+		if (ret)
+			goto done;
+	}
+
+	xdev->notifier.ops = &xvip_graph_notify_ops;
+
+	ret = v4l2_async_nf_register(&xdev->v4l2_dev, &xdev->notifier);
+	if (ret < 0) {
+		dev_err(xdev->dev, "notifier registration failed\n");
+		goto done;
+	}
+
+	ret = 0;
+
+done:
+	if (ret < 0)
+		xvip_graph_cleanup(xdev);
+
+	return ret;
+}
+
+static int xvip_composite_remove(struct platform_device *pdev)
+{
+	struct xvip_m2m_dev *xdev = platform_get_drvdata(pdev);
+
+	xvip_graph_cleanup(xdev);
+	xvip_composite_v4l2_cleanup(xdev);
+
+	return 0;
+}
+
+static int xvip_m2m_probe(struct platform_device *pdev)
+{
+	struct xvip_m2m_dev *xdev = NULL;
+	int ret;
+
+	xdev = devm_kzalloc(&pdev->dev, sizeof(*xdev), GFP_KERNEL);
+	if (!xdev)
+		return -ENOMEM;
+
+	xdev->dev = &pdev->dev;
+	INIT_LIST_HEAD(&xdev->entities);
+	v4l2_async_nf_init(&xdev->notifier);
+
+	ret = xvip_composite_v4l2_init(xdev);
+	if (ret)
+		return -EINVAL;
+
+	xdev->m2m_dev = v4l2_m2m_init(&xvip_m2m_ops);
+	if (IS_ERR(xdev->m2m_dev)) {
+		dev_err(xdev->dev, "Failed to init mem2mem device\n");
+		return PTR_ERR(xdev->m2m_dev);
+	}
+
+	ret = xvip_graph_init(xdev);
+	if (ret < 0)
+		goto error;
+
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
+	if (ret) {
+		dev_err(&pdev->dev, "dma_set_coherent_mask: %d\n", ret);
+		goto dma_cleanup;
+	}
+
+	platform_set_drvdata(pdev, xdev);
+
+	dev_info(xdev->dev, "mem2mem device registered\n");
+	return 0;
+
+dma_cleanup:
+	xvip_m2m_dma_deinit(xdev->dma);
+
+error:
+	v4l2_device_unregister(&xdev->v4l2_dev);
+	return ret;
+}
+
+static int xvip_m2m_remove(struct platform_device *pdev)
+{
+	xvip_composite_remove(pdev);
+	return 0;
+}
+
+static const struct of_device_id xvip_m2m_of_id_table[] = {
+	{ .compatible = "xlnx,mem2mem" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xvip_m2m_of_id_table);
+
+static struct platform_driver xvip_m2m_driver = {
+	.driver = {
+		.name = XVIP_M2M_NAME,
+		.of_match_table = xvip_m2m_of_id_table,
+	},
+	.probe = xvip_m2m_probe,
+	.remove = xvip_m2m_remove,
+};
+
+module_platform_driver(xvip_m2m_driver);
+
+MODULE_AUTHOR("Xilinx Inc.");
+MODULE_DESCRIPTION("Xilinx V4L2 mem2mem driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-multi-scaler-coeff.h b/drivers/media/platform/xilinx/xilinx-multi-scaler-coeff.h
new file mode 100644
index 000000000..65a3482aa
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-multi-scaler-coeff.h
@@ -0,0 +1,574 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx Memory-to-Memory Video Multi-Scaler IP
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Author: Suresh Gupta <sureshg@xilinx.com>
+ *
+ * The file contains the coefficients used by the Xilinx
+ * Video Multi Scaler Controller driver (xm2msc)
+ *
+ */
+
+#define XSCALER_MAX_PHASES	(64)
+#define XSCALER_MAX_TAPS	(12)
+
+#define XSCALER_TAPS_6		(6)
+#define XSCALER_TAPS_8		(8)
+#define XSCALER_TAPS_10		(10)
+#define XSCALER_TAPS_12		(12)
+
+/* Filter bank ID for various filter tap configurations */
+enum xm2mvsc_filter_bank_id {
+	FILTER_BANK_TAPS_6 = 0,
+	FILTER_BANK_TAPS_8,
+	FILTER_BANK_TAPS_10,
+	FILTER_BANK_TAPS_12,
+};
+
+/* H-scaler coefficients for 6, 8, 10 and 12 tap filters */
+static const short
+xhsc_coeff_taps6[XSCALER_MAX_PHASES][XSCALER_TAPS_6] = {
+	{  -132,   236,  3824,   236,  -132,    64, },
+	{  -116,   184,  3816,   292,  -144,    64, },
+	{  -100,   132,  3812,   348,  -160,    64, },
+	{   -88,    84,  3808,   404,  -176,    64, },
+	{   -72,    36,  3796,   464,  -192,    64, },
+	{   -60,    -8,  3780,   524,  -208,    68, },
+	{   -48,   -52,  3768,   588,  -228,    68, },
+	{   -32,   -96,  3748,   652,  -244,    68, },
+	{   -20,  -136,  3724,   716,  -260,    72, },
+	{    -8,  -172,  3696,   784,  -276,    72, },
+	{     0,  -208,  3676,   848,  -292,    72, },
+	{    12,  -244,  3640,   920,  -308,    76, },
+	{    20,  -276,  3612,   988,  -324,    76, },
+	{    32,  -304,  3568,  1060,  -340,    80, },
+	{    40,  -332,  3532,  1132,  -356,    80, },
+	{    48,  -360,  3492,  1204,  -372,    84, },
+	{    56,  -384,  3448,  1276,  -388,    88, },
+	{    64,  -408,  3404,  1352,  -404,    88, },
+	{    72,  -428,  3348,  1428,  -416,    92, },
+	{    76,  -448,  3308,  1500,  -432,    92, },
+	{    84,  -464,  3248,  1576,  -444,    96, },
+	{    88,  -480,  3200,  1652,  -460,    96, },
+	{    92,  -492,  3140,  1728,  -472,   100, },
+	{    96,  -504,  3080,  1804,  -484,   104, },
+	{   100,  -516,  3020,  1880,  -492,   104, },
+	{   104,  -524,  2956,  1960,  -504,   104, },
+	{   104,  -532,  2892,  2036,  -512,   108, },
+	{   108,  -540,  2832,  2108,  -520,   108, },
+	{   108,  -544,  2764,  2184,  -528,   112, },
+	{   112,  -544,  2688,  2260,  -532,   112, },
+	{   112,  -548,  2624,  2336,  -540,   112, },
+	{   112,  -548,  2556,  2408,  -544,   112, },
+	{   112,  -544,  2480,  2480,  -544,   112, },
+	{   112,  -544,  2408,  2556,  -548,   112, },
+	{   112,  -540,  2336,  2624,  -548,   112, },
+	{   112,  -532,  2260,  2688,  -544,   112, },
+	{   112,  -528,  2184,  2764,  -544,   108, },
+	{   108,  -520,  2108,  2832,  -540,   108, },
+	{   108,  -512,  2036,  2892,  -532,   104, },
+	{   104,  -504,  1960,  2956,  -524,   104, },
+	{   104,  -492,  1880,  3020,  -516,   100, },
+	{   104,  -484,  1804,  3080,  -504,    96, },
+	{   100,  -472,  1728,  3140,  -492,    92, },
+	{    96,  -460,  1652,  3200,  -480,    88, },
+	{    96,  -444,  1576,  3248,  -464,    84, },
+	{    92,  -432,  1500,  3308,  -448,    76, },
+	{    92,  -416,  1428,  3348,  -428,    72, },
+	{    88,  -404,  1352,  3404,  -408,    64, },
+	{    88,  -388,  1276,  3448,  -384,    56, },
+	{    84,  -372,  1204,  3492,  -360,    48, },
+	{    80,  -356,  1132,  3532,  -332,    40, },
+	{    80,  -340,  1060,  3568,  -304,    32, },
+	{    76,  -324,   988,  3612,  -276,    20, },
+	{    76,  -308,   920,  3640,  -244,    12, },
+	{    72,  -292,   848,  3676,  -208,     0, },
+	{    72,  -276,   784,  3696,  -172,    -8, },
+	{    72,  -260,   716,  3724,  -136,   -20, },
+	{    68,  -244,   652,  3748,   -96,   -32, },
+	{    68,  -228,   588,  3768,   -52,   -48, },
+	{    68,  -208,   524,  3780,    -8,   -60, },
+	{    64,  -192,   464,  3796,    36,   -72, },
+	{    64,  -176,   404,  3808,    84,   -88, },
+	{    64,  -160,   348,  3812,   132,  -100, },
+	{    64,  -144,   292,  3816,   184,  -116, }
+};
+
+static const short
+xhsc_coeff_taps8[XSCALER_MAX_PHASES][XSCALER_TAPS_8] = {
+	{-5, 309, 1023, 1445, 1034, 317, -3, -24, },
+	{-6, 300, 1011, 1445, 1045, 326, -1, -24, },
+	{-7, 291, 1000, 1444, 1056, 336, 0, -24, },
+	{-9, 282, 988, 1444, 1067, 345, 2, -24, },
+	{-10, 274, 977, 1443, 1078, 354, 4, -24, },
+	{-11, 266, 965, 1441, 1089, 364, 6, -24, },
+	{-12, 258, 953, 1440, 1100, 373, 8, -24, },
+	{-13, 250, 942, 1438, 1110, 383, 10, -24, },
+	{-14, 242, 930, 1437, 1121, 393, 12, -24, },
+	{-15, 234, 918, 1434, 1131, 403, 14, -24, },
+	{-16, 226, 906, 1432, 1142, 413, 17, -24, },
+	{-17, 219, 894, 1430, 1152, 423, 19, -24, },
+	{-17, 211, 882, 1427, 1162, 433, 22, -24, },
+	{-18, 204, 870, 1424, 1172, 443, 24, -24, },
+	{-19, 197, 858, 1420, 1182, 454, 27, -24, },
+	{-19, 190, 846, 1417, 1191, 464, 30, -24, },
+	{-20, 183, 834, 1413, 1201, 475, 33, -24, },
+	{-20, 176, 822, 1409, 1210, 486, 36, -24, },
+	{-21, 170, 810, 1405, 1220, 497, 39, -24, },
+	{-21, 163, 798, 1401, 1229, 507, 42, -24, },
+	{-22, 157, 786, 1396, 1238, 518, 46, -24, },
+	{-22, 151, 774, 1392, 1247, 529, 49, -24, },
+	{-22, 144, 762, 1387, 1255, 540, 53, -24, },
+	{-23, 139, 750, 1382, 1264, 552, 57, -24, },
+	{-23, 133, 738, 1376, 1272, 563, 60, -24, },
+	{-23, 127, 726, 1371, 1280, 574, 64, -24, },
+	{-23, 121, 714, 1365, 1288, 586, 69, -24, },
+	{-23, 116, 703, 1359, 1296, 597, 73, -24, },
+	{-24, 111, 691, 1353, 1304, 609, 77, -24, },
+	{-24, 105, 679, 1346, 1312, 620, 81, -24, },
+	{-24, 100, 667, 1340, 1319, 632, 86, -24, },
+	{-24, 96, 655, 1333, 1326, 644, 91, -24, },
+	{-24, 91, 644, 1326, 1333, 655, 96, -24, },
+	{-24, 86, 632, 1319, 1340, 667, 100, -24, },
+	{-24, 81, 620, 1312, 1346, 679, 105, -24, },
+	{-24, 77, 609, 1304, 1353, 691, 111, -24, },
+	{-24, 73, 597, 1296, 1359, 703, 116, -23, },
+	{-24, 69, 586, 1288, 1365, 714, 121, -23, },
+	{-24, 64, 574, 1280, 1371, 726, 127, -23, },
+	{-24, 60, 563, 1272, 1376, 738, 133, -23, },
+	{-24, 57, 552, 1264, 1382, 750, 139, -23, },
+	{-24, 53, 540, 1255, 1387, 762, 144, -22, },
+	{-24, 49, 529, 1247, 1392, 774, 151, -22, },
+	{-24, 46, 518, 1238, 1396, 786, 157, -22, },
+	{-24, 42, 507, 1229, 1401, 798, 163, -21, },
+	{-24, 39, 497, 1220, 1405, 810, 170, -21, },
+	{-24, 36, 486, 1210, 1409, 822, 176, -20, },
+	{-24, 33, 475, 1201, 1413, 834, 183, -20, },
+	{-24, 30, 464, 1191, 1417, 846, 190, -19, },
+	{-24, 27, 454, 1182, 1420, 858, 197, -19, },
+	{-24, 24, 443, 1172, 1424, 870, 204, -18, },
+	{-24, 22, 433, 1162, 1427, 882, 211, -17, },
+	{-24, 19, 423, 1152, 1430, 894, 219, -17, },
+	{-24, 17, 413, 1142, 1432, 906, 226, -16, },
+	{-24, 14, 403, 1131, 1434, 918, 234, -15, },
+	{-24, 12, 393, 1121, 1437, 930, 242, -14, },
+	{-24, 10, 383, 1110, 1438, 942, 250, -13, },
+	{-24, 8, 373, 1100, 1440, 953, 258, -12, },
+	{-24, 6, 364, 1089, 1441, 965, 266, -11, },
+	{-24, 4, 354, 1078, 1443, 977, 274, -10, },
+	{-24, 2, 345, 1067, 1444, 988, 282, -9, },
+	{-24, 0, 336, 1056, 1444, 1000, 291, -7, },
+	{-24, -1, 326, 1045, 1445, 1011, 300, -6, },
+	{-24, -3, 317, 1034, 1445, 1023, 309, -5, },
+};
+
+static const short
+xhsc_coeff_taps10[XSCALER_MAX_PHASES][XSCALER_TAPS_10] = {
+	{59, 224, 507, 790, 911, 793, 512, 227, 61, 13, },
+	{58, 220, 502, 786, 911, 797, 516, 231, 62, 13, },
+	{56, 216, 497, 783, 911, 800, 521, 235, 64, 13, },
+	{55, 213, 492, 779, 910, 804, 526, 238, 65, 13, },
+	{54, 209, 487, 775, 910, 807, 531, 242, 67, 14, },
+	{52, 206, 482, 772, 910, 810, 536, 246, 69, 14, },
+	{51, 202, 477, 768, 909, 813, 541, 250, 70, 14, },
+	{50, 199, 473, 764, 909, 817, 545, 254, 72, 14, },
+	{48, 195, 468, 760, 908, 820, 550, 258, 74, 15, },
+	{47, 192, 463, 756, 908, 823, 555, 262, 76, 15, },
+	{46, 188, 458, 752, 907, 826, 560, 266, 78, 15, },
+	{45, 185, 453, 748, 906, 829, 565, 270, 79, 16, },
+	{44, 182, 448, 744, 906, 832, 569, 274, 81, 16, },
+	{42, 179, 444, 740, 905, 835, 574, 278, 83, 16, },
+	{41, 175, 439, 736, 904, 837, 579, 282, 85, 17, },
+	{40, 172, 434, 732, 903, 840, 584, 286, 87, 17, },
+	{39, 169, 429, 728, 902, 843, 589, 290, 89, 18, },
+	{38, 166, 425, 724, 901, 846, 593, 294, 91, 18, },
+	{37, 163, 420, 720, 900, 848, 598, 298, 93, 18, },
+	{36, 160, 415, 716, 899, 851, 603, 302, 95, 19, },
+	{35, 157, 410, 711, 897, 854, 608, 307, 98, 19, },
+	{34, 154, 406, 707, 896, 856, 612, 311, 100, 20, },
+	{33, 151, 401, 703, 895, 859, 617, 315, 102, 20, },
+	{33, 148, 396, 698, 893, 861, 622, 320, 104, 21, },
+	{32, 145, 392, 694, 892, 863, 626, 324, 107, 21, },
+	{31, 142, 387, 690, 890, 866, 631, 328, 109, 22, },
+	{30, 140, 382, 685, 889, 868, 636, 333, 111, 23, },
+	{29, 137, 378, 681, 887, 870, 640, 337, 114, 23, },
+	{28, 134, 373, 677, 886, 872, 645, 342, 116, 24, },
+	{28, 131, 369, 672, 884, 874, 649, 346, 119, 24, },
+	{27, 129, 364, 668, 882, 876, 654, 350, 121, 25, },
+	{26, 126, 359, 663, 880, 878, 659, 355, 124, 26, },
+	{26, 124, 355, 659, 878, 880, 663, 359, 126, 26, },
+	{25, 121, 350, 654, 876, 882, 668, 364, 129, 27, },
+	{24, 119, 346, 649, 874, 884, 672, 369, 131, 28, },
+	{24, 116, 342, 645, 872, 886, 677, 373, 134, 28, },
+	{23, 114, 337, 640, 870, 887, 681, 378, 137, 29, },
+	{23, 111, 333, 636, 868, 889, 685, 382, 140, 30, },
+	{22, 109, 328, 631, 866, 890, 690, 387, 142, 31, },
+	{21, 107, 324, 626, 863, 892, 694, 392, 145, 32, },
+	{21, 104, 320, 622, 861, 893, 698, 396, 148, 33, },
+	{20, 102, 315, 617, 859, 895, 703, 401, 151, 33, },
+	{20, 100, 311, 612, 856, 896, 707, 406, 154, 34, },
+	{19, 98, 307, 608, 854, 897, 711, 410, 157, 35, },
+	{19, 95, 302, 603, 851, 899, 716, 415, 160, 36, },
+	{18, 93, 298, 598, 848, 900, 720, 420, 163, 37, },
+	{18, 91, 294, 593, 846, 901, 724, 425, 166, 38, },
+	{18, 89, 290, 589, 843, 902, 728, 429, 169, 39, },
+	{17, 87, 286, 584, 840, 903, 732, 434, 172, 40, },
+	{17, 85, 282, 579, 837, 904, 736, 439, 175, 41, },
+	{16, 83, 278, 574, 835, 905, 740, 444, 179, 42, },
+	{16, 81, 274, 569, 832, 906, 744, 448, 182, 44, },
+	{16, 79, 270, 565, 829, 906, 748, 453, 185, 45, },
+	{15, 78, 266, 560, 826, 907, 752, 458, 188, 46, },
+	{15, 76, 262, 555, 823, 908, 756, 463, 192, 47, },
+	{15, 74, 258, 550, 820, 908, 760, 468, 195, 48, },
+	{14, 72, 254, 545, 817, 909, 764, 473, 199, 50, },
+	{14, 70, 250, 541, 813, 909, 768, 477, 202, 51, },
+	{14, 69, 246, 536, 810, 910, 772, 482, 206, 52, },
+	{14, 67, 242, 531, 807, 910, 775, 487, 209, 54, },
+	{13, 65, 238, 526, 804, 910, 779, 492, 213, 55, },
+	{13, 64, 235, 521, 800, 911, 783, 497, 216, 56, },
+	{13, 62, 231, 516, 797, 911, 786, 502, 220, 58, },
+	{13, 61, 227, 512, 793, 911, 790, 507, 224, 59, },
+};
+
+static const short
+xhsc_coeff_taps12[XSCALER_MAX_PHASES][XSCALER_TAPS_12] = {
+	{48, 143, 307, 504, 667, 730, 669, 507, 310, 145, 49, 18, },
+	{47, 141, 304, 501, 665, 730, 670, 510, 313, 147, 50, 18, },
+	{46, 138, 301, 498, 663, 730, 672, 513, 316, 149, 51, 18, },
+	{45, 136, 298, 495, 661, 730, 674, 516, 319, 151, 52, 18, },
+	{44, 134, 295, 492, 659, 730, 676, 519, 322, 153, 53, 18, },
+	{44, 132, 292, 489, 657, 730, 677, 522, 325, 155, 54, 18, },
+	{43, 130, 289, 486, 655, 729, 679, 525, 328, 157, 55, 19, },
+	{42, 129, 287, 483, 653, 729, 681, 528, 331, 160, 56, 19, },
+	{41, 127, 284, 480, 651, 729, 683, 531, 334, 162, 57, 19, },
+	{40, 125, 281, 477, 648, 729, 684, 534, 337, 164, 58, 19, },
+	{40, 123, 278, 474, 646, 728, 686, 537, 340, 166, 59, 20, },
+	{39, 121, 275, 471, 644, 728, 687, 539, 343, 169, 60, 20, },
+	{38, 119, 272, 468, 642, 727, 689, 542, 346, 171, 61, 20, },
+	{37, 117, 269, 465, 640, 727, 690, 545, 349, 173, 62, 20, },
+	{37, 115, 266, 461, 638, 727, 692, 548, 353, 175, 63, 21, },
+	{36, 114, 264, 458, 635, 726, 693, 551, 356, 178, 65, 21, },
+	{35, 112, 261, 455, 633, 726, 695, 554, 359, 180, 66, 21, },
+	{35, 110, 258, 452, 631, 725, 696, 556, 362, 183, 67, 21, },
+	{34, 108, 255, 449, 628, 724, 698, 559, 365, 185, 68, 22, },
+	{33, 107, 252, 446, 626, 724, 699, 562, 368, 187, 69, 22, },
+	{33, 105, 250, 443, 624, 723, 700, 565, 371, 190, 71, 22, },
+	{32, 103, 247, 440, 621, 723, 702, 567, 374, 192, 72, 23, },
+	{32, 101, 244, 437, 619, 722, 703, 570, 377, 195, 73, 23, },
+	{31, 100, 241, 433, 617, 721, 704, 573, 380, 197, 75, 23, },
+	{31, 98, 239, 430, 614, 720, 705, 576, 383, 200, 76, 24, },
+	{30, 97, 236, 427, 612, 720, 707, 578, 387, 202, 77, 24, },
+	{29, 95, 233, 424, 609, 719, 708, 581, 390, 205, 79, 24, },
+	{29, 93, 231, 421, 607, 718, 709, 584, 393, 207, 80, 25, },
+	{28, 92, 228, 418, 604, 717, 710, 586, 396, 210, 81, 25, },
+	{28, 90, 225, 415, 602, 716, 711, 589, 399, 212, 83, 26, },
+	{27, 89, 223, 412, 599, 715, 712, 591, 402, 215, 84, 26, },
+	{27, 87, 220, 408, 597, 714, 713, 594, 405, 217, 86, 27, },
+	{27, 86, 217, 405, 594, 713, 714, 597, 408, 220, 87, 27, },
+	{26, 84, 215, 402, 591, 712, 715, 599, 412, 223, 89, 27, },
+	{26, 83, 212, 399, 589, 711, 716, 602, 415, 225, 90, 28, },
+	{25, 81, 210, 396, 586, 710, 717, 604, 418, 228, 92, 28, },
+	{25, 80, 207, 393, 584, 709, 718, 607, 421, 231, 93, 29, },
+	{24, 79, 205, 390, 581, 708, 719, 609, 424, 233, 95, 29, },
+	{24, 77, 202, 387, 578, 707, 720, 612, 427, 236, 97, 30, },
+	{24, 76, 200, 383, 576, 705, 720, 614, 430, 239, 98, 31, },
+	{23, 75, 197, 380, 573, 704, 721, 617, 433, 241, 100, 31, },
+	{23, 73, 195, 377, 570, 703, 722, 619, 437, 244, 101, 32, },
+	{23, 72, 192, 374, 567, 702, 723, 621, 440, 247, 103, 32, },
+	{22, 71, 190, 371, 565, 700, 723, 624, 443, 250, 105, 33, },
+	{22, 69, 187, 368, 562, 699, 724, 626, 446, 252, 107, 33, },
+	{22, 68, 185, 365, 559, 698, 724, 628, 449, 255, 108, 34, },
+	{21, 67, 183, 362, 556, 696, 725, 631, 452, 258, 110, 35, },
+	{21, 66, 180, 359, 554, 695, 726, 633, 455, 261, 112, 35, },
+	{21, 65, 178, 356, 551, 693, 726, 635, 458, 264, 114, 36, },
+	{21, 63, 175, 353, 548, 692, 727, 638, 461, 266, 115, 37, },
+	{20, 62, 173, 349, 545, 690, 727, 640, 465, 269, 117, 37, },
+	{20, 61, 171, 346, 542, 689, 727, 642, 468, 272, 119, 38, },
+	{20, 60, 169, 343, 539, 687, 728, 644, 471, 275, 121, 39, },
+	{20, 59, 166, 340, 537, 686, 728, 646, 474, 278, 123, 40, },
+	{19, 58, 164, 337, 534, 684, 729, 648, 477, 281, 125, 40, },
+	{19, 57, 162, 334, 531, 683, 729, 651, 480, 284, 127, 41, },
+	{19, 56, 160, 331, 528, 681, 729, 653, 483, 287, 129, 42, },
+	{19, 55, 157, 328, 525, 679, 729, 655, 486, 289, 130, 43, },
+	{18, 54, 155, 325, 522, 677, 730, 657, 489, 292, 132, 44, },
+	{18, 53, 153, 322, 519, 676, 730, 659, 492, 295, 134, 44, },
+	{18, 52, 151, 319, 516, 674, 730, 661, 495, 298, 136, 45, },
+	{18, 51, 149, 316, 513, 672, 730, 663, 498, 301, 138, 46, },
+	{18, 50, 147, 313, 510, 670, 730, 665, 501, 304, 141, 47, },
+	{18, 49, 145, 310, 507, 669, 730, 667, 504, 307, 143, 48, },
+};
+
+/* V-scaler coefficients for 6, 8, 10 and 12 tap filters */
+static const short
+xvsc_coeff_taps6[XSCALER_MAX_PHASES][XSCALER_TAPS_6] = {
+	{-132, 236, 3824, 236, -132, 64, },
+	{-116, 184, 3816, 292, -144, 64, },
+	{-100, 132, 3812, 348, -160, 64, },
+	{-88, 84, 3808, 404, -176, 64, },
+	{-72, 36, 3796, 464, -192, 64, },
+	{-60, -8, 3780, 524, -208, 68, },
+	{-48, -52, 3768, 588, -228, 68, },
+	{-32, -96, 3748, 652, -244, 68, },
+	{-20, -136, 3724, 716, -260, 72, },
+	{-8, -172, 3696, 784, -276, 72, },
+	{0, -208, 3676, 848, -292, 72, },
+	{12, -244, 3640, 920, -308, 76, },
+	{20, -276, 3612, 988, -324, 76, },
+	{32, -304, 3568, 1060, -340, 80, },
+	{40, -332, 3532, 1132, -356, 80, },
+	{48, -360, 3492, 1204, -372, 84, },
+	{56, -384, 3448, 1276, -388, 88, },
+	{64, -408, 3404, 1352, -404, 88, },
+	{72, -428, 3348, 1428, -416, 92, },
+	{76, -448, 3308, 1500, -432, 92, },
+	{84, -464, 3248, 1576, -444, 96, },
+	{88, -480, 3200, 1652, -460, 96, },
+	{92, -492, 3140, 1728, -472, 100, },
+	{96, -504, 3080, 1804, -484, 104, },
+	{100, -516, 3020, 1880, -492, 104, },
+	{104, -524, 2956, 1960, -504, 104, },
+	{104, -532, 2892, 2036, -512, 108, },
+	{108, -540, 2832, 2108, -520, 108, },
+	{108, -544, 2764, 2184, -528, 112, },
+	{112, -544, 2688, 2260, -532, 112, },
+	{112, -548, 2624, 2336, -540, 112, },
+	{112, -548, 2556, 2408, -544, 112, },
+	{112, -544, 2480, 2480, -544, 112, },
+	{112, -544, 2408, 2556, -548, 112, },
+	{112, -540, 2336, 2624, -548, 112, },
+	{112, -532, 2260, 2688, -544, 112, },
+	{112, -528, 2184, 2764, -544, 108, },
+	{108, -520, 2108, 2832, -540, 108, },
+	{108, -512, 2036, 2892, -532, 104, },
+	{104, -504, 1960, 2956, -524, 104, },
+	{104, -492, 1880, 3020, -516, 100, },
+	{104, -484, 1804, 3080, -504, 96, },
+	{100, -472, 1728, 3140, -492, 92, },
+	{ 96, -460, 1652, 3200, -480, 88, },
+	{ 96, -444, 1576, 3248, -464, 84, },
+	{ 92, -432, 1500, 3308, -448, 76, },
+	{ 92, -416, 1428, 3348, -428, 72, },
+	{ 88, -404, 1352, 3404, -408, 64, },
+	{ 88, -388, 1276, 3448, -384, 56, },
+	{ 84, -372, 1204, 3492, -360, 48, },
+	{ 80, -356, 1132, 3532, -332, 40, },
+	{ 80, -340, 1060, 3568, -304, 32, },
+	{ 76, -324, 988, 3612, -276, 20, },
+	{ 76, -308, 920, 3640, -244, 12, },
+	{ 72, -292, 848, 3676, -208, 0, },
+	{ 72, -276, 784, 3696, -172, -8, },
+	{ 72, -260, 716, 3724, -136, -20, },
+	{ 68, -244, 652, 3748, -96, -32, },
+	{ 68, -228, 588, 3768, -52, -48, },
+	{ 68, -208, 524, 3780, -8, -60, },
+	{ 64, -192, 464, 3796, 36, -72, },
+	{ 64, -176, 404, 3808, 84, -88, },
+	{ 64, -160, 348, 3812, 132, -100, },
+	{ 64, -144, 292, 3816, 184, -116, }
+};
+
+static const short
+xvsc_coeff_taps8[XSCALER_MAX_PHASES][XSCALER_TAPS_8] = {
+	{-5, 309, 1023, 1445, 1034, 317, -3, -24, },
+	{-6, 300, 1011, 1445, 1045, 326, -1, -24, },
+	{-7, 291, 1000, 1444, 1056, 336, 0, -24, },
+	{-9, 282, 988, 1444, 1067, 345, 2, -24, },
+	{-10, 274, 977, 1443, 1078, 354, 4, -24, },
+	{-11, 266, 965, 1441, 1089, 364, 6, -24, },
+	{-12, 258, 953, 1440, 1100, 373, 8, -24, },
+	{-13, 250, 942, 1438, 1110, 383, 10, -24, },
+	{-14, 242, 930, 1437, 1121, 393, 12, -24, },
+	{-15, 234, 918, 1434, 1131, 403, 14, -24, },
+	{-16, 226, 906, 1432, 1142, 413, 17, -24, },
+	{-17, 219, 894, 1430, 1152, 423, 19, -24, },
+	{-17, 211, 882, 1427, 1162, 433, 22, -24, },
+	{-18, 204, 870, 1424, 1172, 443, 24, -24, },
+	{-19, 197, 858, 1420, 1182, 454, 27, -24, },
+	{-19, 190, 846, 1417, 1191, 464, 30, -24, },
+	{-20, 183, 834, 1413, 1201, 475, 33, -24, },
+	{-20, 176, 822, 1409, 1210, 486, 36, -24, },
+	{-21, 170, 810, 1405, 1220, 497, 39, -24, },
+	{-21, 163, 798, 1401, 1229, 507, 42, -24, },
+	{-22, 157, 786, 1396, 1238, 518, 46, -24, },
+	{-22, 151, 774, 1392, 1247, 529, 49, -24, },
+	{-22, 144, 762, 1387, 1255, 540, 53, -24, },
+	{-23, 139, 750, 1382, 1264, 552, 57, -24, },
+	{-23, 133, 738, 1376, 1272, 563, 60, -24, },
+	{-23, 127, 726, 1371, 1280, 574, 64, -24, },
+	{-23, 121, 714, 1365, 1288, 586, 69, -24, },
+	{-23, 116, 703, 1359, 1296, 597, 73, -24, },
+	{-24, 111, 691, 1353, 1304, 609, 77, -24, },
+	{-24, 105, 679, 1346, 1312, 620, 81, -24, },
+	{-24, 100, 667, 1340, 1319, 632, 86, -24, },
+	{-24, 96, 655, 1333, 1326, 644, 91, -24, },
+	{-24, 91, 644, 1326, 1333, 655, 96, -24, },
+	{-24, 86, 632, 1319, 1340, 667, 100, -24, },
+	{-24, 81, 620, 1312, 1346, 679, 105, -24, },
+	{-24, 77, 609, 1304, 1353, 691, 111, -24, },
+	{-24, 73, 597, 1296, 1359, 703, 116, -23, },
+	{-24, 69, 586, 1288, 1365, 714, 121, -23, },
+	{-24, 64, 574, 1280, 1371, 726, 127, -23, },
+	{-24, 60, 563, 1272, 1376, 738, 133, -23, },
+	{-24, 57, 552, 1264, 1382, 750, 139, -23, },
+	{-24, 53, 540, 1255, 1387, 762, 144, -22, },
+	{-24, 49, 529, 1247, 1392, 774, 151, -22, },
+	{-24, 46, 518, 1238, 1396, 786, 157, -22, },
+	{-24, 42, 507, 1229, 1401, 798, 163, -21, },
+	{-24, 39, 497, 1220, 1405, 810, 170, -21, },
+	{-24, 36, 486, 1210, 1409, 822, 176, -20, },
+	{-24, 33, 475, 1201, 1413, 834, 183, -20, },
+	{-24, 30, 464, 1191, 1417, 846, 190, -19, },
+	{-24, 27, 454, 1182, 1420, 858, 197, -19, },
+	{-24, 24, 443, 1172, 1424, 870, 204, -18, },
+	{-24, 22, 433, 1162, 1427, 882, 211, -17, },
+	{-24, 19, 423, 1152, 1430, 894, 219, -17, },
+	{-24, 17, 413, 1142, 1432, 906, 226, -16, },
+	{-24, 14, 403, 1131, 1434, 918, 234, -15, },
+	{-24, 12, 393, 1121, 1437, 930, 242, -14, },
+	{-24, 10, 383, 1110, 1438, 942, 250, -13, },
+	{-24, 8, 373, 1100, 1440, 953, 258, -12, },
+	{-24, 6, 364, 1089, 1441, 965, 266, -11, },
+	{-24, 4, 354, 1078, 1443, 977, 274, -10, },
+	{-24, 2, 345, 1067, 1444, 988, 282, -9, },
+	{-24, 0, 336, 1056, 1444, 1000, 291, -7, },
+	{-24, -1, 326, 1045, 1445, 1011, 300, -6, },
+	{-24, -3, 317, 1034, 1445, 1023, 309, -5, },
+};
+
+static const short
+xvsc_coeff_taps10[XSCALER_MAX_PHASES][XSCALER_TAPS_10] = {
+	{59, 224, 507, 790, 911, 793, 512, 227, 61, 13, },
+	{58, 220, 502, 786, 911, 797, 516, 231, 62, 13, },
+	{56, 216, 497, 783, 911, 800, 521, 235, 64, 13, },
+	{55, 213, 492, 779, 910, 804, 526, 238, 65, 13, },
+	{54, 209, 487, 775, 910, 807, 531, 242, 67, 14, },
+	{52, 206, 482, 772, 910, 810, 536, 246, 69, 14, },
+	{51, 202, 477, 768, 909, 813, 541, 250, 70, 14, },
+	{50, 199, 473, 764, 909, 817, 545, 254, 72, 14, },
+	{48, 195, 468, 760, 908, 820, 550, 258, 74, 15, },
+	{47, 192, 463, 756, 908, 823, 555, 262, 76, 15, },
+	{46, 188, 458, 752, 907, 826, 560, 266, 78, 15, },
+	{45, 185, 453, 748, 906, 829, 565, 270, 79, 16, },
+	{44, 182, 448, 744, 906, 832, 569, 274, 81, 16, },
+	{42, 179, 444, 740, 905, 835, 574, 278, 83, 16, },
+	{41, 175, 439, 736, 904, 837, 579, 282, 85, 17, },
+	{40, 172, 434, 732, 903, 840, 584, 286, 87, 17, },
+	{39, 169, 429, 728, 902, 843, 589, 290, 89, 18, },
+	{38, 166, 425, 724, 901, 846, 593, 294, 91, 18, },
+	{37, 163, 420, 720, 900, 848, 598, 298, 93, 18, },
+	{36, 160, 415, 716, 899, 851, 603, 302, 95, 19, },
+	{35, 157, 410, 711, 897, 854, 608, 307, 98, 19, },
+	{34, 154, 406, 707, 896, 856, 612, 311, 100, 20, },
+	{33, 151, 401, 703, 895, 859, 617, 315, 102, 20, },
+	{33, 148, 396, 698, 893, 861, 622, 320, 104, 21, },
+	{32, 145, 392, 694, 892, 863, 626, 324, 107, 21, },
+	{31, 142, 387, 690, 890, 866, 631, 328, 109, 22, },
+	{30, 140, 382, 685, 889, 868, 636, 333, 111, 23, },
+	{29, 137, 378, 681, 887, 870, 640, 337, 114, 23, },
+	{28, 134, 373, 677, 886, 872, 645, 342, 116, 24, },
+	{28, 131, 369, 672, 884, 874, 649, 346, 119, 24, },
+	{27, 129, 364, 668, 882, 876, 654, 350, 121, 25, },
+	{26, 126, 359, 663, 880, 878, 659, 355, 124, 26, },
+	{26, 124, 355, 659, 878, 880, 663, 359, 126, 26, },
+	{25, 121, 350, 654, 876, 882, 668, 364, 129, 27, },
+	{24, 119, 346, 649, 874, 884, 672, 369, 131, 28, },
+	{24, 116, 342, 645, 872, 886, 677, 373, 134, 28, },
+	{23, 114, 337, 640, 870, 887, 681, 378, 137, 29, },
+	{23, 111, 333, 636, 868, 889, 685, 382, 140, 30, },
+	{22, 109, 328, 631, 866, 890, 690, 387, 142, 31, },
+	{21, 107, 324, 626, 863, 892, 694, 392, 145, 32, },
+	{21, 104, 320, 622, 861, 893, 698, 396, 148, 33, },
+	{20, 102, 315, 617, 859, 895, 703, 401, 151, 33, },
+	{20, 100, 311, 612, 856, 896, 707, 406, 154, 34, },
+	{19, 98, 307, 608, 854, 897, 711, 410, 157, 35, },
+	{19, 95, 302, 603, 851, 899, 716, 415, 160, 36, },
+	{18, 93, 298, 598, 848, 900, 720, 420, 163, 37, },
+	{18, 91, 294, 593, 846, 901, 724, 425, 166, 38, },
+	{18, 89, 290, 589, 843, 902, 728, 429, 169, 39, },
+	{17, 87, 286, 584, 840, 903, 732, 434, 172, 40, },
+	{17, 85, 282, 579, 837, 904, 736, 439, 175, 41, },
+	{16, 83, 278, 574, 835, 905, 740, 444, 179, 42, },
+	{16, 81, 274, 569, 832, 906, 744, 448, 182, 44, },
+	{16, 79, 270, 565, 829, 906, 748, 453, 185, 45, },
+	{15, 78, 266, 560, 826, 907, 752, 458, 188, 46, },
+	{15, 76, 262, 555, 823, 908, 756, 463, 192, 47, },
+	{15, 74, 258, 550, 820, 908, 760, 468, 195, 48, },
+	{14, 72, 254, 545, 817, 909, 764, 473, 199, 50, },
+	{14, 70, 250, 541, 813, 909, 768, 477, 202, 51, },
+	{14, 69, 246, 536, 810, 910, 772, 482, 206, 52, },
+	{14, 67, 242, 531, 807, 910, 775, 487, 209, 54, },
+	{13, 65, 238, 526, 804, 910, 779, 492, 213, 55, },
+	{13, 64, 235, 521, 800, 911, 783, 497, 216, 56, },
+	{13, 62, 231, 516, 797, 911, 786, 502, 220, 58, },
+	{13, 61, 227, 512, 793, 911, 790, 507, 224, 59, },
+};
+
+static const short
+xvsc_coeff_taps12[XSCALER_MAX_PHASES][XSCALER_TAPS_12] = {
+	{48, 143, 307, 504, 667, 730, 669, 507, 310, 145, 49, 18, },
+	{47, 141, 304, 501, 665, 730, 670, 510, 313, 147, 50, 18, },
+	{46, 138, 301, 498, 663, 730, 672, 513, 316, 149, 51, 18, },
+	{45, 136, 298, 495, 661, 730, 674, 516, 319, 151, 52, 18, },
+	{44, 134, 295, 492, 659, 730, 676, 519, 322, 153, 53, 18, },
+	{44, 132, 292, 489, 657, 730, 677, 522, 325, 155, 54, 18, },
+	{43, 130, 289, 486, 655, 729, 679, 525, 328, 157, 55, 19, },
+	{42, 129, 287, 483, 653, 729, 681, 528, 331, 160, 56, 19, },
+	{41, 127, 284, 480, 651, 729, 683, 531, 334, 162, 57, 19, },
+	{40, 125, 281, 477, 648, 729, 684, 534, 337, 164, 58, 19, },
+	{40, 123, 278, 474, 646, 728, 686, 537, 340, 166, 59, 20, },
+	{39, 121, 275, 471, 644, 728, 687, 539, 343, 169, 60, 20, },
+	{38, 119, 272, 468, 642, 727, 689, 542, 346, 171, 61, 20, },
+	{37, 117, 269, 465, 640, 727, 690, 545, 349, 173, 62, 20, },
+	{37, 115, 266, 461, 638, 727, 692, 548, 353, 175, 63, 21, },
+	{36, 114, 264, 458, 635, 726, 693, 551, 356, 178, 65, 21, },
+	{35, 112, 261, 455, 633, 726, 695, 554, 359, 180, 66, 21, },
+	{35, 110, 258, 452, 631, 725, 696, 556, 362, 183, 67, 21, },
+	{34, 108, 255, 449, 628, 724, 698, 559, 365, 185, 68, 22, },
+	{33, 107, 252, 446, 626, 724, 699, 562, 368, 187, 69, 22, },
+	{33, 105, 250, 443, 624, 723, 700, 565, 371, 190, 71, 22, },
+	{32, 103, 247, 440, 621, 723, 702, 567, 374, 192, 72, 23, },
+	{32, 101, 244, 437, 619, 722, 703, 570, 377, 195, 73, 23, },
+	{31, 100, 241, 433, 617, 721, 704, 573, 380, 197, 75, 23, },
+	{31, 98, 239, 430, 614, 720, 705, 576, 383, 200, 76, 24, },
+	{30, 97, 236, 427, 612, 720, 707, 578, 387, 202, 77, 24, },
+	{29, 95, 233, 424, 609, 719, 708, 581, 390, 205, 79, 24, },
+	{29, 93, 231, 421, 607, 718, 709, 584, 393, 207, 80, 25, },
+	{28, 92, 228, 418, 604, 717, 710, 586, 396, 210, 81, 25, },
+	{28, 90, 225, 415, 602, 716, 711, 589, 399, 212, 83, 26, },
+	{27, 89, 223, 412, 599, 715, 712, 591, 402, 215, 84, 26, },
+	{27, 87, 220, 408, 597, 714, 713, 594, 405, 217, 86, 27, },
+	{27, 86, 217, 405, 594, 713, 714, 597, 408, 220, 87, 27, },
+	{26, 84, 215, 402, 591, 712, 715, 599, 412, 223, 89, 27, },
+	{26, 83, 212, 399, 589, 711, 716, 602, 415, 225, 90, 28, },
+	{25, 81, 210, 396, 586, 710, 717, 604, 418, 228, 92, 28, },
+	{25, 80, 207, 393, 584, 709, 718, 607, 421, 231, 93, 29, },
+	{24, 79, 205, 390, 581, 708, 719, 609, 424, 233, 95, 29, },
+	{24, 77, 202, 387, 578, 707, 720, 612, 427, 236, 97, 30, },
+	{24, 76, 200, 383, 576, 705, 720, 614, 430, 239, 98, 31, },
+	{23, 75, 197, 380, 573, 704, 721, 617, 433, 241, 100, 31, },
+	{23, 73, 195, 377, 570, 703, 722, 619, 437, 244, 101, 32, },
+	{23, 72, 192, 374, 567, 702, 723, 621, 440, 247, 103, 32, },
+	{22, 71, 190, 371, 565, 700, 723, 624, 443, 250, 105, 33, },
+	{22, 69, 187, 368, 562, 699, 724, 626, 446, 252, 107, 33, },
+	{22, 68, 185, 365, 559, 698, 724, 628, 449, 255, 108, 34, },
+	{21, 67, 183, 362, 556, 696, 725, 631, 452, 258, 110, 35, },
+	{21, 66, 180, 359, 554, 695, 726, 633, 455, 261, 112, 35, },
+	{21, 65, 178, 356, 551, 693, 726, 635, 458, 264, 114, 36, },
+	{21, 63, 175, 353, 548, 692, 727, 638, 461, 266, 115, 37, },
+	{20, 62, 173, 349, 545, 690, 727, 640, 465, 269, 117, 37, },
+	{20, 61, 171, 346, 542, 689, 727, 642, 468, 272, 119, 38, },
+	{20, 60, 169, 343, 539, 687, 728, 644, 471, 275, 121, 39, },
+	{20, 59, 166, 340, 537, 686, 728, 646, 474, 278, 123, 40, },
+	{19, 58, 164, 337, 534, 684, 729, 648, 477, 281, 125, 40, },
+	{19, 57, 162, 334, 531, 683, 729, 651, 480, 284, 127, 41, },
+	{19, 56, 160, 331, 528, 681, 729, 653, 483, 287, 129, 42, },
+	{19, 55, 157, 328, 525, 679, 729, 655, 486, 289, 130, 43, },
+	{18, 54, 155, 325, 522, 677, 730, 657, 489, 292, 132, 44, },
+	{18, 53, 153, 322, 519, 676, 730, 659, 492, 295, 134, 44, },
+	{18, 52, 151, 319, 516, 674, 730, 661, 495, 298, 136, 45, },
+	{18, 51, 149, 316, 513, 672, 730, 663, 498, 301, 138, 46, },
+	{18, 50, 147, 313, 510, 670, 730, 665, 501, 304, 141, 47, },
+	{18, 49, 145, 310, 507, 669, 730, 667, 504, 307, 143, 48, },
+};
diff --git a/drivers/media/platform/xilinx/xilinx-multi-scaler.c b/drivers/media/platform/xilinx/xilinx-multi-scaler.c
new file mode 100644
index 000000000..84add376a
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-multi-scaler.c
@@ -0,0 +1,2499 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Memory-to-Memory Video Multi-Scaler IP
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Author: Suresh Gupta <suresh.gupta@xilinx.com>
+ *
+ * Based on the virtual v4l2-mem2mem example device
+ *
+ * This driver adds support to control the Xilinx Video Multi
+ * Scaler Controller
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "xilinx-multi-scaler-coeff.h"
+
+/* 0x0000 : Control signals */
+#define XM2MSC_AP_CTRL			0x0000
+#define XM2MSC_AP_CTRL_START		BIT(0)
+#define XM2MSC_AP_CTRL_DONE		BIT(1)
+#define XM2MSC_AP_CTRL_IDEL		BIT(2)
+#define XM2MSC_AP_CTRL_READY		BIT(3)
+#define XM2MSC_AP_CTRL_AUTO_RESTART	BIT(7)
+
+/* 0x0004 : Global Interrupt Enable Register */
+#define XM2MSC_GIE			0x0004
+#define XM2MSC_GIE_EN			BIT(0)
+
+/* 0x0008 : IP Interrupt Enable Register (Read/Write) */
+#define XM2MSC_IER			0x0008
+#define XM2MSC_ISR			0x000c
+#define XM2MSC_ISR_DONE			BIT(0)
+#define XM2MSC_ISR_READY		BIT(1)
+
+#define XM2MSC_NUM_OUTS			0x0010
+
+#define XM2MSC_WIDTHIN			0x000
+#define XM2MSC_WIDTHOUT			0x008
+#define XM2MSC_HEIGHTIN			0x010
+#define XM2MSC_HEIGHTOUT		0x018
+#define XM2MSC_LINERATE			0x020
+#define XM2MSC_PIXELRATE		0x028
+#define XM2MSC_INPIXELFMT		0x030
+#define XM2MSC_OUTPIXELFMT		0x038
+#define XM2MSC_INSTRIDE			0x050
+#define XM2MSC_OUTSTRIDE		0x058
+#define XM2MSC_SRCIMGBUF0		0x060
+#define XM2MSC_SRCIMGBUF1		0x070
+#define XM2MSC_DSTIMGBUF0		0x090
+#define XM2MSC_DSTIMGBUF1		0x0100
+
+#define XM2MVSC_VFLTCOEFF_L	0x2000
+#define XM2MVSC_VFLTCOEFF(x)	(XM2MVSC_VFLTCOEFF_L + 0x2000 * (x))
+#define XM2MVSC_HFLTCOEFF_L	0x2800
+#define XM2MVSC_HFLTCOEFF(x)	(XM2MVSC_HFLTCOEFF_L + 0x2000 * (x))
+
+#define XM2MSC_CHAN_REGS_START(x)	(0x100 + 0x200 * (x))
+
+/*
+ * IP has reserved area between XM2MSC_DSTIMGBUF0 and
+ * XM2MSC_DSTIMGBUF1 registers of channel 4
+ */
+#define XM2MSC_RESERVED_AREA		0x600
+
+/* GPIO RESET MACROS */
+#define XM2MSC_RESET_ASSERT	(0x1)
+#define XM2MSC_RESET_DEASSERT	(0x0)
+
+#define XM2MSC_MIN_CHAN		1
+#define XM2MSC_MAX_CHAN		8
+
+#define XM2MSC_MAX_WIDTH	(8192)
+#define XM2MSC_MAX_HEIGHT	(4320)
+#define XM2MSC_MIN_WIDTH	(64)
+#define XM2MSC_MIN_HEIGHT	(64)
+#define XM2MSC_STEP_PRECISION	(65536)
+/* Mask definitions for Low 16 bits in a 32 bit number */
+#define XM2MSC_MASK_LOW_16BITS	GENMASK(15, 0)
+#define XM2MSC_BITSHIFT_16	(16)
+
+#define XM2MSC_DRIVER_NAME	"xm2msc"
+
+#define CHAN_ATTACHED		BIT(0)
+#define CHAN_OPENED		BIT(1)
+
+#define XM2MSC_CHAN_OUT		0
+#define XM2MSC_CHAN_CAP		1
+
+#define NUM_STREAM(_x)			\
+	({ typeof(_x) (x) = (_x);	\
+	min(ffz(x->out_streamed_chan),	\
+	    ffz(x->cap_streamed_chan)); })
+
+#define XM2MSC_ALIGN_MUL	8
+
+/*
+ * These are temporary variables. Once the stride and height
+ * alignment support added to plugin, these variables will
+ * be remove.
+ */
+static unsigned int output_stride_align[XM2MSC_MAX_CHAN] = {
+					1, 1, 1, 1, 1, 1, 1, 1 };
+module_param_array(output_stride_align, uint, NULL, 0644);
+MODULE_PARM_DESC(output_stride_align,
+		 "Per Cahnnel stride alignment requied at output.");
+
+static unsigned int capture_stride_align[XM2MSC_MAX_CHAN] = {
+					1, 1, 1, 1, 1, 1, 1, 1 };
+module_param_array(capture_stride_align, uint, NULL, 0644);
+MODULE_PARM_DESC(capture_stride_align,
+		 "Per channel stride alignment requied at capture.");
+
+static unsigned int output_height_align[XM2MSC_MAX_CHAN] = {
+					1, 1, 1, 1, 1, 1, 1, 1 };
+module_param_array(output_height_align, uint, NULL, 0644);
+MODULE_PARM_DESC(output_height_align,
+		 "Per Channel height alignment requied at output.");
+
+static unsigned int capture_height_align[XM2MSC_MAX_CHAN] = {
+					1, 1, 1, 1, 1, 1, 1, 1 };
+module_param_array(capture_height_align, uint, NULL, 0644);
+MODULE_PARM_DESC(capture_height_align,
+		 "Per channel height alignment requied at capture.");
+
+/* Xilinx Video Specific Color/Pixel Formats */
+enum xm2msc_pix_fmt {
+	XILINX_M2MSC_FMT_RGBX8		= 10,
+	XILINX_M2MSC_FMT_YUVX8		= 11,
+	XILINX_M2MSC_FMT_YUYV8		= 12,
+	XILINX_M2MSC_FMT_RGBX10		= 15,
+	XILINX_M2MSC_FMT_YUVX10		= 16,
+	XILINX_M2MSC_FMT_Y_UV8		= 18,
+	XILINX_M2MSC_FMT_Y_UV8_420	= 19,
+	XILINX_M2MSC_FMT_RGB8		= 20,
+	XILINX_M2MSC_FMT_YUV8		= 21,
+	XILINX_M2MSC_FMT_Y_UV10		= 22,
+	XILINX_M2MSC_FMT_Y_UV10_420	= 23,
+	XILINX_M2MSC_FMT_Y8		= 24,
+	XILINX_M2MSC_FMT_Y10		= 25,
+	XILINX_M2MSC_FMT_BGRX8		= 27,
+	XILINX_M2MSC_FMT_UYVY8		= 28,
+	XILINX_M2MSC_FMT_BGR8		= 29,
+};
+
+/**
+ * struct xm2msc_fmt - driver info for each of the supported video formats
+ * @name: human-readable device tree name for this entry
+ * @fourcc: standard format identifier
+ * @xm2msc_fmt: Xilinx Video Specific Color/Pixel Formats
+ * @num_buffs: number of physically non-contiguous data planes/buffs
+ */
+struct xm2msc_fmt {
+	char *name;
+	u32 fourcc;
+	enum xm2msc_pix_fmt xm2msc_fmt;
+	u32 num_buffs;
+};
+
+static const struct xm2msc_fmt formats[] = {
+	{
+		.name = "xbgr8888",
+		.fourcc = V4L2_PIX_FMT_BGRX32,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_RGBX8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "xvuy8888",
+		.fourcc = V4L2_PIX_FMT_XVUY32,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_YUVX8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "yuyv",
+		.fourcc = V4L2_PIX_FMT_YUYV,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_YUYV8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "xbgr2101010",
+		.fourcc = V4L2_PIX_FMT_XBGR30,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_RGBX10,
+		.num_buffs = 1,
+	},
+	{
+		.name = "yuvx2101010",
+		.fourcc = V4L2_PIX_FMT_XVUY10,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_YUVX10,
+		.num_buffs = 1,
+	},
+	{
+		.name = "nv16",
+		.fourcc = V4L2_PIX_FMT_NV16M,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV8,
+		.num_buffs = 2,
+	},
+	{
+		.name = "nv16",
+		.fourcc = V4L2_PIX_FMT_NV16,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "nv12",
+		.fourcc = V4L2_PIX_FMT_NV12M,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV8_420,
+		.num_buffs = 2,
+	},
+	{
+		.name = "nv12",
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV8_420,
+		.num_buffs = 1,
+	},
+	{
+		.name = "bgr888",
+		.fourcc = V4L2_PIX_FMT_RGB24,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_RGB8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "vuy888",
+		.fourcc = V4L2_PIX_FMT_VUY24,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_YUV8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "xv20",
+		.fourcc = V4L2_PIX_FMT_XV20M,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV10,
+		.num_buffs = 2,
+	},
+	{
+		.name = "xv20",
+		.fourcc = V4L2_PIX_FMT_XV20,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV10,
+		.num_buffs = 1,
+	},
+	{
+		.name = "xv15",
+		.fourcc = V4L2_PIX_FMT_XV15M,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV10_420,
+		.num_buffs = 2,
+	},
+	{
+		.name = "xv15",
+		.fourcc = V4L2_PIX_FMT_XV15,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y_UV10_420,
+		.num_buffs = 1,
+	},
+	{
+		.name = "y8",
+		.fourcc = V4L2_PIX_FMT_GREY,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "y10",
+		.fourcc = V4L2_PIX_FMT_Y10,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_Y10,
+		.num_buffs = 1,
+	},
+	{
+		.name = "xrgb8888",
+		.fourcc = V4L2_PIX_FMT_XBGR32,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_BGRX8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "uyvy",
+		.fourcc = V4L2_PIX_FMT_UYVY,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_UYVY8,
+		.num_buffs = 1,
+	},
+	{
+		.name = "rgb888",
+		.fourcc = V4L2_PIX_FMT_BGR24,
+		.xm2msc_fmt = XILINX_M2MSC_FMT_BGR8,
+		.num_buffs = 1,
+	},
+};
+
+/**
+ * struct xm2msc_q_data - Per-queue, driver-specific private data
+ * There is one source queue and one destination queue for each m2m context.
+ * @width: frame width
+ * @height: frame height
+ * @stride: bytes per lines
+ * @nbuffs: Current number of buffs
+ * @bytesperline: bytes per line per plane
+ * @sizeimage: image size per plane
+ * @colorspace: supported colorspace
+ * @field: supported field value
+ * @fmt: format info
+ */
+struct xm2msc_q_data {
+	unsigned int width;
+	unsigned int height;
+	unsigned int stride;
+	unsigned int nbuffs;
+	unsigned int bytesperline[2];
+	unsigned int sizeimage[2];
+	enum v4l2_colorspace colorspace;
+	enum v4l2_field field;
+	const struct xm2msc_fmt *fmt;
+};
+
+/**
+ * struct xm2msc_chan_ctx - Scaler Channel Info, Per-Channel context
+ * @regs: IO mapped base address of the Channel
+ * @xm2msc_dev: Pointer to struct xm2m_msc_dev
+ * @num: HW Scaling Channel number
+ * @minor: Minor number of the video device
+ * @output_stride_align: required align stride value at output pad
+ * @capture_stride_align: required align stride valure at capture pad
+ * @output_height_align: required align height value at output pad
+ * @capture_height_align: required align heigh value at capture pad
+ * @status: channel status, CHAN_ATTACHED or CHAN_OPENED
+ * @frames: number of frames processed
+ * @vfd: V4L2 device
+ * @fh: v4l2 file handle
+ * @m2m_dev: m2m device
+ * @m2m_ctx: memory to memory context structure
+ * @q_data: src & dst queue data
+ */
+struct xm2msc_chan_ctx {
+	void __iomem *regs;
+	struct xm2m_msc_dev *xm2msc_dev;
+	u32 num;
+	u32 minor;
+	u32 output_stride_align;
+	u32 capture_stride_align;
+	u32 output_height_align;
+	u32 capture_height_align;
+	u8 status;
+	unsigned long frames;
+
+	struct video_device vfd;
+	struct v4l2_fh fh;
+	struct v4l2_m2m_dev *m2m_dev;
+	struct v4l2_m2m_ctx *m2m_ctx;
+
+	struct xm2msc_q_data q_data[2];
+};
+
+/**
+ * struct xm2m_msc_dev - Xilinx M2M Multi-scaler Device
+ * @dev: pointer to struct device instance used by the driver
+ * @regs: IO mapped base address of the HW/IP
+ * @irq: interrupt number
+ * @clk: video core clock
+ * @max_chan: maximum number of Scaling Channels
+ * @max_ht: maximum number of rows in a plane
+ * @max_wd: maximum number of column in a plane
+ * @taps: number of taps set in HW
+ * @supported_fmt: bitmap for all supported fmts by HW
+ * @dma_addr_size: Size of dma address pointer in IP (either 32 or 64)
+ * @ppc: Pixels per clock set in IP (1, 2 or 4)
+ * @rst_gpio: reset gpio handler
+ * @opened_chan: bitmap for all open channel
+ * @out_streamed_chan: bitmap for all out streamed channel
+ * @cap_streamed_chan: bitmap for all capture streamed channel
+ * @running_chan: currently running channels
+ * @device_busy: HW device is busy or not
+ * @isr_wait: flag to follow the ISR complete or not
+ * @isr_finished: Wait queue used to wait for IP to complete processing
+ * @v4l2_dev: main struct to for V4L2 device drivers
+ * @dev_mutex: lock for V4L2 device
+ * @mutex: lock for channel ctx
+ * @lock: lock used in IRQ
+ * @xm2msc_chan: arrey of channel context
+ * @hscaler_coeff: Array of filter coefficients for the Horizontal Scaler
+ * @vscaler_coeff: Array of filter coefficients for the Vertical Scaler
+ */
+struct xm2m_msc_dev {
+	struct device *dev;
+	void __iomem *regs;
+	int irq;
+	struct clk *clk;
+	u32 max_chan;
+	u32 max_ht;
+	u32 max_wd;
+	u32 taps;
+	u32 supported_fmt;
+	u32 dma_addr_size;
+	u8 ppc;
+	struct gpio_desc *rst_gpio;
+
+	u32 opened_chan;
+	u32 out_streamed_chan;
+	u32 cap_streamed_chan;
+	u32 running_chan;
+	bool device_busy;
+	bool isr_wait;
+	wait_queue_head_t isr_finished;
+
+	struct v4l2_device v4l2_dev;
+
+	struct mutex dev_mutex; /*the mutex for v4l2*/
+	struct mutex mutex; /*lock for bitmap reg*/
+	spinlock_t lock; /*IRQ lock*/
+
+	struct xm2msc_chan_ctx xm2msc_chan[XM2MSC_MAX_CHAN];
+	short hscaler_coeff[XSCALER_MAX_PHASES][XSCALER_MAX_TAPS];
+	short vscaler_coeff[XSCALER_MAX_PHASES][XSCALER_MAX_TAPS];
+};
+
+#define fh_to_chanctx(__fh) container_of(__fh, struct xm2msc_chan_ctx, fh)
+
+static inline u32 xm2msc_readreg(const void __iomem *addr)
+{
+	return ioread32(addr);
+}
+
+static inline void xm2msc_write64reg(void __iomem *addr, u64 value)
+{
+	iowrite32(lower_32_bits(value), addr);
+	iowrite32(upper_32_bits(value), (void __iomem *)(addr + 4));
+}
+
+static inline void xm2msc_writereg(void __iomem *addr, u32 value)
+{
+	iowrite32(value, addr);
+}
+
+static bool xm2msc_is_yuv_singlebuff(u32 fourcc)
+{
+	if (fourcc == V4L2_PIX_FMT_NV12 || fourcc == V4L2_PIX_FMT_XV15 ||
+	    fourcc ==  V4L2_PIX_FMT_NV16 || fourcc == V4L2_PIX_FMT_XV20)
+		return true;
+
+	return false;
+}
+
+static inline u32 xm2msc_yuv_1stplane_size(struct xm2msc_q_data *q_data,
+					   u32 row_align)
+{
+	return	q_data->bytesperline[0] * ALIGN(q_data->height, row_align);
+}
+
+static struct xm2msc_q_data *get_q_data(struct xm2msc_chan_ctx *chan_ctx,
+					enum v4l2_buf_type type)
+{
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		return &chan_ctx->q_data[XM2MSC_CHAN_OUT];
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		return &chan_ctx->q_data[XM2MSC_CHAN_CAP];
+	default:
+		v4l2_err(&chan_ctx->xm2msc_dev->v4l2_dev,
+			 "Not supported Q type %d\n", type);
+	}
+	return NULL;
+}
+
+static u32 find_format_index(struct v4l2_format *f)
+{
+	const struct xm2msc_fmt *fmt;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(formats); i++) {
+		fmt = &formats[i];
+		if (fmt->fourcc == f->fmt.pix_mp.pixelformat)
+			break;
+	}
+
+	return i;
+}
+
+static const struct xm2msc_fmt *find_format(struct v4l2_format *f)
+{
+	const struct xm2msc_fmt *fmt;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(formats); i++) {
+		fmt = &formats[i];
+		if (fmt->fourcc == f->fmt.pix_mp.pixelformat)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(formats))
+		return NULL;
+
+	return &formats[i];
+}
+
+static void
+xm2msc_hscaler_load_ext_coeff(struct xm2m_msc_dev *xm2msc,
+			      const short *coeff, u32 ntaps)
+{
+	unsigned int i, j, pad, offset;
+	const u32 nphases = XSCALER_MAX_PHASES;
+
+	/* Determine if coefficient needs padding (effective vs. max taps) */
+	pad = XSCALER_MAX_TAPS - ntaps;
+	offset = pad >> 1;
+
+	memset(xm2msc->hscaler_coeff, 0, sizeof(xm2msc->hscaler_coeff));
+
+	/* Load coefficients into scaler coefficient table */
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps; ++j)
+			xm2msc->hscaler_coeff[i][j + offset] =
+						coeff[i * ntaps + j];
+	}
+}
+
+static void xm2msc_hscaler_set_coeff(struct xm2msc_chan_ctx *chan_ctx,
+				     const u32 base_addr)
+{
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	int val, offset, rd_indx;
+	unsigned int i, j;
+	u32 ntaps = chan_ctx->xm2msc_dev->taps;
+	const u32 nphases = XSCALER_MAX_PHASES;
+
+	offset = (XSCALER_MAX_TAPS - ntaps) / 2;
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps / 2; j++) {
+			rd_indx = j * 2 + offset;
+			val = (xm2msc->hscaler_coeff[i][rd_indx + 1] <<
+			       XM2MSC_BITSHIFT_16) |
+			       (xm2msc->hscaler_coeff[i][rd_indx] &
+			       XM2MSC_MASK_LOW_16BITS);
+			 xm2msc_writereg((xm2msc->regs + base_addr) +
+				    ((i * ntaps / 2 + j) * 4), val);
+		}
+	}
+}
+
+static void
+xm2msc_vscaler_load_ext_coeff(struct xm2m_msc_dev *xm2msc,
+			      const short *coeff, const u32 ntaps)
+{
+	unsigned int i, j;
+	int pad, offset;
+	const u32 nphases = XSCALER_MAX_PHASES;
+
+	/* Determine if coefficient needs padding (effective vs. max taps) */
+	pad = XSCALER_MAX_TAPS - ntaps;
+	offset = pad ? (pad >> 1) : 0;
+
+	/* Zero Entire Array */
+	memset(xm2msc->vscaler_coeff, 0, sizeof(xm2msc->vscaler_coeff));
+
+	/* Load User defined coefficients into scaler coefficient table */
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps; ++j)
+			xm2msc->vscaler_coeff[i][j + offset] =
+						coeff[i * ntaps + j];
+	}
+}
+
+static void
+xm2msc_vscaler_set_coeff(struct xm2msc_chan_ctx *chan_ctx,
+			 const u32 base_addr)
+{
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	u32 val, i, j, offset, rd_indx;
+	u32 ntaps = chan_ctx->xm2msc_dev->taps;
+	const u32 nphases = XSCALER_MAX_PHASES;
+
+	offset = (XSCALER_MAX_TAPS - ntaps) / 2;
+
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps / 2; j++) {
+			rd_indx = j * 2 + offset;
+			val = (xm2msc->vscaler_coeff[i][rd_indx + 1] <<
+			       XM2MSC_BITSHIFT_16) |
+			       (xm2msc->vscaler_coeff[i][rd_indx] &
+			       XM2MSC_MASK_LOW_16BITS);
+			xm2msc_writereg((xm2msc->regs +
+				   base_addr) + ((i * ntaps / 2 + j) * 4), val);
+		}
+	}
+}
+
+static u32
+xm2msc_select_hcoeff(struct xm2msc_chan_ctx *chan_ctx, const short **coeff)
+{
+	u16 hscale_ratio;
+	u32 width_in = chan_ctx->q_data[XM2MSC_CHAN_OUT].width;
+	u32 width_out = chan_ctx->q_data[XM2MSC_CHAN_CAP].width;
+	u32 ntaps;
+
+	if (width_out < width_in) {
+		hscale_ratio = (width_in * 10) / width_out;
+
+		switch (chan_ctx->xm2msc_dev->taps) {
+		case XSCALER_TAPS_12:
+			if (hscale_ratio > 35) {
+				*coeff = &xhsc_coeff_taps12[0][0];
+				ntaps = XSCALER_TAPS_12;
+			} else if (hscale_ratio > 25) {
+				*coeff = &xhsc_coeff_taps10[0][0];
+				ntaps = XSCALER_TAPS_10;
+			} else if (hscale_ratio > 15) {
+				*coeff = &xhsc_coeff_taps8[0][0];
+				ntaps = XSCALER_TAPS_8;
+			} else {
+				*coeff = &xhsc_coeff_taps6[0][0];
+				ntaps = XSCALER_TAPS_6;
+			}
+		break;
+		case XSCALER_TAPS_10:
+			if (hscale_ratio > 25) {
+				*coeff = &xhsc_coeff_taps10[0][0];
+				ntaps = XSCALER_TAPS_10;
+			} else if (hscale_ratio > 15) {
+				*coeff = &xhsc_coeff_taps8[0][0];
+				ntaps = XSCALER_TAPS_8;
+			} else {
+				*coeff = &xhsc_coeff_taps6[0][0];
+				ntaps = XSCALER_TAPS_6;
+			}
+		break;
+		case XSCALER_TAPS_8:
+			if (hscale_ratio > 15) {
+				*coeff = &xhsc_coeff_taps8[0][0];
+				ntaps = XSCALER_TAPS_8;
+			} else {
+				*coeff = &xhsc_coeff_taps6[0][0];
+				ntaps = XSCALER_TAPS_6;
+			}
+		break;
+		default: /* or XSCALER_TAPS_6 */
+			*coeff = &xhsc_coeff_taps6[0][0];
+			ntaps = XSCALER_TAPS_6;
+		}
+	} else {
+		/*
+		 * Scale Up Mode will always use 6 tap filter
+		 * This also includes 1:1
+		 */
+		*coeff = &xhsc_coeff_taps6[0][0];
+		ntaps = XSCALER_TAPS_6;
+	}
+
+	return ntaps;
+}
+
+static u32
+xm2msc_select_vcoeff(struct xm2msc_chan_ctx *chan_ctx, const short **coeff)
+{
+	u16 vscale_ratio;
+	u32 height_in = chan_ctx->q_data[XM2MSC_CHAN_OUT].height;
+	u32 height_out = chan_ctx->q_data[XM2MSC_CHAN_CAP].height;
+	u32 ntaps;
+
+	if (height_out < height_in) {
+		vscale_ratio = (height_in * 10) / height_out;
+
+		switch (chan_ctx->xm2msc_dev->taps) {
+		case XSCALER_TAPS_12:
+			if (vscale_ratio > 35) {
+				*coeff = &xvsc_coeff_taps12[0][0];
+				ntaps = XSCALER_TAPS_12;
+			} else if (vscale_ratio > 25) {
+				*coeff = &xvsc_coeff_taps10[0][0];
+				ntaps = XSCALER_TAPS_10;
+			} else if (vscale_ratio > 15) {
+				*coeff = &xvsc_coeff_taps8[0][0];
+				ntaps = XSCALER_TAPS_8;
+			} else {
+				*coeff = &xvsc_coeff_taps6[0][0];
+				ntaps = XSCALER_TAPS_6;
+			}
+		break;
+		case XSCALER_TAPS_10:
+			if (vscale_ratio > 25) {
+				*coeff = &xvsc_coeff_taps10[0][0];
+				ntaps = XSCALER_TAPS_10;
+			} else if (vscale_ratio > 15) {
+				*coeff = &xvsc_coeff_taps8[0][0];
+				ntaps = XSCALER_TAPS_8;
+			} else {
+				*coeff = &xvsc_coeff_taps6[0][0];
+				ntaps = XSCALER_TAPS_6;
+			}
+		break;
+		case XSCALER_TAPS_8:
+			if (vscale_ratio > 15) {
+				*coeff = &xvsc_coeff_taps8[0][0];
+				ntaps = XSCALER_TAPS_8;
+			} else {
+				*coeff = &xvsc_coeff_taps6[0][0];
+				ntaps = XSCALER_TAPS_6;
+			}
+		break;
+		default: /* or XSCALER_TAPS_6 */
+			*coeff = &xvsc_coeff_taps6[0][0];
+			ntaps = XSCALER_TAPS_6;
+		}
+	} else {
+		/*
+		 * Scale Up Mode will always use 6 tap filter
+		 * This also includes 1:1
+		 */
+		*coeff = &xvsc_coeff_taps6[0][0];
+		ntaps = XSCALER_TAPS_6;
+	}
+
+	return ntaps;
+}
+
+static void xm2mvsc_initialize_coeff_banks(struct xm2msc_chan_ctx *chan_ctx)
+{
+	const short *coeff = NULL;
+	u32 ntaps;
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+
+	ntaps = xm2msc_select_hcoeff(chan_ctx, &coeff);
+	xm2msc_hscaler_load_ext_coeff(xm2msc, coeff, ntaps);
+	xm2msc_hscaler_set_coeff(chan_ctx, XM2MVSC_HFLTCOEFF(chan_ctx->num));
+
+	dev_dbg(xm2msc->dev, "htaps %d selected for chan %d\n",
+		ntaps, chan_ctx->num);
+
+	ntaps = xm2msc_select_vcoeff(chan_ctx, &coeff);
+	xm2msc_vscaler_load_ext_coeff(xm2msc, coeff, ntaps);
+	xm2msc_vscaler_set_coeff(chan_ctx, XM2MVSC_VFLTCOEFF(chan_ctx->num));
+
+	dev_dbg(xm2msc->dev, "vtaps %d selected for chan %d\n",
+		ntaps, chan_ctx->num);
+}
+
+static int xm2msc_set_chan_params(struct xm2msc_chan_ctx *chan_ctx,
+				  enum v4l2_buf_type type)
+{
+	struct xm2msc_q_data *q_data = get_q_data(chan_ctx, type);
+	const struct xm2msc_fmt *fmt;
+	void __iomem *base = chan_ctx->regs;
+
+	if (!q_data)
+		return -EINVAL;
+
+	fmt = q_data->fmt;
+
+	if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		xm2msc_writereg(base + XM2MSC_WIDTHIN, q_data->width);
+		xm2msc_writereg(base + XM2MSC_HEIGHTIN, q_data->height);
+		xm2msc_writereg(base + XM2MSC_INPIXELFMT, fmt->xm2msc_fmt);
+		xm2msc_writereg(base + XM2MSC_INSTRIDE, q_data->stride);
+	} else {
+		xm2msc_writereg(base + XM2MSC_WIDTHOUT, q_data->width);
+		xm2msc_writereg(base + XM2MSC_HEIGHTOUT, q_data->height);
+		xm2msc_writereg(base + XM2MSC_OUTPIXELFMT, fmt->xm2msc_fmt);
+		xm2msc_writereg(base + XM2MSC_OUTSTRIDE, q_data->stride);
+	}
+
+	return 0;
+}
+
+static void xm2msc_set_chan_com_params(struct xm2msc_chan_ctx *chan_ctx)
+{
+	void __iomem *base = chan_ctx->regs;
+	struct xm2msc_q_data *out_q_data = &chan_ctx->q_data[XM2MSC_CHAN_OUT];
+	struct xm2msc_q_data *cap_q_data = &chan_ctx->q_data[XM2MSC_CHAN_CAP];
+	u32 pixel_rate;
+	u32 line_rate;
+
+	xm2mvsc_initialize_coeff_banks(chan_ctx);
+
+	pixel_rate = (out_q_data->width * XM2MSC_STEP_PRECISION) /
+		cap_q_data->width;
+	line_rate = (out_q_data->height * XM2MSC_STEP_PRECISION) /
+		cap_q_data->height;
+
+	xm2msc_writereg(base + XM2MSC_PIXELRATE, pixel_rate);
+	xm2msc_writereg(base + XM2MSC_LINERATE, line_rate);
+}
+
+static int xm2msc_program_allchan(struct xm2m_msc_dev *xm2msc)
+{
+	u32 chan;
+
+	for (chan = 0; chan < xm2msc->running_chan; chan++) {
+		struct xm2msc_chan_ctx *chan_ctx;
+		enum v4l2_buf_type type;
+		int ret;
+
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+		ret = xm2msc_set_chan_params(chan_ctx, type);
+		if (ret)
+			return ret;
+
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+		ret = xm2msc_set_chan_params(chan_ctx, type);
+		if (ret)
+			return ret;
+		xm2msc_set_chan_com_params(chan_ctx);
+	}
+	return 0;
+}
+
+static void
+xm2msc_pr_q(struct device *dev, struct xm2msc_q_data *q, int chan,
+	    int type, const char *fun_name)
+{
+	unsigned int i;
+	const struct xm2msc_fmt *fmt = q->fmt;
+
+	if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		dev_dbg(dev, "\n\nOUTPUT Q (%d) Context from [[ %s ]]",
+			chan, fun_name);
+	else
+		dev_dbg(dev, "\n\nCAPTURE Q (%d) Context from [[ %s ]]",
+			chan, fun_name);
+
+	dev_dbg(dev, "width height stride clrspace field planes\n");
+	dev_dbg(dev, "  %d  %d    %d     %d       %d    %d\n",
+		q->width, q->height, q->stride,
+		q->colorspace, q->field, q->nbuffs);
+
+	for (i = 0; i < q->nbuffs; i++) {
+		dev_dbg(dev, "[plane %d ] bytesperline sizeimage\n", i);
+		dev_dbg(dev, "                %d        %d\n",
+			q->bytesperline[i], q->sizeimage[i]);
+	}
+
+	dev_dbg(dev, "fmt_name 4cc xlnx-fmt\n");
+	dev_dbg(dev, "%s %d %d\n",
+		fmt->name, fmt->fourcc, fmt->xm2msc_fmt);
+	dev_dbg(dev, "\n\n");
+}
+
+static void
+xm2msc_pr_status(struct xm2m_msc_dev *xm2msc,
+		 const char *fun_name)
+{
+	struct device *dev = xm2msc->dev;
+
+	dev_dbg(dev, "Status in %s\n", fun_name);
+	dev_dbg(dev, "opened_chan out_streamed_chan cap_streamed_chan\n");
+	dev_dbg(dev, "0x%x           0x%x               0x%x\n",
+		xm2msc->opened_chan, xm2msc->out_streamed_chan,
+		xm2msc->cap_streamed_chan);
+	dev_dbg(dev, "\n\n");
+}
+
+static void
+xm2msc_pr_chanctx(struct xm2msc_chan_ctx *ctx, const char *fun_name)
+{
+	struct device *dev = ctx->xm2msc_dev->dev;
+
+	dev_dbg(dev, "\n\n----- [[ %s ]]: Channel %d (0x%p) context -----\n",
+		fun_name, ctx->num, ctx);
+	dev_dbg(dev, "minor = %d\n", ctx->minor);
+	dev_dbg(dev, "reg mapped at %p\n", ctx->regs);
+	dev_dbg(dev, "xm2msc \tm2m_dev \tm2m_ctx\n");
+	dev_dbg(dev, "%p \t%p \t%p\n", ctx->xm2msc_dev,
+		ctx->m2m_dev, ctx->m2m_ctx);
+
+	if (ctx->status & CHAN_OPENED)
+		dev_dbg(dev, "Opened ");
+	if (ctx->status & CHAN_ATTACHED)
+		dev_dbg(dev, "and attached");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "-----------------------------------\n");
+	dev_dbg(dev, "\n\n");
+}
+
+static void
+xm2msc_pr_screg(struct device *dev, const void __iomem *base)
+{
+	dev_dbg(dev, "Ctr, GIE,  IE,  IS   OUT\n");
+	dev_dbg(dev, "0x%x  0x%x   0x%x  0x%x  0x%x\n",
+		xm2msc_readreg(base + XM2MSC_AP_CTRL),
+		xm2msc_readreg(base + XM2MSC_GIE),
+		xm2msc_readreg(base + XM2MSC_IER),
+		xm2msc_readreg(base + XM2MSC_ISR),
+		xm2msc_readreg(base + XM2MSC_NUM_OUTS));
+}
+
+static void
+xm2msc_pr_chanreg(struct device *dev, struct xm2msc_chan_ctx *chan)
+{
+	const void __iomem *base = chan->regs;
+
+	dev_dbg(dev, "WIN HIN INPIXELFMT INSTRIDE SRCB0L/H SRCB1L/H\n");
+	dev_dbg(dev, "%d   %d     %d       %d      0x%x/0x%x      0x%x/0x%x\n",
+		xm2msc_readreg(base + XM2MSC_WIDTHIN),
+		xm2msc_readreg(base + XM2MSC_HEIGHTIN),
+		xm2msc_readreg(base + XM2MSC_INPIXELFMT),
+		xm2msc_readreg(base + XM2MSC_INSTRIDE),
+		xm2msc_readreg(base + XM2MSC_SRCIMGBUF0),
+		xm2msc_readreg(base + XM2MSC_SRCIMGBUF0 + 4),
+		xm2msc_readreg(base + XM2MSC_SRCIMGBUF1),
+		xm2msc_readreg(base + XM2MSC_SRCIMGBUF1 + 4));
+	dev_dbg(dev, "WOUT HOUT OUTPIXELFMT OUTSTRIDE DBUF0L/H DBUF1L/H\n");
+	dev_dbg(dev, "%d   %d     %d       %d      0x%x/0x%x      0x%x/0x%x\n",
+		xm2msc_readreg(base + XM2MSC_WIDTHOUT),
+		xm2msc_readreg(base + XM2MSC_HEIGHTOUT),
+		xm2msc_readreg(base + XM2MSC_OUTPIXELFMT),
+		xm2msc_readreg(base + XM2MSC_OUTSTRIDE),
+		xm2msc_readreg(base + XM2MSC_DSTIMGBUF0),
+		xm2msc_readreg(base + XM2MSC_DSTIMGBUF0 + 4),
+		chan->num == 4 ?
+		xm2msc_readreg(base +
+			       XM2MSC_DSTIMGBUF1 + XM2MSC_RESERVED_AREA) :
+			xm2msc_readreg(base + XM2MSC_DSTIMGBUF1),
+		chan->num == 4 ?
+		xm2msc_readreg(base +
+			       XM2MSC_DSTIMGBUF1 + XM2MSC_RESERVED_AREA + 4) :
+			xm2msc_readreg(base + XM2MSC_DSTIMGBUF1 + 4));
+
+	dev_dbg(dev, "LINERATE PIXELRATE\n");
+	dev_dbg(dev, "0x%x     0x%x\n",
+		xm2msc_readreg(base + XM2MSC_LINERATE),
+		xm2msc_readreg(base + XM2MSC_PIXELRATE));
+}
+
+static void
+xm2msc_pr_allchanreg(struct xm2m_msc_dev *xm2msc)
+{
+	unsigned int i;
+	struct xm2msc_chan_ctx *chan_ctx;
+	struct device *dev = xm2msc->dev;
+
+	xm2msc_pr_screg(xm2msc->dev, xm2msc->regs);
+
+	for (i = 0; i < xm2msc->running_chan; i++) {
+		chan_ctx = &xm2msc->xm2msc_chan[i];
+		dev_dbg(dev, "Regs val for channel %d\n", i);
+		dev_dbg(dev, "______________________________________________\n");
+		xm2msc_pr_chanreg(dev, chan_ctx);
+		dev_dbg(dev, "processed frames = %lu\n", chan_ctx->frames);
+		dev_dbg(dev, "______________________________________________\n");
+	}
+}
+
+static inline bool xm2msc_testbit(int num, u32 *addr)
+{
+	return (*addr & BIT(num));
+}
+
+static inline void xm2msc_setbit(int num, u32 *addr)
+{
+	*addr |= BIT(num);
+}
+
+static inline void xm2msc_clrbit(int num, u32 *addr)
+{
+	*addr &= ~BIT(num);
+}
+
+static void xm2msc_stop(struct xm2m_msc_dev *xm2msc)
+{
+	void __iomem *base = xm2msc->regs;
+	u32 data = xm2msc_readreg(base + XM2MSC_AP_CTRL);
+
+	data &= ~XM2MSC_AP_CTRL_START;
+	xm2msc_writereg(base + XM2MSC_AP_CTRL, data);
+}
+
+static void xm2msc_start(struct xm2m_msc_dev *xm2msc)
+{
+	void __iomem *base = xm2msc->regs;
+	u32 data = xm2msc_readreg(base + XM2MSC_AP_CTRL);
+
+	data |= XM2MSC_AP_CTRL_START;
+	xm2msc_writereg(base + XM2MSC_AP_CTRL, data);
+}
+
+static void xm2msc_set_chan(struct xm2msc_chan_ctx *ctx, bool state)
+{
+	mutex_lock(&ctx->xm2msc_dev->mutex);
+	if (state)
+		xm2msc_setbit(ctx->num, &ctx->xm2msc_dev->opened_chan);
+	else
+		xm2msc_clrbit(ctx->num, &ctx->xm2msc_dev->opened_chan);
+	mutex_unlock(&ctx->xm2msc_dev->mutex);
+}
+
+static void
+xm2msc_set_chan_stream(struct xm2msc_chan_ctx *ctx, bool state, int type)
+{
+	u32 *ptr;
+
+	if (type == XM2MSC_CHAN_OUT)
+		ptr = &ctx->xm2msc_dev->out_streamed_chan;
+	else
+		ptr = &ctx->xm2msc_dev->cap_streamed_chan;
+
+	spin_lock(&ctx->xm2msc_dev->lock);
+	if (state)
+		xm2msc_setbit(ctx->num, ptr);
+	else
+		xm2msc_clrbit(ctx->num, ptr);
+
+	spin_unlock(&ctx->xm2msc_dev->lock);
+}
+
+static int
+xm2msc_chk_chan_stream(struct xm2msc_chan_ctx *ctx, int type)
+{
+	u32 *ptr;
+	int ret;
+
+	if (type == XM2MSC_CHAN_OUT)
+		ptr = &ctx->xm2msc_dev->out_streamed_chan;
+	else
+		ptr = &ctx->xm2msc_dev->cap_streamed_chan;
+
+	mutex_lock(&ctx->xm2msc_dev->mutex);
+	ret = xm2msc_testbit(ctx->num, ptr);
+	mutex_unlock(&ctx->xm2msc_dev->mutex);
+
+	return ret;
+}
+
+static void xm2msc_set_fmt(struct xm2m_msc_dev *xm2msc, u32 index)
+{
+	xm2msc_setbit(index, &xm2msc->supported_fmt);
+}
+
+static int xm2msc_chk_fmt(struct xm2m_msc_dev *xm2msc, u32 index)
+{
+	return xm2msc_testbit(index, &xm2msc->supported_fmt);
+}
+
+static void xm2msc_reset(struct xm2m_msc_dev *xm2msc)
+{
+	gpiod_set_value_cansleep(xm2msc->rst_gpio, XM2MSC_RESET_ASSERT);
+	gpiod_set_value_cansleep(xm2msc->rst_gpio, XM2MSC_RESET_DEASSERT);
+}
+
+/*
+ * mem2mem callbacks
+ */
+static int xm2msc_job_ready(void *priv)
+{
+	struct xm2msc_chan_ctx *chan_ctx = priv;
+
+	if ((v4l2_m2m_num_src_bufs_ready(chan_ctx->m2m_ctx) > 0) &&
+	    (v4l2_m2m_num_dst_bufs_ready(chan_ctx->m2m_ctx) > 0))
+		return 1;
+	return 0;
+}
+
+static bool xm2msc_alljob_ready(struct xm2m_msc_dev *xm2msc)
+{
+	struct xm2msc_chan_ctx *chan_ctx;
+	unsigned int chan;
+
+	for (chan = 0; chan < xm2msc->running_chan; chan++) {
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+
+		if (!xm2msc_job_ready((void *)chan_ctx)) {
+			dev_dbg(xm2msc->dev, "chan %d not ready\n",
+				chan_ctx->num);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static void xm2msc_chan_abort_bufs(struct xm2msc_chan_ctx *chan_ctx)
+{
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	struct vb2_v4l2_buffer *dst_vb, *src_vb;
+
+	spin_lock(&xm2msc->lock);
+	dev_dbg(xm2msc->dev, "aborting all buffers\n");
+
+	while (v4l2_m2m_num_src_bufs_ready(chan_ctx->m2m_ctx) > 0) {
+		src_vb = v4l2_m2m_src_buf_remove(chan_ctx->m2m_ctx);
+		if (src_vb)
+			v4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_ERROR);
+	}
+
+	while (v4l2_m2m_num_dst_bufs_ready(chan_ctx->m2m_ctx) > 0) {
+		dst_vb = v4l2_m2m_dst_buf_remove(chan_ctx->m2m_ctx);
+		if (dst_vb)
+			v4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_ERROR);
+	}
+
+	v4l2_m2m_job_finish(chan_ctx->m2m_dev, chan_ctx->m2m_ctx);
+	spin_unlock(&xm2msc->lock);
+}
+
+static void xm2msc_job_abort(void *priv)
+{
+	struct xm2msc_chan_ctx *chan_ctx = priv;
+
+	xm2msc_chan_abort_bufs(chan_ctx);
+
+	/*
+	 * Stream off the channel as job_abort may not always
+	 * be called after streamoff
+	 */
+	xm2msc_set_chan_stream(chan_ctx, false, XM2MSC_CHAN_OUT);
+	xm2msc_set_chan_stream(chan_ctx, false, XM2MSC_CHAN_CAP);
+}
+
+static int xm2msc_set_bufaddr(struct xm2m_msc_dev *xm2msc)
+{
+	unsigned int chan;
+	u32 row_align;
+	struct xm2msc_chan_ctx *chan_ctx;
+	struct vb2_v4l2_buffer *src_vb, *dst_vb;
+	void __iomem *base;
+	struct xm2msc_q_data *q_data;
+	dma_addr_t src_luma, dst_luma;
+	dma_addr_t src_croma, dst_croma;
+
+	if (!xm2msc_alljob_ready(xm2msc))
+		return -EINVAL;
+
+	for (chan = 0; chan < xm2msc->running_chan; chan++) {
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+		base = chan_ctx->regs;
+
+		src_vb = v4l2_m2m_next_src_buf(chan_ctx->m2m_ctx);
+		dst_vb = v4l2_m2m_next_dst_buf(chan_ctx->m2m_ctx);
+
+		if (!src_vb || !dst_vb) {
+			v4l2_err(&xm2msc->v4l2_dev, "buffer not found chan = %d\n",
+				 chan_ctx->num);
+			return -EINVAL;
+		}
+
+		src_luma = vb2_dma_contig_plane_dma_addr(&src_vb->vb2_buf, 0);
+		dst_luma = vb2_dma_contig_plane_dma_addr(&dst_vb->vb2_buf, 0);
+
+		q_data = &chan_ctx->q_data[XM2MSC_CHAN_OUT];
+		row_align = chan_ctx->output_height_align;
+		if (chan_ctx->q_data[XM2MSC_CHAN_OUT].nbuffs == 2)
+			/* fmts having 2 planes 2 buffers */
+			src_croma =
+				vb2_dma_contig_plane_dma_addr(&src_vb->vb2_buf,
+							      1);
+		else if (xm2msc_is_yuv_singlebuff(q_data->fmt->fourcc))
+			/* fmts having 2 planes 1 contiguous buffer */
+			src_croma = src_luma +
+				xm2msc_yuv_1stplane_size(q_data, row_align);
+		else /* fmts having 1 planes 1 contiguous buffer */
+			src_croma = 0;
+
+		q_data = &chan_ctx->q_data[XM2MSC_CHAN_CAP];
+		row_align = chan_ctx->capture_height_align;
+		if (chan_ctx->q_data[XM2MSC_CHAN_CAP].nbuffs == 2)
+			dst_croma =
+				vb2_dma_contig_plane_dma_addr(&dst_vb->vb2_buf,
+							      1);
+		else if (xm2msc_is_yuv_singlebuff(q_data->fmt->fourcc))
+			dst_croma = dst_luma +
+				xm2msc_yuv_1stplane_size(q_data, row_align);
+		else
+			dst_croma = 0;
+
+		if (xm2msc->dma_addr_size == 64 &&
+		    sizeof(dma_addr_t) == sizeof(u64)) {
+			xm2msc_write64reg(base + XM2MSC_SRCIMGBUF0, src_luma);
+			xm2msc_write64reg(base + XM2MSC_SRCIMGBUF1, src_croma);
+			xm2msc_write64reg(base + XM2MSC_DSTIMGBUF0, dst_luma);
+			if (chan_ctx->num == 4) /* TODO: To be fixed in HW */
+				xm2msc_write64reg(base + XM2MSC_DSTIMGBUF1 +
+						  XM2MSC_RESERVED_AREA,
+						  dst_croma);
+			else
+				xm2msc_write64reg(base + XM2MSC_DSTIMGBUF1,
+						  dst_croma);
+		} else {
+			xm2msc_writereg(base + XM2MSC_SRCIMGBUF0, src_luma);
+			xm2msc_writereg(base + XM2MSC_SRCIMGBUF1, src_croma);
+			xm2msc_writereg(base + XM2MSC_DSTIMGBUF0, dst_luma);
+			if (chan_ctx->num == 4) /* TODO: To be fixed in HW */
+				xm2msc_writereg(base + XM2MSC_DSTIMGBUF1 +
+						XM2MSC_RESERVED_AREA,
+						dst_croma);
+			else
+				xm2msc_writereg(base + XM2MSC_DSTIMGBUF1,
+						dst_croma);
+		}
+	}
+	return 0;
+}
+
+static void xm2msc_job_finish(struct xm2m_msc_dev *xm2msc)
+{
+	unsigned int chan;
+
+	for (chan = 0; chan < xm2msc->running_chan; chan++) {
+		struct xm2msc_chan_ctx *chan_ctx;
+
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+		v4l2_m2m_job_finish(chan_ctx->m2m_dev, chan_ctx->m2m_ctx);
+	}
+}
+
+static void xm2msc_job_done(struct xm2m_msc_dev *xm2msc)
+{
+	u32 chan;
+
+	for (chan = 0; chan < xm2msc->running_chan; chan++) {
+		struct xm2msc_chan_ctx *chan_ctx;
+		struct vb2_v4l2_buffer *src_vb, *dst_vb;
+		unsigned long flags;
+
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+
+		src_vb = v4l2_m2m_src_buf_remove(chan_ctx->m2m_ctx);
+		dst_vb = v4l2_m2m_dst_buf_remove(chan_ctx->m2m_ctx);
+
+		if (src_vb && dst_vb) {
+			dst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;
+			dst_vb->timecode = src_vb->timecode;
+			dst_vb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;
+			dst_vb->flags |=
+			    src_vb->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;
+
+			spin_lock_irqsave(&xm2msc->lock, flags);
+			v4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);
+			v4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);
+			spin_unlock_irqrestore(&xm2msc->lock, flags);
+		}
+		chan_ctx->frames++;
+	}
+}
+
+static void xm2msc_device_run(void *priv)
+{
+	struct xm2msc_chan_ctx *chan_ctx = priv;
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	void __iomem *base = xm2msc->regs;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&xm2msc->lock, flags);
+	if (xm2msc->device_busy) {
+		spin_unlock_irqrestore(&xm2msc->lock, flags);
+		return;
+	}
+	xm2msc->device_busy = true;
+
+	if (xm2msc->running_chan != NUM_STREAM(xm2msc)) {
+		dev_dbg(xm2msc->dev, "Running chan was %d\n",
+			xm2msc->running_chan);
+		xm2msc->running_chan = NUM_STREAM(xm2msc);
+
+		/* IP need reset for updating of XM2MSC_NUM_OUT */
+		xm2msc_reset(xm2msc);
+		xm2msc_writereg(base + XM2MSC_NUM_OUTS, xm2msc->running_chan);
+		ret = xm2msc_program_allchan(xm2msc);
+		if (ret) {
+			spin_unlock_irqrestore(&xm2msc->lock, flags);
+			xm2msc->device_busy = false;
+			return;
+		}
+	}
+	spin_unlock_irqrestore(&xm2msc->lock, flags);
+
+	dev_dbg(xm2msc->dev, "Running chan = %d\n", xm2msc->running_chan);
+	if (!xm2msc->running_chan) {
+		xm2msc->device_busy = false;
+		return;
+	}
+
+	ret = xm2msc_set_bufaddr(xm2msc);
+	if (ret) {
+		/*
+		 * All channel does not have buffer
+		 * Currently we do not handle the removal of any Intermediate
+		 * channel while streaming is going on
+		 */
+		if (xm2msc->out_streamed_chan || xm2msc->cap_streamed_chan)
+			dev_dbg(xm2msc->dev,
+				"Buffer not available, streaming chan 0x%x\n",
+				xm2msc->cap_streamed_chan);
+
+		xm2msc->device_busy = false;
+		return;
+	}
+
+	xm2msc_writereg(base + XM2MSC_GIE, XM2MSC_GIE_EN);
+	xm2msc_writereg(base + XM2MSC_IER, XM2MSC_ISR_DONE);
+
+	xm2msc_pr_status(xm2msc, __func__);
+	xm2msc_pr_screg(xm2msc->dev, base);
+	xm2msc_pr_allchanreg(xm2msc);
+
+	xm2msc_start(xm2msc);
+
+	xm2msc->isr_wait = true;
+	wait_event(xm2msc->isr_finished, !xm2msc->isr_wait);
+
+	xm2msc_job_done(xm2msc);
+
+	xm2msc->device_busy = false;
+
+	if (xm2msc_alljob_ready(xm2msc))
+		xm2msc_device_run(xm2msc->xm2msc_chan);
+
+	xm2msc_job_finish(xm2msc);
+}
+
+static irqreturn_t xm2msc_isr(int irq, void *data)
+{
+	struct xm2m_msc_dev *xm2msc = (struct xm2m_msc_dev *)data;
+	void __iomem *base = xm2msc->regs;
+	u32 status;
+
+	status = xm2msc_readreg(base + XM2MSC_ISR);
+	if (!(status & XM2MSC_ISR_DONE))
+		return IRQ_NONE;
+
+	xm2msc_writereg(base + XM2MSC_ISR, status & XM2MSC_ISR_DONE);
+
+	xm2msc_stop(xm2msc);
+
+	xm2msc->isr_wait = false;
+	wake_up(&xm2msc->isr_finished);
+
+	return IRQ_HANDLED;
+}
+
+static int xm2msc_streamon(struct file *file, void *fh,
+			   enum v4l2_buf_type type)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_streamon(file, chan_ctx->m2m_ctx, type);
+}
+
+static int xm2msc_streamoff(struct file *file, void *fh,
+			    enum v4l2_buf_type type)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+	int ret;
+
+	ret = v4l2_m2m_streamoff(file, chan_ctx->m2m_ctx, type);
+
+	/* Check if any channel is still running */
+	xm2msc_device_run(chan_ctx);
+	return ret;
+}
+
+static int xm2msc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_qbuf(file, chan_ctx->m2m_ctx, buf);
+}
+
+static int xm2msc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_dqbuf(file, chan_ctx->m2m_ctx, buf);
+}
+
+static int xm2msc_expbuf(struct file *file, void *fh,
+			 struct v4l2_exportbuffer *eb)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_expbuf(file, chan_ctx->m2m_ctx, eb);
+}
+
+static int xm2msc_createbufs(struct file *file, void *fh,
+			     struct v4l2_create_buffers *cb)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_create_bufs(file, chan_ctx->m2m_ctx, cb);
+}
+
+static int xm2msc_reqbufs(struct file *file, void *fh,
+			  struct v4l2_requestbuffers *reqbufs)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_reqbufs(file, chan_ctx->m2m_ctx, reqbufs);
+}
+
+static int xm2msc_querybuf(struct file *file, void *fh,
+			   struct v4l2_buffer *buf)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return v4l2_m2m_querybuf(file, chan_ctx->m2m_ctx, buf);
+}
+
+static void
+xm2msc_cal_imagesize(struct xm2msc_chan_ctx *chan_ctx,
+		     struct xm2msc_q_data *q_data, u32 type)
+{
+	unsigned int i;
+	u32 fourcc = q_data->fmt->fourcc;
+	u32 height = q_data->height;
+
+	if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		height = ALIGN(height, chan_ctx->output_height_align);
+	else if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		height = ALIGN(height, chan_ctx->capture_height_align);
+
+	for (i = 0; i < q_data->nbuffs; i++) {
+		q_data->bytesperline[i] = q_data->stride;
+		q_data->sizeimage[i] = q_data->stride * height;
+	}
+
+	switch (fourcc) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_XV15:
+		/*
+		 * Adding chroma plane size as NV12/XV15
+		 * have a contiguous buffer for luma and chroma
+		 */
+		q_data->sizeimage[0] +=
+				q_data->stride * (height / 2);
+		break;
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_XV20:
+		/*
+		 * Adding chroma plane size as NV16
+		 * have a contiguous buffer for luma and chrome
+		 */
+		q_data->sizeimage[0] +=
+				q_data->stride * height;
+		break;
+	case V4L2_PIX_FMT_NV12M:
+	case V4L2_PIX_FMT_XV15M:
+		q_data->sizeimage[1] =
+				q_data->stride * (height / 2);
+		break;
+	default:
+		break;
+	}
+}
+
+static unsigned int
+xm2msc_cal_stride(unsigned int width, enum xm2msc_pix_fmt xfmt, u8 ppc)
+{
+	unsigned int stride;
+	u32 align;
+
+	/* Stride in Bytes = (Width × Bytes per Pixel); */
+	switch (xfmt) {
+	case XILINX_M2MSC_FMT_RGBX8:
+	case XILINX_M2MSC_FMT_YUVX8:
+	case XILINX_M2MSC_FMT_RGBX10:
+	case XILINX_M2MSC_FMT_YUVX10:
+	case XILINX_M2MSC_FMT_BGRX8:
+		stride = width * 4;
+		break;
+	case XILINX_M2MSC_FMT_YUYV8:
+	case XILINX_M2MSC_FMT_UYVY8:
+		stride = width * 2;
+		break;
+	case XILINX_M2MSC_FMT_Y_UV8:
+	case XILINX_M2MSC_FMT_Y_UV8_420:
+	case XILINX_M2MSC_FMT_Y8:
+		stride = width * 1;
+		break;
+	case XILINX_M2MSC_FMT_RGB8:
+	case XILINX_M2MSC_FMT_YUV8:
+	case XILINX_M2MSC_FMT_BGR8:
+		stride = width * 3;
+		break;
+	case XILINX_M2MSC_FMT_Y_UV10:
+	case XILINX_M2MSC_FMT_Y_UV10_420:
+	case XILINX_M2MSC_FMT_Y10:
+		/* 4 bytes per 3 pixels */
+		stride = DIV_ROUND_UP(width * 4, 3);
+		break;
+	default:
+		stride = 0;
+	}
+
+	/* The data size is 64*pixels per clock bits */
+	align = ppc * XM2MSC_ALIGN_MUL;
+	stride = ALIGN(stride, align);
+
+	return stride;
+}
+
+static int
+vidioc_try_fmt(struct xm2msc_chan_ctx *chan_ctx, struct v4l2_format *f)
+{
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct xm2msc_q_data *q_data;
+	struct vb2_queue *vq;
+	int index;
+
+	if (pix->width < XM2MSC_MIN_WIDTH || pix->width > xm2msc->max_wd ||
+	    pix->height < XM2MSC_MIN_HEIGHT || pix->height > xm2msc->max_ht)
+		dev_dbg(xm2msc->dev,
+			"Wrong input parameters %d, wxh: %dx%d.\n",
+			f->type, f->fmt.pix.width, f->fmt.pix.height);
+
+	/* The width value must be a multiple of pixels per clock */
+	if (pix->width % chan_ctx->xm2msc_dev->ppc) {
+		dev_dbg(xm2msc->dev,
+			"Wrong align parameters %d, wxh: %dx%d.\n",
+			f->type, f->fmt.pix.width, f->fmt.pix.height);
+		pix->width = ALIGN(pix->width, chan_ctx->xm2msc_dev->ppc);
+	}
+
+	/*
+	 * V4L2 specification suggests the driver corrects the
+	 * format struct if any of the dimensions is unsupported
+	 */
+	if (pix->height < XM2MSC_MIN_HEIGHT)
+		pix->height = XM2MSC_MIN_HEIGHT;
+	else if (pix->height > xm2msc->max_ht)
+		pix->height = xm2msc->max_ht;
+
+	if (pix->width < XM2MSC_MIN_WIDTH)
+		pix->width = XM2MSC_MIN_WIDTH;
+	else if (pix->width > xm2msc->max_wd)
+		pix->width = xm2msc->max_wd;
+
+	vq = v4l2_m2m_get_vq(chan_ctx->m2m_ctx, (enum v4l2_buf_type)f->type);
+	if (!vq)
+		return -EINVAL;
+
+	q_data = get_q_data(chan_ctx, (enum v4l2_buf_type)f->type);
+	if (!q_data)
+		return -EINVAL;
+
+	if (vb2_is_busy(vq)) {
+		v4l2_err(&xm2msc->v4l2_dev,
+			 "%s queue busy\n", __func__);
+		return -EBUSY;
+	}
+
+	q_data->fmt = find_format(f);
+	index = find_format_index(f);
+	if (!q_data->fmt || index == ARRAY_SIZE(formats) ||
+	    !xm2msc_chk_fmt(xm2msc, index)) {
+		v4l2_err(&xm2msc->v4l2_dev,
+			 "Couldn't set format type %d, wxh: %dx%d. ",
+			 f->type, f->fmt.pix.width, f->fmt.pix.height);
+		v4l2_err(&xm2msc->v4l2_dev,
+			 "fmt: %d, field: %d\n",
+			 f->fmt.pix.pixelformat, f->fmt.pix.field);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void xm2msc_get_align(struct xm2msc_chan_ctx *chan_ctx)
+{
+	/*
+	 * TODO: This is a temporary solution, will be reverted once stride and
+	 * height align value come from application.
+	 */
+	chan_ctx->output_stride_align = output_stride_align[chan_ctx->num];
+	chan_ctx->capture_stride_align = capture_stride_align[chan_ctx->num];
+	chan_ctx->output_height_align = output_height_align[chan_ctx->num];
+	chan_ctx->capture_height_align = capture_height_align[chan_ctx->num];
+	if (output_stride_align[chan_ctx->num] != 1 ||
+	    capture_stride_align[chan_ctx->num] != 1 ||
+	    output_height_align[chan_ctx->num] != 1 ||
+	    capture_height_align[chan_ctx->num] != 1) {
+		dev_info(chan_ctx->xm2msc_dev->dev,
+			 "You entered values other than default values.\n");
+		dev_info(chan_ctx->xm2msc_dev->dev,
+			 "Please note this may not be available for longer");
+		dev_info(chan_ctx->xm2msc_dev->dev,
+			 "and align values will come from application\n");
+		dev_info(chan_ctx->xm2msc_dev->dev,
+			 "value entered are -\n"
+			 "output_stride_align = %d\n"
+			 "output_height_align = %d\n"
+			 "capture_stride_align = %d\n"
+			 "capture_height_align = %d\n",
+			chan_ctx->output_stride_align,
+			chan_ctx->output_height_align,
+			chan_ctx->capture_stride_align,
+			chan_ctx->capture_height_align);
+	}
+}
+
+static int
+vidioc_s_fmt(struct xm2msc_chan_ctx *chan_ctx, struct v4l2_format *f)
+{
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	struct xm2msc_q_data *q_data;
+	unsigned int i;
+	unsigned int align = 1;
+
+	q_data = get_q_data(chan_ctx, (enum v4l2_buf_type)f->type);
+	if (!q_data)
+		return -EINVAL;
+
+	q_data->width = pix->width;
+	q_data->height = pix->height;
+	q_data->stride = xm2msc_cal_stride(pix->width,
+					   q_data->fmt->xm2msc_fmt,
+					   chan_ctx->xm2msc_dev->ppc);
+
+	xm2msc_get_align(chan_ctx);
+
+	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		align = chan_ctx->output_stride_align;
+	else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		align = chan_ctx->capture_stride_align;
+
+	q_data->stride = ALIGN(q_data->stride, align);
+
+	q_data->colorspace = (enum v4l2_colorspace)pix->colorspace;
+	q_data->field = (enum v4l2_field)pix->field;
+	q_data->nbuffs = q_data->fmt->num_buffs;
+
+	xm2msc_cal_imagesize(chan_ctx, q_data, f->type);
+
+	for (i = 0; i < q_data->nbuffs; i++) {
+		pix->plane_fmt[i].bytesperline = q_data->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = q_data->sizeimage[i];
+	}
+
+	xm2msc_pr_q(chan_ctx->xm2msc_dev->dev, q_data,
+		    chan_ctx->num, f->type, __func__);
+
+	return 0;
+}
+
+static int xm2msc_try_fmt_vid_out(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return vidioc_try_fmt(chan_ctx, f);
+}
+
+static int xm2msc_try_fmt_vid_cap(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return vidioc_try_fmt(chan_ctx, f);
+}
+
+static int xm2msc_s_fmt_vid_cap(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	int ret;
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	ret = xm2msc_try_fmt_vid_cap(file, fh, f);
+	if (ret)
+		return ret;
+	return vidioc_s_fmt(chan_ctx, f);
+}
+
+static int xm2msc_s_fmt_vid_out(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	int ret;
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	ret = xm2msc_try_fmt_vid_out(file, fh, f);
+	if (ret)
+		return ret;
+
+	return vidioc_s_fmt(chan_ctx, f);
+}
+
+static int vidioc_g_fmt(struct xm2msc_chan_ctx *chan_ctx, struct v4l2_format *f)
+{
+	struct vb2_queue *vq;
+	struct xm2msc_q_data *q_data;
+	struct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;
+	unsigned int i;
+
+	vq = v4l2_m2m_get_vq(chan_ctx->m2m_ctx, (enum v4l2_buf_type)f->type);
+	if (!vq)
+		return -EINVAL;
+
+	q_data = get_q_data(chan_ctx, (enum v4l2_buf_type)f->type);
+	if (!q_data)
+		return -EINVAL;
+
+	pix->width = q_data->width;
+	pix->height = q_data->height;
+	pix->field = V4L2_FIELD_NONE;
+	pix->pixelformat = q_data->fmt->fourcc;
+	pix->colorspace = q_data->colorspace;
+	pix->num_planes = q_data->nbuffs;
+
+	for (i = 0; i < pix->num_planes; i++) {
+		pix->plane_fmt[i].bytesperline = q_data->bytesperline[i];
+		pix->plane_fmt[i].sizeimage = q_data->sizeimage[i];
+	}
+
+	return 0;
+}
+
+static int xm2msc_g_fmt_vid_out(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return vidioc_g_fmt(chan_ctx, f);
+}
+
+static int xm2msc_g_fmt_vid_cap(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	return vidioc_g_fmt(chan_ctx, f);
+}
+
+static int enum_fmt(struct xm2m_msc_dev *xm2msc, struct v4l2_fmtdesc *f)
+{
+	const struct xm2msc_fmt *fmt;
+	unsigned int i, enabled = 0;
+
+	for (i = 0; i < ARRAY_SIZE(formats); i++) {
+		if (xm2msc_chk_fmt(xm2msc, i) && enabled++ == f->index)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(formats))
+		/* Format not found */
+		return -EINVAL;
+
+	/* Format found */
+	fmt = &formats[i];
+	strlcpy((char *)f->description, (char *)fmt->name,
+		sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+
+	return 0;
+}
+
+static int xm2msc_enum_fmt_vid_cap(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	return enum_fmt(chan_ctx->xm2msc_dev, f);
+}
+
+static int xm2msc_enum_fmt_vid_out(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		return -EINVAL;
+
+	return enum_fmt(chan_ctx->xm2msc_dev, f);
+}
+
+static int xm2msc_querycap(struct file *file, void *fh,
+			   struct v4l2_capability *cap)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(fh);
+	struct video_device *vfd = &chan_ctx->vfd;
+
+	strncpy((char *)cap->driver, XM2MSC_DRIVER_NAME,
+		sizeof(cap->driver) - 1);
+	strncpy((char *)cap->card, XM2MSC_DRIVER_NAME, sizeof(cap->card) - 1);
+	snprintf((char *)cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", XM2MSC_DRIVER_NAME);
+	cap->device_caps = vfd->device_caps;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int xm2msc_queue_setup(struct vb2_queue *vq,
+			      unsigned int *nbuffers, unsigned int *nplanes,
+			      unsigned int sizes[], struct device *alloc_devs[])
+{
+	unsigned int i;
+	struct xm2msc_chan_ctx *chan_ctx = vb2_get_drv_priv(vq);
+	struct xm2msc_q_data *q_data;
+
+	q_data = get_q_data(chan_ctx, (enum v4l2_buf_type)vq->type);
+	if (!q_data)
+		return -EINVAL;
+
+	*nplanes = q_data->nbuffs;
+
+	for (i = 0; i < *nplanes; i++)
+		sizes[i] = q_data->sizeimage[i];
+
+	dev_dbg(chan_ctx->xm2msc_dev->dev, "get %d buffer(s) of size %d",
+		*nbuffers, sizes[0]);
+	if (q_data->nbuffs == 2)
+		dev_dbg(chan_ctx->xm2msc_dev->dev, " and %d\n", sizes[1]);
+
+	return 0;
+}
+
+static int xm2msc_buf_prepare(struct vb2_buffer *vb)
+{
+	struct xm2msc_chan_ctx *chan_ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	struct xm2msc_q_data *q_data;
+	unsigned int i, num_buffs;
+
+	q_data = get_q_data(chan_ctx, (enum v4l2_buf_type)vb->vb2_queue->type);
+	if (!q_data)
+		return -EINVAL;
+	num_buffs = q_data->nbuffs;
+
+	for (i = 0; i < num_buffs; i++) {
+		if (vb2_plane_size(vb, i) < q_data->sizeimage[i]) {
+			v4l2_err(&xm2msc->v4l2_dev, "data will not fit into plane ");
+				   v4l2_err(&xm2msc->v4l2_dev, "(%lu < %lu)\n",
+					    vb2_plane_size(vb, i),
+					    (long)q_data->sizeimage[i]);
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; i < num_buffs; i++)
+		vb2_set_plane_payload(vb, i, q_data->sizeimage[i]);
+
+	return 0;
+}
+
+static void xm2msc_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct xm2msc_chan_ctx *chan_ctx = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_m2m_buf_queue(chan_ctx->m2m_ctx, vbuf);
+}
+
+static void xm2msc_return_all_buffers(struct xm2msc_chan_ctx *chan_ctx,
+				      struct vb2_queue *q,
+				      enum vb2_buffer_state state)
+{
+	struct vb2_v4l2_buffer *vb;
+	unsigned long flags;
+
+	for (;;) {
+		if (V4L2_TYPE_IS_OUTPUT(q->type))
+			vb = v4l2_m2m_src_buf_remove(chan_ctx->m2m_ctx);
+		else
+			vb = v4l2_m2m_dst_buf_remove(chan_ctx->m2m_ctx);
+		if (!vb)
+			break;
+		spin_lock_irqsave(&chan_ctx->xm2msc_dev->lock, flags);
+		v4l2_m2m_buf_done(vb, state);
+		spin_unlock_irqrestore(&chan_ctx->xm2msc_dev->lock, flags);
+	}
+}
+
+static int xm2msc_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct xm2msc_chan_ctx *chan_ctx = vb2_get_drv_priv(q);
+	static struct xm2msc_q_data *q_data;
+	int type;
+	int ret;
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type))
+		xm2msc_set_chan_stream(chan_ctx, true, XM2MSC_CHAN_OUT);
+	else
+		xm2msc_set_chan_stream(chan_ctx, true, XM2MSC_CHAN_CAP);
+
+	ret = xm2msc_set_chan_params(chan_ctx, (enum v4l2_buf_type)q->type);
+	if (ret)
+		return ret;
+
+	if (xm2msc_chk_chan_stream(chan_ctx, XM2MSC_CHAN_CAP) &&
+	    xm2msc_chk_chan_stream(chan_ctx, XM2MSC_CHAN_OUT))
+		xm2msc_set_chan_com_params(chan_ctx);
+
+	type = V4L2_TYPE_IS_OUTPUT(q->type) ?
+		V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :
+		V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	q_data = get_q_data(chan_ctx, (enum v4l2_buf_type)type);
+	xm2msc_pr_q(chan_ctx->xm2msc_dev->dev, q_data, chan_ctx->num,
+		    type, __func__);
+	xm2msc_pr_status(chan_ctx->xm2msc_dev, __func__);
+
+	return 0;
+}
+
+static void xm2msc_stop_streaming(struct vb2_queue *q)
+{
+	struct xm2msc_chan_ctx *chan_ctx = vb2_get_drv_priv(q);
+
+	xm2msc_return_all_buffers(chan_ctx, q, VB2_BUF_STATE_ERROR);
+
+	if (V4L2_TYPE_IS_OUTPUT(q->type))
+		xm2msc_set_chan_stream(chan_ctx, false, XM2MSC_CHAN_OUT);
+	else
+		xm2msc_set_chan_stream(chan_ctx, false, XM2MSC_CHAN_CAP);
+}
+
+static const struct vb2_ops xm2msc_qops = {
+	.queue_setup = xm2msc_queue_setup,
+	.buf_prepare = xm2msc_buf_prepare,
+	.buf_queue = xm2msc_buf_queue,
+	.start_streaming = xm2msc_start_streaming,
+	.stop_streaming = xm2msc_stop_streaming,
+};
+
+static int queue_init(void *priv, struct vb2_queue *src_vq,
+		      struct vb2_queue *dst_vq)
+{
+	struct xm2msc_chan_ctx *chan_ctx = priv;
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	int ret;
+
+	memset(src_vq, 0, sizeof(*src_vq));
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_DMABUF | VB2_MMAP | VB2_USERPTR;
+	src_vq->drv_priv = chan_ctx;
+	src_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	src_vq->ops = &xm2msc_qops;
+	src_vq->mem_ops = &vb2_dma_contig_memops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->lock = &xm2msc->dev_mutex;
+	src_vq->dev = xm2msc->v4l2_dev.dev;
+
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	memset(dst_vq, 0, sizeof(*dst_vq));
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_USERPTR;
+	dst_vq->drv_priv = chan_ctx;
+	dst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);
+	dst_vq->ops = &xm2msc_qops;
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->lock = &xm2msc->dev_mutex;
+	dst_vq->dev = xm2msc->v4l2_dev.dev;
+
+	return vb2_queue_init(dst_vq);
+}
+
+static const struct v4l2_ioctl_ops xm2msc_ioctl_ops = {
+	.vidioc_querycap = xm2msc_querycap,
+
+	.vidioc_enum_fmt_vid_cap = xm2msc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap_mplane = xm2msc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap_mplane = xm2msc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap_mplane = xm2msc_s_fmt_vid_cap,
+
+	.vidioc_enum_fmt_vid_out = xm2msc_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_out_mplane = xm2msc_g_fmt_vid_out,
+	.vidioc_try_fmt_vid_out_mplane = xm2msc_try_fmt_vid_out,
+	.vidioc_s_fmt_vid_out_mplane = xm2msc_s_fmt_vid_out,
+
+	.vidioc_reqbufs = xm2msc_reqbufs,
+	.vidioc_querybuf = xm2msc_querybuf,
+	.vidioc_expbuf = xm2msc_expbuf,
+	.vidioc_create_bufs = xm2msc_createbufs,
+
+	.vidioc_qbuf = xm2msc_qbuf,
+	.vidioc_dqbuf = xm2msc_dqbuf,
+
+	.vidioc_streamon = xm2msc_streamon,
+	.vidioc_streamoff = xm2msc_streamoff,
+};
+
+static int xm2msc_set_q_data(struct xm2msc_chan_ctx *chan_ctx,
+			     const struct xm2msc_fmt *fmt,
+			     enum v4l2_buf_type type)
+{
+	struct xm2msc_q_data *q_data;
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+
+	q_data = get_q_data(chan_ctx, type);
+
+	if (!q_data)
+		return -EINVAL;
+
+	q_data->fmt = fmt;
+	q_data->width = xm2msc->max_wd;
+	q_data->height = xm2msc->max_ht;
+	q_data->field = V4L2_FIELD_NONE;
+	q_data->nbuffs = q_data->fmt->num_buffs;
+
+	q_data->stride = xm2msc_cal_stride(q_data->width,
+				q_data->fmt->xm2msc_fmt,
+				xm2msc->ppc);
+
+	xm2msc_cal_imagesize(chan_ctx, q_data, type);
+
+	return 0;
+}
+
+static int xm2msc_set_chan_parm(struct xm2msc_chan_ctx *chan_ctx)
+{
+	int ret = 0;
+	unsigned int i;
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+
+	chan_ctx->output_stride_align = 1;
+	chan_ctx->output_height_align = 1;
+	chan_ctx->capture_stride_align = 1;
+	chan_ctx->capture_height_align = 1;
+
+	for (i = 0; i < ARRAY_SIZE(formats); i++) {
+		if (xm2msc_chk_fmt(xm2msc, i))
+			break;
+	}
+
+	/* No supported format */
+	if (i == ARRAY_SIZE(formats)) {
+		dev_err(xm2msc->dev, "no supported format found\n");
+		return -EINVAL;
+	}
+
+	ret = xm2msc_set_q_data(chan_ctx, &formats[i],
+				V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	if (ret)
+		return ret;
+
+	return xm2msc_set_q_data(chan_ctx, &formats[i],
+				 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+}
+
+static int xm2msc_open(struct file *file)
+{
+	struct xm2m_msc_dev *xm2msc = video_drvdata(file);
+	struct xm2msc_chan_ctx *chan_ctx = NULL;
+	u32 minor, chan;
+	int ret;
+
+	if (mutex_lock_interruptible(&xm2msc->dev_mutex))
+		return -ERESTARTSYS;
+
+	minor = iminor(file_inode(file));
+
+	for (chan = 0; chan < xm2msc->max_chan; chan++) {
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+
+		if ((chan_ctx->status & CHAN_ATTACHED) &&
+		    chan_ctx->minor == minor)
+			break;
+	}
+
+	if (chan == xm2msc->max_chan) {
+		v4l2_err(&xm2msc->v4l2_dev,
+			 "%s Chan not found with minor = %d\n",
+			 __func__, minor);
+		ret = -EBADF;
+		goto unlock;
+	}
+
+	/* Already opened, do not allow same channel
+	 * to be open more then once
+	 */
+	if (chan_ctx->status & CHAN_OPENED) {
+		v4l2_warn(&xm2msc->v4l2_dev,
+			  "%s Chan already opened for minor = %d\n",
+			  __func__, minor);
+		ret = -EBUSY;
+		goto unlock;
+	}
+
+	v4l2_fh_init(&chan_ctx->fh, &chan_ctx->vfd);
+	file->private_data = &chan_ctx->fh;
+	v4l2_fh_add(&chan_ctx->fh);
+
+	chan_ctx->m2m_ctx = v4l2_m2m_ctx_init(chan_ctx->m2m_dev,
+					      chan_ctx, &queue_init);
+	if (IS_ERR(chan_ctx->m2m_ctx)) {
+		ret = PTR_ERR(chan_ctx->m2m_ctx);
+		v4l2_err(&xm2msc->v4l2_dev,
+			 "%s Chan M2M CTX not creted for minor %d\n",
+			 __func__, minor);
+		goto error_m2m;
+	}
+
+	chan_ctx->fh.m2m_ctx = chan_ctx->m2m_ctx;
+	chan_ctx->status |= CHAN_OPENED;
+	chan_ctx->xm2msc_dev = xm2msc;
+	chan_ctx->frames = 0;
+
+	xm2msc_set_chan(chan_ctx, true);
+
+	v4l2_info(&xm2msc->v4l2_dev, "Channel %d instance created\n", chan);
+
+	mutex_unlock(&xm2msc->dev_mutex);
+	xm2msc_pr_chanctx(chan_ctx, __func__);
+	xm2msc_pr_status(xm2msc, __func__);
+	return 0;
+
+error_m2m:
+	v4l2_fh_del(&chan_ctx->fh);
+	v4l2_fh_exit(&chan_ctx->fh);
+unlock:
+	mutex_unlock(&xm2msc->dev_mutex);
+	xm2msc_pr_chanctx(chan_ctx, __func__);
+	xm2msc_pr_status(xm2msc, __func__);
+	return ret;
+}
+
+static int xm2msc_release(struct file *file)
+{
+	struct xm2m_msc_dev *xm2msc = video_drvdata(file);
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(file->private_data);
+
+	if (mutex_lock_interruptible(&xm2msc->dev_mutex))
+		return -ERESTARTSYS;
+
+	v4l2_m2m_ctx_release(chan_ctx->m2m_ctx);
+	v4l2_fh_del(&chan_ctx->fh);
+	v4l2_fh_exit(&chan_ctx->fh);
+	chan_ctx->status &= ~CHAN_OPENED;
+	xm2msc_set_chan(chan_ctx, false);
+
+	v4l2_info(&xm2msc->v4l2_dev, "Channel %d instance released\n",
+		  chan_ctx->num);
+
+	mutex_unlock(&xm2msc->dev_mutex);
+	return 0;
+}
+
+static unsigned int xm2msc_poll(struct file *file,
+				struct poll_table_struct *wait)
+{
+	struct xm2msc_chan_ctx *chan_ctx = fh_to_chanctx(file->private_data);
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	int ret;
+
+	mutex_lock(&xm2msc->dev_mutex);
+	ret = v4l2_m2m_poll(file, chan_ctx->m2m_ctx, wait);
+	mutex_unlock(&xm2msc->dev_mutex);
+
+	return ret;
+}
+
+static int xm2msc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct xm2msc_chan_ctx *chan_ctx = file->private_data;
+	struct xm2m_msc_dev *xm2msc = chan_ctx->xm2msc_dev;
+	int ret;
+
+	mutex_lock(&xm2msc->dev_mutex);
+	ret = v4l2_m2m_mmap(file, chan_ctx->m2m_ctx, vma);
+
+	mutex_unlock(&xm2msc->dev_mutex);
+	return ret;
+}
+
+static const struct v4l2_file_operations xm2msc_fops = {
+	.owner = THIS_MODULE,
+	.open = xm2msc_open,
+	.release = xm2msc_release,
+	.poll = xm2msc_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = xm2msc_mmap,
+};
+
+static const struct video_device xm2msc_videodev = {
+	.name = XM2MSC_DRIVER_NAME,
+	.fops = &xm2msc_fops,
+	.ioctl_ops = &xm2msc_ioctl_ops,
+	.minor = -1,
+	.release = video_device_release_empty,
+	.vfl_dir = VFL_DIR_M2M,
+};
+
+static const struct v4l2_m2m_ops xm2msc_m2m_ops = {
+	.device_run = xm2msc_device_run,
+	.job_ready = xm2msc_job_ready,
+	.job_abort = xm2msc_job_abort,
+};
+
+static int xm2msc_parse_of(struct platform_device *pdev,
+			   struct xm2m_msc_dev *xm2msc)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	int hw_vid_fmt_cnt;
+	const char *vid_fmts[ARRAY_SIZE(formats)];
+	int ret;
+	u32 i, j;
+
+	xm2msc->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(xm2msc->clk)) {
+		ret = PTR_ERR(xm2msc->clk);
+		dev_err(dev, "failed to get clk (%d)\n", ret);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xm2msc->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR((__force void *)xm2msc->regs))
+		return PTR_ERR((__force const void *)xm2msc->regs);
+
+	dev_dbg(dev, "IO Mem %pa mapped at %p\n", &res->start, xm2msc->regs);
+
+	ret = of_property_read_u32(node, "xlnx,max-chan",
+				   &xm2msc->max_chan);
+	if (ret < 0)
+		return ret;
+
+	if (xm2msc->max_chan < XM2MSC_MIN_CHAN ||
+	    xm2msc->max_chan > XM2MSC_MAX_CHAN) {
+		dev_err(dev,
+			"Invalid maximum scaler channels : %d",
+			xm2msc->max_chan);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,max-width",
+				   &xm2msc->max_wd);
+	if (ret < 0) {
+		dev_err(dev,
+			"missing xlnx,max-width prop\n");
+		return ret;
+	}
+
+	if (xm2msc->max_wd < XM2MSC_MIN_WIDTH ||
+	    xm2msc->max_wd > XM2MSC_MAX_WIDTH) {
+		dev_err(dev, "Invalid width : %d",
+			xm2msc->max_wd);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,max-height",
+				   &xm2msc->max_ht);
+	if (ret < 0) {
+		dev_err(dev, "missing xlnx,max-height prop\n");
+		return ret;
+	}
+
+	if (xm2msc->max_ht < XM2MSC_MIN_HEIGHT ||
+	    xm2msc->max_ht > XM2MSC_MAX_HEIGHT) {
+		dev_err(dev, "Invalid height : %d",
+			xm2msc->max_ht);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,dma-addr-width",
+				   &xm2msc->dma_addr_size);
+	if (ret || (xm2msc->dma_addr_size != 32 &&
+		    xm2msc->dma_addr_size != 64)) {
+		dev_err(dev, "missing/invalid addr width dts prop\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u8(node, "xlnx,pixels-per-clock",
+				  &xm2msc->ppc);
+	if (ret || (xm2msc->ppc != 1 && xm2msc->ppc != 2 && xm2msc->ppc != 4)) {
+		dev_err(dev, "missing or invalid pixels per clock dts prop\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,num-taps",
+				   &xm2msc->taps);
+	if (ret || (xm2msc->taps != XSCALER_TAPS_6 &&
+		    xm2msc->taps != XSCALER_TAPS_8 &&
+		    xm2msc->taps != XSCALER_TAPS_10 &&
+		    xm2msc->taps != XSCALER_TAPS_12)) {
+		dev_err(dev, "missing/invalid taps in dts prop\n");
+		return -EINVAL;
+	}
+
+	xm2msc->irq = irq_of_parse_and_map(node, 0);
+	if (xm2msc->irq < 0) {
+		dev_err(dev, "Unable to get IRQ");
+		return xm2msc->irq;
+	}
+
+	dev_dbg(dev, "Max Channel Supported = %d\n", xm2msc->max_chan);
+	dev_dbg(dev, "DMA Addr width Supported = %d\n", xm2msc->dma_addr_size);
+	dev_dbg(dev, "Max col/row Supported = (%d) / (%d)\n",
+		xm2msc->max_wd, xm2msc->max_ht);
+	dev_dbg(dev, "taps Supported = %d\n", xm2msc->taps);
+	/* read supported video formats and update internal table */
+	hw_vid_fmt_cnt = of_property_count_strings(node, "xlnx,vid-formats");
+
+	/* Validate the number of strings returned */
+	if (hw_vid_fmt_cnt < 0)
+		return hw_vid_fmt_cnt;
+
+	if (hw_vid_fmt_cnt > ARRAY_SIZE(formats))
+		return -EINVAL;
+
+	ret = of_property_read_string_array(node, "xlnx,vid-formats",
+					    vid_fmts, hw_vid_fmt_cnt);
+	if (ret < 0) {
+		dev_err(dev,
+			"Missing or invalid xlnx,vid-formats dts prop\n");
+		return ret;
+	}
+
+	dev_dbg(dev, "Supported format = ");
+	for (i = 0; i < hw_vid_fmt_cnt; i++) {
+		const char *vid_fmt_name = vid_fmts[i];
+
+		for (j = 0; j < ARRAY_SIZE(formats); j++) {
+			const char *dts_name = formats[j].name;
+
+			if (strcmp(vid_fmt_name, dts_name))
+				continue;
+			dev_dbg(dev, "%s ", dts_name);
+
+			xm2msc_set_fmt(xm2msc, j);
+		}
+	}
+	dev_dbg(dev, "\n");
+	xm2msc->rst_gpio = devm_gpiod_get(dev, "reset",
+					  GPIOD_OUT_HIGH);
+	if (IS_ERR(xm2msc->rst_gpio)) {
+		ret = PTR_ERR(xm2msc->rst_gpio);
+		if (ret == -EPROBE_DEFER)
+			dev_info(dev,
+				 "Probe deferred due to GPIO reset defer\n");
+		else
+			dev_err(dev,
+				"Unable to locate reset property in dt\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void xm2msc_unreg_video_n_m2m(struct xm2m_msc_dev *xm2msc)
+{
+	struct xm2msc_chan_ctx *chan_ctx;
+	unsigned int chan;
+
+	for (chan = 0; chan < xm2msc->max_chan; chan++) {
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+		if (!(chan_ctx->status & CHAN_ATTACHED))
+			break;	/*We register video sequentially */
+		video_unregister_device(&chan_ctx->vfd);
+		chan_ctx->status &= ~CHAN_ATTACHED;
+
+		if (!IS_ERR(chan_ctx->m2m_dev))
+			v4l2_m2m_release(chan_ctx->m2m_dev);
+	}
+}
+
+static int xm2m_msc_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct xm2m_msc_dev *xm2msc;
+	struct xm2msc_chan_ctx *chan_ctx;
+	struct video_device *vfd;
+	unsigned int chan;
+
+	xm2msc = devm_kzalloc(&pdev->dev, sizeof(*xm2msc), GFP_KERNEL);
+	if (!xm2msc)
+		return -ENOMEM;
+
+	ret = xm2msc_parse_of(pdev, xm2msc);
+	if (ret < 0)
+		return ret;
+
+	xm2msc->dev = &pdev->dev;
+
+	ret = clk_prepare_enable(xm2msc->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable clk (%d)\n", ret);
+		return ret;
+	}
+
+	xm2msc_reset(xm2msc);
+
+	spin_lock_init(&xm2msc->lock);
+
+	ret = v4l2_device_register(&pdev->dev, &xm2msc->v4l2_dev);
+	if (ret)
+		goto reg_dev_err;
+
+	for (chan = 0; chan < xm2msc->max_chan; chan++) {
+		chan_ctx = &xm2msc->xm2msc_chan[chan];
+
+		vfd = &chan_ctx->vfd;
+		*vfd = xm2msc_videodev;
+		vfd->lock = &xm2msc->dev_mutex;
+		vfd->v4l2_dev = &xm2msc->v4l2_dev;
+		vfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE |
+				   V4L2_CAP_STREAMING;
+
+		ret = video_register_device(vfd, VFL_TYPE_VIDEO, chan);
+		if (ret) {
+			v4l2_err(&xm2msc->v4l2_dev,
+				 "Failed to register video dev for chan %d\n",
+				 chan);
+			goto unreg_dev;
+		}
+
+		chan_ctx->status = CHAN_ATTACHED;
+
+		video_set_drvdata(vfd, xm2msc);
+		snprintf(vfd->name, sizeof(vfd->name),
+			 "%s", xm2msc_videodev.name);
+		v4l2_info(&xm2msc->v4l2_dev,
+			  " Device registered as /dev/video%d\n", vfd->num);
+
+		dev_dbg(xm2msc->dev, "%s Device registered as /dev/video%d\n",
+			__func__, vfd->num);
+
+		chan_ctx->m2m_dev = v4l2_m2m_init(&xm2msc_m2m_ops);
+		if (IS_ERR(chan_ctx->m2m_dev)) {
+			v4l2_err(&xm2msc->v4l2_dev,
+				 "Failed to init mem2mem device for chan %d\n",
+				 chan);
+			ret = PTR_ERR(chan_ctx->m2m_dev);
+			goto unreg_dev;
+		}
+		chan_ctx->xm2msc_dev = xm2msc;
+		chan_ctx->regs = xm2msc->regs + XM2MSC_CHAN_REGS_START(chan);
+		if (chan > 4) /* TODO: To be fixed in HW */
+			chan_ctx->regs += XM2MSC_RESERVED_AREA;
+		chan_ctx->num = chan;
+		chan_ctx->minor = vfd->minor;
+
+		/* Set channel parameters to default values */
+		ret = xm2msc_set_chan_parm(chan_ctx);
+		if (ret)
+			goto unreg_dev;
+
+		xm2msc_pr_chanctx(chan_ctx, __func__);
+	}
+
+	mutex_init(&xm2msc->dev_mutex);
+	mutex_init(&xm2msc->mutex);
+	init_waitqueue_head(&xm2msc->isr_finished);
+
+	ret = devm_request_irq(&pdev->dev, xm2msc->irq,
+			       xm2msc_isr, IRQF_SHARED,
+			       XM2MSC_DRIVER_NAME, xm2msc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Unable to register IRQ\n");
+		goto unreg_dev;
+	}
+
+	platform_set_drvdata(pdev, xm2msc);
+
+	return 0;
+
+unreg_dev:
+	xm2msc_unreg_video_n_m2m(xm2msc);
+	v4l2_device_unregister(&xm2msc->v4l2_dev);
+reg_dev_err:
+	clk_disable_unprepare(xm2msc->clk);
+	return ret;
+}
+
+static int xm2m_msc_remove(struct platform_device *pdev)
+{
+	struct xm2m_msc_dev *xm2msc = platform_get_drvdata(pdev);
+
+	xm2msc_unreg_video_n_m2m(xm2msc);
+	v4l2_device_unregister(&xm2msc->v4l2_dev);
+	clk_disable_unprepare(xm2msc->clk);
+	return 0;
+}
+
+static const struct of_device_id xm2m_msc_of_id_table[] = {
+	{.compatible = "xlnx,v-multi-scaler-v1.0"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, xm2m_msc_of_id_table);
+
+static struct platform_driver xm2m_msc_driver = {
+	.driver = {
+		.name = "xilinx-multiscaler",
+		.of_match_table = xm2m_msc_of_id_table,
+	},
+	.probe = xm2m_msc_probe,
+	.remove = xm2m_msc_remove,
+};
+
+module_platform_driver(xm2m_msc_driver);
+
+MODULE_DESCRIPTION("Xilinx M2M Multi-Scaler Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("xlnx_m2m_multiscaler_dev");
diff --git a/drivers/media/platform/xilinx/xilinx-remapper.c b/drivers/media/platform/xilinx/xilinx-remapper.c
new file mode 100644
index 000000000..00c61650d
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-remapper.c
@@ -0,0 +1,566 @@
+/*
+ * Xilinx Video Remapper
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XREMAP_MIN_WIDTH			1
+#define XREMAP_DEF_WIDTH			1920
+#define XREMAP_MAX_WIDTH			65535
+#define XREMAP_MIN_HEIGHT			1
+#define XREMAP_DEF_HEIGHT			1080
+#define XREMAP_MAX_HEIGHT			65535
+
+#define XREMAP_PAD_SINK				0
+#define XREMAP_PAD_SOURCE			1
+
+/**
+ * struct xremap_mapping_output - Output format description
+ * @code: media bus pixel core after remapping
+ * @num_components: number of pixel components after remapping
+ * @component_maps: configuration array corresponding to this output
+ */
+struct xremap_mapping_output {
+	u32 code;
+	unsigned int num_components;
+	unsigned int component_maps[4];
+};
+
+/**
+ * struct xremap_mapping - Input-output remapping description
+ * @code: media bus pixel code before remapping
+ * @width: video bus width in bits
+ * @num_components: number of pixel components before remapping
+ * @outputs: array of possible output formats
+ */
+struct xremap_mapping {
+	u32 code;
+	unsigned int width;
+	unsigned int num_components;
+	const struct xremap_mapping_output *outputs;
+};
+
+/**
+ * struct xremap_device - Xilinx Test Pattern Generator device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @config: device configuration parsed from its DT node
+ * @config.width: video bus width in bits
+ * @config.num_s_components: number of pixel components at the input
+ * @config.num_m_components: number of pixel components at the output
+ * @config.component_maps: component remapping configuration
+ * @default_mapping: Default mapping compatible with the configuration
+ * @default_output: Default output format for the default mapping
+ */
+struct xremap_device {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt formats[2];
+
+	struct {
+		unsigned int width;
+		unsigned int num_s_components;
+		unsigned int num_m_components;
+		unsigned int component_maps[4];
+	} config;
+
+	const struct xremap_mapping *default_mapping;
+	const struct xremap_mapping_output *default_output;
+};
+
+static inline struct xremap_device *to_remap(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xremap_device, xvip.subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * Mappings
+ */
+
+static const struct xremap_mapping xremap_mappings[] = {
+	{
+		.code = MEDIA_BUS_FMT_RBG888_1X24,
+		.width = 8,
+		.num_components = 3,
+		.outputs = (const struct xremap_mapping_output[]) {
+			{ MEDIA_BUS_FMT_RGB888_1X32_PADHI, 4, { 1, 0, 2, 4 } },
+			{ },
+		},
+	},
+};
+
+static const struct xremap_mapping_output *
+xremap_match_mapping(struct xremap_device *xremap,
+		     const struct xremap_mapping *mapping)
+{
+	const struct xremap_mapping_output *output;
+
+	if (mapping->width != xremap->config.width ||
+	    mapping->num_components != xremap->config.num_s_components)
+		return NULL;
+
+	for (output = mapping->outputs; output->code; ++output) {
+		unsigned int i;
+
+		if (output->num_components != xremap->config.num_m_components)
+			continue;
+
+		for (i = 0; i < output->num_components; ++i) {
+			if (output->component_maps[i] !=
+			    xremap->config.component_maps[i])
+				break;
+		}
+
+		if (i == output->num_components)
+			return output;
+	}
+
+	return NULL;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static int xremap_enum_mbus_code(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	if (code->pad == XREMAP_PAD_SINK) {
+		const struct xremap_mapping *mapping = NULL;
+		unsigned int index = code->index + 1;
+		unsigned int i;
+
+		/* Iterate through the mappings and skip the ones that don't
+		 * match the remapper configuration until we reach the requested
+		 * index.
+		 */
+		for (i = 0; i < ARRAY_SIZE(xremap_mappings) && index; ++i) {
+			mapping = &xremap_mappings[i];
+
+			if (xremap_match_mapping(xremap, mapping))
+				index--;
+		}
+
+		/* If the index was larger than the number of supported mappings
+		 * return -EINVAL.
+		 */
+		if (index > 0)
+			return -EINVAL;
+
+		code->code = mapping->code;
+	} else {
+		if (code->index)
+			return -EINVAL;
+
+		format = v4l2_subdev_get_try_format(subdev, sd_state, code->pad);
+		code->code = format->code;
+	}
+
+	return 0;
+}
+
+static int xremap_enum_frame_size(struct v4l2_subdev *subdev,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);
+
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	if (fse->pad == XREMAP_PAD_SINK) {
+		/* The remapper doesn't restrict the size on the sink pad. */
+		fse->min_width = XREMAP_MIN_WIDTH;
+		fse->max_width = XREMAP_MAX_WIDTH;
+		fse->min_height = XREMAP_MIN_HEIGHT;
+		fse->max_height = XREMAP_MAX_HEIGHT;
+	} else {
+		/* The size on the source pad are fixed and always identical to
+		 * the size on the sink pad.
+		 */
+		fse->min_width = format->width;
+		fse->max_width = format->width;
+		fse->min_height = format->height;
+		fse->max_height = format->height;
+	}
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+xremap_get_pad_format(struct xremap_device *xremap,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xremap->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xremap->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xremap_get_format(struct v4l2_subdev *subdev,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = xremap_get_pad_format(xremap, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xremap_set_format(struct v4l2_subdev *subdev,
+			     struct v4l2_subdev_state *sd_state,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	const struct xremap_mapping_output *output = NULL;
+	const struct xremap_mapping *mapping;
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+
+	format = xremap_get_pad_format(xremap, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == XREMAP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	/* Find the mapping. If the requested format has no mapping, use the
+	 * default.
+	 */
+	for (i = 0; i < ARRAY_SIZE(xremap_mappings); ++i) {
+		mapping = &xremap_mappings[i];
+		if (mapping->code != fmt->format.code)
+			continue;
+
+		output = xremap_match_mapping(xremap, mapping);
+		if (output)
+			break;
+	}
+
+	if (!output) {
+		mapping = xremap->default_mapping;
+		output = xremap->default_output;
+	}
+
+	format->code = mapping->code;
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XREMAP_MIN_WIDTH, XREMAP_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XREMAP_MIN_HEIGHT, XREMAP_MAX_HEIGHT);
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad. */
+	format = xremap_get_pad_format(xremap, sd_state, XREMAP_PAD_SOURCE,
+				       fmt->which);
+	if (!format)
+		return -EINVAL;
+	*format = fmt->format;
+	format->code = output->code;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+/*
+ * xremap_init_formats - Initialize formats on all pads
+ * @subdev: remapper V4L2 subdevice
+ * @fh: V4L2 subdev file handle
+ *
+ * Initialize all pad formats with default values. If fh is not NULL, try
+ * formats are initialized on the file handle. Otherwise active formats are
+ * initialized on the device.
+ */
+static void xremap_init_formats(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_fh *fh)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	struct v4l2_subdev_format format;
+
+	memset(&format, 0, sizeof(format));
+
+	format.pad = XREMAP_PAD_SINK;
+	format.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	format.format.code = xremap->default_mapping->code;
+	format.format.width = XREMAP_DEF_WIDTH;
+	format.format.height = XREMAP_DEF_HEIGHT;
+
+	xremap_set_format(subdev, fh ? fh->state : NULL, &format);
+}
+
+static int xremap_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	xremap_init_formats(subdev, fh);
+
+	return 0;
+}
+
+static int xremap_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops xremap_core_ops = {
+};
+
+static struct v4l2_subdev_video_ops xremap_video_ops = {
+};
+
+static struct v4l2_subdev_pad_ops xremap_pad_ops = {
+	.enum_mbus_code = xremap_enum_mbus_code,
+	.enum_frame_size = xremap_enum_frame_size,
+	.get_fmt = xremap_get_format,
+	.set_fmt = xremap_set_format,
+};
+
+static struct v4l2_subdev_ops xremap_ops = {
+	.core   = &xremap_core_ops,
+	.video  = &xremap_video_ops,
+	.pad    = &xremap_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xremap_internal_ops = {
+	.open = xremap_open,
+	.close = xremap_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xremap_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xremap_parse_of(struct xremap_device *xremap)
+{
+	struct device_node *node = xremap->xvip.dev->of_node;
+	unsigned int i;
+	int ret;
+
+	/* Parse the DT properties. */
+	ret = of_property_read_u32(node, "xlnx,video-width",
+				   &xremap->config.width);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"xlnx,video-width");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "#xlnx,s-components",
+				   &xremap->config.num_s_components);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"#xlnx,s-components");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "#xlnx,m-components",
+				   &xremap->config.num_m_components);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"#xlnx,m-components");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32_array(node, "xlnx,component-maps",
+					 xremap->config.component_maps,
+					 xremap->config.num_m_components);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"xlnx,component-maps");
+		return -EINVAL;
+	}
+
+	/* Validate the parsed values. */
+	if (xremap->config.num_s_components > 4 ||
+	    xremap->config.num_m_components > 4) {
+		dev_dbg(xremap->xvip.dev,
+			"invalid number of components (s %u m %u)\n",
+			xremap->config.num_s_components,
+			xremap->config.num_m_components);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < xremap->config.num_m_components; ++i) {
+		if (xremap->config.component_maps[i] > 4) {
+			dev_dbg(xremap->xvip.dev, "invalid map %u @%u\n",
+				xremap->config.component_maps[i], i);
+			return -EINVAL;
+		}
+	}
+
+	/* Find the first mapping that matches the remapper configuration and
+	 * store it as the default mapping.
+	 */
+	for (i = 0; i < ARRAY_SIZE(xremap_mappings); ++i) {
+		const struct xremap_mapping_output *output;
+		const struct xremap_mapping *mapping;
+
+		mapping = &xremap_mappings[i];
+		output = xremap_match_mapping(xremap, mapping);
+
+		if (output) {
+			xremap->default_mapping = mapping;
+			xremap->default_output = output;
+			return 0;
+		}
+	}
+
+	dev_err(xremap->xvip.dev,
+		"No format compatible with device configuration\n");
+
+	return -EINVAL;
+}
+
+static int xremap_probe(struct platform_device *pdev)
+{
+	struct xremap_device *xremap;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	xremap = devm_kzalloc(&pdev->dev, sizeof(*xremap), GFP_KERNEL);
+	if (!xremap)
+		return -ENOMEM;
+
+	xremap->xvip.dev = &pdev->dev;
+
+	ret = xremap_parse_of(xremap);
+	if (ret < 0)
+		return ret;
+
+	xremap->xvip.clk = devm_clk_get(xremap->xvip.dev, NULL);
+	if (IS_ERR(xremap->xvip.clk))
+		return PTR_ERR(xremap->xvip.clk);
+
+	ret = clk_prepare_enable(xremap->xvip.clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable clk (%d)\n", ret);
+		return ret;
+	}
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xremap->xvip.subdev;
+	v4l2_subdev_init(subdev, &xremap_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xremap_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xremap);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	xremap_init_formats(subdev, NULL);
+
+	xremap->pads[XREMAP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xremap->pads[XREMAP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xremap_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, xremap->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xremap);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(&pdev->dev, "device registered\n");
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xremap->xvip.clk);
+	return ret;
+}
+
+static int xremap_remove(struct platform_device *pdev)
+{
+	struct xremap_device *xremap = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xremap->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	clk_disable_unprepare(xremap->xvip.clk);
+
+	return 0;
+}
+
+static const struct of_device_id xremap_of_id_table[] = {
+	{ .compatible = "xlnx,v-remapper" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xremap_of_id_table);
+
+static struct platform_driver xremap_driver = {
+	.driver = {
+		.name = "xilinx-remapper",
+		.of_match_table = xremap_of_id_table,
+	},
+	.probe = xremap_probe,
+	.remove = xremap_remove,
+};
+
+module_platform_driver(xremap_driver);
+
+MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_DESCRIPTION("Xilinx Video Remapper Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-rgb2yuv.c b/drivers/media/platform/xilinx/xilinx-rgb2yuv.c
new file mode 100644
index 000000000..a9e1fe7d9
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-rgb2yuv.c
@@ -0,0 +1,581 @@
+/*
+ * Xilinx RGB to YUV Convertor
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XRGB2YUV_YMAX					0x100
+#define XRGB2YUV_YMIN					0x104
+#define XRGB2YUV_CBMAX					0x108
+#define XRGB2YUV_CBMIN					0x10c
+#define XRGB2YUV_CRMAX					0x110
+#define XRGB2YUV_CRMIN					0x114
+#define XRGB2YUV_YOFFSET				0x118
+#define XRGB2YUV_CBOFFSET				0x11c
+#define XRGB2YUV_CROFFSET				0x120
+#define XRGB2YUV_ACOEF					0x124
+#define XRGB2YUV_BCOEF					0x128
+#define XRGB2YUV_CCOEF					0x12c
+#define XRGB2YUV_DCOEF					0x130
+
+/**
+ * struct xrgb2yuv_device - Xilinx RGB2YUV device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: Xilinx Video IP formats
+ * @ctrl_handler: control handler
+ */
+struct xrgb2yuv_device {
+	struct xvip_device xvip;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+};
+
+static inline struct xrgb2yuv_device *to_rgb2yuv(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xrgb2yuv_device, xvip.subdev);
+}
+
+/*
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xrgb2yuv_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
+
+	if (!enable) {
+		xvip_stop(&xrgb2yuv->xvip);
+		return 0;
+	}
+
+	xvip_set_frame_size(&xrgb2yuv->xvip, &xrgb2yuv->formats[XVIP_PAD_SINK]);
+
+	xvip_start(&xrgb2yuv->xvip);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+__xrgb2yuv_get_pad_format(struct xrgb2yuv_device *xrgb2yuv,
+			  struct v4l2_subdev_state *sd_state,
+			  unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xrgb2yuv->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xrgb2yuv->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xrgb2yuv_get_format(struct v4l2_subdev *subdev,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xrgb2yuv_get_pad_format(xrgb2yuv, sd_state, fmt->pad,
+					   fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xrgb2yuv_set_format(struct v4l2_subdev *subdev,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xrgb2yuv_get_pad_format(xrgb2yuv, sd_state, fmt->pad,
+					   fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == XVIP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	xvip_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad. */
+	format = __xrgb2yuv_get_pad_format(xrgb2yuv, sd_state, XVIP_PAD_SOURCE,
+					     fmt->which);
+
+	xvip_set_format_size(format, fmt);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Operations
+ */
+
+static int xrgb2yuv_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xrgb2yuv->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SOURCE);
+	*format = xrgb2yuv->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xrgb2yuv_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static int xrgb2yuv_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct xrgb2yuv_device *xrgb2yuv =
+		container_of(ctrl->handler, struct xrgb2yuv_device,
+			     ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_RGB2YUV_YMAX:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_YMAX, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_YMIN:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_YMIN, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CBMAX:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CBMAX, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CBMIN:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CBMIN, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CRMAX:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CRMAX, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CRMIN:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CRMIN, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_YOFFSET:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_YOFFSET, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CBOFFSET:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CBOFFSET, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CROFFSET:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CROFFSET, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_ACOEF:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_ACOEF, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_BCOEF:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_BCOEF, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_CCOEF:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_CCOEF, ctrl->val);
+		return 0;
+	case V4L2_CID_XILINX_RGB2YUV_DCOEF:
+		xvip_write(&xrgb2yuv->xvip, XRGB2YUV_DCOEF, ctrl->val);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static const struct v4l2_ctrl_ops xrgb2yuv_ctrl_ops = {
+	.s_ctrl	= xrgb2yuv_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops xrgb2yuv_video_ops = {
+	.s_stream = xrgb2yuv_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xrgb2yuv_pad_ops = {
+	.enum_mbus_code		= xvip_enum_mbus_code,
+	.enum_frame_size	= xvip_enum_frame_size,
+	.get_fmt		= xrgb2yuv_get_format,
+	.set_fmt		= xrgb2yuv_set_format,
+};
+
+static struct v4l2_subdev_ops xrgb2yuv_ops = {
+	.video  = &xrgb2yuv_video_ops,
+	.pad    = &xrgb2yuv_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xrgb2yuv_internal_ops = {
+	.open	= xrgb2yuv_open,
+	.close	= xrgb2yuv_close,
+};
+
+/*
+ * Control Configs
+ */
+
+static struct v4l2_ctrl_config xrgb2yuv_ctrls[] = {
+	{
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_YMAX,
+		.name	= "RGB to YUV: Maximum Y value",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 16) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_YMIN,
+		.name	= "RGB to YUV: Minimum Y value",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 16) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CBMAX,
+		.name	= "RGB to YUV: Maximum Cb value",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 16) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CBMIN,
+		.name	= "RGB to YUV: Minimum Cb value",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 16) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CRMAX,
+		.name	= "RGB to YUV: Maximum Cr value",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 16) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CRMIN,
+		.name	= "RGB to YUV: Minimum Cr value",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 16) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_YOFFSET,
+		.name	= "RGB to YUV: Luma offset",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CBOFFSET,
+		.name	= "RGB to YUV: Chroma Cb offset",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CROFFSET,
+		.name	= "RGB to YUV: Chroma Cr offset",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_ACOEF,
+		.name	= "RGB to YUV: CA coefficient",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= -((1 << 17) - 1),
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_BCOEF,
+		.name	= "RGB to YUV: CB coefficient",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= -((1 << 17) - 1),
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_CCOEF,
+		.name	= "RGB to YUV: CC coefficient",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= -((1 << 17) - 1),
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	}, {
+		.ops	= &xrgb2yuv_ctrl_ops,
+		.id	= V4L2_CID_XILINX_RGB2YUV_DCOEF,
+		.name	= "RGB to YUV: CD coefficient",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= -((1 << 17) - 1),
+		.max	= (1 << 17) - 1,
+		.step	= 1,
+	},
+};
+
+/*
+ * Media Operations
+ */
+
+static const struct media_entity_operations xrgb2yuv_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/*
+ * Power Management
+ */
+
+static int __maybe_unused xrgb2yuv_pm_suspend(struct device *dev)
+{
+	struct xrgb2yuv_device *xrgb2yuv = dev_get_drvdata(dev);
+
+	xvip_suspend(&xrgb2yuv->xvip);
+
+	return 0;
+}
+
+static int __maybe_unused xrgb2yuv_pm_resume(struct device *dev)
+{
+	struct xrgb2yuv_device *xrgb2yuv = dev_get_drvdata(dev);
+
+	xvip_resume(&xrgb2yuv->xvip);
+
+	return 0;
+}
+
+/*
+ * Platform Device Driver
+ */
+
+static int xrgb2yuv_parse_of(struct xrgb2yuv_device *xrgb2yuv)
+{
+	struct device *dev = xrgb2yuv->xvip.dev;
+	struct device_node *node = xrgb2yuv->xvip.dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id;
+	int ret;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct xvip_video_format *vip_format;
+
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "no reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "invalid reg in DT");
+				return -EINVAL;
+			}
+
+			xrgb2yuv->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	return 0;
+}
+
+static int xrgb2yuv_probe(struct platform_device *pdev)
+{
+	struct xrgb2yuv_device *xrgb2yuv;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	unsigned int i;
+	int ret;
+
+	xrgb2yuv = devm_kzalloc(&pdev->dev, sizeof(*xrgb2yuv), GFP_KERNEL);
+	if (!xrgb2yuv)
+		return -ENOMEM;
+
+	xrgb2yuv->xvip.dev = &pdev->dev;
+
+	ret = xrgb2yuv_parse_of(xrgb2yuv);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xrgb2yuv->xvip);
+	if (ret < 0)
+		return ret;
+
+	/* Reset and initialize the core */
+	xvip_reset(&xrgb2yuv->xvip);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xrgb2yuv->xvip.subdev;
+	v4l2_subdev_init(subdev, &xrgb2yuv_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xrgb2yuv_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xrgb2yuv);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &xrgb2yuv->default_formats[XVIP_PAD_SINK];
+	default_format->code = xrgb2yuv->vip_formats[XVIP_PAD_SINK]->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	xvip_get_frame_size(&xrgb2yuv->xvip, default_format);
+
+	xrgb2yuv->formats[XVIP_PAD_SINK] = *default_format;
+
+	default_format = &xrgb2yuv->default_formats[XVIP_PAD_SOURCE];
+	*default_format = xrgb2yuv->default_formats[XVIP_PAD_SINK];
+	default_format->code = xrgb2yuv->vip_formats[XVIP_PAD_SOURCE]->code;
+
+	xrgb2yuv->formats[XVIP_PAD_SOURCE] = *default_format;
+
+	xrgb2yuv->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xrgb2yuv->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xrgb2yuv_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, xrgb2yuv->pads);
+	if (ret < 0)
+		goto error;
+
+	v4l2_ctrl_handler_init(&xrgb2yuv->ctrl_handler, 13);
+
+	for (i = 0; i < ARRAY_SIZE(xrgb2yuv_ctrls); i++) {
+		xrgb2yuv_ctrls[i].def = xvip_read(&xrgb2yuv->xvip,
+						  XRGB2YUV_YMAX + i * 4);
+		v4l2_ctrl_new_custom(&xrgb2yuv->ctrl_handler,
+				     &xrgb2yuv_ctrls[i], NULL);
+	}
+
+	if (xrgb2yuv->ctrl_handler.error) {
+		dev_err(&pdev->dev, "failed to add controls\n");
+		ret = xrgb2yuv->ctrl_handler.error;
+		goto error;
+	}
+	subdev->ctrl_handler = &xrgb2yuv->ctrl_handler;
+
+	platform_set_drvdata(pdev, xrgb2yuv);
+
+	xvip_print_version(&xrgb2yuv->xvip);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&xrgb2yuv->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xrgb2yuv->xvip);
+	return ret;
+}
+
+static int xrgb2yuv_remove(struct platform_device *pdev)
+{
+	struct xrgb2yuv_device *xrgb2yuv = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xrgb2yuv->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xrgb2yuv->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xrgb2yuv->xvip);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(xrgb2yuv_pm_ops, xrgb2yuv_pm_suspend,
+			 xrgb2yuv_pm_resume);
+
+static const struct of_device_id xrgb2yuv_of_id_table[] = {
+	{ .compatible = "xlnx,v-rgb2yuv-7.1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xrgb2yuv_of_id_table);
+
+static struct platform_driver xrgb2yuv_driver = {
+	.driver			= {
+		.name		= "xilinx-rgb2yuv",
+		.pm		= &xrgb2yuv_pm_ops,
+		.of_match_table	= xrgb2yuv_of_id_table,
+	},
+	.probe			= xrgb2yuv_probe,
+	.remove			= xrgb2yuv_remove,
+};
+
+module_platform_driver(xrgb2yuv_driver);
+
+MODULE_DESCRIPTION("Xilinx RGB to YUV Converter Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-scaler.c b/drivers/media/platform/xilinx/xilinx-scaler.c
new file mode 100644
index 000000000..29f57a51d
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-scaler.c
@@ -0,0 +1,751 @@
+/*
+ * Xilinx Scaler
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/device.h>
+#include <linux/fixp-arith.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XSCALER_MIN_WIDTH			32
+#define XSCALER_MAX_WIDTH			4096
+#define XSCALER_MIN_HEIGHT			32
+#define XSCALER_MAX_HEIGHT			4096
+
+#define XSCALER_HSF				0x0100
+#define XSCALER_VSF				0x0104
+#define XSCALER_SF_SHIFT			20
+#define XSCALER_SF_MASK				0xffffff
+#define XSCALER_SOURCE_SIZE			0x0108
+#define XSCALER_SIZE_HORZ_SHIFT			0
+#define XSCALER_SIZE_VERT_SHIFT			16
+#define XSCALER_SIZE_MASK			0xfff
+#define XSCALER_HAPERTURE			0x010c
+#define XSCALER_VAPERTURE			0x0110
+#define XSCALER_APERTURE_START_SHIFT		0
+#define XSCALER_APERTURE_END_SHIFT		16
+#define XSCALER_OUTPUT_SIZE			0x0114
+#define XSCALER_COEF_DATA_IN			0x0134
+#define XSCALER_COEF_DATA_IN_SHIFT		16
+
+/* Fixed point operations */
+#define FRAC_N	8
+
+static inline s16 fixp_new(s16 a)
+{
+	return a << FRAC_N;
+}
+
+static inline s16 fixp_mult(s16 a, s16 b)
+{
+	return ((s32)(a * b)) >> FRAC_N;
+}
+
+/**
+ * struct xscaler_device - Xilinx Scaler device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_format: Xilinx Video IP format
+ * @crop: Active crop rectangle for the sink pad
+ * @num_hori_taps: number of vertical taps
+ * @num_vert_taps: number of vertical taps
+ * @max_num_phases: maximum number of phases
+ * @separate_yc_coef: separate coefficients for Luma(y) and Chroma(c)
+ * @separate_hv_coef: separate coefficients for Horizontal(h) and Vertical(v)
+ */
+struct xscaler_device {
+	struct xvip_device xvip;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_format;
+	struct v4l2_rect crop;
+
+	u32 num_hori_taps;
+	u32 num_vert_taps;
+	u32 max_num_phases;
+	bool separate_yc_coef;
+	bool separate_hv_coef;
+};
+
+static inline struct xscaler_device *to_scaler(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xscaler_device, xvip.subdev);
+}
+
+/*
+ * V4L2 Subdevice Video Operations
+ */
+
+/**
+ * lanczos - Lanczos 2D FIR kernel convolution
+ * @x: phase
+ * @a: Lanczos kernel size
+ *
+ * Return: the coefficient value in fixed point format.
+ */
+static s16 lanczos(s16 x, s16 a)
+{
+	s16 pi;
+	s16 numerator;
+	s16 denominator;
+	s16 temp;
+
+	if (x < -a || x > a)
+		return 0;
+	else if (x == 0)
+		return fixp_new(1);
+
+	/* a * sin(pi * x) * sin(pi * x / a) / (pi * pi * x * x) */
+
+	pi = (fixp_new(157) << FRAC_N) / fixp_new(50);
+
+	if (x < 0)
+		x = -x;
+
+	/* sin(pi * x) */
+	temp = fixp_mult(fixp_new(180), x);
+	temp = fixp_sin16(temp >> FRAC_N);
+
+	/* a * sin(pi * x) */
+	numerator = fixp_mult(temp, a);
+
+	/* sin(pi * x / a) */
+	temp = (fixp_mult(fixp_new(180), x) << FRAC_N) / a;
+	temp = fixp_sin16(temp >> FRAC_N);
+
+	/* a * sin(pi * x) * sin(pi * x / a) */
+	numerator = fixp_mult(temp, numerator);
+
+	/* pi * pi * x * x */
+	denominator = fixp_mult(pi, pi);
+	temp = fixp_mult(x, x);
+	denominator = fixp_mult(temp, denominator);
+
+	return (numerator << FRAC_N) / denominator;
+}
+
+/**
+ * xscaler_set_coefs - generate and program the coefficient table
+ * @xscaler: scaler device
+ * @taps: maximum coefficient tap index
+ *
+ * Generate the coefficient table using Lanczos resampling, and program
+ * generated coefficients to the scaler. The generated coefficients are
+ * supposed to work regardless of resolutions.
+ *
+ * Return: 0 if the coefficient table is programmed, and -ENOMEM if memory
+ * allocation for the table fails.
+ */
+static int xscaler_set_coefs(struct xscaler_device *xscaler, s16 taps)
+{
+	s16 *coef;
+	s16 dy;
+	u32 coef_val;
+	u16 phases = xscaler->max_num_phases;
+	u16 i;
+	u16 j;
+
+	coef = kcalloc(phases, sizeof(*coef), GFP_KERNEL);
+	if (!coef)
+		return -ENOMEM;
+
+	for (i = 0; i < phases; i++) {
+		s16 sum = 0;
+
+		dy = ((fixp_new(i) << FRAC_N) / fixp_new(phases));
+
+		/* Generate Lanczos coefficients */
+		for (j = 0; j < taps; j++) {
+			coef[j] = lanczos(fixp_new(j - (taps >> 1)) + dy,
+					  fixp_new(taps >> 1));
+			sum += coef[j];
+		}
+
+		/* Program coefficients */
+		for (j = 0; j < taps; j += 2) {
+			/* Normalize and multiply coefficients */
+			coef_val = (((coef[j] << FRAC_N) << (FRAC_N - 2)) /
+				    sum) & 0xffff;
+			if (j + 1 < taps)
+				coef_val |= ((((coef[j + 1] << FRAC_N) <<
+					      (FRAC_N - 2)) / sum) & 0xffff) <<
+					    16;
+
+			xvip_write(&xscaler->xvip, XSCALER_COEF_DATA_IN,
+				   coef_val);
+		}
+	}
+
+	kfree(coef);
+
+	return 0;
+}
+
+static void xscaler_set_aperture(struct xscaler_device *xscaler)
+{
+	u16 start;
+	u16 end;
+	u32 scale_factor;
+
+	xvip_disable_reg_update(&xscaler->xvip);
+
+	/* set horizontal aperture */
+	start = xscaler->crop.left;
+	end = start + xscaler->crop.width - 1;
+	xvip_write(&xscaler->xvip, XSCALER_HAPERTURE,
+		   (end << XSCALER_APERTURE_END_SHIFT) |
+		   (start << XSCALER_APERTURE_START_SHIFT));
+
+	/* set vertical aperture */
+	start = xscaler->crop.top;
+	end = start + xscaler->crop.height - 1;
+	xvip_write(&xscaler->xvip, XSCALER_VAPERTURE,
+		   (end << XSCALER_APERTURE_END_SHIFT) |
+		   (start << XSCALER_APERTURE_START_SHIFT));
+
+	/* set scaling factors */
+	scale_factor = ((xscaler->crop.width << XSCALER_SF_SHIFT) /
+			xscaler->formats[XVIP_PAD_SOURCE].width) &
+		       XSCALER_SF_MASK;
+	xvip_write(&xscaler->xvip, XSCALER_HSF, scale_factor);
+
+	scale_factor = ((xscaler->crop.height << XSCALER_SF_SHIFT) /
+			xscaler->formats[XVIP_PAD_SOURCE].height) &
+		       XSCALER_SF_MASK;
+	xvip_write(&xscaler->xvip, XSCALER_VSF, scale_factor);
+
+	xvip_enable_reg_update(&xscaler->xvip);
+}
+
+static int xscaler_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	u32 width;
+	u32 height;
+
+	if (!enable) {
+		xvip_stop(&xscaler->xvip);
+		return 0;
+	}
+
+	/* set input width / height */
+	width = xscaler->formats[XVIP_PAD_SINK].width;
+	height = xscaler->formats[XVIP_PAD_SINK].height;
+	xvip_write(&xscaler->xvip, XSCALER_SOURCE_SIZE,
+		   (height << XSCALER_SIZE_VERT_SHIFT) |
+		   (width << XSCALER_SIZE_HORZ_SHIFT));
+
+	/* set output width / height */
+	width = xscaler->formats[XVIP_PAD_SOURCE].width;
+	height = xscaler->formats[XVIP_PAD_SOURCE].height;
+	xvip_write(&xscaler->xvip, XSCALER_OUTPUT_SIZE,
+		   (height << XSCALER_SIZE_VERT_SHIFT) |
+		   (width << XSCALER_SIZE_HORZ_SHIFT));
+
+	/* set aperture */
+	xscaler_set_aperture(xscaler);
+
+	xvip_start(&xscaler->xvip);
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Pad Operations
+ */
+
+static int xscaler_enum_frame_size(struct v4l2_subdev *subdev,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);
+
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	fse->min_width = XSCALER_MIN_WIDTH;
+	fse->max_width = XSCALER_MAX_WIDTH;
+	fse->min_height = XSCALER_MIN_HEIGHT;
+	fse->max_height = XSCALER_MAX_HEIGHT;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__xscaler_get_pad_format(struct xscaler_device *xscaler,
+			 struct v4l2_subdev_state *sd_state,
+			 unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xscaler->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xscaler->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static struct v4l2_rect *__xscaler_get_crop(struct xscaler_device *xscaler,
+					    struct v4l2_subdev_state *sd_state,
+					    u32 which)
+{
+	struct v4l2_rect *crop;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		crop = v4l2_subdev_get_try_crop(&xscaler->xvip.subdev,
+						sd_state,
+						XVIP_PAD_SINK);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		crop = &xscaler->crop;
+		break;
+	default:
+		crop = NULL;
+		break;
+	}
+
+	return crop;
+}
+
+static int xscaler_get_format(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xscaler_get_pad_format(xscaler, sd_state, fmt->pad,
+					  fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static void xscaler_try_crop(const struct v4l2_mbus_framefmt *sink,
+			     struct v4l2_rect *crop)
+{
+
+	crop->left = min_t(u32, crop->left, sink->width - XSCALER_MIN_WIDTH);
+	crop->top = min_t(u32, crop->top, sink->height - XSCALER_MIN_HEIGHT);
+	crop->width = clamp_t(u32, crop->width, XSCALER_MIN_WIDTH,
+			      sink->width - crop->left);
+	crop->height = clamp_t(u32, crop->height, XSCALER_MIN_HEIGHT,
+			       sink->height - crop->top);
+}
+
+static int xscaler_set_format(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_rect *crop;
+
+	format = __xscaler_get_pad_format(xscaler, sd_state, fmt->pad,
+					  fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				  XSCALER_MIN_WIDTH, XSCALER_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				   XSCALER_MIN_HEIGHT, XSCALER_MAX_HEIGHT);
+
+	fmt->format = *format;
+
+	if (fmt->pad == XVIP_PAD_SINK) {
+		/* Set the crop rectangle to the full frame */
+		crop = __xscaler_get_crop(xscaler, sd_state, fmt->which);
+		if (!crop)
+			return -EINVAL;
+		crop->left = 0;
+		crop->top = 0;
+		crop->width = fmt->format.width;
+		crop->height = fmt->format.height;
+	}
+
+	return 0;
+}
+
+static int xscaler_get_selection(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_rect *crop;
+
+	if (sel->pad != XVIP_PAD_SINK)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		format = __xscaler_get_pad_format(xscaler, sd_state,
+						  XVIP_PAD_SINK,
+						  sel->which);
+		if (!format)
+			return -EINVAL;
+
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = format->width;
+		sel->r.height = format->height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		crop = __xscaler_get_crop(xscaler, sd_state, sel->which);
+		if (!crop)
+			return -EINVAL;
+		sel->r = *crop;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int xscaler_set_selection(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_rect *crop;
+
+	if ((sel->target != V4L2_SEL_TGT_CROP) || (sel->pad != XVIP_PAD_SINK))
+		return -EINVAL;
+
+	format = __xscaler_get_pad_format(xscaler, sd_state, XVIP_PAD_SINK,
+					  sel->which);
+	if (!format)
+		return -EINVAL;
+
+	xscaler_try_crop(format, &sel->r);
+	crop = __xscaler_get_crop(xscaler, sd_state, sel->which);
+	if (!crop)
+		return -EINVAL;
+
+	*crop = sel->r;
+
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Operations
+ */
+
+static int xscaler_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xscaler->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state,
+					    XVIP_PAD_SOURCE);
+	*format = xscaler->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xscaler_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops xscaler_video_ops = {
+	.s_stream = xscaler_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xscaler_pad_ops = {
+	.enum_mbus_code		= xvip_enum_mbus_code,
+	.enum_frame_size	= xscaler_enum_frame_size,
+	.get_fmt		= xscaler_get_format,
+	.set_fmt		= xscaler_set_format,
+	.get_selection		= xscaler_get_selection,
+	.set_selection		= xscaler_set_selection,
+};
+
+static struct v4l2_subdev_ops xscaler_ops = {
+	.video  = &xscaler_video_ops,
+	.pad    = &xscaler_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xscaler_internal_ops = {
+	.open	= xscaler_open,
+	.close	= xscaler_close,
+};
+
+/*
+ * Media Operations
+ */
+
+static const struct media_entity_operations xscaler_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/*
+ * Power Management
+ */
+
+static int __maybe_unused xscaler_pm_suspend(struct device *dev)
+{
+	struct xscaler_device *xscaler = dev_get_drvdata(dev);
+
+	xvip_suspend(&xscaler->xvip);
+
+	return 0;
+}
+
+static int __maybe_unused xscaler_pm_resume(struct device *dev)
+{
+	struct xscaler_device *xscaler = dev_get_drvdata(dev);
+
+	xvip_resume(&xscaler->xvip);
+
+	return 0;
+}
+
+/*
+ * Platform Device Driver
+ */
+
+static int xscaler_parse_of(struct xscaler_device *xscaler)
+{
+	struct device *dev = xscaler->xvip.dev;
+	struct device_node *node = xscaler->xvip.dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	int ret;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct xvip_video_format *vip_format;
+
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			if (!xscaler->vip_format) {
+				xscaler->vip_format = vip_format;
+			} else if (xscaler->vip_format != vip_format) {
+				dev_err(dev, "in/out format mismatch in DT");
+				return -EINVAL;
+			}
+		}
+	}
+
+	ret = of_property_read_u32(node, "xlnx,num-hori-taps",
+				   &xscaler->num_hori_taps);
+	if (ret < 0)
+		return ret;
+
+	ret = of_property_read_u32(node, "xlnx,num-vert-taps",
+				   &xscaler->num_vert_taps);
+	if (ret < 0)
+		return ret;
+
+	ret = of_property_read_u32(node, "xlnx,max-num-phases",
+				   &xscaler->max_num_phases);
+	if (ret < 0)
+		return ret;
+
+	xscaler->separate_yc_coef =
+		of_property_read_bool(node, "xlnx,separate-yc-coef");
+
+	xscaler->separate_hv_coef =
+		of_property_read_bool(node, "xlnx,separate-hv-coef");
+
+	return 0;
+}
+
+static int xscaler_probe(struct platform_device *pdev)
+{
+	struct xscaler_device *xscaler;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	u32 size;
+	int ret;
+
+	xscaler = devm_kzalloc(&pdev->dev, sizeof(*xscaler), GFP_KERNEL);
+	if (!xscaler)
+		return -ENOMEM;
+
+	xscaler->xvip.dev = &pdev->dev;
+
+	ret = xscaler_parse_of(xscaler);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xscaler->xvip);
+	if (ret < 0)
+		return ret;
+
+	/* Reset and initialize the core */
+	xvip_reset(&xscaler->xvip);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xscaler->xvip.subdev;
+	v4l2_subdev_init(subdev, &xscaler_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xscaler_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xscaler);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &xscaler->default_formats[XVIP_PAD_SINK];
+	default_format->code = xscaler->vip_format->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	size = xvip_read(&xscaler->xvip, XSCALER_SOURCE_SIZE);
+	default_format->width = (size >> XSCALER_SIZE_HORZ_SHIFT) &
+				 XSCALER_SIZE_MASK;
+	default_format->height = (size >> XSCALER_SIZE_VERT_SHIFT) &
+				 XSCALER_SIZE_MASK;
+
+	xscaler->formats[XVIP_PAD_SINK] = *default_format;
+
+	default_format = &xscaler->default_formats[XVIP_PAD_SOURCE];
+	*default_format = xscaler->default_formats[XVIP_PAD_SINK];
+	size = xvip_read(&xscaler->xvip, XSCALER_OUTPUT_SIZE);
+	default_format->width = (size >> XSCALER_SIZE_HORZ_SHIFT) &
+				 XSCALER_SIZE_MASK;
+	default_format->height = (size >> XSCALER_SIZE_VERT_SHIFT) &
+				 XSCALER_SIZE_MASK;
+
+	xscaler->formats[XVIP_PAD_SOURCE] = *default_format;
+
+	xscaler->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xscaler->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xscaler_media_ops;
+
+	ret = media_entity_pads_init(&subdev->entity, 2, xscaler->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xscaler);
+
+	xvip_print_version(&xscaler->xvip);
+
+	ret = xscaler_set_coefs(xscaler, (s16)xscaler->num_hori_taps);
+	if (ret < 0)
+		goto error;
+
+	if (xscaler->separate_hv_coef) {
+		ret = xscaler_set_coefs(xscaler, (s16)xscaler->num_vert_taps);
+		if (ret < 0)
+			goto error;
+	}
+
+	if (xscaler->separate_yc_coef) {
+		ret = xscaler_set_coefs(xscaler, (s16)xscaler->num_hori_taps);
+		if (ret < 0)
+			goto error;
+
+		if (xscaler->separate_hv_coef) {
+			ret = xscaler_set_coefs(xscaler,
+						(s16)xscaler->num_vert_taps);
+			if (ret < 0)
+				goto error;
+		}
+	}
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xscaler->xvip);
+	return ret;
+}
+
+static int xscaler_remove(struct platform_device *pdev)
+{
+	struct xscaler_device *xscaler = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xscaler->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xscaler->xvip);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(xscaler_pm_ops, xscaler_pm_suspend, xscaler_pm_resume);
+
+static const struct of_device_id xscaler_of_id_table[] = {
+	{ .compatible = "xlnx,v-scaler-8.1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xscaler_of_id_table);
+
+static struct platform_driver xscaler_driver = {
+	.driver			= {
+		.name		= "xilinx-scaler",
+		.pm		= &xscaler_pm_ops,
+		.of_match_table	= xscaler_of_id_table,
+	},
+	.probe			= xscaler_probe,
+	.remove			= xscaler_remove,
+};
+
+module_platform_driver(xscaler_driver);
+
+MODULE_DESCRIPTION("Xilinx Scaler Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-scenechange-channel.c b/drivers/media/platform/xilinx/xilinx-scenechange-channel.c
new file mode 100644
index 000000000..f664a1fc5
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-scenechange-channel.c
@@ -0,0 +1,464 @@
+//SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Scene Change Detection driver
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Authors: Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>
+ *          Satish Kumar Nagireddy <satish.nagireddy.nagireddy@xilinx.com>
+ */
+
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/xilinx-v4l2-events.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-scenechange.h"
+#include "xilinx-vip.h"
+
+#define XSCD_DEFAULT_WIDTH	3840
+#define XSCD_DEFAULT_HEIGHT	2160
+#define XSCD_MAX_WIDTH		8192
+#define XSCD_MAX_HEIGHT		4320
+#define XSCD_MIN_WIDTH		64
+#define XSCD_MIN_HEIGHT		64
+
+#define XSCD_V_SUBSAMPLING		16
+#define XSCD_BYTE_ALIGN			16
+#define MULTIPLICATION_FACTOR		100
+
+#define XSCD_SCENE_CHANGE		1
+#define XSCD_NO_SCENE_CHANGE		0
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static int xscd_enum_mbus_code(struct v4l2_subdev *subdev,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_mbus_code_enum *code)
+{
+	return 0;
+}
+
+static int xscd_enum_frame_size(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__xscd_get_pad_format(struct xscd_chan *chan,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&chan->subdev, sd_state,
+						  pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &chan->format;
+	default:
+		return NULL;
+	}
+	return NULL;
+}
+
+static int xscd_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xscd_chan *chan = to_xscd_chan(subdev);
+
+	fmt->format = *__xscd_get_pad_format(chan, sd_state, fmt->pad,
+					     fmt->which);
+	return 0;
+}
+
+static int xscd_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xscd_chan *chan = to_xscd_chan(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xscd_get_pad_format(chan, sd_state, fmt->pad, fmt->which);
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XSCD_MIN_WIDTH, XSCD_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XSCD_MIN_HEIGHT, XSCD_MAX_HEIGHT);
+	format->code = fmt->format.code;
+	/*
+	 * If memory based, SCD can support interlaced alternate mode because
+	 * SCD is agnostic to field. If stream based, SCD does not have a fid
+	 * pin so interlaced alternate mode is not supported there.
+	 */
+	if (chan->xscd->memory_based)
+		format->field = fmt->format.field;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xscd_chan_get_vid_fmt(u32 media_bus_fmt, bool memory_based)
+{
+	u32 vid_fmt;
+
+	if (memory_based) {
+		switch (media_bus_fmt) {
+		case MEDIA_BUS_FMT_VYYUYY8_1X24:
+		case MEDIA_BUS_FMT_UYVY8_1X16:
+		case MEDIA_BUS_FMT_VUY8_1X24:
+			vid_fmt = XSCD_VID_FMT_Y8;
+			break;
+		case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		case MEDIA_BUS_FMT_UYVY10_1X20:
+		case MEDIA_BUS_FMT_VUY10_1X30:
+			vid_fmt = XSCD_VID_FMT_Y10;
+			break;
+		default:
+			vid_fmt = XSCD_VID_FMT_Y8;
+		}
+
+		return vid_fmt;
+	}
+
+	/* Streaming based */
+	switch (media_bus_fmt) {
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+	case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		vid_fmt = XSCD_VID_FMT_YUV_420;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		vid_fmt = XSCD_VID_FMT_YUV_422;
+		break;
+	case MEDIA_BUS_FMT_VUY8_1X24:
+	case MEDIA_BUS_FMT_VUY10_1X30:
+		vid_fmt = XSCD_VID_FMT_YUV_444;
+		break;
+	case MEDIA_BUS_FMT_RBG888_1X24:
+	case MEDIA_BUS_FMT_RBG101010_1X30:
+		vid_fmt = XSCD_VID_FMT_RGB;
+		break;
+	default:
+		vid_fmt = XSCD_VID_FMT_YUV_420;
+	}
+
+	return vid_fmt;
+}
+
+/**
+ * xscd_chan_configure_params - Program parameters to HW registers
+ * @chan: Driver specific channel struct pointer
+ */
+static void xscd_chan_configure_params(struct xscd_chan *chan)
+{
+	u32 vid_fmt, stride;
+
+	xscd_write(chan->iomem, XSCD_WIDTH_OFFSET, chan->format.width);
+
+	/* Stride is required only for memory based IP, not for streaming IP */
+	if (chan->xscd->memory_based) {
+		stride = roundup(chan->format.width, XSCD_BYTE_ALIGN);
+		xscd_write(chan->iomem, XSCD_STRIDE_OFFSET, stride);
+	}
+
+	xscd_write(chan->iomem, XSCD_HEIGHT_OFFSET, chan->format.height);
+
+	/* Hardware video format */
+	vid_fmt = xscd_chan_get_vid_fmt(chan->format.code,
+					chan->xscd->memory_based);
+	xscd_write(chan->iomem, XSCD_VID_FMT_OFFSET, vid_fmt);
+
+	/*
+	 * This is the vertical subsampling factor of the input image. Instead
+	 * of sampling every line to calculate the histogram, IP uses this
+	 * register value to sample only specific lines of the frame.
+	 */
+	xscd_write(chan->iomem, XSCD_SUBSAMPLE_OFFSET, XSCD_V_SUBSAMPLING);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+static int xscd_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct xscd_chan *chan = container_of(ctrl->handler, struct xscd_chan,
+					      ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_SCD_THRESHOLD:
+		chan->threshold = ctrl->val;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int xscd_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xscd_chan *chan = to_xscd_chan(subdev);
+	struct xscd_device *xscd = chan->xscd;
+
+	if (enable)
+		xscd_chan_configure_params(chan);
+
+	xscd_dma_enable_channel(&chan->dmachan, enable);
+
+	/*
+	 * Resolution change doesn't work in stream based mode unless
+	 * the device is reset.
+	 */
+	if (!enable && !xscd->memory_based) {
+		gpiod_set_value_cansleep(xscd->rst_gpio, XSCD_RESET_ASSERT);
+		gpiod_set_value_cansleep(xscd->rst_gpio, XSCD_RESET_DEASSERT);
+	}
+
+	return 0;
+}
+
+static int xscd_subscribe_event(struct v4l2_subdev *sd,
+				struct v4l2_fh *fh,
+				struct v4l2_event_subscription *sub)
+{
+	int ret;
+	struct xscd_chan *chan = to_xscd_chan(sd);
+
+	mutex_lock(&chan->lock);
+
+	switch (sub->type) {
+	case V4L2_EVENT_XLNXSCD:
+		ret = v4l2_event_subscribe(fh, sub, 1, NULL);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&chan->lock);
+
+	return ret;
+}
+
+static int xscd_unsubscribe_event(struct v4l2_subdev *sd,
+				  struct v4l2_fh *fh,
+				  struct v4l2_event_subscription *sub)
+{
+	int ret;
+	struct xscd_chan *chan = to_xscd_chan(sd);
+
+	mutex_lock(&chan->lock);
+	ret = v4l2_event_unsubscribe(fh, sub);
+	mutex_unlock(&chan->lock);
+
+	return ret;
+}
+
+static int xscd_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static int xscd_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops xscd_ctrl_ops = {
+	.s_ctrl	= xscd_s_ctrl
+};
+
+static const struct v4l2_ctrl_config xscd_ctrls[] = {
+	{
+		.ops = &xscd_ctrl_ops,
+		.id = V4L2_CID_XILINX_SCD_THRESHOLD,
+		.name = "Threshold Value",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = 50,
+	}
+};
+
+static const struct v4l2_subdev_core_ops xscd_core_ops = {
+	.subscribe_event = xscd_subscribe_event,
+	.unsubscribe_event = xscd_unsubscribe_event
+};
+
+static struct v4l2_subdev_video_ops xscd_video_ops = {
+	.s_stream = xscd_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xscd_pad_ops = {
+	.enum_mbus_code = xscd_enum_mbus_code,
+	.enum_frame_size = xscd_enum_frame_size,
+	.get_fmt = xscd_get_format,
+	.set_fmt = xscd_set_format,
+};
+
+static struct v4l2_subdev_ops xscd_ops = {
+	.core = &xscd_core_ops,
+	.video = &xscd_video_ops,
+	.pad = &xscd_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xscd_internal_ops = {
+	.open = xscd_open,
+	.close = xscd_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xscd_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+void xscd_chan_event_notify(struct xscd_chan *chan)
+{
+	u32 *eventdata;
+	u32 sad;
+
+	sad = xscd_read(chan->iomem, XSCD_SAD_OFFSET);
+	sad = (sad * XSCD_V_SUBSAMPLING * MULTIPLICATION_FACTOR) /
+	       (chan->format.width * chan->format.height);
+	eventdata = (u32 *)&chan->event.u.data;
+
+	if (sad > chan->threshold)
+		eventdata[0] = XSCD_SCENE_CHANGE;
+	else
+		eventdata[0] = XSCD_NO_SCENE_CHANGE;
+
+	chan->event.type = V4L2_EVENT_XLNXSCD;
+	v4l2_subdev_notify_event(&chan->subdev, &chan->event);
+}
+
+/**
+ * xscd_chan_init - Initialize the V4L2 subdev for a channel
+ * @xscd: Pointer to the SCD device structure
+ * @chan_id: Channel id
+ * @node: device node
+ *
+ * Return: '0' on success and failure value on error
+ */
+int xscd_chan_init(struct xscd_device *xscd, unsigned int chan_id,
+		   struct device_node *node)
+{
+	struct xscd_chan *chan = &xscd->chans[chan_id];
+	struct v4l2_subdev *subdev;
+	unsigned int num_pads;
+	int ret;
+	unsigned int i;
+
+	mutex_init(&chan->lock);
+	chan->xscd = xscd;
+	chan->id = chan_id;
+	chan->iomem = chan->xscd->iomem + chan->id * XSCD_CHAN_OFFSET;
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &chan->subdev;
+	v4l2_subdev_init(subdev, &xscd_ops);
+	subdev->dev = chan->xscd->dev;
+	subdev->fwnode = of_fwnode_handle(node);
+	subdev->internal_ops = &xscd_internal_ops;
+	snprintf(subdev->name, sizeof(subdev->name), "xlnx-scdchan.%u",
+		 chan_id);
+	v4l2_set_subdevdata(subdev, chan);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	/* Initialize default format */
+	chan->format.code = MEDIA_BUS_FMT_VYYUYY8_1X24;
+	chan->format.field = V4L2_FIELD_NONE;
+	chan->format.width = XSCD_DEFAULT_WIDTH;
+	chan->format.height = XSCD_DEFAULT_HEIGHT;
+
+	/* Initialize media pads */
+	num_pads = xscd->memory_based ? 1 : 2;
+
+	chan->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	if (!xscd->memory_based)
+		chan->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&subdev->entity, num_pads, chan->pads);
+	if (ret < 0)
+		goto media_init_error;
+
+	subdev->entity.ops = &xscd_media_ops;
+
+	/* Initialize V4L2 Control Handler */
+	v4l2_ctrl_handler_init(&chan->ctrl_handler, ARRAY_SIZE(xscd_ctrls));
+
+	for (i = 0; i < ARRAY_SIZE(xscd_ctrls); i++) {
+		struct v4l2_ctrl *ctrl;
+
+		dev_dbg(chan->xscd->dev, "%d ctrl = 0x%x\n", i,
+			xscd_ctrls[i].id);
+		ctrl = v4l2_ctrl_new_custom(&chan->ctrl_handler, &xscd_ctrls[i],
+					    NULL);
+		if (!ctrl) {
+			dev_err(chan->xscd->dev, "Failed for %s ctrl\n",
+				xscd_ctrls[i].name);
+			goto ctrl_handler_error;
+		}
+	}
+
+	if (chan->ctrl_handler.error) {
+		dev_err(chan->xscd->dev, "failed to add controls\n");
+		ret = chan->ctrl_handler.error;
+		goto ctrl_handler_error;
+	}
+
+	subdev->ctrl_handler = &chan->ctrl_handler;
+
+	ret = v4l2_ctrl_handler_setup(&chan->ctrl_handler);
+	if (ret < 0) {
+		dev_err(chan->xscd->dev, "failed to set controls\n");
+		goto ctrl_handler_error;
+	}
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(chan->xscd->dev, "failed to register subdev\n");
+		goto ctrl_handler_error;
+	}
+
+	dev_info(chan->xscd->dev, "Scene change detection channel found!\n");
+	return 0;
+
+ctrl_handler_error:
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+media_init_error:
+	media_entity_cleanup(&subdev->entity);
+	mutex_destroy(&chan->lock);
+	return ret;
+}
+
+/**
+ * xscd_chan_cleanup - Clean up the V4L2 subdev for a channel
+ * @xscd: Pointer to the SCD device structure
+ * @chan_id: Channel id
+ * @node: device node
+ */
+void xscd_chan_cleanup(struct xscd_device *xscd, unsigned int chan_id,
+		       struct device_node *node)
+{
+	struct xscd_chan *chan = &xscd->chans[chan_id];
+	struct v4l2_subdev *subdev = &chan->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	mutex_destroy(&chan->lock);
+}
diff --git a/drivers/media/platform/xilinx/xilinx-scenechange-dma.c b/drivers/media/platform/xilinx/xilinx-scenechange-dma.c
new file mode 100644
index 000000000..58437a769
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-scenechange-dma.c
@@ -0,0 +1,554 @@
+//SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Scene Change Detection DMA driver
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Authors: Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>
+ *          Satish Kumar Nagireddy <satish.nagireddy.nagireddy@xilinx.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/of_dma.h>
+#include <linux/slab.h>
+
+#include "../../../dma/dmaengine.h"
+
+#include "xilinx-scenechange.h"
+
+/**
+ * xscd_dma_start - Start the SCD core
+ * @xscd: The SCD device
+ * @channels: Bitmask of enabled channels
+ */
+static void xscd_dma_start(struct xscd_device *xscd, unsigned int channels)
+{
+	xscd_write(xscd->iomem, XSCD_IE_OFFSET, XSCD_IE_AP_DONE);
+	xscd_write(xscd->iomem, XSCD_GIE_OFFSET, XSCD_GIE_EN);
+	xscd_write(xscd->iomem, XSCD_CHAN_EN_OFFSET, channels);
+
+	xscd_set(xscd->iomem, XSCD_CTRL_OFFSET,
+		 xscd->memory_based ? XSCD_CTRL_AP_START
+				    : XSCD_CTRL_AP_START |
+				      XSCD_CTRL_AUTO_RESTART);
+
+	xscd->running = true;
+}
+
+/**
+ * xscd_dma_stop - Stop the SCD core
+ * @xscd: The SCD device
+ */
+static void xscd_dma_stop(struct xscd_device *xscd)
+{
+	xscd_clr(xscd->iomem, XSCD_CTRL_OFFSET,
+		 xscd->memory_based ? XSCD_CTRL_AP_START
+				    : XSCD_CTRL_AP_START |
+				      XSCD_CTRL_AUTO_RESTART);
+
+	xscd->running = false;
+}
+
+/**
+ * xscd_dma_setup_channel - Setup a channel for transfer
+ * @chan: Driver specific channel struct pointer
+ *
+ * Return: 1 if the channel starts to run for a new transfer. Otherwise, 0.
+ */
+static int xscd_dma_setup_channel(struct xscd_dma_chan *chan)
+{
+	struct xscd_dma_tx_descriptor *desc;
+
+	if (!chan->enabled)
+		return 0;
+
+	if (list_empty(&chan->pending_list))
+		return 0;
+
+	desc = list_first_entry(&chan->pending_list,
+				struct xscd_dma_tx_descriptor, node);
+	list_del(&desc->node);
+
+	xscd_write(chan->iomem, XSCD_ADDR_OFFSET, desc->sw.luma_plane_addr);
+	chan->active_desc = desc;
+
+	return 1;
+}
+
+/**
+ * xscd_dma_kick - Start a run of the SCD core if channels are ready
+ * @xscd: The SCD device
+ *
+ * This function starts a single run of the SCD core when all the following
+ * conditions are met:
+ *
+ * - The SCD is not currently running
+ * - At least one channel is enabled and has buffers available
+ *
+ * It can be used to start the SCD when a buffer is queued, when a channel
+ * starts streaming, or to start the next run. Calling this function is only
+ * valid for memory-based mode and is not permitted for stream-based mode.
+ *
+ * The running state for all channels is updated. Channels that are being
+ * stopped are signalled through the channel wait queue.
+ *
+ * The function must be called with the xscd_device lock held.
+ */
+static void xscd_dma_kick(struct xscd_device *xscd)
+{
+	unsigned int channels = 0;
+	unsigned int i;
+
+	lockdep_assert_held(&xscd->lock);
+
+	if (xscd->running)
+		return;
+
+	for (i = 0; i < xscd->num_streams; i++) {
+		struct xscd_dma_chan *chan = xscd->channels[i];
+		unsigned long flags;
+		unsigned int running;
+		bool stopped;
+
+		spin_lock_irqsave(&chan->lock, flags);
+		running = xscd_dma_setup_channel(chan);
+		stopped = chan->running && !running;
+		chan->running = running;
+		spin_unlock_irqrestore(&chan->lock, flags);
+
+		channels |= running << chan->id;
+		if (stopped)
+			wake_up(&chan->wait);
+	}
+
+	if (channels)
+		xscd_dma_start(xscd, channels);
+	else
+		xscd_dma_stop(xscd);
+}
+
+/**
+ * xscd_dma_enable_channel - Enable/disable a channel
+ * @chan: Driver specific channel struct pointer
+ * @enable: True to enable the channel, false to disable it
+ *
+ * This function enables or disable a channel. When operating in memory-based
+ * mode, enabling a channel kicks processing if buffers are available for any
+ * enabled channel and the SCD core is idle. When operating in stream-based
+ * mode, the SCD core is started or stopped synchronously when then channel is
+ * enabled or disabled.
+ *
+ * This function must be called in non-atomic, non-interrupt context.
+ */
+void xscd_dma_enable_channel(struct xscd_dma_chan *chan, bool enable)
+{
+	struct xscd_device *xscd = chan->xscd;
+
+	if (enable) {
+		/*
+		 * FIXME: Don't set chan->enabled to false here, it will be
+		 * done in xscd_dma_terminate_all(). This works around a bug
+		 * introduced in commit 2e77607047c6 ("xilinx: v4l2: dma: Add
+		 * multiple output support") that stops all channels when the
+		 * first one is stopped, even though they are part of
+		 * independent pipelines. This workaround should be safe as
+		 * long as dmaengine_terminate_all() is called after
+		 * xvip_pipeline_set_stream().
+		 */
+		spin_lock_irq(&chan->lock);
+		chan->enabled = true;
+		spin_unlock_irq(&chan->lock);
+	}
+
+	if (xscd->memory_based) {
+		if (enable) {
+			spin_lock_irq(&xscd->lock);
+			xscd_dma_kick(xscd);
+			spin_unlock_irq(&xscd->lock);
+		}
+	} else {
+		if (enable)
+			xscd_dma_start(xscd, BIT(chan->id));
+		else
+			xscd_dma_stop(xscd);
+	}
+}
+
+/**
+ * xscd_dma_irq_handler - scdma Interrupt handler
+ * @xscd: Pointer to the SCD device structure
+ */
+void xscd_dma_irq_handler(struct xscd_device *xscd)
+{
+	unsigned int i;
+
+	/*
+	 * Mark the active descriptors as complete, move them to the done list
+	 * and schedule the tasklet to clean them up.
+	 */
+	for (i = 0; i < xscd->num_streams; ++i) {
+		struct xscd_dma_chan *chan = xscd->channels[i];
+		struct xscd_dma_tx_descriptor *desc = chan->active_desc;
+
+		if (!desc)
+			continue;
+
+		dma_cookie_complete(&desc->async_tx);
+		xscd_chan_event_notify(&xscd->chans[i]);
+
+		spin_lock(&chan->lock);
+		list_add_tail(&desc->node, &chan->done_list);
+		chan->active_desc = NULL;
+		spin_unlock(&chan->lock);
+
+		tasklet_schedule(&chan->tasklet);
+	}
+
+	/* Start the next run, if any. */
+	spin_lock(&xscd->lock);
+	xscd->running = false;
+	xscd_dma_kick(xscd);
+	spin_unlock(&xscd->lock);
+}
+
+/* -----------------------------------------------------------------------------
+ * DMA Engine
+ */
+
+/**
+ * xscd_dma_tx_submit - Submit DMA transaction
+ * @tx: Async transaction descriptor
+ *
+ * Return: cookie value on success and failure value on error
+ */
+static dma_cookie_t xscd_dma_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct xscd_dma_tx_descriptor *desc = to_xscd_dma_tx_descriptor(tx);
+	struct xscd_dma_chan *chan = to_xscd_dma_chan(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->lock, flags);
+	cookie = dma_cookie_assign(tx);
+	list_add_tail(&desc->node, &chan->pending_list);
+	spin_unlock_irqrestore(&chan->lock, flags);
+
+	return cookie;
+}
+
+/**
+ * xscd_dma_free_desc_list - Free descriptors list
+ * @chan: Driver specific dma channel
+ * @list: List to parse and delete the descriptor
+ */
+static void xscd_dma_free_desc_list(struct xscd_dma_chan *chan,
+				    struct list_head *list)
+{
+	struct xscd_dma_tx_descriptor *desc, *next;
+
+	list_for_each_entry_safe(desc, next, list, node) {
+		list_del(&desc->node);
+		kfree(desc);
+	}
+}
+
+/**
+ * xscd_dma_free_descriptors - Free channel descriptors
+ * @chan: Driver specific dma channel
+ */
+static void xscd_dma_free_descriptors(struct xscd_dma_chan *chan)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->lock, flags);
+
+	xscd_dma_free_desc_list(chan, &chan->pending_list);
+	xscd_dma_free_desc_list(chan, &chan->done_list);
+	kfree(chan->active_desc);
+
+	chan->active_desc = NULL;
+	INIT_LIST_HEAD(&chan->pending_list);
+	INIT_LIST_HEAD(&chan->done_list);
+
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
+
+/**
+ * scd_dma_chan_desc_cleanup - Clean channel descriptors
+ * @chan: Driver specific dma channel
+ */
+static void xscd_dma_chan_desc_cleanup(struct xscd_dma_chan *chan)
+{
+	struct xscd_dma_tx_descriptor *desc, *next;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->lock, flags);
+
+	list_for_each_entry_safe(desc, next, &chan->done_list, node) {
+		dma_async_tx_callback callback;
+		void *callback_param;
+
+		list_del(&desc->node);
+
+		/* Run the link descriptor callback function */
+		callback = desc->async_tx.callback;
+		callback_param = desc->async_tx.callback_param;
+		if (callback) {
+			spin_unlock_irqrestore(&chan->lock, flags);
+			callback(callback_param);
+			spin_lock_irqsave(&chan->lock, flags);
+		}
+
+		kfree(desc);
+	}
+
+	spin_unlock_irqrestore(&chan->lock, flags);
+}
+
+/**
+ * xscd_dma_dma_prep_interleaved - prepare a descriptor for a
+ * DMA_SLAVE transaction
+ * @dchan: DMA channel
+ * @xt: Interleaved template pointer
+ * @flags: transfer ack flags
+ *
+ * Return: Async transaction descriptor on success and NULL on failure
+ */
+static struct dma_async_tx_descriptor *
+xscd_dma_prep_interleaved(struct dma_chan *dchan,
+			  struct dma_interleaved_template *xt,
+			  unsigned long flags)
+{
+	struct xscd_dma_chan *chan = to_xscd_dma_chan(dchan);
+	struct xscd_dma_tx_descriptor *desc;
+	struct xscd_dma_desc *sw;
+
+	desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+	if (!desc)
+		return NULL;
+
+	dma_async_tx_descriptor_init(&desc->async_tx, &chan->common);
+	desc->async_tx.tx_submit = xscd_dma_tx_submit;
+	async_tx_ack(&desc->async_tx);
+
+	sw = &desc->sw;
+	sw->vsize = xt->numf;
+	sw->hsize = xt->sgl[0].size;
+	sw->stride = xt->sgl[0].size + xt->sgl[0].icg;
+	sw->luma_plane_addr = xt->src_start;
+
+	return &desc->async_tx;
+}
+
+static bool xscd_dma_is_running(struct xscd_dma_chan *chan)
+{
+	bool running;
+
+	spin_lock_irq(&chan->lock);
+	running = chan->running;
+	spin_unlock_irq(&chan->lock);
+
+	return running;
+}
+
+/**
+ * xscd_dma_terminate_all - Halt the channel and free descriptors
+ * @dchan: Driver specific dma channel pointer
+ *
+ * Return: 0
+ */
+static int xscd_dma_terminate_all(struct dma_chan *dchan)
+{
+	struct xscd_dma_chan *chan = to_xscd_dma_chan(dchan);
+	int ret;
+
+	spin_lock_irq(&chan->lock);
+	chan->enabled = false;
+	spin_unlock_irq(&chan->lock);
+
+	/* Wait for any on-going transfer to complete. */
+	ret = wait_event_timeout(chan->wait, !xscd_dma_is_running(chan),
+				 msecs_to_jiffies(100));
+	WARN_ON(ret == 0);
+
+	xscd_dma_free_descriptors(chan);
+	return 0;
+}
+
+/**
+ * xscd_dma_issue_pending - Issue pending transactions
+ * @dchan: DMA channel
+ */
+static void xscd_dma_issue_pending(struct dma_chan *dchan)
+{
+	struct xscd_dma_chan *chan = to_xscd_dma_chan(dchan);
+	struct xscd_device *xscd = chan->xscd;
+	unsigned long flags;
+
+	spin_lock_irqsave(&xscd->lock, flags);
+	xscd_dma_kick(xscd);
+	spin_unlock_irqrestore(&xscd->lock, flags);
+}
+
+static enum dma_status xscd_dma_tx_status(struct dma_chan *dchan,
+					  dma_cookie_t cookie,
+					  struct dma_tx_state *txstate)
+{
+	return dma_cookie_status(dchan, cookie, txstate);
+}
+
+/**
+ * xscd_dma_free_chan_resources - Free channel resources
+ * @dchan: DMA channel
+ */
+static void xscd_dma_free_chan_resources(struct dma_chan *dchan)
+{
+	struct xscd_dma_chan *chan = to_xscd_dma_chan(dchan);
+
+	xscd_dma_free_descriptors(chan);
+}
+
+/**
+ * xscd_dma_do_tasklet - Schedule completion tasklet
+ * @data: Pointer to the Xilinx scdma channel structure
+ */
+static void xscd_dma_do_tasklet(unsigned long data)
+{
+	struct xscd_dma_chan *chan = (struct xscd_dma_chan *)data;
+
+	xscd_dma_chan_desc_cleanup(chan);
+}
+
+/**
+ * xscd_dma_alloc_chan_resources - Allocate channel resources
+ * @dchan: DMA channel
+ *
+ * Return: '0' on success and failure value on error
+ */
+static int xscd_dma_alloc_chan_resources(struct dma_chan *dchan)
+{
+	dma_cookie_init(dchan);
+	return 0;
+}
+
+/**
+ * of_scdma_xilinx_xlate - Translation function
+ * @dma_spec: Pointer to DMA specifier as found in the device tree
+ * @ofdma: Pointer to DMA controller data
+ *
+ * Return: DMA channel pointer on success and NULL on error
+ */
+static struct dma_chan *of_scdma_xilinx_xlate(struct of_phandle_args *dma_spec,
+					      struct of_dma *ofdma)
+{
+	struct xscd_device *xscd = ofdma->of_dma_data;
+	u32 chan_id = dma_spec->args[0];
+
+	if (chan_id >= xscd->num_streams)
+		return NULL;
+
+	if (!xscd->channels[chan_id])
+		return NULL;
+
+	return dma_get_slave_channel(&xscd->channels[chan_id]->common);
+}
+
+static void xscd_dma_chan_init(struct xscd_device *xscd, int chan_id)
+{
+	struct xscd_dma_chan *chan = &xscd->chans[chan_id].dmachan;
+
+	chan->id = chan_id;
+	chan->iomem = xscd->iomem + chan->id * XSCD_CHAN_OFFSET;
+	chan->xscd = xscd;
+
+	xscd->channels[chan->id] = chan;
+
+	spin_lock_init(&chan->lock);
+	INIT_LIST_HEAD(&chan->pending_list);
+	INIT_LIST_HEAD(&chan->done_list);
+	tasklet_init(&chan->tasklet, xscd_dma_do_tasklet,
+		     (unsigned long)chan);
+	init_waitqueue_head(&chan->wait);
+
+	chan->common.device = &xscd->dma_device;
+	list_add_tail(&chan->common.device_node, &xscd->dma_device.channels);
+}
+
+/**
+ * xscd_dma_chan_remove - Per Channel remove function
+ * @chan: Driver specific DMA channel
+ */
+static void xscd_dma_chan_remove(struct xscd_dma_chan *chan)
+{
+	list_del(&chan->common.device_node);
+}
+
+/**
+ * xscd_dma_init - Initialize the SCD DMA engine
+ * @xscd: Pointer to the SCD device structure
+ *
+ * Return: '0' on success and failure value on error
+ */
+int xscd_dma_init(struct xscd_device *xscd)
+{
+	struct dma_device *ddev = &xscd->dma_device;
+	unsigned int chan_id;
+	int ret;
+
+	/* Initialize the DMA engine */
+	ddev->dev = xscd->dev;
+	dma_set_mask(xscd->dev, DMA_BIT_MASK(32));
+
+	INIT_LIST_HEAD(&ddev->channels);
+	dma_cap_set(DMA_SLAVE, ddev->cap_mask);
+	dma_cap_set(DMA_PRIVATE, ddev->cap_mask);
+	ddev->device_alloc_chan_resources = xscd_dma_alloc_chan_resources;
+	ddev->device_free_chan_resources = xscd_dma_free_chan_resources;
+	ddev->device_tx_status = xscd_dma_tx_status;
+	ddev->device_issue_pending = xscd_dma_issue_pending;
+	ddev->device_terminate_all = xscd_dma_terminate_all;
+	ddev->device_prep_interleaved_dma = xscd_dma_prep_interleaved;
+
+	for (chan_id = 0; chan_id < xscd->num_streams; chan_id++)
+		xscd_dma_chan_init(xscd, chan_id);
+
+	ret = dma_async_device_register(ddev);
+	if (ret) {
+		dev_err(xscd->dev, "failed to register the dma device\n");
+		goto error;
+	}
+
+	ret = of_dma_controller_register(xscd->dev->of_node,
+					 of_scdma_xilinx_xlate, xscd);
+	if (ret) {
+		dev_err(xscd->dev, "failed to register DMA to DT DMA helper\n");
+		goto error_of_dma;
+	}
+
+	dev_info(xscd->dev, "Xilinx Scene Change DMA is initialized!\n");
+	return 0;
+
+error_of_dma:
+	dma_async_device_unregister(ddev);
+
+error:
+	for (chan_id = 0; chan_id < xscd->num_streams; chan_id++)
+		xscd_dma_chan_remove(xscd->channels[chan_id]);
+
+	return ret;
+}
+
+/**
+ * xscd_dma_cleanup - Clean up the SCD DMA engine
+ * @xscd: Pointer to the SCD device structure
+ *
+ * This function is the counterpart of xscd_dma_init() and cleans up the
+ * resources related to the DMA engine.
+ */
+void xscd_dma_cleanup(struct xscd_device *xscd)
+{
+	dma_async_device_unregister(&xscd->dma_device);
+	of_dma_controller_free(xscd->dev->of_node);
+}
diff --git a/drivers/media/platform/xilinx/xilinx-scenechange.c b/drivers/media/platform/xilinx/xilinx-scenechange.c
new file mode 100644
index 000000000..38db9c7d3
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-scenechange.c
@@ -0,0 +1,195 @@
+//SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx Scene Change Detection driver
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Authors: Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>
+ *          Satish Kumar Nagireddy <satish.nagireddy.nagireddy@xilinx.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include "xilinx-scenechange.h"
+
+static irqreturn_t xscd_irq_handler(int irq, void *data)
+{
+	struct xscd_device *xscd = (struct xscd_device *)data;
+	u32 status;
+
+	status = xscd_read(xscd->iomem, XSCD_ISR_OFFSET);
+	if (!(status & XSCD_IE_AP_DONE))
+		return IRQ_NONE;
+
+	xscd_write(xscd->iomem, XSCD_ISR_OFFSET, XSCD_IE_AP_DONE);
+
+	if (xscd->memory_based)
+		xscd_dma_irq_handler(xscd);
+	else
+		xscd_chan_event_notify(&xscd->chans[0]);
+
+	return IRQ_HANDLED;
+}
+
+static int xscd_init_resources(struct xscd_device *xscd)
+{
+	struct platform_device *pdev = to_platform_device(xscd->dev);
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xscd->iomem = devm_ioremap_resource(xscd->dev, res);
+	if (IS_ERR(xscd->iomem))
+		return PTR_ERR(xscd->iomem);
+
+	xscd->irq = platform_get_irq(pdev, 0);
+	if (xscd->irq < 0) {
+		dev_err(xscd->dev, "No valid irq found\n");
+		return -EINVAL;
+	}
+
+	xscd->clk = devm_clk_get(xscd->dev, NULL);
+	if (IS_ERR(xscd->clk))
+		return PTR_ERR(xscd->clk);
+
+	clk_prepare_enable(xscd->clk);
+	return 0;
+}
+
+static int xscd_parse_of(struct xscd_device *xscd)
+{
+	struct device *dev = xscd->dev;
+	struct device_node *node = xscd->dev->of_node;
+	int ret;
+
+	xscd->memory_based = of_property_read_bool(node, "xlnx,memorybased");
+	xscd->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(xscd->rst_gpio)) {
+		if (PTR_ERR(xscd->rst_gpio) != -EPROBE_DEFER)
+			dev_err(dev, "Reset GPIO not setup in DT\n");
+
+		return PTR_ERR(xscd->rst_gpio);
+	}
+
+	ret = of_property_read_u32(node, "xlnx,numstreams",
+				   &xscd->num_streams);
+	if (ret < 0)
+		return ret;
+
+	if (!xscd->memory_based && xscd->num_streams != 1) {
+		dev_err(dev, "Stream-based mode only supports one stream\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xscd_probe(struct platform_device *pdev)
+{
+	struct xscd_device *xscd;
+	struct device_node *subdev_node;
+	unsigned int id;
+	int ret;
+
+	xscd = devm_kzalloc(&pdev->dev, sizeof(*xscd), GFP_KERNEL);
+	if (!xscd)
+		return -ENOMEM;
+
+	spin_lock_init(&xscd->lock);
+
+	xscd->dev = &pdev->dev;
+	platform_set_drvdata(pdev, xscd);
+
+	ret = xscd_parse_of(xscd);
+	if (ret < 0)
+		return ret;
+
+	ret = xscd_init_resources(xscd);
+	if (ret < 0)
+		return ret;
+
+	/* Reset Scene Change Detection IP */
+	gpiod_set_value_cansleep(xscd->rst_gpio, XSCD_RESET_ASSERT);
+	gpiod_set_value_cansleep(xscd->rst_gpio, XSCD_RESET_DEASSERT);
+
+	/* Initialize the channels. */
+	xscd->chans = devm_kcalloc(xscd->dev, xscd->num_streams,
+				   sizeof(*xscd->chans), GFP_KERNEL);
+	if (!xscd->chans)
+		return -ENOMEM;
+
+	id = 0;
+	for_each_child_of_node(xscd->dev->of_node, subdev_node) {
+		if (id >= xscd->num_streams) {
+			dev_warn(&pdev->dev,
+				 "Too many channels, limiting to %u\n",
+				 xscd->num_streams);
+			of_node_put(subdev_node);
+			break;
+		}
+
+		ret = xscd_chan_init(xscd, id, subdev_node);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to initialize channel %u\n",
+				id);
+			return ret;
+		}
+
+		id++;
+	}
+
+	/* Initialize the DMA engine. */
+	ret = xscd_dma_init(xscd);
+	if (ret < 0)
+		dev_err(&pdev->dev, "Failed to initialize the DMA\n");
+
+	ret = devm_request_irq(xscd->dev, xscd->irq, xscd_irq_handler,
+			       IRQF_SHARED, dev_name(xscd->dev), xscd);
+	if (ret < 0)
+		dev_err(&pdev->dev, "Failed to request IRQ\n");
+
+	dev_info(xscd->dev, "scene change detect device found!\n");
+	return 0;
+}
+
+static int xscd_remove(struct platform_device *pdev)
+{
+	struct xscd_device *xscd = platform_get_drvdata(pdev);
+	struct device_node *subdev_node;
+	unsigned int id = 0;
+
+	for_each_child_of_node(xscd->dev->of_node, subdev_node) {
+		xscd_chan_cleanup(xscd, id, subdev_node);
+		id++;
+	}
+
+	xscd_dma_cleanup(xscd);
+	clk_disable_unprepare(xscd->clk);
+
+	return 0;
+}
+
+static const struct of_device_id xscd_of_id_table[] = {
+	{ .compatible = "xlnx,v-scd" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xscd_of_id_table);
+
+static struct platform_driver xscd_driver = {
+	.driver = {
+		.name		= "xilinx-scd",
+		.of_match_table	= xscd_of_id_table,
+	},
+	.probe			= xscd_probe,
+	.remove			= xscd_remove,
+};
+
+module_platform_driver(xscd_driver);
+
+MODULE_AUTHOR("Xilinx Inc.");
+MODULE_DESCRIPTION("Xilinx Scene Change Detection");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-scenechange.h b/drivers/media/platform/xilinx/xilinx-scenechange.h
new file mode 100644
index 000000000..5cc9ce54b
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-scenechange.h
@@ -0,0 +1,245 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx Scene Change Detection driver
+ *
+ * Copyright (C) 2018 Xilinx, Inc.
+ *
+ * Authors: Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>
+ *          Satish Kumar Nagireddy <satish.nagireddy.nagireddy@xilinx.com>
+ */
+
+#ifndef _XILINX_SCENECHANGE_H_
+#define _XILINX_SCENECHANGE_H_
+
+#include <linux/bitops.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+struct clk;
+struct device;
+struct device_node;
+struct gpio_desc;
+
+/* Register/Descriptor Offsets */
+#define XSCD_CTRL_OFFSET		0x000
+#define XSCD_CTRL_AP_START		BIT(0)
+#define XSCD_CTRL_AP_DONE		BIT(1)
+#define XSCD_CTRL_AP_IDLE		BIT(2)
+#define XSCD_CTRL_AP_READY		BIT(3)
+#define XSCD_CTRL_AUTO_RESTART		BIT(7)
+
+#define XSCD_GIE_OFFSET			0x004
+#define XSCD_GIE_EN			BIT(0)
+
+#define XSCD_IE_OFFSET			0x008
+#define XSCD_IE_AP_DONE			BIT(0)
+#define XSCD_IE_AP_READY		BIT(1)
+
+#define XSCD_ISR_OFFSET			0x00c
+#define XSCD_WIDTH_OFFSET		0x010
+#define XSCD_HEIGHT_OFFSET		0x018
+#define XSCD_STRIDE_OFFSET		0x020
+#define XSCD_VID_FMT_OFFSET		0x028
+#define XSCD_VID_FMT_RGB		0
+#define XSCD_VID_FMT_YUV_444		1
+#define XSCD_VID_FMT_YUV_422		2
+#define XSCD_VID_FMT_YUV_420		3
+#define XSCD_VID_FMT_Y8			24
+#define XSCD_VID_FMT_Y10		25
+
+#define XSCD_SUBSAMPLE_OFFSET		0x030
+#define XSCD_SAD_OFFSET			0x038
+#define XSCD_ADDR_OFFSET		0x040
+#define XSCD_CHAN_OFFSET		0x100
+#define XSCD_CHAN_EN_OFFSET		0x780
+
+#define XSCD_MAX_CHANNELS		8
+
+#define XSCD_RESET_DEASSERT		(0)
+#define XSCD_RESET_ASSERT		(1)
+
+/****************************** PROTOTYPES ************************************/
+
+struct xscd_device;
+
+/**
+ * struct xscd_dma_desc - DMA channel
+ * @luma_plane_addr: Luma plane buffer address
+ * @vsize: width of the luma frame
+ * @hsize: height of the luma frame
+ * @stride: stride of the luma frame
+ */
+struct xscd_dma_desc {
+	dma_addr_t luma_plane_addr;
+	u32 vsize;
+	u32 hsize;
+	u32 stride;
+};
+
+/**
+ * struct xscd_dma_tx_descriptor - Per Transaction structure
+ * @async_tx: Async transaction descriptor
+ * @sw: Software Descriptor
+ * @node: Node in the channel descriptor list
+ */
+struct xscd_dma_tx_descriptor {
+	struct dma_async_tx_descriptor async_tx;
+	struct xscd_dma_desc sw;
+	struct list_head node;
+};
+
+static inline struct xscd_dma_tx_descriptor *
+to_xscd_dma_tx_descriptor(struct dma_async_tx_descriptor *tx)
+{
+	return container_of(tx, struct xscd_dma_tx_descriptor, async_tx);
+}
+
+/**
+ * struct xscd_dma_chan - DMA Channel structure
+ * @xscd: SCD device
+ * @iomem: I/O memory address of the channel registers
+ * @id: scene change channel ID
+ * @common: DMA common channel
+ * @tasklet: Cleanup work after irq
+ * @lock: Protects pending_list, done_list, active_desc, enabled and running
+ * @pending_list: Descriptors waiting
+ * @done_list: Complete descriptors
+ * @active_desc: Currently active buffer being read/written to
+ * @enabled: Channel is enabled
+ * @running: Channel is running
+ * @wait: Wait queue to wait for the channel to stop
+ */
+struct xscd_dma_chan {
+	struct xscd_device *xscd;
+	void __iomem *iomem;
+	unsigned int id;
+
+	struct dma_chan common;
+	struct tasklet_struct tasklet;
+
+	spinlock_t lock;
+	struct list_head pending_list;
+	struct list_head done_list;
+	struct xscd_dma_tx_descriptor *active_desc;
+	unsigned int enabled;
+	unsigned int running;
+	wait_queue_head_t wait;
+};
+
+static inline struct xscd_dma_chan *to_xscd_dma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct xscd_dma_chan, common);
+}
+
+/**
+ * struct xscd_chan - Video Stream structure
+ * @id: scene change channel ID
+ * @threshold: scene change detection threshold
+ * @iomem: I/O memory address of the channel registers
+ * @xscd: SCD device
+ * @subdev: V4L2 subdevice
+ * @ctrl_handler: V4L2 control handler
+ * @pads: media pads
+ * @format: active V4L2 media bus format for the pad
+ * @event: scene change event
+ * @dmachan: dma channel part of the scenechange stream
+ * @lock: lock to protect active stream count variable
+ */
+struct xscd_chan {
+	int id;
+	int threshold;
+	void __iomem *iomem;
+	struct xscd_device *xscd;
+	struct v4l2_subdev subdev;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_event event;
+	struct xscd_dma_chan dmachan;
+
+	/* Lock to protect active stream count */
+	struct mutex lock;
+};
+
+static inline struct xscd_chan *to_xscd_chan(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xscd_chan, subdev);
+}
+
+/**
+ * struct xscd_device - Xilinx Scene Change Detection device structure
+ * @dev: (OF) device
+ * @iomem: device I/O register space remapped to kernel virtual memory
+ * @rst_gpio: reset GPIO
+ * @clk: video core clock
+ * @irq: Device IRQ
+ * @memory_based: Flag to identify memory based mode
+ * @num_streams: Number of streams in the design
+ * @chans: video stream instances
+ * @dma_device: DMA device structure
+ * @channels: DMA channels
+ * @lock: Protects the running field
+ * @running: True when the SCD core is running
+ */
+struct xscd_device {
+	struct device *dev;
+	void __iomem *iomem;
+	struct gpio_desc *rst_gpio;
+	struct clk *clk;
+	int irq;
+
+	u8 memory_based;
+	int num_streams;
+
+	struct xscd_chan *chans;
+
+	struct dma_device dma_device;
+	struct xscd_dma_chan *channels[XSCD_MAX_CHANNELS];
+
+	/* This lock is to protect the running field */
+	spinlock_t lock;
+	u8 running;
+};
+
+/*
+ * Register related operations
+ */
+static inline u32 xscd_read(void __iomem *iomem, u32 addr)
+{
+	return ioread32(iomem + addr);
+}
+
+static inline void xscd_write(void __iomem *iomem, u32 addr, u32 value)
+{
+	iowrite32(value, iomem + addr);
+}
+
+static inline void xscd_clr(void __iomem *iomem, u32 addr, u32 clr)
+{
+	xscd_write(iomem, addr, xscd_read(iomem, addr) & ~clr);
+}
+
+static inline void xscd_set(void __iomem *iomem, u32 addr, u32 set)
+{
+	xscd_write(iomem, addr, xscd_read(iomem, addr) | set);
+}
+
+void xscd_dma_enable_channel(struct xscd_dma_chan *chan, bool enable);
+void xscd_dma_irq_handler(struct xscd_device *xscd);
+int xscd_dma_init(struct xscd_device *xscd);
+void xscd_dma_cleanup(struct xscd_device *xscd);
+
+void xscd_chan_event_notify(struct xscd_chan *chan);
+int xscd_chan_init(struct xscd_device *xscd, unsigned int chan_id,
+		   struct device_node *node);
+void xscd_chan_cleanup(struct xscd_device *xscd, unsigned int chan_id,
+		       struct device_node *node);
+#endif
diff --git a/drivers/media/platform/xilinx/xilinx-sdirxss.c b/drivers/media/platform/xilinx/xilinx-sdirxss.c
new file mode 100644
index 000000000..9315659c7
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-sdirxss.c
@@ -0,0 +1,2758 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx SDI Rx Subsystem
+ *
+ * Copyright (C) 2017 Xilinx, Inc.
+ *
+ * Contacts: Vishal Sagar <vsagar@xilinx.com>
+ *
+ */
+
+#include <dt-bindings/media/xilinx-vip.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/compiler.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/types.h>
+#include <linux/v4l2-dv-timings.h>
+#include <linux/v4l2-subdev.h>
+#include <linux/xilinx-sdirxss.h>
+#include <linux/xilinx-v4l2-controls.h>
+#include <media/hdr-ctrls.h>
+#include <media/media-entity.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include "xilinx-vip.h"
+
+/*
+ * SDI Rx register map, bitmask and offsets
+ */
+#define XSDIRX_RST_CTRL_REG		0x00
+#define XSDIRX_MDL_CTRL_REG		0x04
+#define XSDIRX_GLBL_IER_REG		0x0C
+#define XSDIRX_ISR_REG			0x10
+#define XSDIRX_IER_REG			0x14
+#define XSDIRX_ST352_VALID_REG		0x18
+#define XSDIRX_ST352_DS1_REG		0x1C
+#define XSDIRX_ST352_DS3_REG		0x20
+#define XSDIRX_ST352_DS5_REG		0x24
+#define XSDIRX_ST352_DS7_REG		0x28
+#define XSDIRX_ST352_DS9_REG		0x2C
+#define XSDIRX_ST352_DS11_REG		0x30
+#define XSDIRX_ST352_DS13_REG		0x34
+#define XSDIRX_ST352_DS15_REG		0x38
+#define XSDIRX_VERSION_REG		0x3C
+#define XSDIRX_SS_CONFIG_REG		0x40
+#define XSDIRX_MODE_DET_STAT_REG	0x44
+#define XSDIRX_TS_DET_STAT_REG		0x48
+#define XSDIRX_EDH_STAT_REG		0x4C
+#define XSDIRX_EDH_ERRCNT_EN_REG	0x50
+#define XSDIRX_EDH_ERRCNT_REG		0x54
+#define XSDIRX_CRC_ERRCNT_REG		0x58
+#define XSDIRX_VID_LOCK_WINDOW_REG	0x5C
+#define XSDIRX_SB_RX_STS_REG		0x60
+
+#define XSDIRX_RST_CTRL_SS_EN_MASK			BIT(0)
+#define XSDIRX_RST_CTRL_SRST_MASK			BIT(1)
+#define XSDIRX_RST_CTRL_RST_CRC_ERRCNT_MASK		BIT(2)
+#define XSDIRX_RST_CTRL_RST_EDH_ERRCNT_MASK		BIT(3)
+#define XSDIRX_RST_CTRL_SDIRX_BRIDGE_ENB_MASK		BIT(8)
+#define XSDIRX_RST_CTRL_VIDIN_AXI4S_MOD_ENB_MASK	BIT(9)
+#define XSDIRX_RST_CTRL_BRIDGE_CH_FMT_OFFSET		10
+#define XSDIRX_RST_CTRL_BRIDGE_CH_FMT_MASK		GENMASK(12, 10)
+#define XSDIRX_RST_CTRL_BRIDGE_CH_FMT_YUV444		1
+
+#define XSDIRX_MDL_CTRL_FRM_EN_MASK		BIT(4)
+#define XSDIRX_MDL_CTRL_MODE_DET_EN_MASK	BIT(5)
+#define XSDIRX_MDL_CTRL_VPID_MASK		BIT(6)
+#define XSDIRX_MDL_CTRL_MODE_HD_EN_MASK		BIT(8)
+#define XSDIRX_MDL_CTRL_MODE_SD_EN_MASK		BIT(9)
+#define XSDIRX_MDL_CTRL_MODE_3G_EN_MASK		BIT(10)
+#define XSDIRX_MDL_CTRL_MODE_6G_EN_MASK		BIT(11)
+#define XSDIRX_MDL_CTRL_MODE_12GI_EN_MASK	BIT(12)
+#define XSDIRX_MDL_CTRL_MODE_12GF_EN_MASK	BIT(13)
+#define XSDIRX_MDL_CTRL_MODE_AUTO_DET_MASK	GENMASK(13, 8)
+
+#define XSDIRX_MDL_CTRL_FORCED_MODE_OFFSET	16
+#define XSDIRX_MDL_CTRL_FORCED_MODE_MASK	GENMASK(18, 16)
+
+#define XSDIRX_GLBL_INTR_EN_MASK	BIT(0)
+
+#define XSDIRX_INTR_VIDLOCK_MASK	BIT(0)
+#define XSDIRX_INTR_VIDUNLOCK_MASK	BIT(1)
+#define XSDIRX_INTR_VSYNC_MASK		BIT(2)
+#define XSDIRX_INTR_OVERFLOW_MASK	BIT(9)
+#define XSDIRX_INTR_UNDERFLOW_MASK	BIT(10)
+
+#define XSDIRX_INTR_ALL_MASK	(XSDIRX_INTR_VIDLOCK_MASK |\
+				XSDIRX_INTR_VIDUNLOCK_MASK |\
+				XSDIRX_INTR_VSYNC_MASK |\
+				XSDIRX_INTR_OVERFLOW_MASK |\
+				XSDIRX_INTR_UNDERFLOW_MASK)
+
+#define XSDIRX_ST352_VALID_DS1_MASK	BIT(0)
+#define XSDIRX_ST352_VALID_DS3_MASK	BIT(1)
+#define XSDIRX_ST352_VALID_DS5_MASK	BIT(2)
+#define XSDIRX_ST352_VALID_DS7_MASK	BIT(3)
+#define XSDIRX_ST352_VALID_DS9_MASK	BIT(4)
+#define XSDIRX_ST352_VALID_DS11_MASK	BIT(5)
+#define XSDIRX_ST352_VALID_DS13_MASK	BIT(6)
+#define XSDIRX_ST352_VALID_DS15_MASK	BIT(7)
+
+#define XSDIRX_MODE_DET_STAT_RX_MODE_MASK	GENMASK(2, 0)
+#define XSDIRX_MODE_DET_STAT_MODE_LOCK_MASK	BIT(3)
+#define XSDIRX_MODE_DET_STAT_ACT_STREAM_MASK	GENMASK(6, 4)
+#define XSDIRX_MODE_DET_STAT_ACT_STREAM_OFFSET	4
+#define XSDIRX_MODE_DET_STAT_LVLB_3G_MASK	BIT(7)
+
+#define XSDIRX_ACTIVE_STREAMS_1		0x0
+#define XSDIRX_ACTIVE_STREAMS_2		0x1
+#define XSDIRX_ACTIVE_STREAMS_4		0x2
+#define XSDIRX_ACTIVE_STREAMS_8		0x3
+#define XSDIRX_ACTIVE_STREAMS_16	0x4
+
+#define XSDIRX_TS_DET_STAT_LOCKED_MASK		BIT(0)
+#define XSDIRX_TS_DET_STAT_SCAN_MASK		BIT(1)
+#define XSDIRX_TS_DET_STAT_SCAN_OFFSET		(1)
+#define XSDIRX_TS_DET_STAT_FAMILY_MASK		GENMASK(7, 4)
+#define XSDIRX_TS_DET_STAT_FAMILY_OFFSET	(4)
+#define XSDIRX_TS_DET_STAT_RATE_MASK		GENMASK(11, 8)
+#define XSDIRX_TS_DET_STAT_RATE_OFFSET		(8)
+
+#define XSDIRX_TS_DET_STAT_RATE_NONE		0x0
+#define XSDIRX_TS_DET_STAT_RATE_96HZ		0x1
+#define XSDIRX_TS_DET_STAT_RATE_23_98HZ		0x2
+#define XSDIRX_TS_DET_STAT_RATE_24HZ		0x3
+#define XSDIRX_TS_DET_STAT_RATE_47_95HZ		0x4
+#define XSDIRX_TS_DET_STAT_RATE_25HZ		0x5
+#define XSDIRX_TS_DET_STAT_RATE_29_97HZ		0x6
+#define XSDIRX_TS_DET_STAT_RATE_30HZ		0x7
+#define XSDIRX_TS_DET_STAT_RATE_48HZ		0x8
+#define XSDIRX_TS_DET_STAT_RATE_50HZ		0x9
+#define XSDIRX_TS_DET_STAT_RATE_59_94HZ		0xA
+#define XSDIRX_TS_DET_STAT_RATE_60HZ		0xB
+#define XSDIRX_TS_DET_STAT_RATE_95_90HZ		0xC
+#define XSDIRX_TS_DET_STAT_RATE_100HZ		0xD
+#define XSDIRX_TS_DET_STAT_RATE_120HZ		0xE
+#define XSDIRX_TS_DET_STAT_RATE_119_88HZ	0xF
+
+#define XSDIRX_EDH_STAT_EDH_AP_MASK	BIT(0)
+#define XSDIRX_EDH_STAT_EDH_FF_MASK	BIT(1)
+#define XSDIRX_EDH_STAT_EDH_ANC_MASK	BIT(2)
+#define XSDIRX_EDH_STAT_AP_FLAG_MASK	GENMASK(8, 4)
+#define XSDIRX_EDH_STAT_FF_FLAG_MASK	GENMASK(13, 9)
+#define XSDIRX_EDH_STAT_ANC_FLAG_MASK	GENMASK(18, 14)
+#define XSDIRX_EDH_STAT_PKT_FLAG_MASK	GENMASK(22, 19)
+
+#define XSDIRX_EDH_ERRCNT_COUNT_MASK	GENMASK(15, 0)
+
+#define XSDIRX_CRC_ERRCNT_COUNT_MASK	GENMASK(31, 16)
+#define XSDIRX_CRC_ERRCNT_DS_CRC_MASK	GENMASK(15, 0)
+
+#define XSDIRX_VERSION_REV_MASK		GENMASK(7, 0)
+#define XSDIRX_VERSION_PATCHID_MASK	GENMASK(11, 8)
+#define XSDIRX_VERSION_VER_REV_MASK	GENMASK(15, 12)
+#define XSDIRX_VERSION_VER_MIN_MASK	GENMASK(23, 16)
+#define XSDIRX_VERSION_VER_MAJ_MASK	GENMASK(31, 24)
+
+#define XSDIRX_SS_CONFIG_EDH_INCLUDED_MASK		BIT(1)
+
+#define XSDIRX_STAT_SB_RX_TDATA_CHANGE_DONE_MASK	BIT(0)
+#define XSDIRX_STAT_SB_RX_TDATA_CHANGE_FAIL_MASK	BIT(1)
+#define XSDIRX_STAT_SB_RX_TDATA_GT_RESETDONE_MASK	BIT(2)
+#define XSDIRX_STAT_SB_RX_TDATA_GT_BITRATE_MASK		BIT(3)
+
+#define XSDIRX_DEFAULT_WIDTH	(1920)
+#define XSDIRX_DEFAULT_HEIGHT	(1080)
+
+#define XSDIRX_MAX_STR_LENGTH	16
+
+#define XSDIRXSS_SDI_STD_3G		0
+#define XSDIRXSS_SDI_STD_6G		1
+#define XSDIRXSS_SDI_STD_12G_8DS	2
+
+#define XSDIRX_DEFAULT_VIDEO_LOCK_WINDOW	0x3000
+
+#define XSDIRX_MODE_HD_MASK	0x0
+#define XSDIRX_MODE_SD_MASK	0x1
+#define XSDIRX_MODE_3G_MASK	0x2
+#define XSDIRX_MODE_6G_MASK	0x4
+#define XSDIRX_MODE_12GI_MASK	0x5
+#define XSDIRX_MODE_12GF_MASK	0x6
+
+/* Maximum number of events per file handle. */
+#define XSDIRX_MAX_EVENTS	(128)
+
+/* ST352 related macros */
+#define XST352_PAYLOAD_BYTE_MASK	0xFF
+#define XST352_PAYLOAD_BYTE1_SHIFT	0
+#define XST352_PAYLOAD_BYTE2_SHIFT	8
+#define XST352_PAYLOAD_BYTE3_SHIFT	16
+#define XST352_PAYLOAD_BYTE4_SHIFT	24
+
+#define XST352_BYTE1_ST292_1x720L_1_5G		0x84
+#define XST352_BYTE1_ST292_1x1080L_1_5G		0x85
+#define XST352_BYTE1_ST425_2008_750L_3GB	0x88
+#define XST352_BYTE1_ST425_2008_1125L_3GA	0x89
+#define XST352_BYTE1_ST372_DL_3GB		0x8A
+#define XST352_BYTE1_ST372_2x720L_3GB		0x8B
+#define XST352_BYTE1_ST372_2x1080L_3GB		0x8C
+#define XST352_BYTE1_ST2081_10_2160L_6G		0xC0
+#define XST352_BYTE1_ST2081_10_2_1080L_6G	0xC1
+#define XST352_BYTE1_ST2081_10_DL_2160L_6G	0xC2
+#define XST352_BYTE1_ST2082_10_2160L_12G	0xCE
+#define XST352_BYTE1_ST2082_10_2_1080L_12G	0xCF
+
+#define XST352_BYTE2_TS_TYPE_MASK		BIT(15)
+#define XST352_BYTE2_TS_TYPE_OFFSET		15
+#define XST352_BYTE2_PIC_TYPE_MASK		BIT(14)
+#define XST352_BYTE2_PIC_TYPE_OFFSET		14
+#define XST352_BYTE2_TS_PIC_TYPE_INTERLACED	0
+#define XST352_BYTE2_TS_PIC_TYPE_PROGRESSIVE	1
+
+#define XST352_BYTE2_FPS_MASK			0xF
+#define XST352_BYTE2_FPS_SHIFT			8
+#define XST352_BYTE2_FPS_96F			0x1
+#define XST352_BYTE2_FPS_24F			0x2
+#define XST352_BYTE2_FPS_24			0x3
+#define XST352_BYTE2_FPS_48F			0x4
+#define XST352_BYTE2_FPS_25			0x5
+#define XST352_BYTE2_FPS_30F			0x6
+#define XST352_BYTE2_FPS_30			0x7
+#define XST352_BYTE2_FPS_48			0x8
+#define XST352_BYTE2_FPS_50			0x9
+#define XST352_BYTE2_FPS_60F			0xA
+#define XST352_BYTE2_FPS_60			0xB
+/* Table 4 ST 2081-10:2015 */
+#define XST352_BYTE2_FPS_96			0xC
+#define XST352_BYTE2_FPS_100			0xD
+#define XST352_BYTE2_FPS_120			0xE
+#define XST352_BYTE2_FPS_120F			0xF
+
+/* Electro Optical Transfer Function Byte 2 bit[5:4] */
+#define XST352_BYTE2_EOTF_MASK			GENMASK(13, 12)
+#define XST352_BYTE2_EOTF_OFFSET		12
+#define XST352_BYTE2_EOTF_SDRTV			0x0
+#define XST352_BYTE2_EOTF_HLG			0x1
+#define XST352_BYTE2_EOTF_SMPTE2084		0x2
+
+#define XST352_BYTE2_COLORIMETRY_MASK		GENMASK(21, 20)
+#define XST352_BYTE2_COLORIMETRY_OFFSET		20
+#define XST352_BYTE2_COLORIMETRY_BT709		0
+#define XST352_BYTE2_COLORIMETRY_VANC		1
+#define XST352_BYTE2_COLORIMETRY_UHDTV		2
+#define XST352_BYTE2_COLORIMETRY_UNKNOWN	3
+
+#define XST352_BYTE3_ACT_LUMA_COUNT_MASK	BIT(22)
+#define XST352_BYTE3_ACT_LUMA_COUNT_OFFSET	22
+
+#define XST352_BYTE3_COLOR_FORMAT_MASK		GENMASK(19, 16)
+#define XST352_BYTE3_COLOR_FORMAT_OFFSET	16
+#define XST352_BYTE3_COLOR_FORMAT_422		0x0
+#define XST352_BYTE3_COLOR_FORMAT_YUV444	0x1
+#define XST352_BYTE3_COLOR_FORMAT_420		0x3
+#define XST352_BYTE3_COLOR_FORMAT_GBR		0x2
+
+#define XST352_BYTE4_BIT_DEPTH_MASK		GENMASK(25, 24)
+#define XST352_BYTE4_BIT_DEPTH_OFFSET		24
+#define XST352_BYTE4_BIT_DEPTH_10		0x1
+#define XST352_BYTE4_BIT_DEPTH_12		0x2
+
+/* Refer Table 3 ST2082-10:2018 */
+#define XST352_BYTE4_LUM_COL_DIFF_MASK		BIT(28)
+
+#define CLK_INT		148500000UL
+
+/**
+ * enum sdi_family_enc - SDI Transport Video Format Detected with Active Pixels
+ * @XSDIRX_SMPTE_ST_274: SMPTE ST 274 detected with AP 1920x1080
+ * @XSDIRX_SMPTE_ST_296: SMPTE ST 296 detected with AP 1280x720
+ * @XSDIRX_SMPTE_ST_2048_2: SMPTE ST 2048-2 detected with AP 2048x1080
+ * @XSDIRX_SMPTE_ST_295: SMPTE ST 295 detected with AP 1920x1080
+ * @XSDIRX_NTSC: NTSC encoding detected with AP 720x486
+ * @XSDIRX_PAL: PAL encoding detected with AP 720x576
+ * @XSDIRX_TS_UNKNOWN: Unknown SMPTE Transport family type
+ */
+enum sdi_family_enc {
+	XSDIRX_SMPTE_ST_274	= 0,
+	XSDIRX_SMPTE_ST_296	= 1,
+	XSDIRX_SMPTE_ST_2048_2	= 2,
+	XSDIRX_SMPTE_ST_295	= 3,
+	XSDIRX_NTSC		= 8,
+	XSDIRX_PAL		= 9,
+	XSDIRX_TS_UNKNOWN	= 15
+};
+
+/**
+ * struct xsdirxss_core - Core configuration SDI Rx Subsystem device structure
+ * @dev: Platform structure
+ * @iomem: Base address of subsystem
+ * @irq: requested irq number
+ * @include_edh: EDH processor presence
+ * @mode: 3G/6G/12G mode
+ * @clks: array of clocks
+ * @num_clks: number of clocks
+ * @rst_gt_gpio: reset gt gpio (fmc init done)
+ * @rst_picxo_gpio: reset picxo core
+ * @bpc: Bits per component, can be 10 or 12
+ */
+struct xsdirxss_core {
+	struct device *dev;
+	void __iomem *iomem;
+	int irq;
+	bool include_edh;
+	int mode;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	struct gpio_desc *rst_gt_gpio;
+	struct gpio_desc *rst_picxo_gpio;
+	u32 bpc;
+};
+
+/**
+ * struct xsdirxss_state - SDI Rx Subsystem device structure
+ * @core: Core structure for MIPI SDI Rx Subsystem
+ * @subdev: The v4l2 subdev structure
+ * @ctrl_handler: control handler
+ * @event: Holds the video unlock event
+ * @format: Active V4L2 format on source pad
+ * @default_format: default V4L2 media bus format
+ * @frame_interval: Captures the frame rate
+ * @vip_format: format information corresponding to the active format
+ * @pad: source media pad
+ * @static_hdr: static hdr payload
+ * @prev_payload: Previous ST352 payload
+ * @vidlockwin: Video lock window value set by control
+ * @edhmask: EDH mask set by control
+ * @searchmask: Search mask set by control
+ * @streaming: Flag for storing streaming state
+ * @s_stream: Flag for storing streaming state
+ * @vidlocked: Flag indicating SDI Rx has locked onto video stream
+ * @ts_is_interlaced: Flag indicating Transport Stream is interlaced.
+ * @framer_enable: Flag for framer enabled or not set by control
+ *
+ * This structure contains the device driver related parameters
+ */
+struct xsdirxss_state {
+	struct xsdirxss_core core;
+	struct v4l2_subdev subdev;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_event event;
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_mbus_framefmt default_format;
+	struct v4l2_fract frame_interval;
+	const struct xvip_video_format *vip_format;
+	struct media_pad pad;
+	struct v4l2_hdr10_payload static_hdr;
+	u32 prev_payload;
+	u32 vidlockwin;
+	u32 edhmask;
+	u16 searchmask;
+	bool streaming;
+	bool s_stream;
+	bool vidlocked;
+	bool ts_is_interlaced;
+	bool framer_enable;
+};
+
+/* List of clocks required by UHD-SDI Rx subsystem */
+static const char * const xsdirxss_clks[] = {
+	"s_axi_aclk", "sdi_rx_clk", "video_out_clk",
+};
+
+static const u32 xsdirxss_10bpc_mbus_fmts[] = {
+	MEDIA_BUS_FMT_UYVY10_1X20,
+	MEDIA_BUS_FMT_VYYUYY10_4X20,
+	MEDIA_BUS_FMT_VUY10_1X30,
+	MEDIA_BUS_FMT_RBG101010_1X30,
+};
+
+static const u32 xsdirxss_12bpc_mbus_fmts[] = {
+	MEDIA_BUS_FMT_UYVY12_1X24,
+	MEDIA_BUS_FMT_UYYVYY12_4X24,
+	MEDIA_BUS_FMT_VUY12_1X36,
+	MEDIA_BUS_FMT_RBG121212_1X36,
+};
+
+#define XLNX_V4L2_DV_BT_2048X1080P24 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 510, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P25 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 400, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P30 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 66, 20, 66, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080I48 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 1, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 329, 44, 329, 2, 5, 15, 3, 5, 15, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080I50 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 1, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 274, 44, 274, 2, 5, 15, 3, 5, 15, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080I60 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 1, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		74250000, 66, 20, 66, 2, 5, 15, 3, 5, 15, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_1920X1080P48 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(1920, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 638, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P48 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 510, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P50 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 400, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P60 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 88, 44, 20, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_3840X2160P48 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(3840, 2160, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		594000000, 1276, 88, 296, 8, 10, 72, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_4096X2160P48 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(4096, 2160, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		594000000, 1020, 88, 296, 8, 10, 72, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_1920X1080I48 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(1920, 1080, 1, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		148500000, 371, 88, 371, 2, 5, 15, 3, 5, 15, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_1920X1080P96 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(1920, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		297000000, 638, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_1920X1080P100 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(1920, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		297000000, 528, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_1920X1080P120 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(1920, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		297000000, 88, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P96 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		297000000, 510, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P100 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		297000000, 400, 44, 148, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+#define XLNX_V4L2_DV_BT_2048X1080P120 { \
+	.type = V4L2_DV_BT_656_1120, \
+	V4L2_INIT_BT_TIMINGS(2048, 1080, 0, \
+		V4L2_DV_HSYNC_POS_POL | V4L2_DV_VSYNC_POS_POL, \
+		297000000, 88, 44, 20, 4, 5, 36, 0, 0, 0, \
+		V4L2_DV_BT_STD_SDI) \
+}
+
+static const struct v4l2_dv_timings fmt_cap[] = {
+	V4L2_DV_BT_SDI_720X487I60,
+	V4L2_DV_BT_CEA_720X576I50,
+	V4L2_DV_BT_CEA_1280X720P24,
+	V4L2_DV_BT_CEA_1280X720P25,
+	V4L2_DV_BT_CEA_1280X720P30,
+	V4L2_DV_BT_CEA_1280X720P50,
+	V4L2_DV_BT_CEA_1280X720P60,
+	V4L2_DV_BT_CEA_1920X1080P24,
+	V4L2_DV_BT_CEA_1920X1080P30,
+	V4L2_DV_BT_CEA_1920X1080I50,
+	V4L2_DV_BT_CEA_1920X1080I60,
+	V4L2_DV_BT_CEA_1920X1080P50,
+	V4L2_DV_BT_CEA_1920X1080P60,
+	V4L2_DV_BT_CEA_3840X2160P24,
+	V4L2_DV_BT_CEA_3840X2160P30,
+	V4L2_DV_BT_CEA_3840X2160P50,
+	V4L2_DV_BT_CEA_3840X2160P60,
+	V4L2_DV_BT_CEA_4096X2160P24,
+	V4L2_DV_BT_CEA_4096X2160P25,
+	V4L2_DV_BT_CEA_4096X2160P30,
+	V4L2_DV_BT_CEA_4096X2160P50,
+	V4L2_DV_BT_CEA_4096X2160P60,
+
+	XLNX_V4L2_DV_BT_2048X1080P24,
+	XLNX_V4L2_DV_BT_2048X1080P25,
+	XLNX_V4L2_DV_BT_2048X1080P30,
+	XLNX_V4L2_DV_BT_2048X1080I48,
+	XLNX_V4L2_DV_BT_2048X1080I50,
+	XLNX_V4L2_DV_BT_2048X1080I60,
+	XLNX_V4L2_DV_BT_2048X1080P48,
+	XLNX_V4L2_DV_BT_2048X1080P50,
+	XLNX_V4L2_DV_BT_2048X1080P60,
+	XLNX_V4L2_DV_BT_1920X1080P48,
+	XLNX_V4L2_DV_BT_1920X1080I48,
+	XLNX_V4L2_DV_BT_3840X2160P48,
+	XLNX_V4L2_DV_BT_4096X2160P48,
+
+	/* HFR */
+	XLNX_V4L2_DV_BT_1920X1080P96,
+	XLNX_V4L2_DV_BT_1920X1080P100,
+	XLNX_V4L2_DV_BT_1920X1080P120,
+	XLNX_V4L2_DV_BT_2048X1080P96,
+	XLNX_V4L2_DV_BT_2048X1080P100,
+	XLNX_V4L2_DV_BT_2048X1080P120,
+};
+
+struct xsdirxss_dv_map {
+	u32 width;
+	u32 height;
+	u32 fps;
+	struct v4l2_dv_timings format;
+};
+
+static const struct xsdirxss_dv_map xsdirxss_dv_timings[] = {
+	/* SD - 720x487i60 */
+	{ 720, 243, 30, V4L2_DV_BT_SDI_720X487I60 },
+	/* SD - 720x576i50 */
+	{ 720, 288, 25, V4L2_DV_BT_CEA_720X576I50 },
+	/* HD - 1280x720p23.98 */
+	/* HD - 1280x720p24 */
+	{ 1280, 720, 24, V4L2_DV_BT_CEA_1280X720P24 },
+	/* HD - 1280x720p25 */
+	{ 1280, 720, 25, V4L2_DV_BT_CEA_1280X720P25 },
+	/* HD - 1280x720p29.97 */
+	/* HD - 1280x720p30 */
+	{ 1280, 720, 30, V4L2_DV_BT_CEA_1280X720P30 },
+	/* HD - 1280x720p50 */
+	{ 1280, 720, 50, V4L2_DV_BT_CEA_1280X720P50 },
+	/* HD - 1280x720p59.94 */
+	/* HD - 1280x720p60 */
+	{ 1280, 720, 60, V4L2_DV_BT_CEA_1280X720P60 },
+	/* HD - 1920x1080p23.98 */
+	/* HD - 1920x1080p24 */
+	{ 1920, 1080, 24, V4L2_DV_BT_CEA_1920X1080P24 },
+	/* HD - 1920x1080p25 */
+	{ 1920, 1080, 25, V4L2_DV_BT_CEA_1920X1080P25 },
+	/* HD - 1920x1080p29.97 */
+	/* HD - 1920x1080p30 */
+	{ 1920, 1080, 30, V4L2_DV_BT_CEA_1920X1080P30 },
+
+	/* HD - 2048x1080p23.98 */
+	/* HD - 2048x1080p24 */
+	{ 2048, 1080, 24, XLNX_V4L2_DV_BT_2048X1080P24 },
+	/* HD - 2048x1080p25 */
+	{ 2048, 1080, 24, XLNX_V4L2_DV_BT_2048X1080P25 },
+	/* HD - 2048x1080p29.97 */
+	/* HD - 2048x1080p30 */
+	{ 2048, 1080, 24, XLNX_V4L2_DV_BT_2048X1080P30 },
+	/* HD - 1920x1080i47.95 */
+	/* HD - 1920x1080i48 */
+	{ 1920, 540, 24, XLNX_V4L2_DV_BT_1920X1080I48 },
+
+	/* HD - 1920x1080i50 */
+	{ 1920, 540, 25, V4L2_DV_BT_CEA_1920X1080I50 },
+	/* HD - 1920x1080i59.94 */
+	/* HD - 1920x1080i60 */
+	{ 1920, 540, 30, V4L2_DV_BT_CEA_1920X1080I60 },
+
+	/* HD - 2048x1080i47.95 */
+	/* HD - 2048x1080i48 */
+	{ 2048, 540, 24, XLNX_V4L2_DV_BT_2048X1080I48 },
+	/* HD - 2048x1080i50 */
+	{ 2048, 540, 25, XLNX_V4L2_DV_BT_2048X1080I50 },
+	/* HD - 2048x1080i59.94 */
+	/* HD - 2048x1080i60 */
+	{ 2048, 540, 30, XLNX_V4L2_DV_BT_2048X1080I60 },
+	/* 3G - 1920x1080p47.95 */
+	/* 3G - 1920x1080p48 */
+	{ 1920, 1080, 48, XLNX_V4L2_DV_BT_1920X1080P48 },
+
+	/* 3G - 1920x1080p50 148.5 */
+	{ 1920, 1080, 50, V4L2_DV_BT_CEA_1920X1080P50 },
+	/* 3G - 1920x1080p59.94 148.5/1.001 */
+	/* 3G - 1920x1080p60 148.5 */
+	{ 1920, 1080, 60, V4L2_DV_BT_CEA_1920X1080P60 },
+
+	/* 3G - 2048x1080p47.95 */
+	/* 3G - 2048x1080p48 */
+	{ 2048, 1080, 48, XLNX_V4L2_DV_BT_2048X1080P48 },
+	/* 3G - 2048x1080p50 */
+	{ 2048, 1080, 50, XLNX_V4L2_DV_BT_2048X1080P50 },
+	/* 3G - 2048x1080p59.94 */
+	/* 3G - 2048x1080p60 */
+	{ 2048, 1080, 60, XLNX_V4L2_DV_BT_2048X1080P60 },
+
+	/* 6G - 3840X2160p23.98 */
+	/* 6G - 3840X2160p24 */
+	{ 3840, 2160, 24, V4L2_DV_BT_CEA_3840X2160P24 },
+	/* 6G - 3840X2160p25 */
+	{ 3840, 2160, 25, V4L2_DV_BT_CEA_3840X2160P25 },
+	/* 6G - 3840X2160p29.97 */
+	/* 6G - 3840X2160p30 */
+	{ 3840, 2160, 30, V4L2_DV_BT_CEA_3840X2160P30 },
+	/* 6G - 4096X2160p23.98 */
+	/* 6G - 4096X2160p24 */
+	{ 4096, 2160, 24, V4L2_DV_BT_CEA_4096X2160P24 },
+	/* 6G - 4096X2160p25 */
+	{ 4096, 2160, 25, V4L2_DV_BT_CEA_4096X2160P25 },
+	/* 6G - 4096X2160p29.97 */
+	/* 6G - 4096X2160p30 */
+	{ 4096, 2160, 30, V4L2_DV_BT_CEA_4096X2160P30 },
+	/* 12G - 3840X2160p47.95 */
+	/* 12G - 3840X2160p48 */
+	{ 3840, 2160, 48, XLNX_V4L2_DV_BT_3840X2160P48 },
+
+	/* 12G - 3840X2160p50 */
+	{ 3840, 2160, 50, V4L2_DV_BT_CEA_3840X2160P50 },
+	/* 12G - 3840X2160p59.94 */
+	/* 12G - 3840X2160p60 */
+	{ 3840, 2160, 60, V4L2_DV_BT_CEA_3840X2160P60 },
+
+	/* 12G - 4096X2160p47.95 */
+	/* 12G - 4096X2160p48 */
+	{ 3840, 2160, 48, XLNX_V4L2_DV_BT_4096X2160P48 },
+
+	/* 12G - 4096X2160p50 */
+	{ 4096, 2160, 50, V4L2_DV_BT_CEA_4096X2160P50 },
+	/* 12G - 4096X2160p59.94 */
+	/* 12G - 4096X2160p60 */
+	{ 4096, 2160, 60, V4L2_DV_BT_CEA_4096X2160P60 },
+
+	/* 6G/12G HFR */
+	{ 1920, 1080, 96, XLNX_V4L2_DV_BT_1920X1080P96 },
+	{ 1920, 1080, 100, XLNX_V4L2_DV_BT_1920X1080P100 },
+	{ 1920, 1080, 120, XLNX_V4L2_DV_BT_1920X1080P120 },
+	{ 2048, 1080, 96, XLNX_V4L2_DV_BT_2048X1080P96 },
+	{ 2048, 1080, 100, XLNX_V4L2_DV_BT_2048X1080P100 },
+	{ 2048, 1080, 120, XLNX_V4L2_DV_BT_2048X1080P120 },
+};
+
+static inline struct xsdirxss_state *
+to_xsdirxssstate(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xsdirxss_state, subdev);
+}
+
+/*
+ * Register related operations
+ */
+static inline u32 xsdirxss_read(struct xsdirxss_core *xsdirxss, u32 addr)
+{
+	return ioread32(xsdirxss->iomem + addr);
+}
+
+static inline void xsdirxss_write(struct xsdirxss_core *xsdirxss, u32 addr,
+				  u32 value)
+{
+	iowrite32(value, xsdirxss->iomem + addr);
+}
+
+static inline void xsdirxss_clr(struct xsdirxss_core *xsdirxss, u32 addr,
+				u32 clr)
+{
+	xsdirxss_write(xsdirxss, addr, xsdirxss_read(xsdirxss, addr) & ~clr);
+}
+
+static inline void xsdirxss_set(struct xsdirxss_core *xsdirxss, u32 addr,
+				u32 set)
+{
+	xsdirxss_write(xsdirxss, addr, xsdirxss_read(xsdirxss, addr) | set);
+}
+
+static inline void xsdirx_core_disable(struct xsdirxss_core *core)
+{
+	/* Set VPID bit to its default */
+	xsdirxss_set(core, XSDIRX_MDL_CTRL_REG, XSDIRX_MDL_CTRL_VPID_MASK);
+	xsdirxss_clr(core, XSDIRX_RST_CTRL_REG, XSDIRX_RST_CTRL_SS_EN_MASK);
+}
+
+static inline void xsdirx_core_enable(struct xsdirxss_core *core)
+{
+	/* Ignore VPID / ST352 payload to generate Video lock interrupt */
+	xsdirxss_clr(core, XSDIRX_MDL_CTRL_REG, XSDIRX_MDL_CTRL_VPID_MASK);
+	xsdirxss_set(core, XSDIRX_RST_CTRL_REG, XSDIRX_RST_CTRL_SS_EN_MASK);
+}
+
+static void xsdirxss_gt_reset(struct xsdirxss_core *core)
+{
+	/* reset qpll0 */
+	gpiod_set_value(core->rst_gt_gpio, 0x1);
+	gpiod_set_value(core->rst_gt_gpio, 0x0);
+	/* reset picxo core */
+	gpiod_set_value(core->rst_picxo_gpio, 0x1);
+	gpiod_set_value(core->rst_picxo_gpio, 0x0);
+}
+
+static int xsdirx_set_modedetect(struct xsdirxss_core *core, u16 mask)
+{
+	u32 i, val;
+
+	mask &= XSDIRX_DETECT_ALL_MODES;
+	if (!mask) {
+		dev_err(core->dev, "Invalid bit mask = 0x%08x\n", mask);
+		return -EINVAL;
+	}
+
+	dev_dbg(core->dev, "mask = 0x%x\n", mask);
+
+	val = xsdirxss_read(core, XSDIRX_MDL_CTRL_REG);
+	val &= ~XSDIRX_MDL_CTRL_MODE_DET_EN_MASK;
+	val &= ~XSDIRX_MDL_CTRL_MODE_AUTO_DET_MASK;
+	val &= ~XSDIRX_MDL_CTRL_FORCED_MODE_MASK;
+
+	if (hweight16(mask) > 1) {
+		/* Multi mode detection as more than 1 bit set in mask */
+		dev_dbg(core->dev, "Detect multiple modes\n");
+		for (i = 0; i < XSDIRX_MODE_NUM_SUPPORTED; i++) {
+			switch (mask & (1 << i)) {
+			case BIT(XSDIRX_MODE_SD_OFFSET):
+				val |= XSDIRX_MDL_CTRL_MODE_SD_EN_MASK;
+				break;
+			case BIT(XSDIRX_MODE_HD_OFFSET):
+				val |= XSDIRX_MDL_CTRL_MODE_HD_EN_MASK;
+				break;
+			case BIT(XSDIRX_MODE_3G_OFFSET):
+				val |= XSDIRX_MDL_CTRL_MODE_3G_EN_MASK;
+				break;
+			case BIT(XSDIRX_MODE_6G_OFFSET):
+				val |= XSDIRX_MDL_CTRL_MODE_6G_EN_MASK;
+				break;
+			case BIT(XSDIRX_MODE_12GI_OFFSET):
+				val |= XSDIRX_MDL_CTRL_MODE_12GI_EN_MASK;
+				break;
+			case BIT(XSDIRX_MODE_12GF_OFFSET):
+				val |= XSDIRX_MDL_CTRL_MODE_12GF_EN_MASK;
+				break;
+			}
+		}
+		val |= XSDIRX_MDL_CTRL_MODE_DET_EN_MASK;
+	} else {
+		/* Fixed Mode */
+		u32 forced_mode_mask;
+
+		dev_dbg(core->dev, "Detect fixed mode\n");
+
+		/* Find offset of first bit set */
+		switch (__ffs(mask)) {
+		case XSDIRX_MODE_SD_OFFSET:
+			forced_mode_mask = XSDIRX_MODE_SD_MASK;
+			break;
+		case XSDIRX_MODE_HD_OFFSET:
+			forced_mode_mask = XSDIRX_MODE_HD_MASK;
+			break;
+		case XSDIRX_MODE_3G_OFFSET:
+			forced_mode_mask = XSDIRX_MODE_3G_MASK;
+			break;
+		case XSDIRX_MODE_6G_OFFSET:
+			forced_mode_mask = XSDIRX_MODE_6G_MASK;
+			break;
+		case XSDIRX_MODE_12GI_OFFSET:
+			forced_mode_mask = XSDIRX_MODE_12GI_MASK;
+			break;
+		case XSDIRX_MODE_12GF_OFFSET:
+			forced_mode_mask = XSDIRX_MODE_12GF_MASK;
+			break;
+		default:
+			forced_mode_mask = 0;
+		}
+		dev_dbg(core->dev, "Forced Mode Mask : 0x%x\n",
+			forced_mode_mask);
+		val |= forced_mode_mask << XSDIRX_MDL_CTRL_FORCED_MODE_OFFSET;
+	}
+
+	dev_dbg(core->dev, "Modes to be detected : sdi ctrl reg = 0x%08x\n",
+		val);
+	xsdirxss_write(core, XSDIRX_MDL_CTRL_REG, val);
+
+	return 0;
+}
+
+static void xsdirx_framer(struct xsdirxss_core *core, bool flag)
+{
+	if (flag)
+		xsdirxss_set(core, XSDIRX_MDL_CTRL_REG,
+			     XSDIRX_MDL_CTRL_FRM_EN_MASK);
+	else
+		xsdirxss_clr(core, XSDIRX_MDL_CTRL_REG,
+			     XSDIRX_MDL_CTRL_FRM_EN_MASK);
+}
+
+static void xsdirx_setedherrcnttrigger(struct xsdirxss_core *core, u32 enable)
+{
+	u32 val;
+
+	val = enable & XSDIRX_EDH_ALLERR_MASK;
+
+	xsdirxss_write(core, XSDIRX_EDH_ERRCNT_EN_REG, val);
+}
+
+static inline void xsdirx_setvidlockwindow(struct xsdirxss_core *core, u32 val)
+{
+	/*
+	 * The video lock window is the amount of time for which
+	 * the mode and transport stream should be locked to get
+	 * the video lock interrupt.
+	 */
+	xsdirxss_write(core, XSDIRX_VID_LOCK_WINDOW_REG, val);
+}
+
+static inline void xsdirx_disableintr(struct xsdirxss_core *core, u32 mask)
+{
+	xsdirxss_clr(core, XSDIRX_IER_REG, mask);
+}
+
+static inline void xsdirx_enableintr(struct xsdirxss_core *core, u32 mask)
+{
+	xsdirxss_set(core, XSDIRX_IER_REG, mask);
+}
+
+static void xsdirx_globalintr(struct xsdirxss_core *core, bool flag)
+{
+	if (flag)
+		xsdirxss_set(core, XSDIRX_GLBL_IER_REG,
+			     XSDIRX_GLBL_INTR_EN_MASK);
+	else
+		xsdirxss_clr(core, XSDIRX_GLBL_IER_REG,
+			     XSDIRX_GLBL_INTR_EN_MASK);
+}
+
+static inline void xsdirx_clearintr(struct xsdirxss_core *core, u32 mask)
+{
+	xsdirxss_set(core, XSDIRX_ISR_REG, mask);
+}
+
+static void xsdirx_vid_bridge_control(struct xsdirxss_core *core,
+				      bool enable)
+{
+	struct xsdirxss_state *state =
+		container_of(core, struct xsdirxss_state, core);
+	u32 mask = XSDIRX_RST_CTRL_SDIRX_BRIDGE_ENB_MASK;
+
+	if (state->format.code == MEDIA_BUS_FMT_VUY10_1X30 ||
+	    state->format.code == MEDIA_BUS_FMT_RBG101010_1X30 ||
+	    state->format.code == MEDIA_BUS_FMT_RBG121212_1X36 ||
+	    state->format.code == MEDIA_BUS_FMT_VUY12_1X36)
+		mask |= (XSDIRX_RST_CTRL_BRIDGE_CH_FMT_YUV444 <<
+			 XSDIRX_RST_CTRL_BRIDGE_CH_FMT_OFFSET);
+
+	if (enable)
+		xsdirxss_set(core, XSDIRX_RST_CTRL_REG, mask);
+	else
+		xsdirxss_clr(core, XSDIRX_RST_CTRL_REG, mask);
+}
+
+static void xsdirx_axis4_bridge_control(struct xsdirxss_core *core,
+					bool enable)
+{
+	if (enable)
+		xsdirxss_set(core, XSDIRX_RST_CTRL_REG,
+			     XSDIRX_RST_CTRL_VIDIN_AXI4S_MOD_ENB_MASK);
+	else
+		xsdirxss_clr(core, XSDIRX_RST_CTRL_REG,
+			     XSDIRX_RST_CTRL_VIDIN_AXI4S_MOD_ENB_MASK);
+}
+
+static void xsdirx_streamflow_control(struct xsdirxss_core *core, bool enable)
+{
+	/* The sdi to native bridge is followed by native to axis4 bridge */
+	if (enable) {
+		xsdirx_axis4_bridge_control(core, enable);
+		xsdirx_vid_bridge_control(core, enable);
+	} else {
+		xsdirx_vid_bridge_control(core, enable);
+		xsdirx_axis4_bridge_control(core, enable);
+	}
+}
+
+static void xsdirxss_get_framerate(struct v4l2_fract *frame_interval,
+				   u32 framerate)
+{
+	switch (framerate) {
+	case XSDIRX_TS_DET_STAT_RATE_23_98HZ:
+		frame_interval->numerator = 1001;
+		frame_interval->denominator = 24000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_24HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 24000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_25HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 25000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_29_97HZ:
+		frame_interval->numerator = 1001;
+		frame_interval->denominator = 30000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_30HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 30000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_47_95HZ:
+		frame_interval->numerator = 1001;
+		frame_interval->denominator = 48000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_48HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 48000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_50HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 50000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_59_94HZ:
+		frame_interval->numerator = 1001;
+		frame_interval->denominator = 60000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_60HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 60000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_95_90HZ:
+		frame_interval->numerator = 1001;
+		frame_interval->denominator = 96000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_96HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 96000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_100HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 100000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_119_88HZ:
+		frame_interval->numerator = 1001;
+		frame_interval->denominator = 120000;
+		break;
+	case XSDIRX_TS_DET_STAT_RATE_120HZ:
+		frame_interval->numerator = 1000;
+		frame_interval->denominator = 120000;
+		break;
+	default:
+		frame_interval->numerator = 1;
+		frame_interval->denominator = 1;
+	}
+}
+
+static void xsdirxss_set_gtclk(struct xsdirxss_state *state)
+{
+	struct clk *gtclk;
+	unsigned long clkrate;
+	int ret, is_frac;
+	struct xsdirxss_core *core = &state->core;
+	u32 mode;
+
+	mode = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+	mode &= XSDIRX_MODE_DET_STAT_RX_MODE_MASK;
+
+	xsdirx_core_disable(core);
+	xsdirx_globalintr(core, false);
+	xsdirx_disableintr(core, XSDIRX_INTR_ALL_MASK);
+
+	/* get sdi_rx_clk */
+	gtclk = core->clks[1].clk;
+	is_frac = state->frame_interval.numerator == 1001 ? 1 : 0;
+
+	/*
+	 * PLL ref clock is 148.5MHz for integer frame rates
+	 * and 148.35MHz for fractional frame rates.
+	 * For SD mode its always 148.5MHz for integer & fractional.
+	 * Please refer to Table 5-2 in PG290
+	 * https://www.xilinx.com/support/documentation/ip_documentation/v_smpte_uhdsdi_rx_ss/v2_0/pg290-v-smpte-uhdsdi-rx-ss.pdf
+	 */
+	if (!is_frac || mode == XSDIRX_MODE_SD_MASK)
+		clkrate = CLK_INT;
+	else
+		clkrate = (CLK_INT * 1000) / 1001;
+
+	ret = clk_set_rate(gtclk, clkrate);
+	if (ret)
+		dev_err(core->dev, "failed to set clk rate = %d\n", ret);
+
+	/* reset qpll0 and picxo core */
+	xsdirxss_gt_reset(core);
+
+	clkrate = clk_get_rate(gtclk);
+
+	dev_dbg(core->dev, "clkrate = %lu is_frac = %d\n",
+		clkrate, is_frac);
+
+	xsdirx_framer(core, state->framer_enable);
+	xsdirx_setedherrcnttrigger(core, state->edhmask);
+	xsdirx_setvidlockwindow(core, state->vidlockwin);
+	xsdirx_set_modedetect(core, state->searchmask);
+	xsdirx_enableintr(core, XSDIRX_INTR_ALL_MASK);
+	xsdirx_globalintr(core, true);
+	xsdirx_core_enable(core);
+}
+
+/**
+ * xsdirx_get_stream_properties - Get SDI Rx stream properties
+ * @state: pointer to driver state
+ *
+ * This function decodes the stream's ST352 payload (if available) to get
+ * stream properties like width, height, picture type (interlaced/progressive),
+ * etc.
+ *
+ * Return: 0 for success else errors
+ */
+static int xsdirx_get_stream_properties(struct xsdirxss_state *state)
+{
+	struct xsdirxss_core *core = &state->core;
+	u32 mode, payload = 0, val, family, valid, tscan;
+	u8 byte1 = 0, active_luma = 0, pic_type = 0, framerate = 0;
+	u8 sampling = XST352_BYTE3_COLOR_FORMAT_422;
+	struct v4l2_mbus_framefmt *format = &state->format;
+	u32 bpc = XST352_BYTE4_BIT_DEPTH_10;
+	u8 is_3GB;
+
+	mode = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+	mode &= XSDIRX_MODE_DET_STAT_RX_MODE_MASK;
+
+	valid = xsdirxss_read(core, XSDIRX_ST352_VALID_REG);
+
+	if (mode >= XSDIRX_MODE_6G_MASK && !valid) {
+		dev_err_ratelimited(core->dev, "No valid ST352 payload present even for 6G mode and above\n");
+		return -EINVAL;
+	}
+
+	val = xsdirxss_read(core, XSDIRX_TS_DET_STAT_REG);
+	if (valid & XSDIRX_ST352_VALID_DS1_MASK) {
+		payload = xsdirxss_read(core, XSDIRX_ST352_DS1_REG);
+		byte1 = (payload >> XST352_PAYLOAD_BYTE1_SHIFT) &
+				XST352_PAYLOAD_BYTE_MASK;
+		active_luma = (payload & XST352_BYTE3_ACT_LUMA_COUNT_MASK) >>
+				XST352_BYTE3_ACT_LUMA_COUNT_OFFSET;
+		pic_type = (payload & XST352_BYTE2_PIC_TYPE_MASK) >>
+				XST352_BYTE2_PIC_TYPE_OFFSET;
+		framerate = (payload >> XST352_BYTE2_FPS_SHIFT) &
+				XST352_BYTE2_FPS_MASK;
+		tscan = (payload & XST352_BYTE2_TS_TYPE_MASK) >>
+				XST352_BYTE2_TS_TYPE_OFFSET;
+		sampling = (payload & XST352_BYTE3_COLOR_FORMAT_MASK) >>
+			   XST352_BYTE3_COLOR_FORMAT_OFFSET;
+		bpc = (payload & XST352_BYTE4_BIT_DEPTH_MASK) >>
+			XST352_BYTE4_BIT_DEPTH_OFFSET;
+	} else {
+		dev_dbg(core->dev, "No ST352 payload available : Mode = %d\n",
+			mode);
+		framerate = (val & XSDIRX_TS_DET_STAT_RATE_MASK) >>
+				XSDIRX_TS_DET_STAT_RATE_OFFSET;
+		tscan = (val & XSDIRX_TS_DET_STAT_SCAN_MASK) >>
+				XSDIRX_TS_DET_STAT_SCAN_OFFSET;
+	}
+
+	if ((bpc == XST352_BYTE4_BIT_DEPTH_10 && core->bpc != 10) ||
+	    (bpc == XST352_BYTE4_BIT_DEPTH_12 && core->bpc != 12)) {
+		dev_dbg(core->dev, "Bit depth not supported. bpc = %d core->bpc = %d\n",
+			bpc, core->bpc);
+		return -EINVAL;
+	}
+
+	family = (val & XSDIRX_TS_DET_STAT_FAMILY_MASK) >>
+			XSDIRX_TS_DET_STAT_FAMILY_OFFSET;
+	state->ts_is_interlaced = tscan ? false : true;
+
+	dev_dbg(core->dev, "ts_is_interlaced = %d, family = %d\n",
+		state->ts_is_interlaced, family);
+
+	switch (mode) {
+	case XSDIRX_MODE_HD_MASK:
+		if (!valid) {
+			/* No payload obtained */
+			dev_dbg(core->dev, "frame rate : %d, tscan = %d\n",
+				framerate, tscan);
+			/*
+			 * NOTE : A progressive segmented frame pSF will be
+			 * reported incorrectly as Interlaced as we rely on IP's
+			 * transport scan locked bit.
+			 */
+			dev_warn(core->dev, "pSF will be incorrectly reported as Interlaced\n");
+
+			switch (framerate) {
+			case XSDIRX_TS_DET_STAT_RATE_23_98HZ:
+			case XSDIRX_TS_DET_STAT_RATE_24HZ:
+			case XSDIRX_TS_DET_STAT_RATE_25HZ:
+			case XSDIRX_TS_DET_STAT_RATE_29_97HZ:
+			case XSDIRX_TS_DET_STAT_RATE_30HZ:
+				if (family == XSDIRX_SMPTE_ST_296) {
+					format->width = 1280;
+					format->height = 720;
+					format->field = V4L2_FIELD_NONE;
+				} else if (family == XSDIRX_SMPTE_ST_2048_2) {
+					format->width = 2048;
+					format->height = 1080;
+					if (tscan)
+						format->field = V4L2_FIELD_NONE;
+					else
+						format->field =
+							V4L2_FIELD_ALTERNATE;
+				} else {
+					format->width = 1920;
+					format->height = 1080;
+					if (tscan)
+						format->field = V4L2_FIELD_NONE;
+					else
+						format->field =
+							V4L2_FIELD_ALTERNATE;
+				}
+				break;
+			case XSDIRX_TS_DET_STAT_RATE_50HZ:
+			case XSDIRX_TS_DET_STAT_RATE_59_94HZ:
+			case XSDIRX_TS_DET_STAT_RATE_60HZ:
+				if (family == XSDIRX_SMPTE_ST_274) {
+					format->width = 1920;
+					format->height = 1080;
+				} else {
+					format->width = 1280;
+					format->height = 720;
+				}
+				format->field = V4L2_FIELD_NONE;
+				break;
+			default:
+				format->width = 1920;
+				format->height = 1080;
+				format->field = V4L2_FIELD_NONE;
+			}
+		} else {
+			dev_dbg(core->dev, "Got the payload\n");
+			switch (byte1) {
+			case XST352_BYTE1_ST292_1x720L_1_5G:
+				/* SMPTE ST 292-1 for 720 line payloads */
+				format->width = 1280;
+				format->height = 720;
+				break;
+			case XST352_BYTE1_ST292_1x1080L_1_5G:
+				/* SMPTE ST 292-1 for 1080 line payloads */
+				format->height = 1080;
+				if (active_luma)
+					format->width = 2048;
+				else
+					format->width = 1920;
+				break;
+			default:
+				dev_dbg(core->dev, "Unknown HD Mode SMPTE standard\n");
+				return -EINVAL;
+			}
+		}
+		break;
+	case XSDIRX_MODE_SD_MASK:
+		format->field = V4L2_FIELD_ALTERNATE;
+
+		switch (family) {
+		case XSDIRX_NTSC:
+			format->width = 720;
+			format->height = 486;
+			break;
+		case XSDIRX_PAL:
+			format->width = 720;
+			format->height = 576;
+			break;
+		default:
+			dev_dbg(core->dev, "Unknown SD Mode SMPTE standard\n");
+			return -EINVAL;
+		}
+		break;
+	case XSDIRX_MODE_3G_MASK:
+		is_3GB = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		is_3GB &= XSDIRX_MODE_DET_STAT_LVLB_3G_MASK;
+
+		if (!valid) {
+			/* No payload obtained */
+			dev_warn(core->dev, "No ST352 valid payload available for 3G modes, source is not 3G compliant\n\r");
+			if (is_3GB) {
+				switch (framerate) {
+				case XSDIRX_TS_DET_STAT_RATE_96HZ:
+				case XSDIRX_TS_DET_STAT_RATE_100HZ:
+				case XSDIRX_TS_DET_STAT_RATE_120HZ:
+					if (family == XSDIRX_SMPTE_ST_2048_2) {
+						format->width = 2048;
+						format->height = 1080;
+						format->field = V4L2_FIELD_ALTERNATE;
+					} else {
+						format->width = 1920;
+						format->height = 1080;
+						format->field = V4L2_FIELD_ALTERNATE;
+					}
+					break;
+				default:
+					format->width = 1920;
+					format->height = 1080;
+					format->field = V4L2_FIELD_ALTERNATE;
+					break;
+				}
+			} else {
+				/* 3GA */
+				switch (framerate) {
+				case XSDIRX_TS_DET_STAT_RATE_48HZ:
+				case XSDIRX_TS_DET_STAT_RATE_50HZ:
+				case XSDIRX_TS_DET_STAT_RATE_60HZ:
+					if (family == XSDIRX_SMPTE_ST_2048_2) {
+						format->width = 2048;
+						format->height = 1080;
+						format->field = V4L2_FIELD_NONE;
+					} else {
+						format->width = 1920;
+						format->height = 1080;
+						format->field = V4L2_FIELD_NONE;
+					}
+					break;
+				default:
+					format->width = 1920;
+					format->height = 1080;
+					format->field = V4L2_FIELD_NONE;
+					break;
+				}
+			}
+		} else {
+			dev_dbg(core->dev, "Got the payload\n");
+			switch (byte1) {
+			case XST352_BYTE1_ST425_2008_750L_3GB:
+				/* Sec 4.1.6.1 SMPTE 425-2008 */
+			case XST352_BYTE1_ST372_2x720L_3GB:
+				/* Table 13 SMPTE 425-2008 */
+				format->width = 1280;
+				format->height = 720;
+				break;
+			case XST352_BYTE1_ST425_2008_1125L_3GA:
+				/* ST352 Table SMPTE 425-1 */
+			case XST352_BYTE1_ST372_DL_3GB:
+				/* Table 13 SMPTE 425-2008 */
+			case XST352_BYTE1_ST372_2x1080L_3GB:
+				/* Table 13 SMPTE 425-2008 */
+				format->height = 1080;
+				if (active_luma)
+					format->width = 2048;
+				else
+					format->width = 1920;
+				break;
+			default:
+				dev_dbg(core->dev, "Unknown 3G Mode SMPTE standard\n");
+				return -EINVAL;
+			}
+		}
+		break;
+	case XSDIRX_MODE_6G_MASK:
+		switch (byte1) {
+		case XST352_BYTE1_ST2081_10_DL_2160L_6G:
+			/* Dual link 6G */
+		case XST352_BYTE1_ST2081_10_2160L_6G:
+			/* Table 3 SMPTE ST 2081-10 */
+			format->height = 2160;
+			if (active_luma)
+				format->width = 4096;
+			else
+				format->width = 3840;
+			break;
+		case XST352_BYTE1_ST2081_10_2_1080L_6G:
+			format->height = 1080;
+			if (active_luma)
+				format->width = 2048;
+			else
+				format->width = 1920;
+			break;
+		default:
+			dev_dbg(core->dev, "Unknown 6G Mode SMPTE standard\n");
+			return -EINVAL;
+		}
+		break;
+	case XSDIRX_MODE_12GI_MASK:
+	case XSDIRX_MODE_12GF_MASK:
+		switch (byte1) {
+		case XST352_BYTE1_ST2082_10_2160L_12G:
+			/* Section 4.3.1 SMPTE ST 2082-10 */
+			format->height = 2160;
+			if (active_luma)
+				format->width = 4096;
+			else
+				format->width = 3840;
+			break;
+		case XST352_BYTE1_ST2082_10_2_1080L_12G:
+			/* Section 5.8.1 SMPTE ST 2082-10 */
+			format->height = 1080;
+			if (active_luma)
+				format->width = 2048;
+			else
+				format->width = 1920;
+			break;
+		default:
+			dev_dbg(core->dev, "Unknown 12G Mode SMPTE standard\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_err(core->dev, "Invalid Mode\n");
+		return -EINVAL;
+	}
+
+	if (valid) {
+		if (pic_type)
+			format->field = V4L2_FIELD_NONE;
+		else
+			format->field = V4L2_FIELD_ALTERNATE;
+
+		if (format->height == 1080 && pic_type && !tscan)
+			format->field = V4L2_FIELD_ALTERNATE;
+
+		if (byte1 == XST352_BYTE1_ST372_DL_3GB) {
+			if (!pic_type)
+				format->field = V4L2_FIELD_ALTERNATE;
+			else
+				format->field = V4L2_FIELD_NONE;
+		}
+	}
+
+	if (format->field == V4L2_FIELD_ALTERNATE)
+		format->height = format->height / 2;
+
+	switch (sampling) {
+	case XST352_BYTE3_COLOR_FORMAT_420:
+		if (core->bpc == 10)
+			format->code = MEDIA_BUS_FMT_VYYUYY10_4X20;
+		else
+			format->code = MEDIA_BUS_FMT_UYYVYY12_4X24;
+		break;
+	case XST352_BYTE3_COLOR_FORMAT_422:
+		if (core->bpc == 10)
+			format->code = MEDIA_BUS_FMT_UYVY10_1X20;
+		else
+			format->code = MEDIA_BUS_FMT_UYVY12_1X24;
+		break;
+	case XST352_BYTE3_COLOR_FORMAT_YUV444:
+		if (core->bpc == 10)
+			format->code = MEDIA_BUS_FMT_VUY10_1X30;
+		else
+			format->code = MEDIA_BUS_FMT_VUY12_1X36;
+		break;
+	case XST352_BYTE3_COLOR_FORMAT_GBR:
+		if (core->bpc == 10)
+			format->code = MEDIA_BUS_FMT_RBG101010_1X30;
+		else
+			format->code = MEDIA_BUS_FMT_RBG121212_1X36;
+		break;
+	default:
+		dev_err(core->dev, "Unsupported color format : %d\n", sampling);
+		return -EINVAL;
+	}
+
+	xsdirxss_get_framerate(&state->frame_interval, framerate);
+
+	memset(&state->static_hdr, 0, sizeof(state->static_hdr));
+
+	state->static_hdr.eotf = V4L2_EOTF_TRADITIONAL_GAMMA_SDR;
+	format->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	format->xfer_func = V4L2_XFER_FUNC_709;
+	format->ycbcr_enc = V4L2_YCBCR_ENC_601;
+	format->quantization = V4L2_QUANTIZATION_LIM_RANGE;
+
+	if (mode != XSDIRX_MODE_SD_MASK) {
+		u8 eotf = (payload & XST352_BYTE2_EOTF_MASK) >>
+			XST352_BYTE2_EOTF_OFFSET;
+
+		u8 colorimetry = (payload & XST352_BYTE2_COLORIMETRY_MASK) >>
+			XST352_BYTE2_COLORIMETRY_OFFSET;
+
+		/*
+		 * Bit 7 and 4 of byte 3 form the colorimetry field for HD.
+		 * Checkout SMPTE 292-1:2018 Sec 9.5 for details
+		 */
+		if (mode == XSDIRX_MODE_HD_MASK ||
+		    byte1 == XST352_BYTE1_ST372_DL_3GB) {
+			/* For case when there might be no payload */
+			colorimetry = XST352_BYTE2_COLORIMETRY_BT709;
+
+			if (valid & XSDIRX_ST352_VALID_DS1_MASK) {
+				colorimetry = (FIELD_GET(BIT(23), payload) << 1) |
+					FIELD_GET(BIT(20), payload);
+			}
+		}
+
+		/* Get the EOTF function */
+		switch (eotf) {
+		case XST352_BYTE2_EOTF_SDRTV:
+			state->static_hdr.eotf =
+				V4L2_EOTF_TRADITIONAL_GAMMA_SDR;
+			break;
+		case XST352_BYTE2_EOTF_SMPTE2084:
+			state->static_hdr.eotf = V4L2_EOTF_SMPTE_ST2084;
+			format->xfer_func = V4L2_XFER_FUNC_SMPTE2084;
+			break;
+		case XST352_BYTE2_EOTF_HLG:
+			state->static_hdr.eotf = V4L2_EOTF_BT_2100_HLG;
+			format->xfer_func = V4L2_XFER_FUNC_HLG;
+			break;
+		}
+
+		/* Get the colorimetry data */
+		switch (colorimetry) {
+		case XST352_BYTE2_COLORIMETRY_BT709:
+			format->colorspace = V4L2_COLORSPACE_REC709;
+			format->ycbcr_enc = V4L2_YCBCR_ENC_709;
+			break;
+		case XST352_BYTE2_COLORIMETRY_UHDTV:
+			format->colorspace = V4L2_COLORSPACE_BT2020;
+			format->ycbcr_enc = V4L2_YCBCR_ENC_BT2020;
+			break;
+		default:
+			/*
+			 * Modes which will have VANC and Unknown colorimetery
+			 * are currently not supported
+			 */
+			format->colorspace = V4L2_COLORSPACE_DEFAULT;
+			format->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+			break;
+		}
+	}
+
+	/* Refer to Table 3 ST 2082-10:2018 */
+	if (mode == XSDIRX_MODE_12GI_OFFSET ||
+	    mode == XSDIRX_MODE_12GF_OFFSET) {
+		switch (sampling) {
+		case XST352_BYTE3_COLOR_FORMAT_420:
+		case XST352_BYTE3_COLOR_FORMAT_422:
+		case XST352_BYTE3_COLOR_FORMAT_YUV444:
+			if (payload & XST352_BYTE4_LUM_COL_DIFF_MASK)
+				format->ycbcr_enc =
+					V4L2_YCBCR_ENC_BT2020_CONST_LUM;
+			else
+				format->ycbcr_enc =
+					V4L2_YCBCR_ENC_BT2020;
+		}
+	}
+
+	/* Set quantization range */
+	if (sampling == XST352_BYTE3_COLOR_FORMAT_GBR &&
+	    format->colorspace != V4L2_COLORSPACE_BT2020)
+		format->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+
+	/*
+	 * Save the payload to be used in vsync interrupt to check for
+	 * change in payload without video lock/unlock sequence
+	 */
+	if (valid & XSDIRX_ST352_VALID_DS1_MASK)
+		state->prev_payload = payload;
+
+	dev_dbg(core->dev, "Stream width = %d height = %d Field = %d payload = 0x%08x ts = 0x%08x\n",
+		format->width, format->height, format->field, payload, val);
+	dev_dbg(core->dev, "frame rate numerator = %d denominator = %d\n",
+		state->frame_interval.numerator,
+		state->frame_interval.denominator);
+	dev_dbg(core->dev, "Stream code = 0x%x\n", format->code);
+	return 0;
+}
+
+/**
+ * xsdirxss_irq_handler - Interrupt handler for SDI Rx
+ * @irq: IRQ number
+ * @dev_id: Pointer to device state
+ *
+ * The SDI Rx interrupts are cleared by writing 1 to corresponding bit.
+ *
+ * Return: IRQ_HANDLED after handling interrupts
+ */
+static irqreturn_t xsdirxss_irq_handler(int irq, void *dev_id)
+{
+	struct xsdirxss_state *state = (struct xsdirxss_state *)dev_id;
+	struct xsdirxss_core *core = &state->core;
+	u32 status;
+
+	status = xsdirxss_read(core, XSDIRX_ISR_REG);
+	dev_dbg(core->dev, "interrupt status = 0x%08x\n", status);
+
+	if (!status)
+		return IRQ_NONE;
+
+	xsdirxss_write(core, XSDIRX_ISR_REG, status);
+
+	if (status & XSDIRX_INTR_VIDLOCK_MASK ||
+	    status & XSDIRX_INTR_VIDUNLOCK_MASK) {
+		u32 val1, val2;
+		bool gen_event = true;
+
+		dev_dbg(core->dev, "video lock/unlock interrupt\n");
+
+		xsdirx_streamflow_control(core, false);
+		state->streaming = false;
+
+		val1 = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		val2 = xsdirxss_read(core, XSDIRX_TS_DET_STAT_REG);
+
+		if ((val1 & XSDIRX_MODE_DET_STAT_MODE_LOCK_MASK) &&
+		    (val2 & XSDIRX_TS_DET_STAT_LOCKED_MASK)) {
+			u32 mask = XSDIRX_RST_CTRL_RST_CRC_ERRCNT_MASK |
+				   XSDIRX_RST_CTRL_RST_EDH_ERRCNT_MASK;
+
+			u32 prev_payload = state->prev_payload;
+
+			dev_dbg(core->dev, "video lock interrupt\n");
+
+			xsdirxss_set(core, XSDIRX_RST_CTRL_REG, mask);
+			xsdirxss_clr(core, XSDIRX_RST_CTRL_REG, mask);
+
+			val1 = xsdirxss_read(core, XSDIRX_ST352_VALID_REG);
+			val2 = xsdirxss_read(core, XSDIRX_ST352_DS1_REG);
+
+			dev_dbg(core->dev, "valid st352 mask = 0x%08x\n", val1);
+			dev_dbg(core->dev, "st352 payload = 0x%08x\n", val2);
+
+			if (state->vidlocked) {
+				gen_event = false;
+				/* If it was came here due to interrupt of
+				 * setting gtclk, re-enabling stream control
+				 */
+				if (state->s_stream) {
+					xsdirx_streamflow_control(core, true);
+					state->streaming = true;
+				}
+			} else if (!xsdirx_get_stream_properties(state)) {
+				state->vidlocked = true;
+				xsdirxss_set_gtclk(state);
+				/* If previous payload and current payload are
+				 * same then start streaming. This is not a
+				 * correct way but a workaround
+				 */
+				if (val2 == prev_payload && state->s_stream) {
+					dev_dbg(core->dev, "Resuming as payload is same\n");
+					xsdirx_streamflow_control(core, true);
+					state->streaming = true;
+				}
+			} else {
+				dev_err_ratelimited(core->dev, "Unable to get stream properties!\n");
+				state->vidlocked = false;
+			}
+
+		} else {
+			dev_dbg(core->dev, "video unlock interrupt\n");
+			state->vidlocked = false;
+		}
+		if (gen_event) {
+			memset(&state->event, 0, sizeof(state->event));
+			state->event.type = V4L2_EVENT_SOURCE_CHANGE;
+			state->event.u.src_change.changes =
+				V4L2_EVENT_SRC_CH_RESOLUTION;
+			v4l2_subdev_notify_event(&state->subdev, &state->event);
+		}
+	}
+
+	if (status & XSDIRX_INTR_UNDERFLOW_MASK) {
+		dev_dbg(core->dev, "Video in to AXI4 Stream core underflow interrupt\n");
+
+		memset(&state->event, 0, sizeof(state->event));
+		state->event.type = V4L2_EVENT_XLNXSDIRX_UNDERFLOW;
+		v4l2_subdev_notify_event(&state->subdev, &state->event);
+	}
+
+	if (status & XSDIRX_INTR_OVERFLOW_MASK) {
+		dev_dbg(core->dev, "Video in to AXI4 Stream core overflow interrupt\n");
+
+		memset(&state->event, 0, sizeof(state->event));
+		state->event.type = V4L2_EVENT_XLNXSDIRX_OVERFLOW;
+		v4l2_subdev_notify_event(&state->subdev, &state->event);
+	}
+
+	if (status & XSDIRX_INTR_VSYNC_MASK) {
+		u32 valid, payload;
+		/*
+		 * If ST352 payload changed without generating video unlock/
+		 * lock sequence, then use vsync interrupt to update the
+		 * frame rate, video format and static hdr structures and
+		 * notify the userspace.
+		 */
+
+		/*
+		 * Do this while driver has state as video locked though
+		 * it is implicit from the interrupt type i.e. vsync interrupt
+		 * can occur only when video is locked.
+		 * Avoid generating source change event twice.
+		 */
+		if (status & XSDIRX_INTR_VIDLOCK_MASK)
+			return IRQ_HANDLED;
+
+		valid = xsdirxss_read(core, XSDIRX_ST352_VALID_REG);
+		if (!(valid & XSDIRX_ST352_VALID_DS1_MASK))
+			return IRQ_HANDLED;
+
+		payload = xsdirxss_read(core, XSDIRX_ST352_DS1_REG);
+		/* Return if previous and current payload are same */
+		if (payload == state->prev_payload)
+			return IRQ_HANDLED;
+
+		if (xsdirx_get_stream_properties(state))
+			return IRQ_HANDLED;
+
+		memset(&state->event, 0, sizeof(state->event));
+		state->event.type = V4L2_EVENT_SOURCE_CHANGE;
+		state->event.u.src_change.changes =
+			V4L2_EVENT_SRC_CH_RESOLUTION;
+		v4l2_subdev_notify_event(&state->subdev, &state->event);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xsdirxss_subscribe_event - Subscribe to video lock and unlock event
+ * @sd: V4L2 Sub device
+ * @fh: V4L2 File Handle
+ * @sub: Subcribe event structure
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int xsdirxss_subscribe_event(struct v4l2_subdev *sd,
+				    struct v4l2_fh *fh,
+				    struct v4l2_event_subscription *sub)
+{
+	int ret;
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	struct xsdirxss_core *core = &xsdirxss->core;
+
+	switch (sub->type) {
+	case V4L2_EVENT_XLNXSDIRX_UNDERFLOW:
+	case V4L2_EVENT_XLNXSDIRX_OVERFLOW:
+		ret = v4l2_event_subscribe(fh, sub, XSDIRX_MAX_EVENTS, NULL);
+		break;
+	case V4L2_EVENT_SOURCE_CHANGE:
+		ret = v4l2_src_change_event_subscribe(fh, sub);
+		break;
+	default:
+		return -EINVAL;
+	}
+	dev_dbg(core->dev, "Event subscribed : 0x%08x\n", sub->type);
+	return ret;
+}
+
+/**
+ * xsdirxss_unsubscribe_event - Unsubscribe from all events registered
+ * @sd: V4L2 Sub device
+ * @fh: V4L2 file handle
+ * @sub: pointer to Event unsubscription structure
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int xsdirxss_unsubscribe_event(struct v4l2_subdev *sd,
+				      struct v4l2_fh *fh,
+				      struct v4l2_event_subscription *sub)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	struct xsdirxss_core *core = &xsdirxss->core;
+
+	dev_dbg(core->dev, "Event unsubscribe : 0x%08x\n", sub->type);
+	return v4l2_event_unsubscribe(fh, sub);
+}
+
+/**
+ * xsdirxss_s_ctrl - This is used to set the Xilinx SDI Rx V4L2 controls
+ * @ctrl: V4L2 control to be set
+ *
+ * This function is used to set the V4L2 controls for the Xilinx SDI Rx
+ * Subsystem.
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int xsdirxss_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	int ret = 0;
+	struct xsdirxss_state *xsdirxss =
+		container_of(ctrl->handler,
+			     struct xsdirxss_state, ctrl_handler);
+	struct xsdirxss_core *core = &xsdirxss->core;
+
+	dev_dbg(core->dev, "set ctrl id = 0x%08x val = 0x%08x\n",
+		ctrl->id, ctrl->val);
+
+	if (xsdirxss->streaming) {
+		dev_err(core->dev, "Cannot set controls while streaming\n");
+		return -EINVAL;
+	}
+
+	xsdirx_core_disable(core);
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_SDIRX_FRAMER:
+		xsdirx_framer(core, ctrl->val);
+		xsdirxss->framer_enable = ctrl->val;
+		break;
+	case V4L2_CID_XILINX_SDIRX_VIDLOCK_WINDOW:
+		xsdirx_setvidlockwindow(core, ctrl->val);
+		xsdirxss->vidlockwin = ctrl->val;
+		break;
+	case V4L2_CID_XILINX_SDIRX_EDH_ERRCNT_ENABLE:
+		xsdirx_setedherrcnttrigger(core, ctrl->val);
+		xsdirxss->edhmask = ctrl->val;
+		break;
+	case V4L2_CID_XILINX_SDIRX_SEARCH_MODES:
+		if (ctrl->val) {
+			if (core->mode == XSDIRXSS_SDI_STD_3G) {
+				dev_dbg(core->dev, "Upto 3G supported\n");
+				ctrl->val &= ~(BIT(XSDIRX_MODE_6G_OFFSET) |
+					       BIT(XSDIRX_MODE_12GI_OFFSET) |
+					       BIT(XSDIRX_MODE_12GF_OFFSET));
+			}
+
+			if (core->mode == XSDIRXSS_SDI_STD_6G) {
+				dev_dbg(core->dev, "Upto 6G supported\n");
+				ctrl->val &= ~(BIT(XSDIRX_MODE_12GI_OFFSET) |
+					       BIT(XSDIRX_MODE_12GF_OFFSET));
+			}
+
+			ret = xsdirx_set_modedetect(core, ctrl->val);
+			if (!ret)
+				xsdirxss->searchmask = ctrl->val;
+		} else {
+			dev_err(core->dev, "Select at least one mode!\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		xsdirxss_set(core, XSDIRX_RST_CTRL_REG,
+			     XSDIRX_RST_CTRL_SS_EN_MASK);
+		return -EINVAL;
+	}
+	xsdirx_core_enable(core);
+	return ret;
+}
+
+/**
+ * xsdirxss_g_volatile_ctrl - get the Xilinx SDI Rx controls
+ * @ctrl: Pointer to V4L2 control
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int xsdirxss_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	u32 val;
+	struct xsdirxss_state *xsdirxss =
+		container_of(ctrl->handler,
+			     struct xsdirxss_state, ctrl_handler);
+	struct xsdirxss_core *core = &xsdirxss->core;
+	struct v4l2_metadata_hdr *hdr_ptr;
+
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_SDIRX_MODE_DETECT:
+		if (!xsdirxss->vidlocked) {
+			dev_err(core->dev, "Can't get values when video not locked!\n");
+			return -EINVAL;
+		}
+		val = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		val &= XSDIRX_MODE_DET_STAT_RX_MODE_MASK;
+
+		switch (val) {
+		case XSDIRX_MODE_SD_MASK:
+			ctrl->val = XSDIRX_MODE_SD_OFFSET;
+			break;
+		case XSDIRX_MODE_HD_MASK:
+			ctrl->val = XSDIRX_MODE_HD_OFFSET;
+			break;
+		case XSDIRX_MODE_3G_MASK:
+			ctrl->val = XSDIRX_MODE_3G_OFFSET;
+			break;
+		case XSDIRX_MODE_6G_MASK:
+			ctrl->val = XSDIRX_MODE_6G_OFFSET;
+			break;
+		case XSDIRX_MODE_12GI_MASK:
+			ctrl->val = XSDIRX_MODE_12GI_OFFSET;
+			break;
+		case XSDIRX_MODE_12GF_MASK:
+			ctrl->val = XSDIRX_MODE_12GF_OFFSET;
+			break;
+		}
+		break;
+	case V4L2_CID_XILINX_SDIRX_CRC:
+		ctrl->val = xsdirxss_read(core, XSDIRX_CRC_ERRCNT_REG);
+		xsdirxss_write(core, XSDIRX_CRC_ERRCNT_REG, 0xFFFF);
+		break;
+	case V4L2_CID_XILINX_SDIRX_EDH_ERRCNT:
+		val = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		val &= XSDIRX_MODE_DET_STAT_RX_MODE_MASK;
+		if (val == XSDIRX_MODE_SD_MASK) {
+			ctrl->val = xsdirxss_read(core, XSDIRX_EDH_ERRCNT_REG);
+		} else {
+			dev_dbg(core->dev, "%d - not in SD mode\n", ctrl->id);
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_XILINX_SDIRX_EDH_STATUS:
+		val = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		val &= XSDIRX_MODE_DET_STAT_RX_MODE_MASK;
+		if (val == XSDIRX_MODE_SD_MASK) {
+			ctrl->val = xsdirxss_read(core, XSDIRX_EDH_STAT_REG);
+		} else {
+			dev_dbg(core->dev, "%d - not in SD mode\n", ctrl->id);
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_XILINX_SDIRX_TS_IS_INTERLACED:
+		if (!xsdirxss->vidlocked) {
+			dev_err(core->dev, "Can't get values when video not locked!\n");
+			return -EINVAL;
+		}
+		ctrl->val = xsdirxss->ts_is_interlaced;
+		break;
+	case V4L2_CID_XILINX_SDIRX_ACTIVE_STREAMS:
+		if (!xsdirxss->vidlocked) {
+			dev_err(core->dev, "Can't get values when video not locked!\n");
+			return -EINVAL;
+		}
+		val = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		val &= XSDIRX_MODE_DET_STAT_ACT_STREAM_MASK;
+		val >>= XSDIRX_MODE_DET_STAT_ACT_STREAM_OFFSET;
+		ctrl->val = 1 << val;
+		break;
+	case V4L2_CID_XILINX_SDIRX_IS_3GB:
+		if (!xsdirxss->vidlocked) {
+			dev_err(core->dev, "Can't get values when video not locked!\n");
+			return -EINVAL;
+		}
+		val = xsdirxss_read(core, XSDIRX_MODE_DET_STAT_REG);
+		val &= XSDIRX_MODE_DET_STAT_LVLB_3G_MASK;
+		ctrl->val = val ? true : false;
+		break;
+	case V4L2_CID_METADATA_HDR:
+		if (!xsdirxss->vidlocked) {
+			dev_err(core->dev, "Can't get values when video not locked!\n");
+			return -EINVAL;
+		}
+		hdr_ptr = (struct v4l2_metadata_hdr *)ctrl->p_new.p;
+		hdr_ptr->metadata_type = V4L2_HDR_TYPE_HDR10;
+		hdr_ptr->size = sizeof(struct v4l2_hdr10_payload);
+		memcpy(hdr_ptr->payload, &xsdirxss->static_hdr,
+		       hdr_ptr->size);
+		break;
+	default:
+		dev_err(core->dev, "Get Invalid control id 0x%0x\n", ctrl->id);
+		return -EINVAL;
+	}
+	dev_dbg(core->dev, "Get ctrl id = 0x%08x val = 0x%08x\n",
+		ctrl->id, ctrl->val);
+	return 0;
+}
+
+/**
+ * xsdirxss_log_status - Logs the status of the SDI Rx Subsystem
+ * @sd: Pointer to V4L2 subdevice structure
+ *
+ * This function prints the current status of Xilinx SDI Rx Subsystem
+ *
+ * Return: 0 on success
+ */
+static int xsdirxss_log_status(struct v4l2_subdev *sd)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	struct xsdirxss_core *core = &xsdirxss->core;
+	u32 i;
+
+	v4l2_info(sd, "***** SDI Rx subsystem reg dump start *****\n");
+	for (i = 0; i < 0x28; i++) {
+		u32 data;
+
+		data = xsdirxss_read(core, i * 4);
+		v4l2_info(sd, "offset 0x%08x data 0x%08x\n",
+			  i * 4, data);
+	}
+	v4l2_info(sd, "***** SDI Rx subsystem reg dump end *****\n");
+	return 0;
+}
+
+/**
+ * xsdirxss_g_frame_interval - Get the frame interval
+ * @sd: V4L2 Sub device
+ * @fi: Pointer to V4l2 Sub device frame interval structure
+ *
+ * This function is used to get the frame interval.
+ * The frame rate can be integral or fractional.
+ * Integral frame rate e.g. numerator = 1000, denominator = 24000 => 24 fps
+ * Fractional frame rate e.g. numerator = 1001, denominator = 24000 => 23.97 fps
+ *
+ * Return: 0 on success
+ */
+static int xsdirxss_g_frame_interval(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_frame_interval *fi)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	struct xsdirxss_core *core = &xsdirxss->core;
+
+	if (!xsdirxss->vidlocked) {
+		dev_err(core->dev, "Video not locked!\n");
+		return -EINVAL;
+	}
+
+	fi->interval = xsdirxss->frame_interval;
+
+	dev_dbg(core->dev, "frame rate numerator = %d denominator = %d\n",
+		xsdirxss->frame_interval.numerator,
+		xsdirxss->frame_interval.denominator);
+	return 0;
+}
+
+/**
+ * xsdirxss_s_stream - It is used to start/stop the streaming.
+ * @sd: V4L2 Sub device
+ * @enable: Flag (True / False)
+ *
+ * This function controls the start or stop of streaming for the
+ * Xilinx SDI Rx Subsystem.
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int xsdirxss_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	struct xsdirxss_core *core = &xsdirxss->core;
+
+	if (enable) {
+		if (!xsdirxss->vidlocked) {
+			dev_dbg(core->dev, "Video is not locked\n");
+			return -EINVAL;
+		}
+		if (xsdirxss->streaming) {
+			dev_dbg(core->dev, "Already streaming\n");
+			return -EINVAL;
+		}
+
+		xsdirx_streamflow_control(core, true);
+		xsdirxss->streaming = true;
+		xsdirxss->s_stream = true;
+		dev_dbg(core->dev, "Streaming started\n");
+	} else {
+		xsdirxss->s_stream = false;
+		if (!xsdirxss->streaming) {
+			dev_dbg(core->dev, "Stopped streaming already\n");
+			return 0;
+		}
+
+		xsdirx_streamflow_control(core, false);
+		xsdirxss->streaming = false;
+		dev_dbg(core->dev, "Streaming stopped\n");
+	}
+
+	return 0;
+}
+
+/**
+ * xsdirxss_g_input_status - It is used to determine if the video signal
+ * is present / locked onto or not.
+ *
+ * @sd: V4L2 Sub device
+ * @status: status of signal locked
+ *
+ * This is used to determine if the video signal is present and locked onto
+ * by the SDI Rx core or not based on vidlocked flag.
+ *
+ * Return: zero on success
+ */
+static int xsdirxss_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+
+	if (!xsdirxss->vidlocked)
+		*status = V4L2_IN_ST_NO_SYNC | V4L2_IN_ST_NO_SIGNAL;
+	else
+		*status = 0;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__xsdirxss_get_pad_format(struct xsdirxss_state *xsdirxss,
+			  struct v4l2_subdev_state *sd_state,
+			  unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xsdirxss->subdev,
+						    sd_state,
+						    pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xsdirxss->format;
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+/**
+ * xsdirxss_get_format - Get the pad format
+ * @sd: Pointer to V4L2 Sub device structure
+ * @sd_state: Pointer to v4l2_subdev_state structure
+ * @fmt: Pointer to pad level media bus format
+ *
+ * This function is used to get the pad format information.
+ *
+ * Return: 0 on success
+ */
+static int xsdirxss_get_format(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	struct xsdirxss_core *core = &xsdirxss->core;
+	struct v4l2_mbus_framefmt *format;
+
+	if (!xsdirxss->vidlocked) {
+		dev_err(core->dev, "Video not locked!\n");
+		return -EINVAL;
+	}
+
+	format = __xsdirxss_get_pad_format(xsdirxss, sd_state,
+					   fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	dev_dbg(core->dev, "Stream width = %d height = %d Field = %d\n",
+		fmt->format.width, fmt->format.height, fmt->format.field);
+
+	return 0;
+}
+
+/**
+ * xsdirxss_set_format - This is used to set the pad format
+ * @sd: Pointer to V4L2 Sub device structure
+ * @sd_state: Pointer to v4l2_subdev_state structure
+ * @fmt: Pointer to pad level media bus format
+ *
+ * This function is used to set the pad format.
+ * Since the pad format is fixed in hardware, it can't be
+ * modified on run time.
+ *
+ * Return: 0 on success
+ */
+static int xsdirxss_set_format(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *__format;
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+
+	dev_dbg(xsdirxss->core.dev,
+		"set width %d height %d code %d field %d colorspace %d\n",
+		fmt->format.width, fmt->format.height,
+		fmt->format.code, fmt->format.field,
+		fmt->format.colorspace);
+
+	__format = __xsdirxss_get_pad_format(xsdirxss, sd_state,
+					     fmt->pad, fmt->which);
+	if (!__format)
+		return -EINVAL;
+
+	/* Currently reset the code to one fixed in hardware */
+	/* TODO : Add checks for width height */
+	fmt->format.code = __format->code;
+
+	return 0;
+}
+
+/**
+ * xsdirxss_enum_mbus_code - Handle pixel format enumeration
+ * @sd: pointer to v4l2 subdev structure
+ * @sd_state: Pointer to v4l2_subdev_state structure
+ * @code: pointer to v4l2_subdev_mbus_code_enum structure
+ *
+ * Return: -EINVAL or zero on success
+ */
+static int xsdirxss_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+	u32 index = code->index;
+
+	if (code->pad || index >= 4)
+		return -EINVAL;
+
+	if (xsdirxss->core.bpc == 12)
+		code->code = xsdirxss_12bpc_mbus_fmts[index];
+	else
+		code->code = xsdirxss_10bpc_mbus_fmts[index];
+
+	return 0;
+}
+
+/**
+ * xsdirxss_enum_dv_timings: Enumerate all the supported DV timings
+ * @sd: pointer to v4l2 subdev structure
+ * @timings: DV timings structure to be returned.
+ *
+ * Return: -EINVAL incase of invalid index and pad or zero on success
+ */
+static int xsdirxss_enum_dv_timings(struct v4l2_subdev *sd,
+				    struct v4l2_enum_dv_timings *timings)
+{
+	if (timings->index >= ARRAY_SIZE(fmt_cap))
+		return -EINVAL;
+
+	if (timings->pad != 0)
+		return -EINVAL;
+
+	timings->timings = fmt_cap[timings->index];
+	return 0;
+}
+
+/**
+ * xsdirxss_query_dv_timings: Query for the current DV timings
+ * @sd: pointer to v4l2 subdev structure
+ * @timings: DV timings structure to be returned.
+ *
+ * Return: -ENOLCK when video is not locked, -ERANGE when corresponding timing
+ * entry is not found or zero on success.
+ */
+static int xsdirxss_query_dv_timings(struct v4l2_subdev *sd,
+				     struct v4l2_dv_timings *timings)
+{
+	struct xsdirxss_state *state = to_xsdirxssstate(sd);
+	unsigned int i;
+
+	if (!state->vidlocked)
+		return -ENOLCK;
+
+	for (i = 0; i < ARRAY_SIZE(xsdirxss_dv_timings); i++) {
+		if (state->format.width == xsdirxss_dv_timings[i].width &&
+		    state->format.height == xsdirxss_dv_timings[i].height &&
+		    state->frame_interval.denominator ==
+		    (xsdirxss_dv_timings[i].fps * 1000)) {
+			*timings = xsdirxss_dv_timings[i].format;
+			return 0;
+		}
+	}
+
+	return -ERANGE;
+}
+
+/**
+ * xsdirxss_open - Called on v4l2_open()
+ * @sd: Pointer to V4L2 sub device structure
+ * @fh: Pointer to V4L2 File handle
+ *
+ * This function is called on v4l2_open(). It sets the default format for pad.
+ *
+ * Return: 0 on success
+ */
+static int xsdirxss_open(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_mbus_framefmt *format;
+	struct xsdirxss_state *xsdirxss = to_xsdirxssstate(sd);
+
+	format = v4l2_subdev_get_try_format(sd, fh->state, 0);
+	*format = xsdirxss->default_format;
+
+	return 0;
+}
+
+/**
+ * xsdirxss_close - Called on v4l2_close()
+ * @sd: Pointer to V4L2 sub device structure
+ * @fh: Pointer to V4L2 File handle
+ *
+ * This function is called on v4l2_close().
+ *
+ * Return: 0 on success
+ */
+static int xsdirxss_close(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xsdirxss_media_ops = {
+	.link_validate = v4l2_subdev_link_validate
+};
+
+static const struct v4l2_ctrl_ops xsdirxss_ctrl_ops = {
+	.g_volatile_ctrl = xsdirxss_g_volatile_ctrl,
+	.s_ctrl	= xsdirxss_s_ctrl
+};
+
+static const struct v4l2_ctrl_config xsdirxss_edh_ctrls[] = {
+	{
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_EDH_ERRCNT_ENABLE,
+		.name	= "SDI Rx : EDH Error Count Enable",
+		.type	= V4L2_CTRL_TYPE_BITMASK,
+		.min	= 0,
+		.max	= XSDIRX_EDH_ALLERR_MASK,
+		.def	= 0,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_EDH_ERRCNT,
+		.name	= "SDI Rx : EDH Error Count",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= 0xFFFF,
+		.step	= 1,
+		.def	= 0,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_EDH_STATUS,
+		.name	= "SDI Rx : EDH Status",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= 0xFFFFFFFF,
+		.step	= 1,
+		.def	= 0,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}
+};
+
+static const struct v4l2_ctrl_config xsdirxss_ctrls[] = {
+	{
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_FRAMER,
+		.name	= "SDI Rx : Enable Framer",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= true,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_VIDLOCK_WINDOW,
+		.name	= "SDI Rx : Video Lock Window",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= 0xFFFFFFFF,
+		.step	= 1,
+		.def	= XSDIRX_DEFAULT_VIDEO_LOCK_WINDOW,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_SEARCH_MODES,
+		.name	= "SDI Rx : Modes search Mask",
+		.type	= V4L2_CTRL_TYPE_BITMASK,
+		.min	= 0,
+		.max	= XSDIRX_DETECT_ALL_MODES,
+		.def	= XSDIRX_DETECT_ALL_MODES,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_MODE_DETECT,
+		.name	= "SDI Rx : Mode Detect Status",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= XSDIRX_MODE_SD_OFFSET,
+		.max	= XSDIRX_MODE_12GF_OFFSET,
+		.step	= 1,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_CRC,
+		.name	= "SDI Rx : CRC Error status",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 0,
+		.max	= 0xFFFFFFFF,
+		.step	= 1,
+		.def	= 0,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_TS_IS_INTERLACED,
+		.name	= "SDI Rx : TS is Interlaced",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.def	= false,
+		.step	= 1,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_ACTIVE_STREAMS,
+		.name	= "SDI Rx : Active Streams",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= 1,
+		.max	= 16,
+		.def	= 1,
+		.step	= 1,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_XILINX_SDIRX_IS_3GB,
+		.name	= "SDI Rx : Is 3GB",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.def	= false,
+		.step	= 1,
+		.flags  = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops	= &xsdirxss_ctrl_ops,
+		.id	= V4L2_CID_METADATA_HDR,
+		.name	= "HDR Controls",
+		.type	= V4L2_CTRL_TYPE_HDR,
+		.min	= 0x8000000000000000,
+		.max	= 0x7FFFFFFFFFFFFFFF,
+		.step	= 1,
+		.def	= 0,
+		.elem_size = sizeof(struct v4l2_metadata_hdr),
+		.flags	= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			V4L2_CTRL_FLAG_READ_ONLY,
+	},
+};
+
+static const struct v4l2_subdev_core_ops xsdirxss_core_ops = {
+	.log_status = xsdirxss_log_status,
+	.subscribe_event = xsdirxss_subscribe_event,
+	.unsubscribe_event = xsdirxss_unsubscribe_event
+};
+
+static const struct v4l2_subdev_video_ops xsdirxss_video_ops = {
+	.g_frame_interval = xsdirxss_g_frame_interval,
+	.s_stream = xsdirxss_s_stream,
+	.g_input_status = xsdirxss_g_input_status,
+	.query_dv_timings = xsdirxss_query_dv_timings,
+};
+
+static const struct v4l2_subdev_pad_ops xsdirxss_pad_ops = {
+	.get_fmt = xsdirxss_get_format,
+	.set_fmt = xsdirxss_set_format,
+	.enum_mbus_code = xsdirxss_enum_mbus_code,
+	.enum_dv_timings = xsdirxss_enum_dv_timings,
+};
+
+static const struct v4l2_subdev_ops xsdirxss_ops = {
+	.core = &xsdirxss_core_ops,
+	.video = &xsdirxss_video_ops,
+	.pad = &xsdirxss_pad_ops
+};
+
+static const struct v4l2_subdev_internal_ops xsdirxss_internal_ops = {
+	.open = xsdirxss_open,
+	.close = xsdirxss_close
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xsdirxss_parse_of(struct xsdirxss_state *xsdirxss)
+{
+	struct device_node *node = xsdirxss->core.dev->of_node;
+	struct device_node *ports = NULL;
+	struct device_node *port = NULL;
+	unsigned int nports = 0;
+	struct xsdirxss_core *core = &xsdirxss->core;
+	int ret;
+	const char *sdi_std;
+
+	core->include_edh = of_property_read_bool(node, "xlnx,include-edh");
+	dev_dbg(core->dev, "EDH property = %s\n",
+		core->include_edh ? "Present" : "Absent");
+
+	ret = of_property_read_string(node, "xlnx,line-rate", &sdi_std);
+	if (ret < 0) {
+		dev_err(core->dev, "xlnx,line-rate property not found\n");
+		return ret;
+	}
+
+	if (!strncmp(sdi_std, "12G_SDI_8DS", XSDIRX_MAX_STR_LENGTH)) {
+		core->mode = XSDIRXSS_SDI_STD_12G_8DS;
+	} else if (!strncmp(sdi_std, "6G_SDI", XSDIRX_MAX_STR_LENGTH)) {
+		core->mode = XSDIRXSS_SDI_STD_6G;
+	} else if (!strncmp(sdi_std, "3G_SDI", XSDIRX_MAX_STR_LENGTH)) {
+		core->mode = XSDIRXSS_SDI_STD_3G;
+	} else {
+		dev_err(core->dev, "Invalid Line Rate\n");
+		return -EINVAL;
+	}
+	dev_dbg(core->dev, "SDI Rx Line Rate = %s, mode = %d\n", sdi_std,
+		core->mode);
+
+	ret = of_property_read_u32(node, "xlnx,bpp", &core->bpc);
+	if (ret < 0) {
+		if (ret != -EINVAL) {
+			dev_err(core->dev, "failed to get xlnx,bpp\n");
+			return ret;
+		}
+
+		/*
+		 * For backward compatibility, set default bpc as 10
+		 * in case xlnx,bpp is not present.
+		 */
+		core->bpc = 10;
+	}
+
+	if (core->bpc != 10 && core->bpc != 12) {
+		dev_err(core->dev, "bits per component=%u. Can be 10 or 12 only\n",
+			core->bpc);
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		const struct xvip_video_format *format;
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		format = xvip_of_get_format(port);
+		if (IS_ERR(format)) {
+			dev_err(core->dev, "invalid format in DT");
+			return PTR_ERR(format);
+		}
+
+		dev_dbg(core->dev, "vf_code = %d bpc = %d bpp = %d\n",
+			format->vf_code, format->width, format->bpp);
+
+		if (format->vf_code != XVIP_VF_YUV_422 &&
+		    format->vf_code != XVIP_VF_YUV_420 &&
+		    format->vf_code != XVIP_VF_YUV_444 &&
+		    format->vf_code != XVIP_VF_RBG &&
+		    ((core->bpc == 10 && format->width != 10) ||
+		     (core->bpc == 12 && format->width != 12))) {
+			dev_err(core->dev,
+				"Incorrect UG934 video format set.\n");
+			return -EINVAL;
+		}
+		xsdirxss->vip_format = format;
+
+		endpoint = of_get_next_child(port, NULL);
+		if (!endpoint) {
+			dev_err(core->dev, "No port at\n");
+			return -EINVAL;
+		}
+
+		/* Count the number of ports. */
+		nports++;
+	}
+
+	if (nports != 1) {
+		dev_err(core->dev, "invalid number of ports %u\n", nports);
+		return -EINVAL;
+	}
+
+	/* Register interrupt handler */
+	core->irq = irq_of_parse_and_map(node, 0);
+	ret = devm_request_threaded_irq(core->dev, core->irq, NULL,
+					xsdirxss_irq_handler, IRQF_ONESHOT,
+					"xilinx-sdirxss", xsdirxss);
+	if (ret) {
+		dev_err(core->dev, "Err = %d Interrupt handler reg failed!\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int xsdirxss_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xsdirxss_state *xsdirxss;
+	struct xsdirxss_core *core;
+	struct resource *res;
+	int ret;
+	unsigned int num_ctrls, num_edh_ctrls = 0, i;
+
+	xsdirxss = devm_kzalloc(&pdev->dev, sizeof(*xsdirxss), GFP_KERNEL);
+	if (!xsdirxss)
+		return -ENOMEM;
+
+	xsdirxss->core.dev = &pdev->dev;
+	core = &xsdirxss->core;
+
+	core->rst_gt_gpio = devm_gpiod_get_optional(&pdev->dev, "reset_gt",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(core->rst_gt_gpio)) {
+		ret = PTR_ERR(core->rst_gt_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Reset GT GPIO not setup in DT\n");
+		return ret;
+	}
+
+	core->rst_picxo_gpio = devm_gpiod_get_optional(&pdev->dev,
+						       "picxo_reset",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(core->rst_picxo_gpio)) {
+		ret = PTR_ERR(core->rst_picxo_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "PICXO Reset GPIO not setup in DT\n");
+		return ret;
+	}
+
+	core->num_clks = ARRAY_SIZE(xsdirxss_clks);
+	core->clks = devm_kcalloc(&pdev->dev, core->num_clks,
+				  sizeof(*core->clks), GFP_KERNEL);
+	if (!core->clks)
+		return -ENOMEM;
+
+	for (i = 0; i < core->num_clks; i++)
+		core->clks[i].id = xsdirxss_clks[i];
+
+	ret = devm_clk_bulk_get(&pdev->dev, core->num_clks, core->clks);
+	if (ret)
+		return ret;
+
+	ret = clk_bulk_prepare_enable(core->num_clks, core->clks);
+	if (ret)
+		return ret;
+
+	ret = xsdirxss_parse_of(xsdirxss);
+	if (ret < 0)
+		goto clk_err;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xsdirxss->core.iomem = devm_ioremap_resource(xsdirxss->core.dev, res);
+	if (IS_ERR(xsdirxss->core.iomem)) {
+		ret = PTR_ERR(xsdirxss->core.iomem);
+		goto clk_err;
+	}
+
+	/* Reset the core */
+	xsdirx_streamflow_control(core, false);
+	xsdirx_core_disable(core);
+	xsdirx_clearintr(core, XSDIRX_INTR_ALL_MASK);
+	xsdirx_disableintr(core, XSDIRX_INTR_ALL_MASK);
+	xsdirx_enableintr(core, XSDIRX_INTR_ALL_MASK);
+	xsdirx_globalintr(core, true);
+	xsdirxss_write(core, XSDIRX_CRC_ERRCNT_REG, 0xFFFF);
+
+	/* Initialize V4L2 subdevice and media entity */
+	xsdirxss->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize the default format */
+	xsdirxss->default_format.code = xsdirxss->vip_format->code;
+	xsdirxss->default_format.field = V4L2_FIELD_NONE;
+	xsdirxss->default_format.colorspace = V4L2_COLORSPACE_DEFAULT;
+	xsdirxss->default_format.width = XSDIRX_DEFAULT_WIDTH;
+	xsdirxss->default_format.height = XSDIRX_DEFAULT_HEIGHT;
+
+	xsdirxss->format = xsdirxss->default_format;
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xsdirxss->subdev;
+	v4l2_subdev_init(subdev, &xsdirxss_ops);
+
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xsdirxss_internal_ops;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	subdev->entity.ops = &xsdirxss_media_ops;
+
+	v4l2_set_subdevdata(subdev, xsdirxss);
+
+	ret = media_entity_pads_init(&subdev->entity, 1, &xsdirxss->pad);
+	if (ret < 0)
+		goto error;
+
+	/* Initialise and register the controls */
+	num_ctrls = ARRAY_SIZE(xsdirxss_ctrls);
+
+	if (xsdirxss->core.include_edh)
+		num_edh_ctrls = ARRAY_SIZE(xsdirxss_edh_ctrls);
+
+	v4l2_ctrl_handler_init(&xsdirxss->ctrl_handler,
+			       (num_ctrls + num_edh_ctrls));
+
+	for (i = 0; i < num_ctrls; i++) {
+		struct v4l2_ctrl *ctrl;
+
+		dev_dbg(xsdirxss->core.dev, "%d %s ctrl = 0x%x\n",
+			i, xsdirxss_ctrls[i].name, xsdirxss_ctrls[i].id);
+
+		ctrl = v4l2_ctrl_new_custom(&xsdirxss->ctrl_handler,
+					    &xsdirxss_ctrls[i], NULL);
+		if (!ctrl) {
+			dev_dbg(xsdirxss->core.dev, "Failed to add %s ctrl\n",
+				xsdirxss_ctrls[i].name);
+			goto error;
+		}
+	}
+
+	if (xsdirxss->core.include_edh) {
+		for (i = 0; i < num_edh_ctrls; i++) {
+			struct v4l2_ctrl *ctrl;
+
+			dev_dbg(xsdirxss->core.dev, "%d %s ctrl = 0x%x\n",
+				i, xsdirxss_edh_ctrls[i].name,
+				xsdirxss_edh_ctrls[i].id);
+
+			ctrl = v4l2_ctrl_new_custom(&xsdirxss->ctrl_handler,
+						    &xsdirxss_edh_ctrls[i],
+						    NULL);
+			if (!ctrl) {
+				dev_dbg(xsdirxss->core.dev, "Failed to add %s ctrl\n",
+					xsdirxss_edh_ctrls[i].name);
+				goto error;
+			}
+		}
+	}
+
+	if (xsdirxss->ctrl_handler.error) {
+		dev_err(&pdev->dev, "failed to add controls\n");
+		ret = xsdirxss->ctrl_handler.error;
+		goto error;
+	}
+
+	subdev->ctrl_handler = &xsdirxss->ctrl_handler;
+
+	ret = v4l2_ctrl_handler_setup(&xsdirxss->ctrl_handler);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to set controls\n");
+		goto error;
+	}
+
+	platform_set_drvdata(pdev, xsdirxss);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	xsdirxss->streaming = false;
+	xsdirxss->s_stream = false;
+
+	xsdirx_core_enable(core);
+
+	dev_info(xsdirxss->core.dev, "Xilinx SDI Rx Subsystem device found!\n");
+
+	return 0;
+error:
+	v4l2_ctrl_handler_free(&xsdirxss->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	xsdirx_globalintr(core, false);
+	xsdirx_disableintr(core, XSDIRX_INTR_ALL_MASK);
+clk_err:
+	clk_bulk_disable_unprepare(core->num_clks, core->clks);
+	return ret;
+}
+
+static int xsdirxss_remove(struct platform_device *pdev)
+{
+	struct xsdirxss_state *xsdirxss = platform_get_drvdata(pdev);
+	struct xsdirxss_core *core = &xsdirxss->core;
+	struct v4l2_subdev *subdev = &xsdirxss->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xsdirxss->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	xsdirx_globalintr(core, false);
+	xsdirx_disableintr(core, XSDIRX_INTR_ALL_MASK);
+	xsdirx_core_disable(core);
+	xsdirx_streamflow_control(core, false);
+
+	clk_bulk_disable_unprepare(core->num_clks, core->clks);
+
+	return 0;
+}
+
+static const struct of_device_id xsdirxss_of_id_table[] = {
+	{ .compatible = "xlnx,v-smpte-uhdsdi-rx-ss" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xsdirxss_of_id_table);
+
+static struct platform_driver xsdirxss_driver = {
+	.driver = {
+		.name		= "xilinx-sdirxss",
+		.of_match_table	= xsdirxss_of_id_table,
+	},
+	.probe			= xsdirxss_probe,
+	.remove			= xsdirxss_remove,
+};
+
+module_platform_driver(xsdirxss_driver);
+
+MODULE_AUTHOR("Vishal Sagar <vsagar@xilinx.com>");
+MODULE_DESCRIPTION("Xilinx SDI Rx Subsystem Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-switch.c b/drivers/media/platform/xilinx/xilinx-switch.c
new file mode 100644
index 000000000..07273c3ce
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-switch.c
@@ -0,0 +1,476 @@
+/*
+ * Xilinx Video Switch
+ *
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/media-device.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XSW_CORE_CH_CTRL			0x0100
+#define XSW_CORE_CH_CTRL_FORCE			(1 << 3)
+
+#define XSW_SWITCH_STATUS			0x0104
+
+/**
+ * struct xswitch_device - Xilinx Video Switch device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @nsinks: number of sink pads (2 to 8)
+ * @nsources: number of source pads (1 to 8)
+ * @routing: sink pad connected to each source pad (-1 if none)
+ * @formats: active V4L2 media bus formats on sink pads
+ */
+struct xswitch_device {
+	struct xvip_device xvip;
+
+	struct media_pad *pads;
+	unsigned int nsinks;
+	unsigned int nsources;
+
+	int routing[8];
+
+	struct v4l2_mbus_framefmt *formats;
+};
+
+static inline struct xswitch_device *to_xsw(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xswitch_device, xvip.subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Video Operations
+ */
+
+static int xsw_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xswitch_device *xsw = to_xsw(subdev);
+	unsigned int unused_input;
+	unsigned int i;
+	u32 routing;
+
+	if (!enable) {
+		xvip_stop(&xsw->xvip);
+		return 0;
+	}
+
+	/*
+	 * All outputs must be routed to an input. When less than 8 inputs are
+	 * synthesized we can use input 7 for that purpose. Otherwise find an
+	 * unused input to connect to unused outputs.
+	 */
+	if (xsw->nsinks == 8) {
+		u32 mask;
+
+		for (i = 0, mask = 0xff; i < xsw->nsources; ++i) {
+			if (xsw->routing[i] != -1)
+				mask &= ~BIT(xsw->routing[i]);
+		}
+
+		/*
+		 * If all inputs are used all outputs are also used. We don't
+		 * need an unused input in that case, use a zero value.
+		 */
+		unused_input = mask ? ffs(mask) - 1 : 0;
+	} else {
+		unused_input = 7;
+	}
+
+	/* Configure routing. */
+	for (i = 0, routing = 0; i < xsw->nsources; ++i) {
+		unsigned int route;
+
+		route = xsw->routing[i] == -1 ?  unused_input : xsw->routing[i];
+		routing |= (XSW_CORE_CH_CTRL_FORCE | route)
+			<< (i * 4);
+	}
+
+	xvip_write(&xsw->xvip, XSW_CORE_CH_CTRL, routing);
+
+	xvip_write(&xsw->xvip, XVIP_CTRL_CONTROL,
+		   ((((unsigned long)1 << xsw->nsources) - 1) << 4) |
+		   XVIP_CTRL_CONTROL_SW_ENABLE);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+xsw_get_pad_format(struct xswitch_device *xsw,
+		   struct v4l2_subdev_state *sd_state,
+		   unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xsw->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xsw->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xsw_get_format(struct v4l2_subdev *subdev,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct xswitch_device *xsw = to_xsw(subdev);
+	int pad = fmt->pad;
+	struct v4l2_mbus_framefmt *format;
+
+	if (pad >= xsw->nsinks) {
+		pad = xsw->routing[pad - xsw->nsinks];
+		if (pad < 0) {
+			memset(&fmt->format, 0, sizeof(fmt->format));
+			return 0;
+		}
+	}
+
+	format = xsw_get_pad_format(xsw, sd_state, pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xsw_set_format(struct v4l2_subdev *subdev,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct xswitch_device *xsw = to_xsw(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* The source pad format is always identical to the sink pad format and
+	 * can't be modified.
+	 */
+	if (fmt->pad >= xsw->nsinks)
+		return xsw_get_format(subdev, sd_state, fmt);
+
+	format = xsw_get_pad_format(xsw, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	format->code = fmt->format.code;
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xsw_get_routing(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_routing *route)
+{
+	struct xswitch_device *xsw = to_xsw(subdev);
+	unsigned int i;
+
+	mutex_lock(&subdev->entity.graph_obj.mdev->graph_mutex);
+
+	for (i = 0; i < min(xsw->nsources, route->num_routes); ++i) {
+		route->routes[i].sink = xsw->routing[i];
+		route->routes[i].source = i;
+	}
+
+	route->num_routes = xsw->nsources;
+
+	mutex_unlock(&subdev->entity.graph_obj.mdev->graph_mutex);
+
+	return 0;
+}
+
+static int xsw_set_routing(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_routing *route)
+{
+	struct xswitch_device *xsw = to_xsw(subdev);
+	unsigned int i;
+	int ret = 0;
+
+	mutex_lock(&subdev->entity.graph_obj.mdev->graph_mutex);
+
+	if (media_entity_is_streaming(&subdev->entity)) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	for (i = 0; i < xsw->nsources; ++i)
+		xsw->routing[i] = -1;
+
+	for (i = 0; i < route->num_routes; ++i)
+		xsw->routing[route->routes[i].source - xsw->nsinks] =
+			route->routes[i].sink;
+
+done:
+	mutex_unlock(&subdev->entity.graph_obj.mdev->graph_mutex);
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+/**
+ * xsw_init_formats - Initialize formats on all pads
+ * @subdev: tpgper V4L2 subdevice
+ * @fh: V4L2 subdev file handle
+ *
+ * Initialize all pad formats with default values. If fh is not NULL, try
+ * formats are initialized on the file handle. Otherwise active formats are
+ * initialized on the device.
+ *
+ * The function sets the format on pad 0 only. In two pads mode, this is the
+ * sink pad and the set format handler will propagate the format to the source
+ * pad. In one pad mode this is the source pad.
+ */
+static void xsw_init_formats(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_fh *fh)
+{
+	struct xswitch_device *xsw = to_xsw(subdev);
+	struct v4l2_subdev_format format;
+	unsigned int i;
+
+	for (i = 0; i < xsw->nsinks; ++i) {
+		memset(&format, 0, sizeof(format));
+
+		format.pad = 0;
+		format.which = fh ? V4L2_SUBDEV_FORMAT_TRY
+			     : V4L2_SUBDEV_FORMAT_ACTIVE;
+		format.format.width = 1920;
+		format.format.height = 1080;
+
+		xsw_set_format(subdev, fh ? fh->state : NULL, &format);
+	}
+}
+
+static int xsw_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	xsw_init_formats(subdev, fh);
+
+	return 0;
+}
+
+static int xsw_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops xsw_video_ops = {
+	.s_stream = xsw_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xsw_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xsw_get_format,
+	.set_fmt = xsw_set_format,
+	.get_routing = xsw_get_routing,
+	.set_routing = xsw_set_routing,
+};
+
+static struct v4l2_subdev_ops xsw_ops = {
+	.video = &xsw_video_ops,
+	.pad = &xsw_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xsw_internal_ops = {
+	.open = xsw_open,
+	.close = xsw_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static bool xsw_has_route(struct media_entity *entity, unsigned int pad0,
+			  unsigned int pad1)
+{
+	struct xswitch_device *xsw = container_of(entity, struct xswitch_device,
+						  xvip.subdev.entity);
+	unsigned int sink0, sink1;
+
+	/* Two sinks are never connected together. */
+	if (pad0 < xsw->nsinks && pad1 < xsw->nsinks)
+		return false;
+
+	sink0 = pad0 < xsw->nsinks ? pad0 : xsw->routing[pad0 - xsw->nsinks];
+	sink1 = pad1 < xsw->nsinks ? pad1 : xsw->routing[pad1 - xsw->nsinks];
+
+	return sink0 == sink1;
+}
+
+static const struct media_entity_operations xsw_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+	.has_route = xsw_has_route,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xsw_parse_of(struct xswitch_device *xsw)
+{
+	struct device_node *node = xsw->xvip.dev->of_node;
+	int ret;
+
+	ret = of_property_read_u32(node, "#xlnx,inputs", &xsw->nsinks);
+	if (ret < 0) {
+		dev_err(xsw->xvip.dev, "missing or invalid #xlnx,%s property\n",
+			"inputs");
+		return ret;
+	}
+
+	ret = of_property_read_u32(node, "#xlnx,outputs", &xsw->nsources);
+	if (ret < 0) {
+		dev_err(xsw->xvip.dev, "missing or invalid #xlnx,%s property\n",
+			"outputs");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int xsw_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct xswitch_device *xsw;
+	unsigned int npads;
+	unsigned int i;
+	int ret;
+
+	xsw = devm_kzalloc(&pdev->dev, sizeof(*xsw), GFP_KERNEL);
+	if (!xsw)
+		return -ENOMEM;
+
+	xsw->xvip.dev = &pdev->dev;
+
+	ret = xsw_parse_of(xsw);
+	if (ret < 0)
+		return ret;
+
+	ret = xvip_init_resources(&xsw->xvip);
+	if (ret < 0)
+		return ret;
+
+	/* Initialize V4L2 subdevice and media entity. Pad numbers depend on the
+	 * number of pads.
+	 */
+	npads = xsw->nsinks + xsw->nsources;
+	xsw->pads = devm_kzalloc(&pdev->dev, npads * sizeof(*xsw->pads),
+				 GFP_KERNEL);
+	if (!xsw->pads)
+		goto error_resources;
+
+	for (i = 0; i < xsw->nsinks; ++i)
+		xsw->pads[i].flags = MEDIA_PAD_FL_SINK;
+	for (; i < npads; ++i)
+		xsw->pads[i].flags = MEDIA_PAD_FL_SOURCE;
+
+	xsw->formats = devm_kzalloc(&pdev->dev,
+				    xsw->nsinks * sizeof(*xsw->formats),
+				    GFP_KERNEL);
+	if (!xsw->formats)
+		goto error_resources;
+
+	for (i = 0; i < xsw->nsources; ++i)
+		xsw->routing[i] = i < xsw->nsinks ? i : -1;
+
+	subdev = &xsw->xvip.subdev;
+	v4l2_subdev_init(subdev, &xsw_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xsw_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xsw);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	subdev->entity.ops = &xsw_media_ops;
+
+	xsw_init_formats(subdev, NULL);
+
+	ret = media_entity_pads_init(&subdev->entity, npads, xsw->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xsw);
+
+	xvip_print_version(&xsw->xvip);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+error_resources:
+	xvip_cleanup_resources(&xsw->xvip);
+	return ret;
+}
+
+static int xsw_remove(struct platform_device *pdev)
+{
+	struct xswitch_device *xsw = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xsw->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	xvip_cleanup_resources(&xsw->xvip);
+
+	return 0;
+}
+
+static const struct of_device_id xsw_of_id_table[] = {
+	{ .compatible = "xlnx,v-switch-1.0" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xsw_of_id_table);
+
+static struct platform_driver xsw_driver = {
+	.driver = {
+		.name		= "xilinx-switch",
+		.of_match_table	= xsw_of_id_table,
+	},
+	.probe			= xsw_probe,
+	.remove			= xsw_remove,
+};
+
+module_platform_driver(xsw_driver);
+
+MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_DESCRIPTION("Xilinx Video Switch Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-tpg.c b/drivers/media/platform/xilinx/xilinx-tpg.c
index 0f2d5a0ed..cfac264a8 100644
--- a/drivers/media/platform/xilinx/xilinx-tpg.c
+++ b/drivers/media/platform/xilinx/xilinx-tpg.c
@@ -20,6 +20,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
+#include "xilinx-hls-common.h"
 #include "xilinx-vip.h"
 #include "xilinx-vtc.h"
 
@@ -58,6 +59,36 @@
 #define XTPG_BAYER_PHASE_BGGR			3
 #define XTPG_BAYER_PHASE_OFF			4
 
+/* TPG v7 is a completely redesigned IP using Vivado HLS
+ * having a different AXI4-Lite interface
+ */
+#define XTPG_HLS_BG_PATTERN			0x0020
+#define XTPG_HLS_FG_PATTERN			0x0028
+#define XTPG_HLS_FG_PATTERN_CROSS_HAIR		(1 << 1)
+#define XTPG_HLS_MASK_ID			0x0030
+#define XTPG_HLS_MOTION_SPEED			0x0038
+#define XTPG_HLS_COLOR_FORMAT			0x0040
+#define XTPG_HLS_COLOR_FORMAT_RGB		0
+#define XTPG_HLS_COLOR_FORMAT_YUV_444		1
+#define XTPG_HLS_COLOR_FORMAT_YUV_422		2
+#define XTPG_HLS_COLOR_FORMAT_YUV_420		3
+#define XTPG_HLS_CROSS_HAIR_HOR			0x0048
+#define XTPG_HLS_CROSS_HAIR_VER			0x0050
+#define XTPG_HLS_ZPLATE_HOR_CNTL_START		0x0058
+#define XTPG_HLS_ZPLATE_HOR_CNTL_DELTA		0x0060
+#define XTPG_HLS_ZPLATE_VER_CNTL_START		0x0068
+#define XTPG_HLS_ZPLATE_VER_CNTL_DELTA		0x0070
+#define XTPG_HLS_BOX_SIZE			0x0078
+#define XTPG_HLS_BOX_COLOR_RED_CB		0x0080
+#define XTPG_HLS_BOX_COLOR_GREEN_CR		0x0088
+#define XTPG_HLS_BOX_COLOR_BLUE_Y		0x0090
+#define XTPG_HLS_ENABLE_INPUT			0x0098
+#define XTPG_HLS_USE_INPUT_VID_STREAM		(1 << 0)
+#define XTPG_HLS_PASS_THRU_START_X		0x00a0
+#define XTPG_HLS_PASS_THRU_START_Y		0x00a8
+#define XTPG_HLS_PASS_THRU_END_X		0x00b0
+#define XTPG_HLS_PASS_THRU_END_Y		0x00b8
+
 /*
  * The minimum blanking value is one clock cycle for the front porch, one clock
  * cycle for the sync pulse and one clock cycle for the back porch.
@@ -67,6 +98,15 @@
 #define XTPG_MIN_VBLANK			3
 #define XTPG_MAX_VBLANK			(XVTC_MAX_VSIZE - XVIP_MIN_HEIGHT)
 
+#define XTPG_MIN_WIDTH			(64)
+#define XTPG_MIN_HEIGHT			(64)
+#define XTPG_MAX_WIDTH			(10328)
+#define XTPG_MAX_HEIGHT			(7760)
+
+#define XTPG_MIN_PPC			1
+
+#define XTPG_MIN_FRM_INT		1
+
 /**
  * struct xtpg_device - Xilinx Test Pattern Generator device structure
  * @xvip: Xilinx Video IP device
@@ -82,8 +122,15 @@
  * @vblank: vertical blanking control
  * @pattern: test pattern control
  * @streaming: is the video stream active
+ * @is_hls: whether the IP core is HLS based
  * @vtc: video timing controller
  * @vtmux_gpio: video timing mux GPIO
+ * @rst_gpio: reset IP core GPIO
+ * @max_width: Maximum width supported by this instance
+ * @max_height: Maximum height supported by this instance
+ * @fi_d: frame interval denominator
+ * @fi_n: frame interval numerator
+ * @ppc: Pixels per clock control
  */
 struct xtpg_device {
 	struct xvip_device xvip;
@@ -102,9 +149,17 @@ struct xtpg_device {
 	struct v4l2_ctrl *vblank;
 	struct v4l2_ctrl *pattern;
 	bool streaming;
+	bool is_hls;
 
 	struct xvtc_device *vtc;
 	struct gpio_desc *vtmux_gpio;
+	struct gpio_desc *rst_gpio;
+
+	u32 max_width;
+	u32 max_height;
+	u32 fi_d;
+	u32 fi_n;
+	u32 ppc;
 };
 
 static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
@@ -128,6 +183,32 @@ static u32 xtpg_get_bayer_phase(unsigned int code)
 	}
 }
 
+static void xtpg_config_vtc(struct xtpg_device *xtpg, int width, int height)
+{
+
+	struct xvtc_config config = {
+		.hblank_start = width / xtpg->ppc,
+		.hsync_start = width / xtpg->ppc + 1,
+		.vblank_start = height,
+		.vsync_start = height + 1,
+		.fps = xtpg->fi_d / xtpg->fi_n,
+	};
+	unsigned int htotal;
+	unsigned int vtotal;
+
+	htotal = min_t(unsigned int, XVTC_MAX_HSIZE,
+		       (v4l2_ctrl_g_ctrl(xtpg->hblank) + width) / xtpg->ppc);
+	vtotal = min_t(unsigned int, XVTC_MAX_VSIZE,
+		       v4l2_ctrl_g_ctrl(xtpg->vblank) + height);
+
+	config.hsync_end = htotal - 1;
+	config.hsize = htotal;
+	config.vsync_end = vtotal - 1;
+	config.vsize = vtotal;
+
+	xvtc_generator_start(xtpg->vtc, &config);
+}
+
 static void __xtpg_update_pattern_control(struct xtpg_device *xtpg,
 					  bool passthrough, bool pattern)
 {
@@ -164,6 +245,33 @@ static void xtpg_update_pattern_control(struct xtpg_device *xtpg,
  * V4L2 Subdevice Video Operations
  */
 
+static int xtpg_g_frame_interval(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_frame_interval *fi)
+{
+	struct xtpg_device *xtpg = to_tpg(subdev);
+
+	fi->interval.numerator = xtpg->fi_n;
+	fi->interval.denominator = xtpg->fi_d;
+
+	return 0;
+}
+
+static int xtpg_s_frame_interval(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_frame_interval *fi)
+{
+	struct xtpg_device *xtpg = to_tpg(subdev);
+
+	if (!fi->interval.numerator || !fi->interval.denominator) {
+		xtpg->fi_n = XTPG_MIN_FRM_INT;
+		xtpg->fi_d = XTPG_MIN_FRM_INT;
+	} else {
+		xtpg->fi_n = fi->interval.numerator;
+		xtpg->fi_d = fi->interval.denominator;
+	}
+
+	return 0;
+}
+
 static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
@@ -173,7 +281,27 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 	u32 bayer_phase;
 
 	if (!enable) {
-		xvip_stop(&xtpg->xvip);
+		if (!xtpg->is_hls) {
+			xvip_stop(&xtpg->xvip);
+		} else {
+			int ret;
+			/*
+			 * There is an known issue in TPG v7.0 that on
+			 * resolution change it doesn't generates pattern
+			 * correctly i.e some hor/ver offset is added.
+			 * As a workaround issue reset on stop.
+			 */
+			gpiod_set_value_cansleep(xtpg->rst_gpio, 0x1);
+			gpiod_set_value_cansleep(xtpg->rst_gpio, 0x0);
+			ret = v4l2_ctrl_handler_setup(&xtpg->ctrl_handler);
+			if (ret) {
+				struct device *dev = xtpg->xvip.dev;
+
+				dev_err(dev, "failed to set controls\n");
+				return ret;
+			}
+		}
+
 		if (xtpg->vtc)
 			xvtc_generator_stop(xtpg->vtc);
 
@@ -182,31 +310,36 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 		return 0;
 	}
 
-	xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
-
-	if (xtpg->vtc) {
-		struct xvtc_config config = {
-			.hblank_start = width,
-			.hsync_start = width + 1,
-			.vblank_start = height,
-			.vsync_start = height + 1,
-		};
-		unsigned int htotal;
-		unsigned int vtotal;
-
-		htotal = min_t(unsigned int, XVTC_MAX_HSIZE,
-			       v4l2_ctrl_g_ctrl(xtpg->hblank) + width);
-		vtotal = min_t(unsigned int, XVTC_MAX_VSIZE,
-			       v4l2_ctrl_g_ctrl(xtpg->vblank) + height);
-
-		config.hsync_end = htotal - 1;
-		config.hsize = htotal;
-		config.vsync_end = vtotal - 1;
-		config.vsize = vtotal;
-
-		xvtc_generator_start(xtpg->vtc, &config);
+	if (xtpg->is_hls) {
+		u32 fmt = 0;
+
+		switch (xtpg->formats[0].code) {
+		case MEDIA_BUS_FMT_VYYUYY8_1X24:
+		case MEDIA_BUS_FMT_VYYUYY10_4X20:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_420;
+			break;
+		case MEDIA_BUS_FMT_UYVY8_1X16:
+		case MEDIA_BUS_FMT_UYVY10_1X20:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_422;
+			break;
+		case MEDIA_BUS_FMT_VUY8_1X24:
+		case MEDIA_BUS_FMT_VUY10_1X30:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_444;
+			break;
+		case MEDIA_BUS_FMT_RBG888_1X24:
+		case MEDIA_BUS_FMT_RBG101010_1X30:
+			fmt = XTPG_HLS_COLOR_FORMAT_RGB;
+			break;
+		}
+		xvip_write(&xtpg->xvip, XTPG_HLS_COLOR_FORMAT, fmt);
+		xvip_write(&xtpg->xvip, XHLS_REG_COLS, width);
+		xvip_write(&xtpg->xvip, XHLS_REG_ROWS, height);
+	} else {
+		xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
 	}
 
+	if (xtpg->vtc)
+		xtpg_config_vtc(xtpg, width, height);
 	/*
 	 * Configure the bayer phase and video timing mux based on the
 	 * operation mode (passthrough or test pattern generation). The test
@@ -215,7 +348,11 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 	 */
 	mutex_lock(xtpg->ctrl_handler.lock);
 
-	xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+	if (xtpg->is_hls)
+		xvip_write(&xtpg->xvip, XTPG_HLS_BG_PATTERN,
+			   xtpg->pattern->cur.val);
+	else
+		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
 			 XTPG_PATTERN_MASK, xtpg->pattern->cur.val);
 
 	/*
@@ -229,18 +366,26 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 
 	mutex_unlock(xtpg->ctrl_handler.lock);
 
-	/*
-	 * For TPG v5.0, the bayer phase needs to be off for the pass through
-	 * mode, otherwise the external input would be subsampled.
-	 */
-	bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
-		    : xtpg_get_bayer_phase(xtpg->formats[0].code);
-	xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
-
 	if (xtpg->vtmux_gpio)
 		gpiod_set_value_cansleep(xtpg->vtmux_gpio, !passthrough);
 
-	xvip_start(&xtpg->xvip);
+	if (xtpg->is_hls) {
+		xvip_set(&xtpg->xvip, XTPG_HLS_ENABLE_INPUT,
+			 XTPG_HLS_USE_INPUT_VID_STREAM);
+		xvip_set(&xtpg->xvip, XVIP_CTRL_CONTROL,
+			 XHLS_REG_CTRL_AUTO_RESTART |
+			 XVIP_CTRL_CONTROL_SW_ENABLE);
+	} else {
+		/*
+		 * For TPG v5.0, the bayer phase needs to be off for the pass
+		 * through mode, otherwise the external input would
+		 * be subsampled.
+		 */
+		bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
+			    : xtpg_get_bayer_phase(xtpg->formats[0].code);
+		xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
+		xvip_start(&xtpg->xvip);
+	}
 
 	return 0;
 }
@@ -254,15 +399,23 @@ __xtpg_get_pad_format(struct xtpg_device *xtpg,
 		      struct v4l2_subdev_state *sd_state,
 		      unsigned int pad, u32 which)
 {
+	struct v4l2_mbus_framefmt *format;
+
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(&xtpg->xvip.subdev,
-						  sd_state, pad);
+		format = v4l2_subdev_get_try_format(&xtpg->xvip.subdev,
+						    sd_state,
+						    pad);
+		break;
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &xtpg->formats[pad];
+		format = &xtpg->formats[pad];
+		break;
 	default:
-		return NULL;
+		format = NULL;
+		break;
 	}
+
+	return format;
 }
 
 static int xtpg_get_format(struct v4l2_subdev *subdev,
@@ -270,9 +423,13 @@ static int xtpg_get_format(struct v4l2_subdev *subdev,
 			   struct v4l2_subdev_format *fmt)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xtpg_get_pad_format(xtpg, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
 
-	fmt->format = *__xtpg_get_pad_format(xtpg, sd_state, fmt->pad,
-					     fmt->which);
+	fmt->format = *format;
 
 	return 0;
 }
@@ -286,6 +443,8 @@ static int xtpg_set_format(struct v4l2_subdev *subdev,
 	u32 bayer_phase;
 
 	__format = __xtpg_get_pad_format(xtpg, sd_state, fmt->pad, fmt->which);
+	if (!__format)
+		return -EINVAL;
 
 	/* In two pads mode the source pad format is always identical to the
 	 * sink pad format.
@@ -302,7 +461,27 @@ static int xtpg_set_format(struct v4l2_subdev *subdev,
 			__format->code = fmt->format.code;
 	}
 
-	xvip_set_format_size(__format, fmt);
+	if (xtpg->is_hls) {
+		switch (fmt->format.code) {
+		case MEDIA_BUS_FMT_VYYUYY8_1X24:
+		case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		case MEDIA_BUS_FMT_UYVY8_1X16:
+		case MEDIA_BUS_FMT_UYVY10_1X20:
+		case MEDIA_BUS_FMT_VUY8_1X24:
+		case MEDIA_BUS_FMT_VUY10_1X30:
+		case MEDIA_BUS_FMT_RBG888_1X24:
+		case MEDIA_BUS_FMT_RBG101010_1X30:
+			__format->code = fmt->format.code;
+			break;
+		default:
+			__format->code = xtpg->default_format.code;
+		}
+	}
+
+	__format->width = clamp_t(unsigned int, fmt->format.width,
+				  XTPG_MIN_WIDTH, xtpg->max_width);
+	__format->height = clamp_t(unsigned int, fmt->format.height,
+				   XTPG_MIN_HEIGHT, xtpg->max_height);
 
 	fmt->format = *__format;
 
@@ -310,6 +489,8 @@ static int xtpg_set_format(struct v4l2_subdev *subdev,
 	if (xtpg->npads == 2) {
 		__format = __xtpg_get_pad_format(xtpg, sd_state, 1,
 						 fmt->which);
+		if (!__format)
+			return -EINVAL;
 		*__format = fmt->format;
 	}
 
@@ -325,6 +506,7 @@ static int xtpg_enum_frame_size(struct v4l2_subdev *subdev,
 				struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct v4l2_mbus_framefmt *format;
+	struct xtpg_device *xtpg = to_tpg(subdev);
 
 	format = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);
 
@@ -333,12 +515,13 @@ static int xtpg_enum_frame_size(struct v4l2_subdev *subdev,
 
 	/* Min / max values for pad 0 is always fixed in both one and two pads
 	 * modes. In two pads mode, the source pad(= 1) size is identical to
-	 * the sink pad size */
+	 * the sink pad size.
+	 */
 	if (fse->pad == 0) {
-		fse->min_width = XVIP_MIN_WIDTH;
-		fse->max_width = XVIP_MAX_WIDTH;
-		fse->min_height = XVIP_MIN_HEIGHT;
-		fse->max_height = XVIP_MAX_HEIGHT;
+		fse->min_width = XTPG_MIN_WIDTH;
+		fse->max_width = xtpg->max_width;
+		fse->min_height = XTPG_MIN_HEIGHT;
+		fse->max_height = xtpg->max_height;
 	} else {
 		fse->min_width = format->width;
 		fse->max_width = format->width;
@@ -377,8 +560,12 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 						ctrl_handler);
 	switch (ctrl->id) {
 	case V4L2_CID_TEST_PATTERN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_MASK, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_BG_PATTERN,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+					 XTPG_PATTERN_MASK, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIRS:
 		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
@@ -389,10 +576,13 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				XTPG_PATTERN_CONTROL_MOVING_BOX, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_COLOR_MASK:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
-				 ctrl->val <<
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_MASK_ID, ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+				      XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
+				      ctrl->val <<
+				      XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_STUCK_PIXEL:
 		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
@@ -407,43 +597,85 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				XTPG_PATTERN_CONTROL_MOTION, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_MOTION_SPEED:
-		xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_MOTION_SPEED,
+				   ctrl->val);
+		else
+			xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_ROW_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_ROW_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_CROSS_HAIR_HOR,
+				    ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
+					 XTPG_CROSS_HAIRS_ROW_MASK,
+					 ctrl->val <<
+					 XTPG_CROSS_HAIRS_ROW_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_COLUMN_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_COLUMN_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_CROSS_HAIR_VER,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
+					 XTPG_CROSS_HAIRS_COLUMN_MASK,
+					 ctrl->val <<
+					 XTPG_CROSS_HAIRS_COLUMN_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_HOR_CNTL_START,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
+					 XTPG_ZPLATE_START_MASK,
+					 ctrl->val << XTPG_ZPLATE_START_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_HOR_CNTL_DELTA,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
+					 XTPG_ZPLATE_SPEED_MASK,
+					 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_VER_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_VER_CNTL_START,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
+					 XTPG_ZPLATE_START_MASK,
+					 ctrl->val << XTPG_ZPLATE_START_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_VER_CNTL_DELTA,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
+					 XTPG_ZPLATE_SPEED_MASK,
+					 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_BOX_SIZE:
-		xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_SIZE, ctrl->val);
+		else
+			xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_BOX_COLOR:
-		xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
+		if (xtpg->is_hls) {
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_RED_CB,
+				   ctrl->val >> 16);
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_GREEN_CR,
+				   ctrl->val >> 8);
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_BLUE_Y,
+				   ctrl->val);
+		} else {
+			xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
+		}
 		return 0;
 	case V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH:
 		xvip_write(&xtpg->xvip, XTPG_STUCK_PIXEL_THRESH, ctrl->val);
@@ -451,6 +683,9 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_XILINX_TPG_NOISE_GAIN:
 		xvip_write(&xtpg->xvip, XTPG_NOISE_GAIN, ctrl->val);
 		return 0;
+	case V4L2_CID_XILINX_TPG_HLS_FG_PATTERN:
+		xvip_write(&xtpg->xvip, XTPG_HLS_FG_PATTERN, ctrl->val);
+		return 0;
 	}
 
 	return 0;
@@ -464,6 +699,8 @@ static const struct v4l2_subdev_core_ops xtpg_core_ops = {
 };
 
 static const struct v4l2_subdev_video_ops xtpg_video_ops = {
+	.g_frame_interval = xtpg_g_frame_interval,
+	.s_frame_interval = xtpg_s_frame_interval,
 	.s_stream = xtpg_s_stream,
 };
 
@@ -508,60 +745,51 @@ static const char *const xtpg_pattern_strings[] = {
 	"Black/White Checker Board",
 };
 
-static struct v4l2_ctrl_config xtpg_ctrls[] = {
+static const char *const xtpg_hls_pattern_strings[] = {
+	"Passthrough",
+	"Horizontal Ramp",
+	"Vertical Ramp",
+	"Temporal Ramp",
+	"Solid Red",
+	"Solid Green",
+	"Solid Blue",
+	"Solid Black",
+	"Solid White",
+	"Color Bars",
+	"Zone Plate",
+	"Tartan Color Bars",
+	"Cross Hatch",
+	"Color Sweep",
+	"Vertical/Horizontal Ramps",
+	"Black/White Checker Board",
+	"PseudoRandom",
+};
+
+static const char *const xtpg_hls_fg_strings[] = {
+	"No Overlay",
+	"Moving Box",
+	"Cross Hairs",
+};
+
+static const struct v4l2_ctrl_config xtpg_hls_fg_ctrl = {
+	.ops	= &xtpg_ctrl_ops,
+	.id     = V4L2_CID_XILINX_TPG_HLS_FG_PATTERN,
+	.name   = "Test Pattern: Foreground Pattern",
+	.type   = V4L2_CTRL_TYPE_MENU,
+	.min	= 0,
+	.max	= ARRAY_SIZE(xtpg_hls_fg_strings) - 1,
+	.qmenu	= xtpg_hls_fg_strings,
+};
+
+static struct v4l2_ctrl_config xtpg_common_ctrls[] = {
 	{
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
-		.name	= "Test Pattern: Cross Hairs",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
-		.name	= "Test Pattern: Moving Box",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_COLOR_MASK,
-		.name	= "Test Pattern: Color Mask",
-		.type	= V4L2_CTRL_TYPE_BITMASK,
-		.min	= 0,
-		.max	= 0xf,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
-		.name	= "Test Pattern: Stuck Pixel",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_NOISE,
-		.name	= "Test Pattern: Noise",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOTION,
-		.name	= "Test Pattern: Motion",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
+		.ops    = &xtpg_ctrl_ops,
+		.id     = V4L2_CID_XILINX_TPG_COLOR_MASK,
+		.name   = "Test Pattern: Color Mask",
+		.type   = V4L2_CTRL_TYPE_BITMASK,
+		.min    = 0,
+		.max    = 0x7,
+		.def    = 0,
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_MOTION_SPEED,
@@ -645,12 +873,61 @@ static struct v4l2_ctrl_config xtpg_ctrls[] = {
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_BOX_COLOR,
-		.name	= "Test Pattern: Box Color(RGB)",
+		.name	= "Test Pattern: Box Color(RGB/YCbCr)",
 		.type	= V4L2_CTRL_TYPE_INTEGER,
 		.min	= 0,
 		.max	= (1 << 24) - 1,
 		.step	= 1,
 		.def	= 0,
+	},
+};
+
+static struct v4l2_ctrl_config xtpg_ctrls[] = {
+	{
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
+		.name	= "Test Pattern: Cross Hairs",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
+		.name	= "Test Pattern: Moving Box",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
+		.name	= "Test Pattern: Stuck Pixel",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_NOISE,
+		.name	= "Test Pattern: Noise",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_MOTION,
+		.name	= "Test Pattern: Motion",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH,
@@ -716,6 +993,49 @@ static int xtpg_parse_of(struct xtpg_device *xtpg)
 	struct device_node *port;
 	unsigned int nports = 0;
 	bool has_endpoint = false;
+	int ret;
+
+	if (!of_device_is_compatible(dev->of_node, "xlnx,v-tpg-5.0"))
+		xtpg->is_hls = true;
+
+	ret = of_property_read_u32(node, "xlnx,max-height",
+				   &xtpg->max_height);
+	if (ret < 0) {
+		if (of_device_is_compatible(dev->of_node, "xlnx,v-tpg-8.0")) {
+			dev_err(dev, "xlnx,max-height dt property is missing!");
+			return -EINVAL;
+		}
+		xtpg->max_height = XTPG_MAX_HEIGHT;
+	} else if (xtpg->max_height > XTPG_MAX_HEIGHT ||
+		   xtpg->max_height < XTPG_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,max-width",
+				   &xtpg->max_width);
+	if (ret < 0) {
+		if (of_device_is_compatible(dev->of_node, "xlnx,v-tpg-8.0")) {
+			dev_err(dev, "xlnx,max-width dt property is missing!");
+			return -EINVAL;
+		}
+		xtpg->max_width = XTPG_MAX_WIDTH;
+	} else if (xtpg->max_width > XTPG_MAX_WIDTH ||
+		   xtpg->max_width < XTPG_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,ppc",
+				   &xtpg->ppc);
+	if (ret < 0) {
+		xtpg->ppc = XTPG_MIN_PPC;
+		dev_dbg(dev, "failed to read ppc in dt\n");
+	} else if ((xtpg->ppc != 1) && (xtpg->ppc != 2) &&
+			(xtpg->ppc != 4) && (xtpg->ppc != 8)) {
+		dev_err(dev, "Invalid ppc config in dt\n");
+		return -EINVAL;
+	}
 
 	ports = of_get_child_by_name(node, "ports");
 	if (ports == NULL)
@@ -772,6 +1092,7 @@ static int xtpg_probe(struct platform_device *pdev)
 	struct v4l2_subdev *subdev;
 	struct xtpg_device *xtpg;
 	u32 i, bayer_phase;
+	u32 npatterns;
 	int ret;
 
 	xtpg = devm_kzalloc(&pdev->dev, sizeof(*xtpg), GFP_KERNEL);
@@ -795,14 +1116,29 @@ static int xtpg_probe(struct platform_device *pdev)
 		goto error_resource;
 	}
 
+	if (xtpg->is_hls) {
+		xtpg->rst_gpio = devm_gpiod_get(&pdev->dev, "reset",
+						   GPIOD_OUT_HIGH);
+		if (IS_ERR(xtpg->rst_gpio)) {
+			ret = PTR_ERR(xtpg->rst_gpio);
+			goto error_resource;
+		}
+	}
+
 	xtpg->vtc = xvtc_of_get(pdev->dev.of_node);
 	if (IS_ERR(xtpg->vtc)) {
 		ret = PTR_ERR(xtpg->vtc);
 		goto error_resource;
 	}
 
-	/* Reset and initialize the core */
-	xvip_reset(&xtpg->xvip);
+	/*
+	 * Reset and initialize the core. For TPG HLS version there
+	 * is no SW_RESET bit hence using GPIO based reset.
+	 */
+	if (xtpg->is_hls)
+		gpiod_set_value_cansleep(xtpg->rst_gpio, 0x0);
+	else
+		xvip_reset(&xtpg->xvip);
 
 	/* Initialize V4L2 subdevice and media entity. Pad numbers depend on the
 	 * number of pads.
@@ -818,11 +1154,23 @@ static int xtpg_probe(struct platform_device *pdev)
 	xtpg->default_format.code = xtpg->vip_format->code;
 	xtpg->default_format.field = V4L2_FIELD_NONE;
 	xtpg->default_format.colorspace = V4L2_COLORSPACE_SRGB;
-	xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
 
-	bayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);
-	if (bayer_phase != XTPG_BAYER_PHASE_OFF)
-		xtpg->bayer = true;
+	if (xtpg->is_hls) {
+		npatterns = ARRAY_SIZE(xtpg_hls_pattern_strings);
+		xtpg->default_format.width = xvip_read(&xtpg->xvip,
+						       XHLS_REG_COLS);
+		xtpg->default_format.height = xvip_read(&xtpg->xvip,
+							XHLS_REG_ROWS);
+	} else {
+		npatterns = ARRAY_SIZE(xtpg_pattern_strings);
+		xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
+	}
+
+	if (!xtpg->is_hls) {
+		bayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);
+		if (bayer_phase != XTPG_BAYER_PHASE_OFF)
+			xtpg->bayer = true;
+	}
 
 	xtpg->formats[0] = xtpg->default_format;
 	if (xtpg->npads == 2)
@@ -842,7 +1190,13 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto error;
 
-	v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 + ARRAY_SIZE(xtpg_ctrls));
+	if (xtpg->is_hls)
+		v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 4 +
+				       ARRAY_SIZE(xtpg_common_ctrls));
+	else
+		v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 +
+				       ARRAY_SIZE(xtpg_common_ctrls) +
+				       ARRAY_SIZE(xtpg_ctrls));
 
 	xtpg->vblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
 					 V4L2_CID_VBLANK, XTPG_MIN_VBLANK,
@@ -850,19 +1204,41 @@ static int xtpg_probe(struct platform_device *pdev)
 	xtpg->hblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
 					 V4L2_CID_HBLANK, XTPG_MIN_HBLANK,
 					 XTPG_MAX_HBLANK, 1, 100);
-	xtpg->pattern = v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
-					&xtpg_ctrl_ops, V4L2_CID_TEST_PATTERN,
-					ARRAY_SIZE(xtpg_pattern_strings) - 1,
-					1, 9, xtpg_pattern_strings);
 
-	for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
-		v4l2_ctrl_new_custom(&xtpg->ctrl_handler, &xtpg_ctrls[i], NULL);
+	if (xtpg->is_hls) {
+		xtpg->pattern =
+			v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
+						     &xtpg_ctrl_ops,
+						     V4L2_CID_TEST_PATTERN,
+						     npatterns - 1,
+						     1, 9,
+						     xtpg_hls_pattern_strings);
+		v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+				     &xtpg_hls_fg_ctrl, NULL);
+	} else {
+		xtpg->pattern =
+			v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
+						     &xtpg_ctrl_ops,
+						     V4L2_CID_TEST_PATTERN,
+						     npatterns - 1,
+						     1, 9,
+						     xtpg_pattern_strings);
+
+		for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
+			v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+					     &xtpg_ctrls[i], NULL);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xtpg_common_ctrls); i++)
+		v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+				     &xtpg_common_ctrls[i], NULL);
 
 	if (xtpg->ctrl_handler.error) {
 		dev_err(&pdev->dev, "failed to add controls\n");
 		ret = xtpg->ctrl_handler.error;
 		goto error;
 	}
+
 	subdev->ctrl_handler = &xtpg->ctrl_handler;
 
 	xtpg_update_pattern_control(xtpg, true, true);
@@ -875,7 +1251,12 @@ static int xtpg_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, xtpg);
 
-	xvip_print_version(&xtpg->xvip);
+	if (!xtpg->is_hls)
+		xvip_print_version(&xtpg->xvip);
+
+	/* Initialize default frame interval */
+	xtpg->fi_n = 1;
+	xtpg->fi_d = 30;
 
 	ret = v4l2_async_register_subdev(subdev);
 	if (ret < 0) {
@@ -912,6 +1293,8 @@ static SIMPLE_DEV_PM_OPS(xtpg_pm_ops, xtpg_pm_suspend, xtpg_pm_resume);
 
 static const struct of_device_id xtpg_of_id_table[] = {
 	{ .compatible = "xlnx,v-tpg-5.0" },
+	{ .compatible = "xlnx,v-tpg-7.0" },
+	{ .compatible = "xlnx,v-tpg-8.0" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, xtpg_of_id_table);
diff --git a/drivers/media/platform/xilinx/xilinx-vip.c b/drivers/media/platform/xilinx/xilinx-vip.c
index 5b214bf7f..621ff0275 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.c
+++ b/drivers/media/platform/xilinx/xilinx-vip.c
@@ -24,24 +24,118 @@
  */
 
 static const struct xvip_video_format xvip_video_formats[] = {
+	{ XVIP_VF_YUV_420, 8, NULL, MEDIA_BUS_FMT_VYYUYY8_1X24,
+	  1, 12, V4L2_PIX_FMT_NV12, 2, 1, 1, 2 },
+	{ XVIP_VF_YUV_420, 8, NULL, MEDIA_BUS_FMT_VYYUYY8_1X24,
+	  1, 12, V4L2_PIX_FMT_NV12M, 2, 2, 1, 2 },
+	{ XVIP_VF_YUV_420, 10, NULL, MEDIA_BUS_FMT_VYYUYY10_4X20,
+	  1, 12, V4L2_PIX_FMT_XV15, 2, 1, 2, 2 },
+	{ XVIP_VF_YUV_420, 10, NULL, MEDIA_BUS_FMT_VYYUYY10_4X20,
+	  1, 12, V4L2_PIX_FMT_XV15M, 2, 2, 1, 2 },
+	{ XVIP_VF_YUV_420, 12, NULL, MEDIA_BUS_FMT_UYYVYY12_4X24,
+	  1, 12, V4L2_PIX_FMT_X012, 2, 1, 2, 2 },
+	{ XVIP_VF_YUV_420, 12, NULL, MEDIA_BUS_FMT_UYYVYY12_4X24,
+	  1, 12, V4L2_PIX_FMT_X012M, 2, 2, 1, 2 },
+	{ XVIP_VF_YUV_420, 16, NULL, MEDIA_BUS_FMT_UYYVYY16_4X32,
+	  2, 12, V4L2_PIX_FMT_X016, 2, 1, 2, 2 },
+	{ XVIP_VF_YUV_420, 16, NULL, MEDIA_BUS_FMT_UYYVYY16_4X32,
+	  2, 12, V4L2_PIX_FMT_X016M, 2, 2, 1, 2 },
 	{ XVIP_VF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,
-	  2, V4L2_PIX_FMT_YUYV },
+	  1, 16, V4L2_PIX_FMT_NV16, 2, 1, 1, 1 },
+	{ XVIP_VF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,
+	  1, 16, V4L2_PIX_FMT_NV16M, 2, 2, 1, 1 },
+	{ XVIP_VF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,
+	  2, 16, V4L2_PIX_FMT_YUYV, 1, 1, 2, 1 },
+	{ XVIP_VF_VUY_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,
+	  2, 16, V4L2_PIX_FMT_UYVY, 1, 1, 2, 1 },
+	{ XVIP_VF_YUV_422, 10, NULL, MEDIA_BUS_FMT_UYVY10_1X20,
+	  1, 16, V4L2_PIX_FMT_XV20, 2, 1, 2, 1 },
+	{ XVIP_VF_YUV_422, 10, NULL, MEDIA_BUS_FMT_UYVY10_1X20,
+	  1, 16, V4L2_PIX_FMT_XV20M, 2, 2, 1, 1 },
+	{ XVIP_VF_YUV_422, 12, NULL, MEDIA_BUS_FMT_UYVY12_1X24,
+	  1, 16, V4L2_PIX_FMT_X212, 2, 1, 2, 1 },
+	{ XVIP_VF_YUV_422, 12, NULL, MEDIA_BUS_FMT_UYVY12_1X24,
+	  1, 16, V4L2_PIX_FMT_X212M, 2, 2, 1, 1 },
+	{ XVIP_VF_YUV_422, 16, NULL, MEDIA_BUS_FMT_UYVY16_2X32,
+	  2, 16, V4L2_PIX_FMT_X216, 2, 1, 2, 1 },
+	{ XVIP_VF_YUV_422, 16, NULL, MEDIA_BUS_FMT_UYVY16_2X32,
+	  2, 16, V4L2_PIX_FMT_X216M, 2, 2, 1, 1 },
+	{ XVIP_VF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,
+	  3, 24, V4L2_PIX_FMT_VUY24, 1, 1, 1, 1 },
+	{ XVIP_VF_YUV_444, 10, NULL, MEDIA_BUS_FMT_VUY10_1X30,
+	  1, 24, V4L2_PIX_FMT_X403, 3, 1, 1, 1 },
 	{ XVIP_VF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,
-	  3, V4L2_PIX_FMT_YUV444 },
+	  1, 24, V4L2_PIX_FMT_YUV444P, 3, 1, 1, 1 },
+	{ XVIP_VF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,
+	  1, 8, V4L2_PIX_FMT_YUV444M, 3, 3, 1, 1 },
+	{ XVIP_VF_YUVX, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,
+	  4, 32, V4L2_PIX_FMT_XVUY32, 1, 1, 1, 1 },
+	{ XVIP_VF_YUVX, 10, NULL, MEDIA_BUS_FMT_VUY10_1X30,
+	  3, 32, V4L2_PIX_FMT_XVUY10, 1, 1, 1, 1 },
+	{ XVIP_VF_YUV_444, 12, NULL, MEDIA_BUS_FMT_VUY12_1X36,
+	  1, 24, V4L2_PIX_FMT_X412, 1, 1, 1, 1 },
+	{ XVIP_VF_YUV_444, 12, NULL, MEDIA_BUS_FMT_VUY12_1X36,
+	  1, 24, V4L2_PIX_FMT_X412M, 1, 1, 1, 1 },
+	{ XVIP_VF_YUV_444, 16, NULL, MEDIA_BUS_FMT_VUY16_1X48,
+	  2, 24, V4L2_PIX_FMT_X416, 1, 1, 1, 1 },
+	{ XVIP_VF_YUV_444, 16, NULL, MEDIA_BUS_FMT_VUY16_1X48,
+	  2, 24, V4L2_PIX_FMT_X416M, 1, 1, 1, 1 },
+	{ XVIP_VF_RBG, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,
+	  3, 24, V4L2_PIX_FMT_BGR24, 1, 1, 1, 1 },
 	{ XVIP_VF_RBG, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,
-	  3, 0 },
+	  3, 24, V4L2_PIX_FMT_RGB24, 1, 1, 1, 1 },
+	{ XVIP_VF_BGRX, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,
+	  4, 32, V4L2_PIX_FMT_BGRX32, 1, 1, 1, 1 },
+	{ XVIP_VF_XRGB, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,
+	  4, 32, V4L2_PIX_FMT_XBGR32, 1, 1, 1, 1 },
+	{ XVIP_VF_XBGR, 10, NULL, MEDIA_BUS_FMT_RBG101010_1X30,
+	  3, 32, V4L2_PIX_FMT_XBGR30, 1, 1, 1, 1 },
+	{ XVIP_VF_XBGR, 12, NULL, MEDIA_BUS_FMT_RBG121212_1X36,
+	  3, 40, V4L2_PIX_FMT_XBGR40, 1, 1, 1, 1 },
+	{ XVIP_VF_RBG, 16, NULL, MEDIA_BUS_FMT_RBG161616_1X48,
+	  6, 48, V4L2_PIX_FMT_BGR48, 1, 1, 1, 1 },
 	{ XVIP_VF_MONO_SENSOR, 8, "mono", MEDIA_BUS_FMT_Y8_1X8,
-	  1, V4L2_PIX_FMT_GREY },
+	  1, 8, V4L2_PIX_FMT_GREY, 1, 1, 1, 1 },
+	{ XVIP_VF_Y_GREY, 10, NULL, MEDIA_BUS_FMT_Y10_1X10,
+	  1, 32, V4L2_PIX_FMT_XY10, 1, 1, 1, 1 },
+	{ XVIP_VF_Y_GREY, 12, NULL, MEDIA_BUS_FMT_Y12_1X12,
+	  1, 12, V4L2_PIX_FMT_XY12, 1, 1, 1, 1 },
+	{ XVIP_VF_Y_GREY, 16, NULL, MEDIA_BUS_FMT_Y16_1X16,
+	  2, 16, V4L2_PIX_FMT_Y16, 1, 1, 1, 1 },
 	{ XVIP_VF_MONO_SENSOR, 8, "rggb", MEDIA_BUS_FMT_SRGGB8_1X8,
-	  1, V4L2_PIX_FMT_SRGGB8 },
+	  1, 8, V4L2_PIX_FMT_SGRBG8, 1, 1, 1, 1 },
 	{ XVIP_VF_MONO_SENSOR, 8, "grbg", MEDIA_BUS_FMT_SGRBG8_1X8,
-	  1, V4L2_PIX_FMT_SGRBG8 },
+	  1, 8, V4L2_PIX_FMT_SGRBG8, 1, 1, 1, 1 },
 	{ XVIP_VF_MONO_SENSOR, 8, "gbrg", MEDIA_BUS_FMT_SGBRG8_1X8,
-	  1, V4L2_PIX_FMT_SGBRG8 },
+	  1, 8, V4L2_PIX_FMT_SGBRG8, 1, 1, 1, 1 },
 	{ XVIP_VF_MONO_SENSOR, 8, "bggr", MEDIA_BUS_FMT_SBGGR8_1X8,
-	  1, V4L2_PIX_FMT_SBGGR8 },
+	  1, 8, V4L2_PIX_FMT_SBGGR8, 1, 1, 1, 1 },
 	{ XVIP_VF_MONO_SENSOR, 12, "mono", MEDIA_BUS_FMT_Y12_1X12,
-	  2, V4L2_PIX_FMT_Y12 },
+	  2, 12, V4L2_PIX_FMT_Y12, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 10, "rggb", MEDIA_BUS_FMT_SRGGB10_1X10,
+	  2, 10, V4L2_PIX_FMT_SRGGB10, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 10, "grbg", MEDIA_BUS_FMT_SGRBG10_1X10,
+	  2, 10, V4L2_PIX_FMT_SGRBG10, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 10, "gbrg", MEDIA_BUS_FMT_SGBRG10_1X10,
+	  2, 10, V4L2_PIX_FMT_SGBRG10, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 10, "bggr", MEDIA_BUS_FMT_SBGGR10_1X10,
+	  2, 10, V4L2_PIX_FMT_SBGGR10, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 12, "rggb", MEDIA_BUS_FMT_SRGGB12_1X12,
+	  2, 12, V4L2_PIX_FMT_SRGGB12, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 12, "grbg", MEDIA_BUS_FMT_SGRBG12_1X12,
+	  2, 12, V4L2_PIX_FMT_SGRBG12, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 12, "gbrg", MEDIA_BUS_FMT_SGBRG12_1X12,
+	  2, 12, V4L2_PIX_FMT_SGBRG12, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 12, "bggr", MEDIA_BUS_FMT_SBGGR12_1X12,
+	  2, 12, V4L2_PIX_FMT_SBGGR12, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 16, "rggb", MEDIA_BUS_FMT_SRGGB16_1X16,
+	  2, 16, V4L2_PIX_FMT_SRGGB16, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 16, "grbg", MEDIA_BUS_FMT_SGRBG16_1X16,
+	  2, 16, V4L2_PIX_FMT_SGRBG16, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 16, "gbrg", MEDIA_BUS_FMT_SGBRG16_1X16,
+	  2, 16, V4L2_PIX_FMT_SGBRG16, 1, 1, 1, 1 },
+	{ XVIP_VF_MONO_SENSOR, 16, "bggr", MEDIA_BUS_FMT_SBGGR16_1X16,
+	  2, 16, V4L2_PIX_FMT_SBGGR16, 1, 1, 1, 1 },
 };
 
 /**
@@ -90,6 +184,89 @@ const struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc)
 }
 EXPORT_SYMBOL_GPL(xvip_get_format_by_fourcc);
 
+/**
+ * xvip_bpl_scaling_factor - Retrieve bpl scaling factor for a 4CC
+ * @fourcc: the format 4CC
+ * @numerator: returning numerator of scaling factor
+ * @denominator: returning denominator of scaling factor
+ *
+ * Return: Return numerator and denominator values by address
+ */
+void xvip_bpl_scaling_factor(u32 fourcc, u32 *numerator, u32 *denominator)
+{
+	switch (fourcc) {
+	case V4L2_PIX_FMT_XY10:
+	case V4L2_PIX_FMT_XV15:
+	case V4L2_PIX_FMT_XV20:
+	case V4L2_PIX_FMT_X403:
+	case V4L2_PIX_FMT_XV15M:
+	case V4L2_PIX_FMT_XV20M:
+	case V4L2_PIX_FMT_XBGR30:
+	case V4L2_PIX_FMT_XVUY10:
+		*numerator = 10;
+		*denominator = 8;
+		break;
+	case V4L2_PIX_FMT_XBGR40:
+	case V4L2_PIX_FMT_XY12:
+	case V4L2_PIX_FMT_X012:
+	case V4L2_PIX_FMT_X012M:
+	case V4L2_PIX_FMT_X212:
+	case V4L2_PIX_FMT_X212M:
+	case V4L2_PIX_FMT_X412:
+	case V4L2_PIX_FMT_X412M:
+		*numerator = 12;
+		*denominator = 8;
+		break;
+	default:
+		*numerator = 1;
+		*denominator = 1;
+		break;
+	}
+}
+EXPORT_SYMBOL_GPL(xvip_bpl_scaling_factor);
+
+/**
+ * xvip_width_padding_factor - Retrieve width's padding factor for a 4CC
+ * @fourcc: the format 4CC
+ * @numerator: returning numerator of padding factor
+ * @denominator: returning denominator of padding factor
+ *
+ * Return: Return numerator and denominator values by address
+ */
+void xvip_width_padding_factor(u32 fourcc, u32 *numerator, u32 *denominator)
+{
+	switch (fourcc) {
+	case V4L2_PIX_FMT_XY10:
+	case V4L2_PIX_FMT_XV15:
+	case V4L2_PIX_FMT_XV20:
+	case V4L2_PIX_FMT_X403:
+	case V4L2_PIX_FMT_XV15M:
+	case V4L2_PIX_FMT_XV20M:
+	case V4L2_PIX_FMT_XBGR30:
+	case V4L2_PIX_FMT_XVUY10:
+		/* 32 bits are required per 30 bits of data */
+		*numerator = 32;
+		*denominator = 30;
+		break;
+	case V4L2_PIX_FMT_XBGR40:
+	case V4L2_PIX_FMT_XY12:
+	case V4L2_PIX_FMT_X012:
+	case V4L2_PIX_FMT_X012M:
+	case V4L2_PIX_FMT_X212:
+	case V4L2_PIX_FMT_X212M:
+	case V4L2_PIX_FMT_X412:
+	case V4L2_PIX_FMT_X412M:
+		*numerator = 40;
+		*denominator = 36;
+		break;
+	default:
+		*numerator = 1;
+		*denominator = 1;
+		break;
+	}
+}
+EXPORT_SYMBOL_GPL(xvip_width_padding_factor);
+
 /**
  * xvip_of_get_format - Parse a device tree node and return format information
  * @node: the device tree node
@@ -104,9 +281,9 @@ EXPORT_SYMBOL_GPL(xvip_get_format_by_fourcc);
 const struct xvip_video_format *xvip_of_get_format(struct device_node *node)
 {
 	const char *pattern = "mono";
-	unsigned int vf_code;
+	unsigned int vf_code = 0;
 	unsigned int i;
-	u32 width;
+	u32 width = 0;
 	int ret;
 
 	ret = of_property_read_u32(node, "xlnx,video-format", &vf_code);
@@ -117,8 +294,13 @@ const struct xvip_video_format *xvip_of_get_format(struct device_node *node)
 	if (ret < 0)
 		return ERR_PTR(ret);
 
-	if (vf_code == XVIP_VF_MONO_SENSOR)
-		of_property_read_string(node, "xlnx,cfa-pattern", &pattern);
+	if (vf_code == XVIP_VF_MONO_SENSOR) {
+		ret = of_property_read_string(node,
+					      "xlnx,cfa-pattern",
+					      &pattern);
+		if (ret < 0)
+			return ERR_PTR(ret);
+	}
 
 	for (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {
 		const struct xvip_video_format *format = &xvip_video_formats[i];
@@ -152,7 +334,7 @@ void xvip_set_format_size(struct v4l2_mbus_framefmt *format,
 	format->width = clamp_t(unsigned int, fmt->format.width,
 				XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
 	format->height = clamp_t(unsigned int, fmt->format.height,
-			 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
+				 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
 }
 EXPORT_SYMBOL_GPL(xvip_set_format_size);
 
@@ -216,8 +398,7 @@ int xvip_init_resources(struct xvip_device *xvip)
 	if (IS_ERR(xvip->clk))
 		return PTR_ERR(xvip->clk);
 
-	clk_prepare_enable(xvip->clk);
-	return 0;
+	return clk_prepare_enable(xvip->clk);
 }
 EXPORT_SYMBOL_GPL(xvip_init_resources);
 
diff --git a/drivers/media/platform/xilinx/xilinx-vip.h b/drivers/media/platform/xilinx/xilinx-vip.h
index 48fe229c5..ddde40c60 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.h
+++ b/drivers/media/platform/xilinx/xilinx-vip.h
@@ -107,21 +107,33 @@ struct xvip_device {
  * @width: AXI4 format width in bits per component
  * @pattern: CFA pattern for Mono/Sensor formats
  * @code: media bus format code
- * @bpp: bytes per pixel (when stored in memory)
+ * @bpl_factor: Bytes per line factor
+ * @bpp: bits per pixel
  * @fourcc: V4L2 pixel format FCC identifier
+ * @num_planes: number of planes w.r.t. color format
+ * @buffers: number of buffers per format
+ * @hsub: Horizontal sampling factor of Chroma
+ * @vsub: Vertical sampling factor of Chroma
  */
 struct xvip_video_format {
 	unsigned int vf_code;
 	unsigned int width;
 	const char *pattern;
 	unsigned int code;
+	unsigned int bpl_factor;
 	unsigned int bpp;
 	u32 fourcc;
+	u8 num_planes;
+	u8 buffers;
+	u8 hsub;
+	u8 vsub;
 };
 
 const struct xvip_video_format *xvip_get_format_by_code(unsigned int code);
 const struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc);
 const struct xvip_video_format *xvip_of_get_format(struct device_node *node);
+void xvip_bpl_scaling_factor(u32 fourcc, u32 *numerator, u32 *denominator);
+void xvip_width_padding_factor(u32 fourcc, u32 *numerator, u32 *denominator);
 void xvip_set_format_size(struct v4l2_mbus_framefmt *format,
 			  const struct v4l2_subdev_format *fmt);
 int xvip_enum_mbus_code(struct v4l2_subdev *subdev,
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index 0a16c218a..706e2c8da 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -15,6 +15,7 @@
 #include <linux/of_graph.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
+#include <linux/of_reserved_mem.h>
 
 #include <media/v4l2-async.h>
 #include <media/v4l2-common.h>
@@ -27,16 +28,27 @@
 #define XVIPP_DMA_S2MM				0
 #define XVIPP_DMA_MM2S				1
 
+/*
+ * This is for backward compatibility for existing applications,
+ * and planned to be deprecated
+ */
+static bool xvip_is_mplane = true;
+MODULE_PARM_DESC(is_mplane,
+		 "v4l2 device capability to handle multi planar formats");
+module_param_named(is_mplane, xvip_is_mplane, bool, 0444);
+
 /**
  * struct xvip_graph_entity - Entity in the video graph
  * @asd: subdev asynchronous registration information
  * @entity: media entity, from the corresponding V4L2 subdev
  * @subdev: V4L2 subdev
+ * @streaming: status of the V4L2 subdev if streaming or not
  */
 struct xvip_graph_entity {
 	struct v4l2_async_subdev asd; /* must be first */
 	struct media_entity *entity;
 	struct v4l2_subdev *subdev;
+	bool streaming;
 };
 
 static inline struct xvip_graph_entity *
@@ -65,6 +77,22 @@ xvip_graph_find_entity(struct xvip_composite_device *xdev,
 	return NULL;
 }
 
+static struct xvip_graph_entity *
+xvip_graph_find_entity_from_media(struct xvip_composite_device *xdev,
+				  struct media_entity *entity)
+{
+	struct xvip_graph_entity *xvip_entity;
+	struct v4l2_async_subdev *asd;
+
+	list_for_each_entry(asd, &xdev->notifier.asd_list, asd_list) {
+		xvip_entity = to_xvip_entity(asd);
+		if (xvip_entity->entity == entity)
+			return xvip_entity;
+	}
+
+	return NULL;
+}
+
 static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 				struct xvip_graph_entity *entity)
 {
@@ -165,7 +193,6 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		}
 	}
 
-	fwnode_handle_put(ep);
 	return ret;
 }
 
@@ -182,6 +209,190 @@ xvip_graph_find_dma(struct xvip_composite_device *xdev, unsigned int port)
 	return NULL;
 }
 
+/**
+ * xvip_graph_entity_set_streaming - Update the streaming status
+ * @xdev: Composite video device
+ * @entity: graph entity to update
+ * @enable: enable/disable streaming status
+ *
+ * Update the streaming status of given entity.
+ *
+ * Return: previous streaming status (true or false)
+ */
+static bool xvip_graph_entity_set_streaming(struct xvip_composite_device *xdev,
+					    struct xvip_graph_entity *entity,
+					    bool enable)
+{
+	bool status = entity->streaming;
+
+	entity->streaming = enable;
+	return status;
+}
+
+static int
+xvip_graph_entity_start_stop_subdev(struct xvip_composite_device *xdev,
+				    struct xvip_graph_entity *entity, bool on)
+{
+	struct v4l2_subdev *subdev;
+	int ret = 0;
+
+	dev_dbg(xdev->dev, "%s entity %s\n",
+		on ? "Starting" : "Stopping", entity->entity->name);
+	subdev = media_entity_to_v4l2_subdev(entity->entity);
+
+	/*
+	 * start or stop the subdev only once in case if they are
+	 * shared between sub-graphs
+	 */
+	if (on) {
+		/* power-on subdevice */
+		ret = v4l2_subdev_call(subdev, core, s_power, 1);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(xdev->dev,
+				"s_power on failed on subdev\n");
+			xvip_graph_entity_set_streaming(xdev, entity, 0);
+			return ret;
+		}
+
+		/* stream-on subdevice */
+		ret = v4l2_subdev_call(subdev, video, s_stream, 1);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(xdev->dev,
+				"s_stream on failed on subdev\n");
+			v4l2_subdev_call(subdev, core, s_power, 0);
+			xvip_graph_entity_set_streaming(xdev, entity, 0);
+		}
+	} else {
+		/* stream-off subdevice */
+		ret = v4l2_subdev_call(subdev, video, s_stream, 0);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(xdev->dev,
+				"s_stream off failed on subdev\n");
+			xvip_graph_entity_set_streaming(xdev, entity, 1);
+		}
+
+		/* power-off subdevice */
+		ret = v4l2_subdev_call(subdev, core, s_power, 0);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			dev_err(xdev->dev,
+				"s_power off failed on subdev\n");
+	}
+
+	if (ret == -ENOIOCTLCMD)
+		ret = 0;
+
+	return ret;
+}
+
+/**
+ * xvip_graph_entity_start_stop - start / stop the graph entity
+ * @xdev: composite device
+ * @entity: entity to check
+ * @on: boolean flag. true for enable and false for disable
+ *
+ * Check if all immediate dependencies are ready dependeing on 'on' flag.
+ * If enabling, check all source pads. Sink pads for disabling. Once all
+ * dependencies are ready, set the streaming state on the entity. If the state
+ * is already set, optimize it by skipping checks.
+ *
+ * Return: true if the state is successfully or already set. false otherwise.
+ */
+static bool xvip_graph_entity_start_stop(struct xvip_composite_device *xdev,
+					 struct xvip_graph_entity *entity,
+					 bool on)
+{
+	unsigned long pad_flag = on ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+	unsigned int i;
+	bool state;
+	int ret;
+
+	if (entity->streaming == on)
+		return true;
+
+	for (i = 0; i < entity->entity->num_pads; i++) {
+		struct xvip_graph_entity *remote;
+		struct media_pad *pad;
+
+		if (!(entity->entity->pads[i].flags & pad_flag))
+			continue;
+
+		/* skipping not connected pads */
+		pad = media_pad_remote_pad_first(&entity->entity->pads[i]);
+		if (!pad || !pad->entity)
+			continue;
+
+		/*
+		 * Skip if there is no remote. This entity is at the end,
+		 * such as DMA, sensor, or other type.
+		 */
+		remote = xvip_graph_find_entity_from_media(xdev, pad->entity);
+		if (!remote)
+			continue;
+
+		/* the dependency state doesn't meet */
+		if (remote->streaming != on) {
+			state = xvip_graph_entity_start_stop(xdev, remote, on);
+			if (!state)
+				return state;
+		}
+	}
+
+	/* set state and report if state is changed or not */
+	state = xvip_graph_entity_set_streaming(xdev, entity, on);
+	/* This shouldn't happen as check is already above */
+	if (state == on) {
+		WARN(1, "Should never get here\n");
+		return true;
+	}
+
+	ret = xvip_graph_entity_start_stop_subdev(xdev, entity, on);
+	if (ret < 0) {
+		dev_err(xdev->dev, "ret = %d for entity %s\n",
+			ret, entity->entity->name);
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * xvip_graph_pipeline_start_stop - start or stop the pipe in the graph
+ * @xdev: composite device
+ * @pipe: pipeline to start / stop
+ * @on: boolean flag. true for enable and false for disable
+ *
+ * Enable or disable the pipe in the graph by iterating the asd list.
+ * The pipe is a sub-graph, and the check ensures the given entity
+ * is part of the pipe before doing start or stop. This function
+ * or any subsequent functions don't and shouldn't change the asd list,
+ * so that there's no race if the caller holds the pipeline lock.
+ * xvip_graph_entity_start_stop() takes care of dependencies,
+ * or state-checking.
+ *
+ * Return: 0 for success, otherwise error code
+ */
+int xvip_graph_pipeline_start_stop(struct xvip_composite_device *xdev,
+				   struct xvip_pipeline *pipe, bool on)
+{
+	struct v4l2_async_subdev *asd;
+
+	list_for_each_entry(asd, &xdev->notifier.asd_list, asd_list) {
+		struct xvip_graph_entity *entity;
+		bool state;
+
+		entity = to_xvip_entity(asd);
+		/* skip an entity not belongng to the given pipe */
+		if (&pipe->pipe != media_entity_pipeline(entity->entity))
+			continue;
+
+		state = xvip_graph_entity_start_stop(xdev, entity, on);
+		if (!state)
+			return -EPIPE;
+	}
+
+	return 0;
+}
+
 static int xvip_graph_build_dma(struct xvip_composite_device *xdev)
 {
 	u32 link_flags = MEDIA_LNK_FL_ENABLED;
@@ -276,7 +487,6 @@ static int xvip_graph_build_dma(struct xvip_composite_device *xdev)
 		}
 	}
 
-	of_node_put(ep);
 	return ret;
 }
 
@@ -441,9 +651,11 @@ static int xvip_graph_dma_init_one(struct xvip_composite_device *xdev,
 		return ret;
 
 	if (strcmp(direction, "input") == 0)
-		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		type = xvip_is_mplane ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE :
+						V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	else if (strcmp(direction, "output") == 0)
-		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		type = xvip_is_mplane ? V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :
+					V4L2_BUF_TYPE_VIDEO_OUTPUT;
 	else
 		return -EINVAL;
 
@@ -461,8 +673,14 @@ static int xvip_graph_dma_init_one(struct xvip_composite_device *xdev,
 
 	list_add_tail(&dma->list, &xdev->dmas);
 
-	xdev->v4l2_caps |= type == V4L2_BUF_TYPE_VIDEO_CAPTURE
-			 ? V4L2_CAP_VIDEO_CAPTURE : V4L2_CAP_VIDEO_OUTPUT;
+	if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		xdev->v4l2_caps |= V4L2_CAP_VIDEO_CAPTURE_MPLANE;
+	else if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		xdev->v4l2_caps |= V4L2_CAP_VIDEO_CAPTURE;
+	else if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		xdev->v4l2_caps |= V4L2_CAP_VIDEO_OUTPUT;
+	else if (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		xdev->v4l2_caps |= V4L2_CAP_VIDEO_OUTPUT_MPLANE;
 
 	return 0;
 }
@@ -595,6 +813,7 @@ static int xvip_composite_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	xdev->dev = &pdev->dev;
+	mutex_init(&xdev->lock);
 	INIT_LIST_HEAD(&xdev->dmas);
 	v4l2_async_nf_init(&xdev->notifier);
 
@@ -606,6 +825,18 @@ static int xvip_composite_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto error;
 
+	xdev->atomic_streamon = of_property_read_bool(xdev->dev->of_node, "xlnx,atomic_streamon");
+
+	ret = of_reserved_mem_device_init(&pdev->dev);
+	if (ret)
+		dev_dbg(&pdev->dev, "of_reserved_mem_device_init: %d\n", ret);
+
+	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (ret) {
+		dev_err(&pdev->dev, "dma_set_mask_and_coherent: %d\n", ret);
+		goto error;
+	}
+
 	platform_set_drvdata(pdev, xdev);
 
 	dev_info(xdev->dev, "device registered\n");
@@ -621,6 +852,7 @@ static int xvip_composite_remove(struct platform_device *pdev)
 {
 	struct xvip_composite_device *xdev = platform_get_drvdata(pdev);
 
+	mutex_destroy(&xdev->lock);
 	xvip_graph_cleanup(xdev);
 	xvip_composite_v4l2_cleanup(xdev);
 
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.h b/drivers/media/platform/xilinx/xilinx-vipp.h
index cc52c1854..58e8406f4 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.h
+++ b/drivers/media/platform/xilinx/xilinx-vipp.h
@@ -27,6 +27,9 @@
  * @notifier: V4L2 asynchronous subdevs notifier
  * @dmas: list of DMA channels at the pipeline output and input
  * @v4l2_caps: V4L2 capabilities of the whole device (see VIDIOC_QUERYCAP)
+ * @lock: This is to ensure all dma path entities acquire same pipeline object
+ * @atomic_streamon: Indicates that multi dma media pipe will get enabled
+ *  with single dma start
  */
 struct xvip_composite_device {
 	struct v4l2_device v4l2_dev;
@@ -37,6 +40,11 @@ struct xvip_composite_device {
 
 	struct list_head dmas;
 	u32 v4l2_caps;
+	struct mutex lock; /* lock to protect xvip pipeline instance */
+	bool atomic_streamon;
 };
 
+int xvip_graph_pipeline_start_stop(struct xvip_composite_device *xdev,
+				   struct xvip_pipeline *pipe, bool on);
+
 #endif /* __XILINX_VIPP_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-vpss-csc.c b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
new file mode 100644
index 000000000..9eeca08e1
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-vpss-csc.c
@@ -0,0 +1,1205 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx VPSS Color Space Converter
+ *
+ * Copyright (C) 2017 Xilinx, Inc.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx-v4l2-controls.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XV_CSC_AP_CTRL					(0x000)
+#define XV_CSC_INVIDEOFORMAT				(0x010)
+#define XV_CSC_OUTVIDEOFORMAT				(0x018)
+#define XV_CSC_WIDTH					(0x020)
+#define XV_CSC_HEIGHT					(0x028)
+#define XV_CSC_K11					(0x050)
+#define XV_CSC_K12					(0x058)
+#define XV_CSC_K13					(0x060)
+#define XV_CSC_K21					(0x068)
+#define XV_CSC_K22					(0x070)
+#define XV_CSC_K23					(0x078)
+#define XV_CSC_K31					(0x080)
+#define XV_CSC_K32					(0x088)
+#define XV_CSC_K33					(0x090)
+#define XV_CSC_ROFFSET					(0x098)
+#define XV_CSC_GOFFSET					(0x0a0)
+#define XV_CSC_BOFFSET					(0x0a8)
+#define XV_CSC_CLAMPMIN					(0x0b0)
+#define XV_CSC_CLIPMAX					(0x0b8)
+
+#define XV_CSC_FRACTIONAL_BITS	(12)
+#define XV_CSC_SCALE_FACTOR	(4096)
+/* This a VPSS CSC specific macro used to calculate Contrast */
+#define XV_CSC_DIVISOR		(10000)
+#define XV_CSC_DEFAULT_HEIGHT	(720)
+#define XV_CSC_DEFAULT_WIDTH	(1280)
+#define XV_CSC_K_MAX_ROWS	(3)
+#define XV_CSC_K_MAX_COLUMNS	(3)
+#define XV_CSC_MIN_WIDTH	(64)
+#define XV_CSC_MAX_WIDTH	(8192)
+#define XV_CSC_MIN_HEIGHT	(64)
+#define XV_CSC_MAX_HEIGHT	(4320)
+
+/* GPIO Reset Assert/De-assert */
+#define XCSC_RESET_ASSERT	(1)
+#define XCSC_RESET_DEASSERT	(0)
+/* Streaming Macros */
+#define XCSC_CLAMP_MIN_ZERO	(0)
+#define XCSC_AP_START		BIT(0)
+#define XCSC_AP_AUTO_RESTART	BIT(7)
+#define XCSC_STREAM_ON	(XCSC_AP_START | XCSC_AP_AUTO_RESTART)
+/* Color Control Macros */
+#define XCSC_COLOR_CTRL_COUNT		(5)
+#define XCSC_COLOR_CTRL_DEFAULT		(50)
+
+enum xcsc_color_fmt {
+	XVIDC_CSF_RGB = 0,
+	XVIDC_CSF_YCRCB_444,
+	XVIDC_CSF_YCRCB_422,
+	XVIDC_CSF_YCRCB_420,
+};
+
+enum xcsc_output_range {
+	XVIDC_CR_0_255 = 1,
+	XVIDC_CR_16_240,
+	XVIDC_CR_16_235
+};
+
+enum xcsc_color_depth {
+	XVIDC_BPC_8 = 8,
+	XVIDC_BPC_10 = 10,
+};
+
+static const s32
+rgb_unity_matrix[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
+	{XV_CSC_SCALE_FACTOR, 0, 0, 0},
+	{0, XV_CSC_SCALE_FACTOR, 0, 0},
+	{0, 0, XV_CSC_SCALE_FACTOR, 0},
+};
+
+static const s32
+ycrcb_to_rgb_unity[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
+	{
+	 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0,
+	 17927 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -2132 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -5329 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 11644 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 21124 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0,
+	 0
+	},
+};
+
+static const s32
+rgb_to_ycrcb_unity[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = {
+	{
+	 1826 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 6142 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 620 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 -1006 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -3386 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 4392 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0
+	},
+	{
+	 4392 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -3989 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 -403 * XV_CSC_SCALE_FACTOR / XV_CSC_DIVISOR,
+	 0,
+	},
+};
+
+/**
+ * struct xcsc_dev - xilinx vpss csc device structure
+ * @xvip: Xilinx Video IP core struct
+ * @pads: Media bus pads for VPSS CSC
+ * @formats: Current media bus formats
+ * @default_formats: Default media bus formats for VPSS CSC
+ * @vip_formats: Pointer to DT specified media bus code info
+ * @ctrl_handler: V4L2 Control Handler struct
+ * @custom_ctrls: Array of pointers to various custom controls
+ * @cft_in: IP or Hardware specific input video format
+ * @cft_out: IP or Hardware specific output video format
+ * @output_range: Color range for Outgoing video
+ * @color_depth: Data width used to represent color
+ * @brightness: Expected brightness value
+ * @contrast: Expected contrast value
+ * @red_gain: Expected red gain
+ * @green_gain: Expect green gain
+ * @blue_gain: Expected blue gain
+ * @brightness_active: Current brightness value
+ * @contrast_active: Current contrast value
+ * @red_gain_active: Current red gain
+ * @green_gain_active: Current green gain
+ * @blue_gain_active: Current blue gain
+ * @k_hw : Coefficients to be written to IP/Hardware
+ * @shadow_coeff: Coefficients to track RGB equivalents for color controls
+ * @clip_max: Maximum value to clip output color range
+ * @rst_gpio: Handle to PS GPIO specifier to assert/de-assert the reset line
+ * @max_width: Maximum width supported by IP.
+ * @max_height: Maximum height supported by IP.
+ */
+struct xcsc_dev {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *custom_ctrls[XCSC_COLOR_CTRL_COUNT];
+
+	enum xcsc_color_fmt cft_in;
+	enum xcsc_color_fmt cft_out;
+	enum xcsc_output_range output_range;
+	enum xcsc_color_depth color_depth;
+	s32 brightness;
+	s32 contrast;
+	s32 red_gain;
+	s32 green_gain;
+	s32 blue_gain;
+	s32 brightness_active;
+	s32 contrast_active;
+	s32 red_gain_active;
+	s32 green_gain_active;
+	s32 blue_gain_active;
+	s32 k_hw[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1];
+	s32 shadow_coeff[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1];
+	s32 clip_max;
+	struct gpio_desc *rst_gpio;
+	u32 max_width;
+	u32 max_height;
+};
+
+#ifdef DEBUG
+static u32 xcsc_read(struct xcsc_dev *xcsc, u32 reg)
+{
+	u32 data;
+
+	data = xvip_read(&xcsc->xvip, reg);
+	return data;
+}
+
+static void xcsc_get_coeff(struct xcsc_dev *xcsc, s32 C[3][4])
+{
+	C[0][0] = xcsc_read(xcsc, XV_CSC_K11);
+	C[0][1] = xcsc_read(xcsc, XV_CSC_K12);
+	C[0][2] = xcsc_read(xcsc, XV_CSC_K13);
+	C[1][0] = xcsc_read(xcsc, XV_CSC_K21);
+	C[1][1] = xcsc_read(xcsc, XV_CSC_K22);
+	C[1][2] = xcsc_read(xcsc, XV_CSC_K23);
+	C[2][0] = xcsc_read(xcsc, XV_CSC_K31);
+	C[2][1] = xcsc_read(xcsc, XV_CSC_K32);
+	C[2][2] = xcsc_read(xcsc, XV_CSC_K33);
+	C[0][3] = xcsc_read(xcsc, XV_CSC_ROFFSET);
+	C[1][3] = xcsc_read(xcsc, XV_CSC_GOFFSET);
+	C[2][3] = xcsc_read(xcsc, XV_CSC_BOFFSET);
+}
+
+static void xcsc_print_coeff(struct xcsc_dev *xcsc)
+{
+	s32 C[3][4];
+
+	xcsc_get_coeff(xcsc, C);
+
+	dev_info(xcsc->xvip.dev,
+		 "-------------CSC Coeff Dump Start------\n");
+	dev_info(xcsc->xvip.dev,
+		 " R row : %5d  %5d  %5d\n",
+		 (s16)C[0][0], (s16)C[0][1], (s16)C[0][2]);
+	dev_info(xcsc->xvip.dev,
+		 " G row : %5d  %5d  %5d\n",
+		 (s16)C[1][0], (s16)C[1][1], (s16)C[1][2]);
+	dev_info(xcsc->xvip.dev,
+		 " B row : %5d  %5d  %5d\n",
+		 (s16)C[2][0], (s16)C[2][1], (s16)C[2][2]);
+	dev_info(xcsc->xvip.dev,
+		 "Offset : %5d  %5d  %5d\n",
+		 (s16)C[0][3], (s16)C[1][3], (s16)C[2][3]);
+	dev_info(xcsc->xvip.dev,
+		 "ClampMin: %3d  ClipMax %3d",
+		 xcsc_read(xcsc, XV_CSC_CLAMPMIN),
+		 xcsc_read(xcsc, XV_CSC_CLIPMAX));
+	dev_info(xcsc->xvip.dev,
+		 "-------------CSC Coeff Dump Stop-------\n");
+}
+
+static void
+xcsc_log_coeff(struct device *dev,
+	       s32 coeff[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	if (!dev)
+		return;
+	dev_dbg(dev, "--- %s : Start Coeff Log ---", __func__);
+	dev_dbg(dev, "R row : %5d  %5d  %5d\n",
+		coeff[0][0], coeff[0][1], coeff[0][2]);
+	dev_dbg(dev, "G row : %5d  %5d  %5d\n",
+		coeff[1][0], coeff[1][1], coeff[1][2]);
+	dev_dbg(dev, "B row : %5d  %5d  %5d\n",
+		coeff[2][0], coeff[2][1], coeff[2][2]);
+	dev_dbg(dev, "Offset: %5d  %5d  %5d\n",
+		coeff[0][3], coeff[1][3], coeff[2][3]);
+	dev_dbg(dev, "---  %s : Stop Coeff Log ---", __func__);
+}
+
+static void xcsc_print_k_hw(struct xcsc_dev *xcsc)
+{
+	dev_dbg(xcsc->xvip.dev,
+		"-------------CSC Driver k_hw[][] Dump------------\n");
+	xcsc_log_coeff(xcsc->xvip.dev, xcsc->k_hw);
+	dev_dbg(xcsc->xvip.dev,
+		"-------------------------------------------------\n");
+}
+#endif /* DEBUG */
+
+static void xcsc_write(struct xcsc_dev *xcsc, u32 reg, u32 data)
+{
+	xvip_write(&xcsc->xvip, reg, data);
+}
+
+static void xcsc_write_rgb_3x3(struct xcsc_dev *xcsc)
+{
+	/* Write Matrix Coefficients */
+	xcsc_write(xcsc, XV_CSC_K11, xcsc->k_hw[0][0]);
+	xcsc_write(xcsc, XV_CSC_K12, xcsc->k_hw[0][1]);
+	xcsc_write(xcsc, XV_CSC_K13, xcsc->k_hw[0][2]);
+	xcsc_write(xcsc, XV_CSC_K21, xcsc->k_hw[1][0]);
+	xcsc_write(xcsc, XV_CSC_K22, xcsc->k_hw[1][1]);
+	xcsc_write(xcsc, XV_CSC_K23, xcsc->k_hw[1][2]);
+	xcsc_write(xcsc, XV_CSC_K31, xcsc->k_hw[2][0]);
+	xcsc_write(xcsc, XV_CSC_K32, xcsc->k_hw[2][1]);
+	xcsc_write(xcsc, XV_CSC_K33, xcsc->k_hw[2][2]);
+}
+
+static void xcsc_write_rgb_offset(struct xcsc_dev *xcsc)
+{
+	/* Write RGB Offsets */
+	xcsc_write(xcsc, XV_CSC_ROFFSET, xcsc->k_hw[0][3]);
+	xcsc_write(xcsc, XV_CSC_GOFFSET, xcsc->k_hw[1][3]);
+	xcsc_write(xcsc, XV_CSC_BOFFSET, xcsc->k_hw[2][3]);
+}
+
+static void xcsc_write_coeff(struct xcsc_dev *xcsc)
+{
+	xcsc_write_rgb_3x3(xcsc);
+	xcsc_write_rgb_offset(xcsc);
+}
+
+static void xcsc_set_control_defaults(struct xcsc_dev *xcsc)
+{
+	/* These are VPSS CSC IP specific defaults */
+	xcsc->brightness = 120;
+	xcsc->contrast = 0;
+	xcsc->red_gain = 120;
+	xcsc->blue_gain = 120;
+	xcsc->green_gain = 120;
+	xcsc->brightness_active	= 120;
+	xcsc->contrast_active = 0;
+	xcsc->red_gain_active = 120;
+	xcsc->blue_gain_active = 120;
+	xcsc->green_gain_active = 120;
+}
+
+static void xcsc_copy_coeff(
+	s32 dest[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1],
+	s32 const src[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	unsigned int i, j;
+
+	for (i = 0; i < XV_CSC_K_MAX_ROWS; i++)
+		for (j = 0; j < XV_CSC_K_MAX_COLUMNS + 1; j++)
+			memcpy(&dest[i][j], &src[i][j], sizeof(dest[0][0]));
+}
+
+static void xcsc_set_unity_matrix(struct xcsc_dev *xcsc)
+{
+	xcsc_copy_coeff(xcsc->k_hw, rgb_unity_matrix);
+	xcsc_copy_coeff(xcsc->shadow_coeff, rgb_unity_matrix);
+}
+
+static void xcsc_set_default_state(struct xcsc_dev *xcsc)
+{
+	xcsc->cft_in = XVIDC_CSF_RGB;
+	xcsc->cft_out = XVIDC_CSF_RGB;
+	xcsc->output_range = XVIDC_CR_0_255;
+	/* Needed to add 10, 12 and 16 bit color depth support */
+	xcsc->clip_max = BIT(xcsc->color_depth) - 1;
+	xcsc_set_control_defaults(xcsc);
+	xcsc_set_unity_matrix(xcsc);
+	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
+	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
+	xcsc_write_coeff(xcsc);
+	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
+	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
+}
+
+static void
+xcsc_ycrcb_to_rgb(struct xcsc_dev *xcsc, s32 *clip_max,
+		  s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	u16 bpc_scale = BIT(xcsc->color_depth - 8);
+
+	/*
+	 * See http://graficaobscura.com/matrix/index.html for
+	 * how these numbers are derived. The VPSS CSC IP is
+	 * derived from this Matrix style algorithm. And the
+	 * 'magic' numbers here are derived from the algorithm.
+	 *
+	 * XV_CSC_DIVISOR is used to help with floating constants
+	 * while performing multiplicative operations
+	 *
+	 * Coefficients valid only for BT 709
+	 */
+	dev_dbg(xcsc->xvip.dev, "Performing YCrCb to RGB BT 709");
+	xcsc_copy_coeff(temp, ycrcb_to_rgb_unity);
+	temp[0][3] = -248 * bpc_scale;
+	temp[1][3] = 77 * bpc_scale;
+	temp[2][3] = -289 * bpc_scale;
+	*clip_max = BIT(xcsc->color_depth) - 1;
+}
+
+static void
+xcsc_matrix_multiply(s32 K1[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1],
+		     s32 K2[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1],
+		     s32 kout[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	s32 A, B, C, D, E, F, G, H, I, J, K, L, M, N;
+	s32 O, P, Q, R, S, T, U, V, W, X;
+
+	A = K1[0][0]; B = K1[0][1]; C = K1[0][2]; J = K1[0][3];
+	D = K1[1][0]; E = K1[1][1]; F = K1[1][2]; K = K1[1][3];
+	G = K1[2][0]; H = K1[2][1]; I = K1[2][2]; L = K1[2][3];
+
+	M = K2[0][0]; N = K2[0][1]; O = K2[0][2]; V = K2[0][3];
+	P = K2[1][0]; Q = K2[1][1]; R = K2[1][2]; W = K2[1][3];
+	S = K2[2][0]; T = K2[2][1]; U = K2[2][2]; X = K2[2][3];
+
+	kout[0][0] = (M * A + N * D + O * G) / XV_CSC_SCALE_FACTOR;
+	kout[0][1] = (M * B + N * E + O * H) / XV_CSC_SCALE_FACTOR;
+	kout[0][2] = (M * C + N * F + O * I) / XV_CSC_SCALE_FACTOR;
+	kout[1][0] = (P * A + Q * D + R * G) / XV_CSC_SCALE_FACTOR;
+	kout[1][1] = (P * B + Q * E + R * H) / XV_CSC_SCALE_FACTOR;
+	kout[1][2] = (P * C + Q * F + R * I) / XV_CSC_SCALE_FACTOR;
+	kout[2][0] = (S * A + T * D + U * G) / XV_CSC_SCALE_FACTOR;
+	kout[2][1] = (S * B + T * E + U * H) / XV_CSC_SCALE_FACTOR;
+	kout[2][2] = (S * C + T * F + U * I) / XV_CSC_SCALE_FACTOR;
+	kout[0][3] = ((M * J + N * K + O * L) / XV_CSC_SCALE_FACTOR) + V;
+	kout[1][3] = ((P * J + Q * K + R * L) / XV_CSC_SCALE_FACTOR) + W;
+	kout[2][3] = ((S * J + T * K + U * L) / XV_CSC_SCALE_FACTOR) + X;
+}
+
+static void
+xcsc_rgb_to_ycrcb(struct xcsc_dev *xcsc, s32 *clip_max,
+		  s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	u16 bpc_scale = BIT(xcsc->color_depth - 8);
+
+	/*
+	 * See http://graficaobscura.com/matrix/index.html for
+	 * how these numbers are derived. The VPSS CSC IP is
+	 * derived from this Matrix style algorithm. And the
+	 * 'magic' numbers here are derived from the algorithm.
+	 *
+	 * XV_CSC_DIVISOR is used to help with floating constants
+	 * while performing multiplicative operations
+	 *
+	 * Coefficients valid only for BT 709
+	 */
+	dev_dbg(xcsc->xvip.dev, "Performing RGB to YCrCb BT 709");
+	xcsc_copy_coeff(temp, rgb_to_ycrcb_unity);
+	temp[0][3] = 16 * bpc_scale;
+	temp[1][3] = 128 * bpc_scale;
+	temp[2][3] = 128 * bpc_scale;
+	*clip_max = BIT(xcsc->color_depth) - 1;
+}
+
+static int xcsc_update_formats(struct xcsc_dev *xcsc)
+{
+	u32 color_in, color_out;
+
+	/* Write In and Out Video Formats */
+	color_in = xcsc->formats[XVIP_PAD_SINK].code;
+	color_out = xcsc->formats[XVIP_PAD_SOURCE].code;
+
+	switch (color_in) {
+	case MEDIA_BUS_FMT_RBG888_1X24:
+	case MEDIA_BUS_FMT_RBG101010_1X30:
+		dev_dbg(xcsc->xvip.dev, "Media Format In : RGB");
+		xcsc->cft_in = XVIDC_CSF_RGB;
+		break;
+	case MEDIA_BUS_FMT_VUY8_1X24:
+	case MEDIA_BUS_FMT_VUY10_1X30:
+		dev_dbg(xcsc->xvip.dev, "Media Format In : YUV 444");
+		xcsc->cft_in = XVIDC_CSF_YCRCB_444;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		dev_dbg(xcsc->xvip.dev, "Media Format In : YUV 422");
+		xcsc->cft_in = XVIDC_CSF_YCRCB_422;
+		break;
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+	case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		dev_dbg(xcsc->xvip.dev, "Media Format In : YUV 420");
+		xcsc->cft_in = XVIDC_CSF_YCRCB_420;
+		break;
+	}
+
+	switch (color_out) {
+	case MEDIA_BUS_FMT_RBG888_1X24:
+	case MEDIA_BUS_FMT_RBG101010_1X30:
+		xcsc->cft_out = XVIDC_CSF_RGB;
+		dev_dbg(xcsc->xvip.dev, "Media Format Out : RGB");
+		if (color_in != MEDIA_BUS_FMT_RBG888_1X24)
+			xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
+		break;
+	case MEDIA_BUS_FMT_VUY8_1X24:
+	case MEDIA_BUS_FMT_VUY10_1X30:
+		xcsc->cft_out = XVIDC_CSF_YCRCB_444;
+		dev_dbg(xcsc->xvip.dev, "Media Format Out : YUV 444");
+		if (color_in == MEDIA_BUS_FMT_RBG888_1X24)
+			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		xcsc->cft_out = XVIDC_CSF_YCRCB_422;
+		dev_dbg(xcsc->xvip.dev, "Media Format Out : YUV 422");
+		if (color_in == MEDIA_BUS_FMT_RBG888_1X24)
+			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
+		break;
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+	case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		xcsc->cft_out = XVIDC_CSF_YCRCB_420;
+		dev_dbg(xcsc->xvip.dev, "Media Format Out : YUV 420");
+		if (color_in ==  MEDIA_BUS_FMT_RBG888_1X24)
+			xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, xcsc->k_hw);
+		else
+			xcsc_set_unity_matrix(xcsc);
+		break;
+	}
+
+	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
+	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
+
+	xcsc_write_coeff(xcsc);
+
+	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
+	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
+#ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
+	xcsc_print_coeff(xcsc);
+#endif
+	return 0;
+}
+
+static inline struct xcsc_dev *to_csc(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xcsc_dev, xvip.subdev);
+}
+
+static struct v4l2_mbus_framefmt *
+__xcsc_get_pad_format(struct xcsc_dev *xcsc,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xcsc->xvip.subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xcsc->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static void
+xcsc_correct_coeff(struct xcsc_dev *xcsc,
+		   s32 temp[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1])
+{
+	s32 csc_change[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
+	s32 csc_extra[XV_CSC_K_MAX_ROWS][XV_CSC_K_MAX_COLUMNS + 1] = { {0} };
+	u32 mbus_in = xcsc->formats[XVIP_PAD_SINK].code;
+	u32 mbus_out = xcsc->formats[XVIP_PAD_SOURCE].code;
+
+#ifdef DEBUG
+	xcsc_log_coeff(xcsc->xvip.dev, temp);
+#endif
+	if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 && mbus_out == mbus_in) {
+		dev_dbg(xcsc->xvip.dev, "%s : RGB to RGB", __func__);
+		xcsc_copy_coeff(xcsc->k_hw,
+				(const s32 (*)[XV_CSC_K_MAX_COLUMNS + 1])temp);
+	} else if (mbus_in == MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : RGB to YUV", __func__);
+		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(temp, csc_change, xcsc->k_hw);
+	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out == MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : YUV to RGB", __func__);
+		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_change, temp, xcsc->k_hw);
+	} else if (mbus_in != MEDIA_BUS_FMT_RBG888_1X24 &&
+		   mbus_out != MEDIA_BUS_FMT_RBG888_1X24) {
+		dev_dbg(xcsc->xvip.dev, "%s : YUV to YUV", __func__);
+		xcsc_ycrcb_to_rgb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_change, temp, csc_extra);
+		xcsc_rgb_to_ycrcb(xcsc, &xcsc->clip_max, csc_change);
+		xcsc_matrix_multiply(csc_extra, csc_change, xcsc->k_hw);
+	} else {
+		/* Should never get here */
+		WARN_ON(1);
+	}
+}
+
+static void xcsc_set_brightness(struct xcsc_dev *xcsc)
+{
+	unsigned int i, j;
+
+	dev_dbg(xcsc->xvip.dev,
+		"%s : Brightness %d Brightness Active %d",
+		__func__,
+		((xcsc->brightness - 20) / 2),
+		((xcsc->brightness_active - 20) / 2));
+	if (xcsc->brightness == xcsc->brightness_active)
+		return;
+	for (i = 0; i < XV_CSC_K_MAX_ROWS; i++) {
+		for (j = 0; j < XV_CSC_K_MAX_COLUMNS; j++) {
+			xcsc->shadow_coeff[i][j] = (xcsc->shadow_coeff[i][j] *
+						    xcsc->brightness) /
+						    xcsc->brightness_active;
+		}
+	}
+	xcsc->brightness_active = xcsc->brightness;
+	xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+	xcsc_write_coeff(xcsc);
+#ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
+	xcsc_print_coeff(xcsc);
+#endif
+}
+
+static void xcsc_set_contrast(struct xcsc_dev *xcsc)
+{
+	s32 contrast;
+	u8 scale = BIT(xcsc->color_depth - 8);
+
+	contrast = xcsc->contrast - xcsc->contrast_active;
+	dev_dbg(xcsc->xvip.dev,
+		"%s : Contrast Difference %d scale = %d",
+		__func__, contrast, scale);
+	/* Avoid updates if same */
+	if (!contrast)
+		return;
+	/* Update RGB Offsets */
+	xcsc->shadow_coeff[0][3] += contrast * scale;
+	xcsc->shadow_coeff[1][3] += contrast * scale;
+	xcsc->shadow_coeff[2][3] += contrast * scale;
+	xcsc->contrast_active = xcsc->contrast;
+	xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+	xcsc_write_coeff(xcsc);
+#ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
+	xcsc_print_coeff(xcsc);
+#endif
+}
+
+static void xcsc_set_red_gain(struct xcsc_dev *xcsc)
+{
+	dev_dbg(xcsc->xvip.dev,
+		"%s: Red Gain %d Red Gain Active %d", __func__,
+		(xcsc->red_gain - 20) / 2,
+		(xcsc->red_gain_active - 20) / 2);
+
+	if (xcsc->red_gain != xcsc->red_gain_active) {
+		xcsc->shadow_coeff[0][0] = (xcsc->shadow_coeff[0][0] *
+					    xcsc->red_gain) /
+					    xcsc->red_gain_active;
+		xcsc->shadow_coeff[0][1] = (xcsc->shadow_coeff[0][1] *
+					    xcsc->red_gain) /
+					    xcsc->red_gain_active;
+		xcsc->shadow_coeff[0][2] = (xcsc->shadow_coeff[0][2] *
+					    xcsc->red_gain) /
+					    xcsc->red_gain_active;
+		xcsc->red_gain_active = xcsc->red_gain;
+		xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+		xcsc_write_coeff(xcsc);
+	}
+#ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
+	xcsc_print_coeff(xcsc);
+#endif
+}
+
+static void xcsc_set_green_gain(struct xcsc_dev *xcsc)
+{
+	dev_dbg(xcsc->xvip.dev,
+		"%s: Green Gain %d Green Gain Active %d", __func__,
+		 (xcsc->green_gain - 20) / 2,
+		 (xcsc->green_gain_active - 20) / 2);
+
+	if (xcsc->green_gain != xcsc->green_gain_active) {
+		xcsc->shadow_coeff[1][0] = (xcsc->shadow_coeff[1][0] *
+					    xcsc->green_gain) /
+					    xcsc->green_gain_active;
+		xcsc->shadow_coeff[1][1] = (xcsc->shadow_coeff[1][1] *
+					    xcsc->green_gain) /
+					    xcsc->green_gain_active;
+		xcsc->shadow_coeff[1][2] = (xcsc->shadow_coeff[1][2] *
+					    xcsc->green_gain) /
+					    xcsc->green_gain_active;
+		xcsc->green_gain_active = xcsc->green_gain;
+		xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+		xcsc_write_coeff(xcsc);
+	}
+#ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
+	xcsc_print_coeff(xcsc);
+#endif
+}
+
+static void xcsc_set_blue_gain(struct xcsc_dev *xcsc)
+{
+	dev_dbg(xcsc->xvip.dev,
+		"%s: Blue Gain %d Blue Gain Active %d", __func__,
+		 (xcsc->blue_gain - 20) / 2,
+		 (xcsc->blue_gain_active - 20) / 2);
+
+	if (xcsc->blue_gain != xcsc->blue_gain_active) {
+		xcsc->shadow_coeff[2][0] = (xcsc->shadow_coeff[2][0] *
+					    xcsc->blue_gain) /
+					     xcsc->blue_gain_active;
+		xcsc->shadow_coeff[2][1] = (xcsc->shadow_coeff[2][1] *
+					    xcsc->blue_gain) /
+					     xcsc->blue_gain_active;
+		xcsc->shadow_coeff[2][2] = (xcsc->shadow_coeff[2][2] *
+					    xcsc->blue_gain) /
+					     xcsc->blue_gain_active;
+		xcsc->blue_gain_active = xcsc->blue_gain;
+		xcsc_correct_coeff(xcsc, xcsc->shadow_coeff);
+		xcsc_write_coeff(xcsc);
+	}
+#ifdef DEBUG
+	xcsc_print_k_hw(xcsc);
+	xcsc_print_coeff(xcsc);
+#endif
+}
+
+static void xcsc_set_size(struct xcsc_dev *xcsc)
+{
+	u32 width, height;
+
+	width = xcsc->formats[XVIP_PAD_SINK].width;
+	height = xcsc->formats[XVIP_PAD_SINK].height;
+	dev_dbg(xcsc->xvip.dev, "%s : Setting width %d and height %d",
+		__func__, width, height);
+	xcsc_write(xcsc, XV_CSC_WIDTH, width);
+	xcsc_write(xcsc, XV_CSC_HEIGHT, height);
+}
+
+static int xcsc_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xcsc_dev *xcsc = to_csc(subdev);
+
+	dev_dbg(xcsc->xvip.dev, "%s : Stream %s", __func__,
+		enable ? "On" : "Off");
+	if (!enable) {
+		/* Reset the Global IP Reset through PS GPIO */
+		gpiod_set_value_cansleep(xcsc->rst_gpio, XCSC_RESET_ASSERT);
+		gpiod_set_value_cansleep(xcsc->rst_gpio, XCSC_RESET_DEASSERT);
+
+		/* Reset the active controls */
+		xcsc->brightness_active	= 120;
+		xcsc->contrast_active = 0;
+		xcsc->red_gain_active = 120;
+		xcsc->blue_gain_active = 120;
+		xcsc->green_gain_active = 120;
+		xcsc_copy_coeff(xcsc->shadow_coeff, rgb_unity_matrix);
+
+		return 0;
+	}
+	/* Set the controls */
+	xcsc_set_brightness(xcsc);
+	xcsc_set_contrast(xcsc);
+	xcsc_set_red_gain(xcsc);
+	xcsc_set_green_gain(xcsc);
+	xcsc_set_blue_gain(xcsc);
+
+	xcsc_write(xcsc, XV_CSC_INVIDEOFORMAT, xcsc->cft_in);
+	xcsc_write(xcsc, XV_CSC_OUTVIDEOFORMAT, xcsc->cft_out);
+	xcsc_write(xcsc, XV_CSC_CLIPMAX, xcsc->clip_max);
+	xcsc_write(xcsc, XV_CSC_CLAMPMIN, XCSC_CLAMP_MIN_ZERO);
+	xcsc_set_size(xcsc);
+	xcsc_write_coeff(xcsc);
+#ifdef DEBUG
+	xcsc_print_coeff(xcsc);
+	dev_dbg(xcsc->xvip.dev, "cft_in = %d cft_out = %d",
+		xcsc_read(xcsc, XV_CSC_INVIDEOFORMAT),
+		xcsc_read(xcsc, XV_CSC_OUTVIDEOFORMAT));
+	dev_dbg(xcsc->xvip.dev, "clipmax = %d clampmin = %d",
+		xcsc_read(xcsc, XV_CSC_CLIPMAX),
+		xcsc_read(xcsc, XV_CSC_CLAMPMIN));
+	dev_dbg(xcsc->xvip.dev, "height = %d width = %d",
+		xcsc_read(xcsc, XV_CSC_HEIGHT),
+		xcsc_read(xcsc, XV_CSC_WIDTH));
+#endif
+	/* Start VPSS CSC IP */
+	xcsc_write(xcsc, XV_CSC_AP_CTRL, XCSC_STREAM_ON);
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops xcsc_video_ops = {
+	.s_stream = xcsc_s_stream,
+};
+
+static int xcsc_get_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xcsc_dev *xcsc = to_csc(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xcsc_get_pad_format(xcsc, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int xcsc_set_format(struct v4l2_subdev *subdev,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct xcsc_dev *xcsc = to_csc(subdev);
+	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *__propagate;
+
+	__format = __xcsc_get_pad_format(xcsc, sd_state, fmt->pad, fmt->which);
+	if (!__format)
+		return -EINVAL;
+
+	/* Propagate to Source Pad */
+	__propagate = __xcsc_get_pad_format(xcsc, sd_state,
+					    XVIP_PAD_SOURCE, fmt->which);
+	if (!__propagate)
+		return -EINVAL;
+
+	*__format = fmt->format;
+
+	__format->width = clamp_t(unsigned int, fmt->format.width,
+				  XV_CSC_MIN_WIDTH, xcsc->max_width);
+	__format->height = clamp_t(unsigned int, fmt->format.height,
+				   XV_CSC_MIN_HEIGHT, xcsc->max_height);
+
+	switch (__format->code) {
+	case MEDIA_BUS_FMT_VUY8_1X24:
+	case MEDIA_BUS_FMT_RBG888_1X24:
+	case MEDIA_BUS_FMT_RBG101010_1X30:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+	case MEDIA_BUS_FMT_VYYUYY10_4X20:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_VUY10_1X30:
+		break;
+	default:
+		/* Unsupported Format. Default to RGB */
+		__format->code = MEDIA_BUS_FMT_RBG888_1X24;
+		return -EINVAL;
+	}
+
+	/* Always propagate Sink image size to Source */
+	__propagate->width  = __format->width;
+	__propagate->height = __format->height;
+
+	fmt->format = *__format;
+	xcsc_update_formats(xcsc);
+	dev_info(xcsc->xvip.dev, "VPSS CSC color controls reset to defaults");
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops xcsc_pad_ops = {
+	.enum_mbus_code = xvip_enum_mbus_code,
+	.enum_frame_size = xvip_enum_frame_size,
+	.get_fmt = xcsc_get_format,
+	.set_fmt = xcsc_set_format,
+};
+
+static const struct v4l2_subdev_ops xcsc_ops = {
+	.video = &xcsc_video_ops,
+	.pad = &xcsc_pad_ops
+};
+
+static int xcsc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct xcsc_dev *xcsc = container_of(ctrl->handler,
+					struct xcsc_dev,
+					ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_XILINX_CSC_BRIGHTNESS:
+		xcsc->brightness = (2 * ctrl->val) + 20;
+		break;
+	case V4L2_CID_XILINX_CSC_CONTRAST:
+		xcsc->contrast = (4 * ctrl->val) - 200;
+		break;
+	case V4L2_CID_XILINX_CSC_RED_GAIN:
+		xcsc->red_gain =  (2 * ctrl->val) + 20;
+		break;
+	case V4L2_CID_XILINX_CSC_BLUE_GAIN:
+		xcsc->blue_gain =  (2 * ctrl->val) + 20;
+		break;
+	case V4L2_CID_XILINX_CSC_GREEN_GAIN:
+		xcsc->green_gain =  (2 * ctrl->val) + 20;
+		break;
+	}
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops xcsc_ctrl_ops = {
+	.s_ctrl = xcsc_s_ctrl,
+};
+
+static struct v4l2_ctrl_config xcsc_color_ctrls[XCSC_COLOR_CTRL_COUNT] = {
+	/* Brightness */
+	{
+		.ops = &xcsc_ctrl_ops,
+		.id = V4L2_CID_XILINX_CSC_BRIGHTNESS,
+		.name = "CSC Brightness",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Contrast */
+	{
+		.ops = &xcsc_ctrl_ops,
+		.id = V4L2_CID_XILINX_CSC_CONTRAST,
+		.name = "CSC Contrast",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Red Gain */
+	{
+		.ops = &xcsc_ctrl_ops,
+		.id = V4L2_CID_XILINX_CSC_RED_GAIN,
+		.name = "CSC Red Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Blue Gain */
+	{
+		.ops = &xcsc_ctrl_ops,
+		.id = V4L2_CID_XILINX_CSC_BLUE_GAIN,
+		.name = "CSC Blue Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+	/* Green Gain */
+	{
+		.ops = &xcsc_ctrl_ops,
+		.id = V4L2_CID_XILINX_CSC_GREEN_GAIN,
+		.name = "CSC Green Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = XCSC_COLOR_CTRL_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+	},
+};
+
+static int xcsc_open(struct v4l2_subdev *subdev,
+		     struct v4l2_subdev_fh *fh)
+{
+	struct xcsc_dev *xcsc = to_csc(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xcsc->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state,
+					    XVIP_PAD_SOURCE);
+	*format = xcsc->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int xcsc_close(struct v4l2_subdev *subdev,
+		      struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops xcsc_internal_ops = {
+	.open  = xcsc_open,
+	.close = xcsc_close,
+};
+
+static const struct media_entity_operations xcsc_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int xcsc_parse_of(struct xcsc_dev *xcsc)
+{
+	struct device *dev = xcsc->xvip.dev;
+	struct device_node *node = xcsc->xvip.dev->of_node;
+	const struct xvip_video_format *vip_format;
+	struct device_node *ports, *port;
+	int rval;
+	u32 port_id = 0;
+	u32 video_width[2] = {0};
+
+	rval = of_property_read_u32(node, "xlnx,max-height", &xcsc->max_height);
+	if (rval < 0) {
+		dev_err(dev, "xlnx,max-height is missing!");
+		return -EINVAL;
+	} else if (xcsc->max_height > XV_CSC_MAX_HEIGHT ||
+		   xcsc->max_height < XV_CSC_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	rval = of_property_read_u32(node, "xlnx,max-width", &xcsc->max_width);
+	if (rval < 0) {
+		dev_err(dev, "xlnx,max-width is missing!");
+		return -EINVAL;
+	} else if (xcsc->max_width > XV_CSC_MAX_WIDTH ||
+		   xcsc->max_width < XV_CSC_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "Invalid media pad format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			rval = of_property_read_u32(port, "reg", &port_id);
+			if (rval < 0) {
+				dev_err(dev, "No reg in DT to specify pad");
+				return rval;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "Invalid reg in DT");
+				return -EINVAL;
+			}
+			xcsc->vip_formats[port_id] = vip_format;
+
+			rval = of_property_read_u32(port, "xlnx,video-width",
+						    &video_width[port_id]);
+			if (rval < 0) {
+				dev_err(dev,
+					"DT Port%d xlnx,video-width not found",
+					port_id);
+				return rval;
+			}
+		}
+	}
+	if (video_width[0] != video_width[1]) {
+		dev_err(dev, "Changing video width in DT not supported");
+		return -EINVAL;
+	}
+	switch (video_width[0]) {
+	case XVIDC_BPC_8:
+		xcsc->color_depth = XVIDC_BPC_8;
+		break;
+	case XVIDC_BPC_10:
+		xcsc->color_depth = XVIDC_BPC_10;
+		break;
+	default:
+		dev_err(dev, "Unsupported color depth %d", video_width[0]);
+		return -EINVAL;
+	}
+	/* Reset GPIO */
+	xcsc->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(xcsc->rst_gpio)) {
+		if (PTR_ERR(xcsc->rst_gpio) != -EPROBE_DEFER)
+			dev_err(dev, "Reset GPIO not setup in DT");
+		return PTR_ERR(xcsc->rst_gpio);
+	}
+	return 0;
+}
+
+static int xcsc_probe(struct platform_device *pdev)
+{
+	struct xcsc_dev *xcsc;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *def_fmt;
+	int rval, itr;
+
+	xcsc = devm_kzalloc(&pdev->dev, sizeof(*xcsc), GFP_KERNEL);
+	if (!xcsc)
+		return -ENOMEM;
+
+	xcsc->xvip.dev = &pdev->dev;
+
+	rval = xcsc_parse_of(xcsc);
+	if (rval < 0)
+		return rval;
+
+	/* Reset and initialize the core */
+	gpiod_set_value_cansleep(xcsc->rst_gpio, XCSC_RESET_DEASSERT);
+	rval = xvip_init_resources(&xcsc->xvip);
+	if (rval < 0)
+		return rval;
+
+	/* Init v4l2 subdev */
+	subdev = &xcsc->xvip.subdev;
+	v4l2_subdev_init(subdev, &xcsc_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xcsc_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xcsc);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Default Formats Initialization */
+	xcsc_set_default_state(xcsc);
+	def_fmt = &xcsc->default_formats[XVIP_PAD_SINK];
+	def_fmt->code = xcsc->vip_formats[XVIP_PAD_SINK]->code;
+	def_fmt->field = V4L2_FIELD_NONE;
+	def_fmt->colorspace = V4L2_COLORSPACE_REC709;
+	def_fmt->width = XV_CSC_DEFAULT_WIDTH;
+	def_fmt->height = XV_CSC_DEFAULT_HEIGHT;
+	xcsc->formats[XVIP_PAD_SINK] = *def_fmt;
+	/* Source supports only YUV 444, YUV 422, and RGB */
+	def_fmt = &xcsc->default_formats[XVIP_PAD_SOURCE];
+	*def_fmt = xcsc->default_formats[XVIP_PAD_SINK];
+	def_fmt->code = xcsc->vip_formats[XVIP_PAD_SOURCE]->code;
+	def_fmt->width = XV_CSC_DEFAULT_WIDTH;
+	def_fmt->height = XV_CSC_DEFAULT_HEIGHT;
+	xcsc->formats[XVIP_PAD_SOURCE] = *def_fmt;
+	xcsc->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xcsc->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Init Media Entity */
+	subdev->entity.ops = &xcsc_media_ops;
+	rval = media_entity_pads_init(&subdev->entity, 2, xcsc->pads);
+	if (rval < 0)
+		goto media_error;
+	/* V4L2 Control Setup */
+	v4l2_ctrl_handler_init(&xcsc->ctrl_handler,
+			       ARRAY_SIZE(xcsc_color_ctrls));
+	for (itr = 0; itr < ARRAY_SIZE(xcsc_color_ctrls); itr++) {
+		xcsc->custom_ctrls[itr] =
+			v4l2_ctrl_new_custom(&xcsc->ctrl_handler,
+					     &xcsc_color_ctrls[itr], NULL);
+	}
+	if (xcsc->ctrl_handler.error) {
+		dev_err(&pdev->dev, "Failed to add  v4l2 controls");
+		rval = xcsc->ctrl_handler.error;
+		goto ctrl_error;
+	}
+	subdev->ctrl_handler = &xcsc->ctrl_handler;
+	rval = v4l2_ctrl_handler_setup(&xcsc->ctrl_handler);
+	if (rval < 0) {
+		dev_err(xcsc->xvip.dev, "Failed to setup control handler");
+		goto ctrl_error;
+	}
+	platform_set_drvdata(pdev, xcsc);
+	rval = v4l2_async_register_subdev(subdev);
+	if (rval < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto ctrl_error;
+	}
+	dev_info(&pdev->dev, "VPSS CSC %d-bit Color Depth Probe Successful",
+		 xcsc->color_depth);
+	return 0;
+ctrl_error:
+	v4l2_ctrl_handler_free(&xcsc->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+media_error:
+	xvip_cleanup_resources(&xcsc->xvip);
+	return rval;
+}
+
+static int xcsc_remove(struct platform_device *pdev)
+{
+	struct xcsc_dev *xcsc = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xcsc->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&xcsc->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+	xvip_cleanup_resources(&xcsc->xvip);
+	return 0;
+}
+
+static const struct of_device_id xcsc_of_id_table[] = {
+	{.compatible = "xlnx,v-vpss-csc"},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, xcsc_of_id_table);
+
+static struct platform_driver xcsc_driver = {
+	.driver = {
+		.name = "xilinx-vpss-csc",
+		.of_match_table = xcsc_of_id_table,
+	},
+	.probe = xcsc_probe,
+	.remove = xcsc_remove,
+};
+
+module_platform_driver(xcsc_driver);
+MODULE_DESCRIPTION("Xilinx VPSS CSC Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-vpss-scaler.c b/drivers/media/platform/xilinx/xilinx-vpss-scaler.c
new file mode 100644
index 000000000..a7620d5c0
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-vpss-scaler.c
@@ -0,0 +1,2125 @@
+/*
+ * Xilinx VPSS Scaler
+ *
+ * Copyright (C) 2017 Xilinx, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+#include "xilinx-vip.h"
+
+#define XSCALER_MIN_WIDTH		(64)
+#define XSCALER_MAX_WIDTH		(8192)
+#define XSCALER_MIN_HEIGHT		(64)
+#define XSCALER_MAX_HEIGHT		(4320)
+#define XSCALER_MAX_PHASES		(64)
+
+/* Modify to defaults incase it is not configured from application */
+#define XSCALER_DEF_IN_HEIGHT		(720)
+#define XSCALER_DEF_IN_WIDTH		(1280)
+#define XSCALER_DEF_OUT_HEIGHT		(1080)
+#define XSCALER_DEF_OUT_WIDTH		(1920)
+
+#define XSCALER_HSF			(0x0100)
+#define XSCALER_VSF			(0x0104)
+#define XSCALER_SF_SHIFT		(20)
+#define XSCALER_SF_MASK			(0xffffff)
+#define XSCALER_SOURCE_SIZE		(0x0108)
+#define XSCALER_SIZE_HORZ_SHIFT		(0)
+#define XSCALER_SIZE_VERT_SHIFT		(16)
+#define XSCALER_SIZE_MASK		(0xfff)
+#define XSCALER_HAPERTURE		(0x010c)
+#define XSCALER_VAPERTURE		(0x0110)
+#define XSCALER_APERTURE_START_SHIFT	(0)
+#define XSCALER_APERTURE_END_SHIFT	(16)
+#define XSCALER_OUTPUT_SIZE		(0x0114)
+#define XSCALER_COEF_DATA_IN		(0x0134)
+#define XSCALER_BITSHIFT_16		(16)
+
+/* Video subsytems block offset */
+#define S_AXIS_RESET_OFF	(0x00010000)
+#define V_HSCALER_OFF		(0x00000000)
+#define V_VSCALER_OFF		(0x00020000)
+
+/* HW Reset Network GPIO Channel */
+#define XGPIO_CH_RESET_SEL		(1)
+#define XGPIO_RESET_MASK_VIDEO_IN	BIT(0)
+#define XGPIO_RESET_MASK_IP_AXIS	BIT(1)
+#define XGPIO_RESET_MASK_IP_AXIMM	BIT(0)
+#define XGPIO_RESET_MASK_ALL_BLOCKS	(XGPIO_RESET_MASK_VIDEO_IN  | \
+						XGPIO_RESET_MASK_IP_AXIS)
+#define XGPIO_DATA_OFFSET		(0x0)
+#define XGPIO_TRI_OFFSET		(0x4)
+#define XGPIO_DATA2_OFFSET		(0x8)
+#define XGPIO_TRI2_OFFSET		(0xc)
+
+#define XGPIO_GIE_OFFSET		(0x11c)
+#define XGPIO_ISR_OFFSET		(0x120)
+#define XGPIO_IER_OFFSET		(0x128)
+#define XGPIO_CHAN_OFFSET		(8)
+#define STEP_PRECISION			(65536)
+
+/* Video IP Formats */
+enum xscaler_vid_reg_fmts {
+	XVIDC_CSF_RGB = 0,
+	XVIDC_CSF_YCRCB_444,
+	XVIDC_CSF_YCRCB_422,
+	XVIDC_CSF_YCRCB_420,
+};
+
+/* Video IP PPC */
+#define XSCALER_PPC_1			(1)
+#define XSCALER_PPC_2			(2)
+#define XSCALER_PPC_4			(4)
+
+#define XV_HSCALER_MAX_H_TAPS           (12)
+#define XV_HSCALER_MAX_H_PHASES         (64)
+#define XV_HSCALER_MAX_LINE_WIDTH       (3840)
+#define XV_VSCALER_MAX_V_TAPS           (12)
+#define XV_VSCALER_MAX_V_PHASES         (64)
+
+#define XV_HSCALER_TAPS_2		(2)
+#define XV_HSCALER_TAPS_4		(4)
+#define XV_HSCALER_TAPS_6		(6)
+#define XV_HSCALER_TAPS_8		(8)
+#define XV_HSCALER_TAPS_10		(10)
+#define XV_HSCALER_TAPS_12		(12)
+#define XV_VSCALER_TAPS_2		(2)
+#define XV_VSCALER_TAPS_4		(4)
+#define XV_VSCALER_TAPS_6		(6)
+#define XV_VSCALER_TAPS_8		(8)
+#define XV_VSCALER_TAPS_10		(10)
+#define XV_VSCALER_TAPS_12		(12)
+
+/* Mask definitions for Low and high 16 bits in a 32 bit number */
+#define XHSC_MASK_LOW_16BITS		GENMASK(15, 0)
+#define XHSC_MASK_HIGH_16BITS		GENMASK(31, 16)
+#define XHSC_MASK_LOW_32BITS		GENMASK(31, 0)
+#define XHSC_STEP_PRECISION_SHIFT	(16)
+#define XHSC_HPHASE_SHIFT_BY_6		(6)
+#define XHSC_HPHASE_MULTIPLIER		(9)
+#define XHSC_HPHASE_MUL_4PPC		(10)
+
+/* Mask definitions for Low and high 16 bits in a 32 bit number */
+#define XVSC_MASK_LOW_16BITS            GENMASK(15, 0)
+#define XVSC_MASK_HIGH_16BITS           GENMASK(31, 16)
+
+/* XSCALER POWER MACROS */
+#define XSCALER_RESET_ASSERT	(0x1)
+#define XSCALER_RESET_DEASSERT	(0x0)
+
+/* Scaler AP Control Registers */
+#define XSCALER_START		BIT(0)
+#define XSCALER_AUTO_RESTART	BIT(7)
+#define XSCALER_STREAM_ON	(XSCALER_START | XSCALER_AUTO_RESTART)
+
+/* H-scaler registers */
+#define XV_HSCALER_CTRL_ADDR_AP_CTRL				(0x0000)
+#define XV_HSCALER_CTRL_ADDR_GIE				(0x0004)
+#define XV_HSCALER_CTRL_ADDR_IER				(0x0008)
+#define XV_HSCALER_CTRL_ADDR_ISR				(0x000c)
+#define XV_HSCALER_CTRL_ADDR_HWREG_HEIGHT_DATA			(0x0010)
+#define XV_HSCALER_CTRL_ADDR_HWREG_WIDTHIN_DATA			(0x0018)
+#define XV_HSCALER_CTRL_ADDR_HWREG_WIDTHOUT_DATA		(0x0020)
+#define XV_HSCALER_CTRL_ADDR_HWREG_COLORMODE_DATA		(0x0028)
+#define XV_HSCALER_CTRL_ADDR_HWREG_PIXELRATE_DATA		(0x0030)
+#define XV_HSCALER_CTRL_ADDR_HWREG_COLORMODEOUT_DATA		(0X0038)
+#define XV_HSCALER_CTRL_ADDR_HWREG_HFLTCOEFF_BASE		(0x0800)
+#define XV_HSCALER_CTRL_ADDR_HWREG_HFLTCOEFF_HIGH		(0x0bff)
+
+/* Coefficients for 6, 8, 10 and 12 tap filters */
+
+static const s16 XV_lanczos2_taps6[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_6] = {
+	{   0,    0, 4096,    0,    0,   0, },
+	{   0,  -40, 4099,   42,    0,  -5, },
+	{  -1,  -77, 4097,   87,   -1,  -9, },
+	{  -2, -111, 4092,  134,   -2, -15, },
+	{  -4, -143, 4082,  184,   -4, -19, },
+	{  -6, -173, 4068,  237,   -7, -23, },
+	{  -8, -201, 4051,  292,  -10, -28, },
+	{ -11, -226, 4029,  350,  -13, -33, },
+	{ -14, -248, 4003,  411,  -18, -38, },
+	{ -17, -269, 3974,  474,  -23, -43, },
+	{ -21, -287, 3940,  539,  -28, -47, },
+	{ -24, -303, 3903,  608,  -34, -54, },
+	{ -28, -317, 3862,  678,  -41, -58, },
+	{ -32, -329, 3817,  751,  -49, -62, },
+	{ -37, -339, 3768,  826,  -57, -65, },
+	{ -41, -347, 3716,  903,  -65, -70, },
+	{ -45, -353, 3661,  982,  -75, -74, },
+	{ -50, -358, 3602, 1063,  -84, -77, },
+	{ -54, -361, 3539, 1146,  -95, -79, },
+	{ -58, -362, 3474, 1230, -106, -82, },
+	{ -62, -361, 3406, 1317, -117, -87, },
+	{ -66, -359, 3335, 1404, -128, -90, },
+	{ -70, -356, 3261, 1493, -140, -92, },
+	{ -74, -351, 3185, 1583, -153, -94, },
+	{ -77, -346, 3106, 1673, -165, -95, },
+	{ -81, -339, 3025, 1765, -178, -96, },
+	{ -84, -331, 2942, 1857, -191, -97, },
+	{ -87, -322, 2858, 1950, -204, -99, },
+	{ -89, -313, 2771, 2043, -217, -99, },
+	{ -92, -302, 2683, 2136, -230, -99, },
+	{ -94, -292, 2594, 2228, -243, -97, },
+	{ -95, -280, 2504, 2321, -256, -98, },
+	{ -97, -268, 2413, 2413, -268, -97, },
+	{ -97, -256, 2321, 2504, -280, -96, },
+	{ -98, -243, 2228, 2594, -292, -93, },
+	{ -98, -230, 2136, 2683, -302, -93, },
+	{ -98, -217, 2043, 2771, -313, -90, },
+	{ -98, -204, 1950, 2858, -322, -88, },
+	{ -97, -191, 1857, 2942, -331, -84, },
+	{ -96, -178, 1765, 3025, -339, -81, },
+	{ -95, -165, 1673, 3106, -346, -77, },
+	{ -93, -153, 1583, 3185, -351, -75, },
+	{ -91, -140, 1493, 3261, -356, -71, },
+	{ -89, -128, 1404, 3335, -359, -67, },
+	{ -86, -117, 1317, 3406, -361, -63, },
+	{ -83, -106, 1230, 3474, -362, -57, },
+	{ -80,  -95, 1146, 3539, -361, -53, },
+	{ -77,  -84, 1063, 3602, -358, -50, },
+	{ -73,  -75,  982, 3661, -353, -46, },
+	{ -69,  -65,  903, 3716, -347, -42, },
+	{ -65,  -57,  826, 3768, -339, -37, },
+	{ -61,  -49,  751, 3817, -329, -33, },
+	{ -57,  -41,  678, 3862, -317, -29, },
+	{ -52,  -34,  608, 3903, -303, -26, },
+	{ -47,  -28,  539, 3940, -287, -21, },
+	{ -43,  -23,  474, 3974, -269, -17, },
+	{ -38,  -18,  411, 4003, -248, -14, },
+	{ -33,  -13,  350, 4029, -226, -11, },
+	{ -28,  -10,  292, 4051, -201,  -8, },
+	{ -24,   -7,  237, 4068, -173,  -5, },
+	{ -19,   -4,  184, 4082, -143,  -4, },
+	{ -14,   -2,  134, 4092, -111,  -3, },
+	{  -9,   -1,   87, 4097,  -77,  -1, },
+	{  -5,    0,   42, 4099,  -40,   0, }
+};
+
+/* ScalingRatio = 1.25 */
+static const s16 XV_fixedcoeff_taps6_SR1p2[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_6] = {
+	{ -102,  512, 3208,  512, -102,  68, },
+	{  -97,  471, 3209,  555, -107,  65, },
+	{  -92,  431, 3208,  599, -113,  63, },
+	{  -87,  392, 3205,  645, -118,  59, },
+	{  -82,  354, 3199,  691, -124,  58, },
+	{  -77,  318, 3191,  739, -130,  55, },
+	{  -72,  282, 3181,  788, -136,  53, },
+	{  -68,  248, 3169,  838, -141,  50, },
+	{  -64,  216, 3155,  889, -147,  47, },
+	{  -59,  184, 3139,  941, -153,  44, },
+	{  -55,  154, 3120,  993, -158,  42, },
+	{  -52,  125, 3100, 1047, -164,  40, },
+	{  -48,   98, 3077, 1101, -169,  37, },
+	{  -44,   71, 3052, 1157, -174,  34, },
+	{  -41,   46, 3025, 1212, -180,  34, },
+	{  -38,   23, 2996, 1269, -184,  30, },
+	{  -35,    0, 2965, 1326, -189,  29, },
+	{  -32,  -21, 2933, 1383, -193,  26, },
+	{  -29,  -41, 2898, 1441, -198,  25, },
+	{  -26,  -60, 2862, 1500, -201,  21, },
+	{  -24,  -78, 2823, 1558, -205,  22, },
+	{  -21,  -94, 2784, 1617, -208,  18, },
+	{  -19, -109, 2742, 1676, -210,  16, },
+	{  -17, -123, 2699, 1734, -212,  15, },
+	{  -14, -136, 2654, 1793, -214,  13, },
+	{  -12, -148, 2608, 1852, -214,  10, },
+	{  -10, -159, 2560, 1910, -215,  10, },
+	{   -9, -168, 2512, 1968, -215,   8, },
+	{   -7, -177, 2461, 2026, -214,   7, },
+	{   -5, -185, 2410, 2083, -212,   5, },
+	{   -3, -192, 2358, 2139, -209,   3, },
+	{   -2, -197, 2304, 2195, -206,   2, },
+	{    0, -202, 2250, 2250, -202,   0, },
+	{    2, -206, 2195, 2304, -197,  -2, },
+	{    3, -209, 2139, 2358, -192,  -3, },
+	{    5, -212, 2083, 2410, -185,  -5, },
+	{    6, -214, 2026, 2461, -177,  -6, },
+	{    8, -215, 1968, 2512, -168,  -9, },
+	{   10, -215, 1910, 2560, -159, -10, },
+	{   11, -214, 1852, 2608, -148, -13, },
+	{   13, -214, 1793, 2654, -136, -14, },
+	{   15, -212, 1734, 2699, -123, -17, },
+	{   17, -210, 1676, 2742, -109, -20, },
+	{   18, -208, 1617, 2784,  -94, -21, },
+	{   20, -205, 1558, 2823,  -78, -22, },
+	{   22, -201, 1500, 2862,  -60, -27, },
+	{   24, -198, 1441, 2898,  -41, -28, },
+	{   26, -193, 1383, 2933,  -21, -32, },
+	{   28, -189, 1326, 2965,    0, -34, },
+	{   30, -184, 1269, 2996,   23, -38, },
+	{   33, -180, 1212, 3025,   46, -40, },
+	{   35, -174, 1157, 3052,   71, -45, },
+	{   37, -169, 1101, 3077,   98, -48, },
+	{   40, -164, 1047, 3100,  125, -52, },
+	{   42, -158,  993, 3120,  154, -55, },
+	{   44, -153,  941, 3139,  184, -59, },
+	{   47, -147,  889, 3155,  216, -64, },
+	{   50, -141,  838, 3169,  248, -68, },
+	{   52, -136,  788, 3181,  282, -71, },
+	{   55, -130,  739, 3191,  318, -77, },
+	{   57, -124,  691, 3199,  354, -81, },
+	{   60, -118,  645, 3205,  392, -88, },
+	{   63, -113,  599, 3208,  431, -92, },
+	{   65, -107,  555, 3209,  471, -97, }
+};
+
+/* ScalingRatio = 2.0 */
+static const s16 XV_fixedcoeff_taps6_SR2[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_6] = {
+	{   0, 970, 2235,  970,   0, -79, },
+	{  -3, 943, 2233,  997,   3, -77, },
+	{  -5, 915, 2231, 1025,   6, -76, },
+	{  -8, 888, 2227, 1052,  10, -73, },
+	{ -10, 861, 2223, 1079,  14, -71, },
+	{ -12, 834, 2218, 1107,  18, -69, },
+	{ -14, 808, 2213, 1134,  22, -67, },
+	{ -15, 782, 2206, 1162,  27, -66, },
+	{ -17, 756, 2199, 1189,  32, -63, },
+	{ -18, 731, 2191, 1217,  37, -62, },
+	{ -20, 706, 2182, 1245,  42, -59, },
+	{ -21, 681, 2172, 1272,  48, -56, },
+	{ -22, 657, 2162, 1300,  55, -56, },
+	{ -22, 633, 2151, 1327,  61, -54, },
+	{ -23, 609, 2139, 1355,  68, -52, },
+	{ -24, 586, 2126, 1382,  76, -50, },
+	{ -25, 564, 2113, 1410,  83, -49, },
+	{ -25, 541, 2099, 1437,  91, -47, },
+	{ -26, 520, 2084, 1464, 100, -46, },
+	{ -26, 498, 2069, 1491, 109, -45, },
+	{ -27, 477, 2053, 1517, 118, -42, },
+	{ -27, 457, 2036, 1544, 128, -42, },
+	{ -27, 437, 2019, 1570, 138, -41, },
+	{ -28, 418, 2001, 1596, 148, -39, },
+	{ -28, 399, 1983, 1622, 160, -40, },
+	{ -29, 380, 1964, 1647, 171, -37, },
+	{ -29, 362, 1944, 1672, 183, -36, },
+	{ -29, 345, 1924, 1697, 195, -36, },
+	{ -30, 328, 1903, 1722, 208, -35, },
+	{ -30, 311, 1882, 1746, 221, -34, },
+	{ -31, 295, 1860, 1770, 235, -33, },
+	{ -31, 279, 1838, 1793, 249, -32, },
+	{ -32, 264, 1816, 1816, 264, -32, },
+	{ -32, 249, 1793, 1838, 279, -31, },
+	{ -33, 235, 1770, 1860, 295, -31, },
+	{ -34, 221, 1746, 1882, 311, -30, },
+	{ -35, 208, 1722, 1903, 328, -30, },
+	{ -35, 195, 1697, 1924, 345, -30, },
+	{ -36, 183, 1672, 1944, 362, -29, },
+	{ -37, 171, 1647, 1964, 380, -29, },
+	{ -38, 160, 1622, 1983, 399, -30, },
+	{ -39, 148, 1596, 2001, 418, -28, },
+	{ -40, 138, 1570, 2019, 437, -28, },
+	{ -42, 128, 1544, 2036, 457, -27, },
+	{ -43, 118, 1517, 2053, 477, -26, },
+	{ -44, 109, 1491, 2069, 498, -27, },
+	{ -46, 100, 1464, 2084, 520, -26, },
+	{ -47,  91, 1437, 2099, 541, -25, },
+	{ -49,  83, 1410, 2113, 564, -25, },
+	{ -50,  76, 1382, 2126, 586, -24, },
+	{ -52,  68, 1355, 2139, 609, -23, },
+	{ -54,  61, 1327, 2151, 633, -22, },
+	{ -55,  55, 1300, 2162, 657, -23, },
+	{ -57,  48, 1272, 2172, 681, -20, },
+	{ -59,  42, 1245, 2182, 706, -20, },
+	{ -61,  37, 1217, 2191, 731, -19, },
+	{ -63,  32, 1189, 2199, 756, -17, },
+	{ -65,  27, 1162, 2206, 782, -16, },
+	{ -67,  22, 1134, 2213, 808, -14, },
+	{ -69,  18, 1107, 2218, 834, -12, },
+	{ -71,  14, 1079, 2223, 861, -10, },
+	{ -73,  10, 1052, 2227, 888,  -8, },
+	{ -75,   6, 1025, 2231, 915,  -6, },
+	{ -77,   3,  997, 2233, 943,  -3, }
+};
+
+/* ScalingRatio = 3.0 */
+static const s16 XV_fixedcoeff_taps6_SR3[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_6] = {
+	{ 126, 1019, 1806, 1019,  126,   0, },
+	{ 120, 1000, 1805, 1038,  132,   1, },
+	{ 114,  980, 1804, 1057,  138,   3, },
+	{ 108,  961, 1802, 1075,  145,   5, },
+	{ 103,  942, 1800, 1094,  152,   5, },
+	{  98,  922, 1797, 1113,  159,   7, },
+	{  93,  903, 1794, 1131,  167,   8, },
+	{  88,  884, 1790, 1150,  174,  10, },
+	{  84,  865, 1786, 1168,  182,  11, },
+	{  80,  846, 1782, 1187,  191,  10, },
+	{  76,  827, 1777, 1205,  199,  12, },
+	{  72,  809, 1771, 1223,  208,  13, },
+	{  68,  790, 1766, 1241,  217,  14, },
+	{  65,  772, 1759, 1259,  226,  15, },
+	{  61,  753, 1753, 1277,  236,  16, },
+	{  58,  735, 1746, 1295,  246,  16, },
+	{  56,  717, 1738, 1313,  256,  16, },
+	{  53,  699, 1730, 1330,  266,  18, },
+	{  50,  682, 1722, 1347,  277,  18, },
+	{  48,  664, 1713, 1364,  288,  19, },
+	{  46,  647, 1704, 1381,  299,  19, },
+	{  43,  630, 1694, 1398,  311,  20, },
+	{  41,  613, 1684, 1414,  323,  21, },
+	{  40,  596, 1674, 1430,  335,  21, },
+	{  38,  580, 1663, 1446,  347,  22, },
+	{  36,  563, 1652, 1462,  360,  23, },
+	{  35,  547, 1641, 1478,  373,  22, },
+	{  33,  531, 1629, 1493,  386,  24, },
+	{  32,  516, 1617, 1508,  399,  24, },
+	{  31,  500, 1604, 1523,  413,  25, },
+	{  30,  485, 1592, 1537,  427,  25, },
+	{  29,  470, 1578, 1551,  441,  27, },
+	{  28,  455, 1565, 1565,  455,  28, },
+	{  27,  441, 1551, 1578,  470,  29, },
+	{  26,  427, 1537, 1592,  485,  29, },
+	{  25,  413, 1523, 1604,  500,  31, },
+	{  24,  399, 1508, 1617,  516,  32, },
+	{  24,  386, 1493, 1629,  531,  33, },
+	{  23,  373, 1478, 1641,  547,  34, },
+	{  22,  360, 1462, 1652,  563,  37, },
+	{  22,  347, 1446, 1663,  580,  38, },
+	{  21,  335, 1430, 1674,  596,  40, },
+	{  20,  323, 1414, 1684,  613,  42, },
+	{  20,  311, 1398, 1694,  630,  43, },
+	{  19,  299, 1381, 1704,  647,  46, },
+	{  19,  288, 1364, 1713,  664,  48, },
+	{  18,  277, 1347, 1722,  682,  50, },
+	{  17,  266, 1330, 1730,  699,  54, },
+	{  17,  256, 1313, 1738,  717,  55, },
+	{  16,  246, 1295, 1746,  735,  58, },
+	{  15,  236, 1277, 1753,  753,  62, },
+	{  15,  226, 1259, 1759,  772,  65, },
+	{  14,  217, 1241, 1766,  790,  68, },
+	{  13,  208, 1223, 1771,  809,  72, },
+	{  12,  199, 1205, 1777,  827,  76, },
+	{  11,  191, 1187, 1782,  846,  79, },
+	{  10,  182, 1168, 1786,  865,  85, },
+	{   9,  174, 1150, 1790,  884,  89, },
+	{   8,  167, 1131, 1794,  903,  93, },
+	{   7,  159, 1113, 1797,  922,  98, },
+	{   6,  152, 1094, 1800,  942, 102, },
+	{   5,  145, 1075, 1802,  961, 108, },
+	{   3,  138, 1057, 1804,  980, 114, },
+	{   2,  132, 1038, 1805, 1000, 119, }
+};
+
+/* ScalingRatio = 4 */
+static const s16 XV_fixedcoeff_taps6_SR4[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_6] = {
+	{ 176, 1009, 1643, 1009, 176,  83, },
+	{ 169,  993, 1644, 1026, 183,  81, },
+	{ 162,  978, 1644, 1042, 190,  80, },
+	{ 156,  962, 1643, 1058, 198,  79, },
+	{ 150,  946, 1642, 1074, 205,  79, },
+	{ 144,  930, 1641, 1091, 213,  77, },
+	{ 138,  914, 1640, 1107, 222,  75, },
+	{ 133,  898, 1638, 1123, 230,  74, },
+	{ 128,  882, 1635, 1139, 239,  73, },
+	{ 123,  866, 1633, 1154, 248,  72, },
+	{ 118,  850, 1629, 1170, 257,  72, },
+	{ 114,  834, 1626, 1186, 267,  69, },
+	{ 109,  818, 1622, 1201, 276,  70, },
+	{ 105,  802, 1618, 1217, 286,  68, },
+	{ 101,  786, 1613, 1232, 297,  67, },
+	{  97,  771, 1608, 1247, 307,  66, },
+	{  94,  755, 1603, 1262, 318,  64, },
+	{  91,  739, 1597, 1276, 328,  65, },
+	{  87,  724, 1591, 1291, 339,  64, },
+	{  85,  708, 1585, 1305, 351,  62, },
+	{  82,  693, 1578, 1319, 362,  62, },
+	{  79,  677, 1571, 1333, 374,  62, },
+	{  77,  662, 1563, 1347, 386,  61, },
+	{  75,  647, 1556, 1360, 398,  60, },
+	{  73,  632, 1547, 1373, 410,  61, },
+	{  71,  617, 1539, 1386, 423,  60, },
+	{  69,  602, 1530, 1399, 436,  60, },
+	{  68,  587, 1521, 1412, 449,  59, },
+	{  66,  573, 1511, 1424, 462,  60, },
+	{  65,  558, 1501, 1436, 475,  61, },
+	{  64,  544, 1491, 1447, 488,  62, },
+	{  63,  530, 1481, 1459, 502,  61, },
+	{  62,  516, 1470, 1470, 516,  62, },
+	{  62,  502, 1459, 1481, 530,  62, },
+	{  61,  488, 1447, 1491, 544,  65, },
+	{  61,  475, 1436, 1501, 558,  65, },
+	{  60,  462, 1424, 1511, 573,  66, },
+	{  60,  449, 1412, 1521, 587,  67, },
+	{  60,  436, 1399, 1530, 602,  69, },
+	{  60,  423, 1386, 1539, 617,  71, },
+	{  61,  410, 1373, 1547, 632,  73, },
+	{  61,  398, 1360, 1556, 647,  74, },
+	{  61,  386, 1347, 1563, 662,  77, },
+	{  62,  374, 1333, 1571, 677,  79, },
+	{  62,  362, 1319, 1578, 693,  82, },
+	{  63,  351, 1305, 1585, 708,  84, },
+	{  64,  339, 1291, 1591, 724,  87, },
+	{  64,  328, 1276, 1597, 739,  92, },
+	{  65,  318, 1262, 1603, 755,  93, },
+	{  66,  307, 1247, 1608, 771,  97, },
+	{  67,  297, 1232, 1613, 786, 101, },
+	{  68,  286, 1217, 1618, 802, 105, },
+	{  69,  276, 1201, 1622, 818, 110, },
+	{  70,  267, 1186, 1626, 834, 113, },
+	{  71,  257, 1170, 1629, 850, 119, },
+	{  72,  248, 1154, 1633, 866, 123, },
+	{  73,  239, 1139, 1635, 882, 128, },
+	{  75,  230, 1123, 1638, 898, 132, },
+	{  76,  222, 1107, 1640, 914, 137, },
+	{  77,  213, 1091, 1641, 930, 144, },
+	{  78,  205, 1074, 1642, 946, 151, },
+	{  79,  198, 1058, 1643, 962, 156, },
+	{  80,  190, 1042, 1644, 978, 162, },
+	{  82,  183, 1026, 1644, 993, 168, }
+};
+
+/* ScalingRatio = 2.0 */
+static const s16 XV_fixedcoeff_taps8_SR2[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_8] = {
+	{ -55,   0, 1078, 2049, 1078,    0, -55,   1, },
+	{ -53,  -7, 1055, 2049, 1102,    7, -56,  -1, },
+	{ -52, -13, 1032, 2048, 1126,   15, -58,  -2, },
+	{ -50, -20, 1009, 2047, 1149,   22, -59,  -2, },
+	{ -49, -26,  986, 2046, 1173,   31, -61,  -4, },
+	{ -47, -31,  963, 2043, 1197,   39, -62,  -6, },
+	{ -46, -37,  940, 2040, 1220,   48, -64,  -5, },
+	{ -45, -42,  917, 2037, 1244,   57, -65,  -7, },
+	{ -43, -47,  894, 2033, 1267,   66, -67,  -7, },
+	{ -42, -51,  871, 2028, 1290,   76, -69,  -7, },
+	{ -41, -55,  848, 2023, 1313,   86, -70,  -8, },
+	{ -40, -59,  826, 2017, 1336,   97, -72,  -9, },
+	{ -38, -63,  803, 2010, 1359,  108, -73, -10, },
+	{ -37, -67,  781, 2003, 1382,  119, -75, -10, },
+	{ -36, -70,  759, 1996, 1405,  130, -76, -12, },
+	{ -35, -73,  737, 1987, 1427,  142, -78, -11, },
+	{ -34, -76,  715, 1979, 1449,  154, -79, -12, },
+	{ -33, -78,  693, 1969, 1471,  167, -81, -12, },
+	{ -32, -81,  672, 1959, 1493,  180, -82, -13, },
+	{ -31, -83,  650, 1949, 1514,  193, -83, -13, },
+	{ -30, -85,  629, 1938, 1536,  207, -85, -14, },
+	{ -29, -86,  609, 1926, 1557,  221, -86, -16, },
+	{ -28, -88,  588, 1914, 1577,  235, -87, -15, },
+	{ -28, -89,  568, 1902, 1598,  250, -88, -17, },
+	{ -27, -90,  548, 1889, 1618,  265, -89, -18, },
+	{ -26, -91,  528, 1875, 1638,  280, -90, -18, },
+	{ -25, -92,  508, 1861, 1657,  296, -91, -18, },
+	{ -24, -93,  489, 1846, 1676,  312, -92, -18, },
+	{ -24, -93,  470, 1831, 1695,  328, -92, -19, },
+	{ -23, -94,  451, 1816, 1714,  345, -93, -20, },
+	{ -22, -94,  432, 1800, 1732,  361, -93, -20, },
+	{ -22, -94,  414, 1783, 1749,  379, -94, -19, },
+	{ -21, -94,  396, 1767, 1767,  396, -94, -21, },
+	{ -21, -94,  379, 1749, 1783,  414, -94, -20, },
+	{ -20, -93,  361, 1732, 1800,  432, -94, -22, },
+	{ -19, -93,  345, 1714, 1816,  451, -94, -24, },
+	{ -19, -92,  328, 1695, 1831,  470, -93, -24, },
+	{ -18, -92,  312, 1676, 1846,  489, -93, -24, },
+	{ -18, -91,  296, 1657, 1861,  508, -92, -25, },
+	{ -17, -90,  280, 1638, 1875,  528, -91, -27, },
+	{ -17, -89,  265, 1618, 1889,  548, -90, -28, },
+	{ -16, -88,  250, 1598, 1902,  568, -89, -29, },
+	{ -16, -87,  235, 1577, 1914,  588, -88, -27, },
+	{ -15, -86,  221, 1557, 1926,  609, -86, -30, },
+	{ -14, -85,  207, 1536, 1938,  629, -85, -30, },
+	{ -14, -83,  193, 1514, 1949,  650, -83, -30, },
+	{ -13, -82,  180, 1493, 1959,  672, -81, -32, },
+	{ -13, -81,  167, 1471, 1969,  693, -78, -32, },
+	{ -12, -79,  154, 1449, 1979,  715, -76, -34, },
+	{ -12, -78,  142, 1427, 1987,  737, -73, -34, },
+	{ -11, -76,  130, 1405, 1996,  759, -70, -37, },
+	{ -10, -75,  119, 1382, 2003,  781, -67, -37, },
+	{ -10, -73,  108, 1359, 2010,  803, -63, -38, },
+	{  -9, -72,   97, 1336, 2017,  826, -59, -40, },
+	{  -8, -70,   86, 1313, 2023,  848, -55, -41, },
+	{  -8, -69,   76, 1290, 2028,  871, -51, -41, },
+	{  -7, -67,   66, 1267, 2033,  894, -47, -43, },
+	{  -6, -65,   57, 1244, 2037,  917, -42, -46, },
+	{  -5, -64,   48, 1220, 2040,  940, -37, -46, },
+	{  -5, -62,   39, 1197, 2043,  963, -31, -48, },
+	{  -4, -61,   31, 1173, 2046,  986, -26, -49, },
+	{  -3, -59,   22, 1149, 2047, 1009, -20, -49, },
+	{  -2, -58,   15, 1126, 2048, 1032, -13, -52, },
+	{  -1, -56,    7, 1102, 2049, 1055,  -7, -53, }
+};
+
+/* ScalingRatio = 3.0 */
+static const s16 XV_fixedcoeff_taps8_SR3[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_8] = {
+	{   0, 275, 1036, 1514, 1036,  275,   0, -40, },
+	{  -1, 266, 1023, 1514, 1048,  283,   1, -38, },
+	{  -2, 257, 1010, 1513, 1060,  292,   2, -36, },
+	{  -3, 249,  997, 1512, 1073,  301,   3, -36, },
+	{  -3, 241,  983, 1510, 1085,  310,   5, -35, },
+	{  -4, 233,  970, 1509, 1097,  319,   6, -34, },
+	{  -5, 225,  957, 1507, 1109,  329,   7, -33, },
+	{  -6, 217,  944, 1505, 1121,  338,   9, -32, },
+	{  -6, 210,  931, 1503, 1133,  348,  10, -33, },
+	{  -7, 202,  917, 1500, 1144,  358,  12, -30, },
+	{  -7, 195,  904, 1497, 1156,  368,  13, -30, },
+	{  -8, 188,  891, 1494, 1167,  378,  15, -29, },
+	{  -9, 181,  877, 1491, 1179,  388,  17, -28, },
+	{  -9, 174,  864, 1487, 1190,  398,  19, -27, },
+	{  -9, 168,  851, 1483, 1201,  409,  21, -28, },
+	{ -10, 161,  837, 1479, 1212,  419,  23, -25, },
+	{ -10, 155,  824, 1475, 1223,  430,  25, -26, },
+	{ -11, 149,  811, 1470, 1233,  441,  27, -24, },
+	{ -11, 142,  798, 1465, 1244,  452,  29, -23, },
+	{ -12, 137,  784, 1460, 1254,  463,  32, -22, },
+	{ -12, 131,  771, 1455, 1264,  474,  34, -21, },
+	{ -12, 125,  758, 1449, 1275,  486,  37, -22, },
+	{ -13, 120,  745, 1444, 1284,  497,  40, -21, },
+	{ -13, 115,  732, 1438, 1294,  509,  42, -21, },
+	{ -13, 109,  719, 1432, 1304,  520,  45, -20, },
+	{ -14, 104,  706, 1425, 1313,  532,  48, -18, },
+	{ -14, 100,  693, 1418, 1322,  544,  52, -19, },
+	{ -14,  95,  680, 1412, 1332,  556,  55, -20, },
+	{ -15,  90,  667, 1404, 1340,  568,  58, -16, },
+	{ -15,  86,  655, 1397, 1349,  580,  62, -18, },
+	{ -16,  82,  642, 1390, 1358,  592,  66, -18, },
+	{ -16,  77,  630, 1382, 1366,  605,  69, -17, },
+	{ -16,  73,  617, 1374, 1374,  617,  73, -16, },
+	{ -17,  69,  605, 1366, 1382,  630,  77, -16, },
+	{ -17,  66,  592, 1358, 1390,  642,  82, -17, },
+	{ -18,  62,  580, 1349, 1397,  655,  86, -15, },
+	{ -18,  58,  568, 1340, 1404,  667,  90, -13, },
+	{ -18,  55,  556, 1332, 1412,  680,  95, -16, },
+	{ -19,  52,  544, 1322, 1418,  693, 100, -14, },
+	{ -19,  48,  532, 1313, 1425,  706, 104, -13, },
+	{ -20,  45,  520, 1304, 1432,  719, 109, -13, },
+	{ -20,  42,  509, 1294, 1438,  732, 115, -14, },
+	{ -21,  40,  497, 1284, 1444,  745, 120, -13, },
+	{ -22,  37,  486, 1275, 1449,  758, 125, -12, },
+	{ -22,  34,  474, 1264, 1455,  771, 131, -11, },
+	{ -23,  32,  463, 1254, 1460,  784, 137, -11, },
+	{ -23,  29,  452, 1244, 1465,  798, 142, -11, },
+	{ -24,  27,  441, 1233, 1470,  811, 149, -11, },
+	{ -25,  25,  430, 1223, 1475,  824, 155, -11, },
+	{ -26,  23,  419, 1212, 1479,  837, 161,  -9, },
+	{ -26,  21,  409, 1201, 1483,  851, 168, -11, },
+	{ -27,  19,  398, 1190, 1487,  864, 174,  -9, },
+	{ -28,  17,  388, 1179, 1491,  877, 181,  -9, },
+	{ -29,  15,  378, 1167, 1494,  891, 188,  -8, },
+	{ -29,  13,  368, 1156, 1497,  904, 195,  -8, },
+	{ -30,  12,  358, 1144, 1500,  917, 202,  -7, },
+	{ -31,  10,  348, 1133, 1503,  931, 210,  -8, },
+	{ -32,   9,  338, 1121, 1505,  944, 217,  -6, },
+	{ -33,   7,  329, 1109, 1507,  957, 225,  -5, },
+	{ -34,   6,  319, 1097, 1509,  970, 233,  -4, },
+	{ -35,   5,  310, 1085, 1510,  983, 241,  -3, },
+	{ -36,   3,  301, 1073, 1512,  997, 249,  -3, },
+	{ -37,   2,  292, 1060, 1513, 1010, 257,  -1, },
+	{ -38,   1,  283, 1048, 1514, 1023, 266,  -1, }
+};
+
+/* ScalingRatio = 4 */
+static const s16 XV_fixedcoeff_taps8_SR4[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_8] = {
+	{ 49, 366, 977, 1312,  977, 366,  49,  0, },
+	{ 48, 357, 967, 1312,  986, 374,  51,  1, },
+	{ 46, 349, 958, 1311,  995, 382,  54,  1, },
+	{ 44, 342, 948, 1311, 1004, 390,  56,  1, },
+	{ 42, 334, 939, 1310, 1013, 399,  58,  1, },
+	{ 40, 326, 929, 1309, 1021, 407,  60,  4, },
+	{ 39, 318, 919, 1308, 1030, 415,  63,  4, },
+	{ 37, 311, 910, 1307, 1039, 424,  65,  3, },
+	{ 36, 303, 900, 1305, 1047, 433,  68,  4, },
+	{ 34, 296, 890, 1303, 1055, 442,  70,  6, },
+	{ 33, 289, 880, 1301, 1064, 450,  73,  6, },
+	{ 32, 282, 870, 1299, 1072, 459,  76,  6, },
+	{ 31, 275, 861, 1297, 1080, 468,  79,  5, },
+	{ 29, 268, 851, 1295, 1088, 477,  82,  6, },
+	{ 28, 261, 841, 1292, 1096, 486,  85,  7, },
+	{ 27, 254, 831, 1289, 1104, 496,  88,  7, },
+	{ 26, 248, 821, 1287, 1112, 505,  91,  6, },
+	{ 25, 241, 811, 1284, 1119, 514,  94,  8, },
+	{ 24, 235, 800, 1280, 1127, 523,  98,  9, },
+	{ 23, 228, 790, 1277, 1134, 533, 101, 10, },
+	{ 22, 222, 780, 1273, 1141, 542, 105, 11, },
+	{ 22, 216, 770, 1270, 1148, 552, 109,  9, },
+	{ 21, 210, 760, 1266, 1155, 561, 112, 11, },
+	{ 20, 204, 750, 1262, 1162, 571, 116, 11, },
+	{ 19, 198, 740, 1257, 1169, 581, 120, 12, },
+	{ 19, 193, 730, 1253, 1175, 590, 124, 12, },
+	{ 18, 187, 720, 1248, 1182, 600, 129, 12, },
+	{ 17, 182, 710, 1244, 1188, 610, 133, 12, },
+	{ 17, 176, 700, 1239, 1194, 620, 137, 13, },
+	{ 16, 171, 690, 1234, 1201, 630, 142, 12, },
+	{ 16, 166, 680, 1229, 1206, 640, 146, 13, },
+	{ 15, 161, 670, 1223, 1212, 650, 151, 14, },
+	{ 15, 156, 660, 1218, 1218, 660, 156, 13, },
+	{ 14, 151, 650, 1212, 1223, 670, 161, 15, },
+	{ 14, 146, 640, 1206, 1229, 680, 166, 15, },
+	{ 13, 142, 630, 1201, 1234, 690, 171, 15, },
+	{ 13, 137, 620, 1194, 1239, 700, 176, 17, },
+	{ 12, 133, 610, 1188, 1244, 710, 182, 17, },
+	{ 12, 129, 600, 1182, 1248, 720, 187, 18, },
+	{ 11, 124, 590, 1175, 1253, 730, 193, 20, },
+	{ 11, 120, 581, 1169, 1257, 740, 198, 20, },
+	{ 11, 116, 571, 1162, 1262, 750, 204, 20, },
+	{ 10, 112, 561, 1155, 1266, 760, 210, 22, },
+	{ 10, 109, 552, 1148, 1270, 770, 216, 21, },
+	{ 10, 105, 542, 1141, 1273, 780, 222, 23, },
+	{  9, 101, 533, 1134, 1277, 790, 228, 24, },
+	{  9,  98, 523, 1127, 1280, 800, 235, 24, },
+	{  8,  94, 514, 1119, 1284, 811, 241, 25, },
+	{  8,  91, 505, 1112, 1287, 821, 248, 24, },
+	{  8,  88, 496, 1104, 1289, 831, 254, 26, },
+	{  7,  85, 486, 1096, 1292, 841, 261, 28, },
+	{  7,  82, 477, 1088, 1295, 851, 268, 28, },
+	{  6,  79, 468, 1080, 1297, 861, 275, 30, },
+	{  6,  76, 459, 1072, 1299, 870, 282, 32, },
+	{  5,  73, 450, 1064, 1301, 880, 289, 34, },
+	{  5,  70, 442, 1055, 1303, 890, 296, 35, },
+	{  4,  68, 433, 1047, 1305, 900, 303, 36, },
+	{  4,  65, 424, 1039, 1307, 910, 311, 36, },
+	{  3,  63, 415, 1030, 1308, 919, 318, 40, },
+	{  3,  60, 407, 1021, 1309, 929, 326, 41, },
+	{  2,  58, 399, 1013, 1310, 939, 334, 41, },
+	{  2,  56, 390, 1004, 1311, 948, 342, 43, },
+	{  1,  54, 382,  995, 1311, 958, 349, 46, },
+	{  1,  51, 374,  986, 1312, 967, 357, 48, }
+};
+
+/* ScalingRatio = 3.0 */
+static const s16 XV_fixedcoeff_taps10_SR3[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_10] = {
+	{ -31,   0, 359, 1033, 1399, 1033,  359,   0, -31, -25, },
+	{ -31,  -2, 350, 1022, 1398, 1043,  368,   3, -31, -24, },
+	{ -30,  -4, 341, 1012, 1398, 1053,  378,   5, -32, -25, },
+	{ -30,  -6, 333, 1002, 1398, 1062,  387,   8, -32, -26, },
+	{ -30,  -8, 324,  992, 1397, 1072,  396,  10, -32, -25, },
+	{ -30, -10, 315,  981, 1396, 1082,  406,  13, -33, -24, },
+	{ -29, -12, 307,  971, 1395, 1091,  415,  16, -33, -25, },
+	{ -29, -13, 298,  960, 1393, 1101,  425,  18, -33, -24, },
+	{ -29, -15, 290,  949, 1392, 1110,  434,  21, -34, -22, },
+	{ -28, -17, 282,  939, 1390, 1120,  444,  25, -34, -25, },
+	{ -28, -18, 274,  928, 1388, 1129,  454,  28, -34, -25, },
+	{ -28, -20, 266,  917, 1386, 1138,  464,  31, -34, -24, },
+	{ -27, -21, 258,  906, 1384, 1147,  474,  34, -35, -24, },
+	{ -27, -22, 250,  895, 1381, 1156,  484,  38, -35, -24, },
+	{ -27, -23, 242,  885, 1379, 1164,  494,  41, -35, -24, },
+	{ -27, -25, 235,  874, 1376, 1173,  504,  45, -35, -24, },
+	{ -26, -26, 227,  863, 1373, 1181,  515,  49, -36, -24, },
+	{ -26, -27, 220,  852, 1369, 1190,  525,  53, -36, -24, },
+	{ -26, -28, 213,  841, 1366, 1198,  535,  56, -36, -23, },
+	{ -26, -29, 206,  830, 1362, 1206,  546,  61, -36, -24, },
+	{ -25, -29, 199,  819, 1358, 1214,  556,  65, -36, -25, },
+	{ -25, -30, 192,  808, 1354, 1222,  567,  69, -36, -25, },
+	{ -25, -31, 185,  797, 1350, 1229,  577,  73, -36, -23, },
+	{ -25, -32, 178,  785, 1346, 1237,  588,  78, -36, -23, },
+	{ -25, -32, 172,  774, 1341, 1244,  599,  83, -36, -24, },
+	{ -25, -33, 165,  763, 1336, 1252,  610,  87, -36, -23, },
+	{ -24, -33, 159,  752, 1331, 1259,  620,  92, -36, -24, },
+	{ -24, -34, 153,  741, 1326, 1266,  631,  97, -36, -24, },
+	{ -24, -34, 147,  730, 1321, 1272,  642, 102, -36, -24, },
+	{ -24, -35, 141,  719, 1315, 1279,  653, 107, -36, -23, },
+	{ -24, -35, 135,  708, 1310, 1285,  664, 113, -36, -24, },
+	{ -24, -35, 129,  697, 1304, 1292,  675, 118, -36, -24, },
+	{ -24, -36, 124,  686, 1298, 1298,  686, 124, -36, -24, },
+	{ -24, -36, 118,  675, 1292, 1304,  697, 129, -35, -24, },
+	{ -24, -36, 113,  664, 1285, 1310,  708, 135, -35, -24, },
+	{ -24, -36, 107,  653, 1279, 1315,  719, 141, -35, -23, },
+	{ -24, -36, 102,  642, 1272, 1321,  730, 147, -34, -24, },
+	{ -23, -36,  97,  631, 1266, 1326,  741, 153, -34, -25, },
+	{ -23, -36,  92,  620, 1259, 1331,  752, 159, -33, -25, },
+	{ -23, -36,  87,  610, 1252, 1336,  763, 165, -33, -25, },
+	{ -23, -36,  83,  599, 1244, 1341,  774, 172, -32, -26, },
+	{ -23, -36,  78,  588, 1237, 1346,  785, 178, -32, -25, },
+	{ -23, -36,  73,  577, 1229, 1350,  797, 185, -31, -25, },
+	{ -23, -36,  69,  567, 1222, 1354,  808, 192, -30, -27, },
+	{ -23, -36,  65,  556, 1214, 1358,  819, 199, -29, -27, },
+	{ -24, -36,  61,  546, 1206, 1362,  830, 206, -29, -26, },
+	{ -24, -36,  56,  535, 1198, 1366,  841, 213, -28, -25, },
+	{ -24, -36,  53,  525, 1190, 1369,  852, 220, -27, -26, },
+	{ -24, -36,  49,  515, 1181, 1373,  863, 227, -26, -26, },
+	{ -24, -35,  45,  504, 1173, 1376,  874, 235, -25, -27, },
+	{ -24, -35,  41,  494, 1164, 1379,  885, 242, -23, -27, },
+	{ -24, -35,  38,  484, 1156, 1381,  895, 250, -22, -27, },
+	{ -24, -35,  34,  474, 1147, 1384,  906, 258, -21, -27, },
+	{ -24, -34,  31,  464, 1138, 1386,  917, 266, -20, -28, },
+	{ -24, -34,  28,  454, 1129, 1388,  928, 274, -18, -29, },
+	{ -24, -34,  25,  444, 1120, 1390,  939, 282, -17, -29, },
+	{ -24, -34,  21,  434, 1110, 1392,  949, 290, -15, -27, },
+	{ -24, -33,  18,  425, 1101, 1393,  960, 298, -13, -29, },
+	{ -24, -33,  16,  415, 1091, 1395,  971, 307, -12, -30, },
+	{ -25, -33,  13,  406, 1082, 1396,  981, 315, -10, -29, },
+	{ -25, -32,  10,  396, 1072, 1397,  992, 324,  -8, -30, },
+	{ -25, -32,   8,  387, 1062, 1398, 1002, 333,  -6, -31, },
+	{ -25, -32,   5,  378, 1053, 1398, 1012, 341,  -4, -30, },
+	{ -25, -31,   3,  368, 1043, 1398, 1022, 350,  -2, -30, }
+};
+
+/* ScalingRatio = 4 */
+static const s16 XV_fixedcoeff_taps10_SR4[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_10] = {
+	{   0, 107, 454, 924, 1150,  924, 454, 107,   0, -24, },
+	{   0, 104, 446, 917, 1149,  930, 461, 110,   0, -21, },
+	{  -1, 100, 439, 910, 1149,  936, 468, 114,   1, -20, },
+	{  -1,  97, 432, 904, 1149,  942, 475, 117,   2, -21, },
+	{  -2,  94, 425, 897, 1148,  948, 482, 121,   2, -19, },
+	{  -2,  91, 418, 890, 1147,  954, 490, 125,   3, -20, },
+	{  -3,  88, 411, 883, 1147,  960, 497, 128,   3, -18, },
+	{  -3,  85, 404, 876, 1146,  966, 504, 132,   4, -18, },
+	{  -3,  82, 397, 869, 1145,  972, 512, 136,   5, -19, },
+	{  -4,  79, 390, 862, 1144,  978, 519, 140,   5, -17, },
+	{  -4,  76, 384, 855, 1142,  983, 526, 144,   6, -16, },
+	{  -4,  74, 377, 848, 1141,  989, 534, 148,   7, -18, },
+	{  -5,  71, 370, 841, 1139,  995, 541, 152,   7, -15, },
+	{  -5,  68, 364, 834, 1138, 1000, 549, 156,   8, -16, },
+	{  -5,  66, 357, 827, 1136, 1005, 556, 160,   9, -15, },
+	{  -6,  63, 350, 820, 1134, 1011, 564, 165,  10, -15, },
+	{  -6,  61, 344, 812, 1132, 1016, 571, 169,  11, -14, },
+	{  -6,  59, 338, 805, 1130, 1021, 579, 174,  12, -16, },
+	{  -6,  56, 331, 798, 1128, 1026, 586, 178,  13, -14, },
+	{  -7,  54, 325, 790, 1126, 1031, 594, 183,  14, -14, },
+	{  -7,  52, 319, 783, 1124, 1036, 601, 187,  15, -14, },
+	{  -7,  50, 312, 776, 1121, 1041, 609, 192,  16, -14, },
+	{  -7,  48, 306, 768, 1119, 1045, 617, 197,  17, -14, },
+	{  -8,  46, 300, 761, 1116, 1050, 624, 202,  18, -13, },
+	{  -8,  44, 294, 753, 1113, 1054, 632, 207,  19, -12, },
+	{  -8,  42, 288, 746, 1110, 1059, 639, 212,  20, -12, },
+	{  -8,  40, 282, 738, 1107, 1063, 647, 217,  22, -12, },
+	{  -9,  38, 277, 731, 1104, 1067, 655, 222,  23, -12, },
+	{  -9,  36, 271, 723, 1101, 1071, 662, 227,  24, -10, },
+	{  -9,  35, 265, 715, 1097, 1075, 670, 232,  26, -10, },
+	{  -9,  33, 259, 708, 1094, 1079, 677, 238,  27, -10, },
+	{ -10,  32, 254, 700, 1091, 1083, 685, 243,  28, -10, },
+	{ -10,  30, 248, 693, 1087, 1087, 693, 248,  30, -10, },
+	{ -10,  28, 243, 685, 1083, 1091, 700, 254,  32, -10, },
+	{ -10,  27, 238, 677, 1079, 1094, 708, 259,  33,  -9, },
+	{ -11,  26, 232, 670, 1075, 1097, 715, 265,  35,  -8, },
+	{ -11,  24, 227, 662, 1071, 1101, 723, 271,  36,  -8, },
+	{ -11,  23, 222, 655, 1067, 1104, 731, 277,  38, -10, },
+	{ -12,  22, 217, 647, 1063, 1107, 738, 282,  40,  -8, },
+	{ -12,  20, 212, 639, 1059, 1110, 746, 288,  42,  -8, },
+	{ -12,  19, 207, 632, 1054, 1113, 753, 294,  44,  -8, },
+	{ -12,  18, 202, 624, 1050, 1116, 761, 300,  46,  -9, },
+	{ -13,  17, 197, 617, 1045, 1119, 768, 306,  48,  -8, },
+	{ -13,  16, 192, 609, 1041, 1121, 776, 312,  50,  -8, },
+	{ -13,  15, 187, 601, 1036, 1124, 783, 319,  52,  -8, },
+	{ -14,  14, 183, 594, 1031, 1126, 790, 325,  54,  -7, },
+	{ -14,  13, 178, 586, 1026, 1128, 798, 331,  56,  -6, },
+	{ -14,  12, 174, 579, 1021, 1130, 805, 338,  59,  -8, },
+	{ -15,  11, 169, 571, 1016, 1132, 812, 344,  61,  -5, },
+	{ -15,  10, 165, 564, 1011, 1134, 820, 350,  63,  -6, },
+	{ -16,   9, 160, 556, 1005, 1136, 827, 357,  66,  -4, },
+	{ -16,   8, 156, 549, 1000, 1138, 834, 364,  68,  -5, },
+	{ -16,   7, 152, 541,  995, 1139, 841, 370,  71,  -4, },
+	{ -17,   7, 148, 534,  989, 1141, 848, 377,  74,  -5, },
+	{ -17,   6, 144, 526,  983, 1142, 855, 384,  76,  -3, },
+	{ -18,   5, 140, 519,  978, 1144, 862, 390,  79,  -3, },
+	{ -18,   5, 136, 512,  972, 1145, 869, 397,  82,  -4, },
+	{ -19,   4, 132, 504,  966, 1146, 876, 404,  85,  -2, },
+	{ -19,   3, 128, 497,  960, 1147, 883, 411,  88,  -2, },
+	{ -20,   3, 125, 490,  954, 1147, 890, 418,  91,  -2, },
+	{ -20,   2, 121, 482,  948, 1148, 897, 425,  94,  -1, },
+	{ -21,   2, 117, 475,  942, 1149, 904, 432,  97,  -1, },
+	{ -21,   1, 114, 468,  936, 1149, 910, 439, 100,   0, },
+	{ -22,   0, 110, 461,  930, 1149, 917, 446, 104,   1, }
+};
+
+/* ScalingRatio = 4 */
+static const s16 XV_fixedcoeff_taps12_SR4[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_TAPS_12] = {
+	{ -19,   0, 152, 498, 893, 1070,  893, 498, 152,   0, -19, -22, },
+	{ -19,  -1, 147, 487, 879, 1059,  889, 499, 155,   1, -19,  19, },
+	{ -19,  -2, 143, 480, 874, 1059,  894, 506, 159,   2, -19,  19, },
+	{ -19,  -3, 139, 474, 869, 1059,  899, 512, 163,   3, -19,  19, },
+	{ -19,  -4, 136, 468, 863, 1059,  904, 519, 167,   4, -19,  18, },
+	{ -19,  -5, 132, 461, 858, 1058,  909, 525, 171,   5, -19,  20, },
+	{ -19,  -5, 128, 455, 853, 1058,  913, 531, 175,   7, -19,  19, },
+	{ -18,  -6, 125, 449, 847, 1057,  918, 538, 180,   8, -19,  17, },
+	{ -18,  -7, 121, 443, 842, 1056,  923, 544, 184,   9, -19,  18, },
+	{ -18,  -8, 118, 436, 836, 1056,  927, 551, 188,  10, -19,  19, },
+	{ -18,  -8, 114, 430, 831, 1055,  932, 557, 193,  12, -19,  17, },
+	{ -18,  -9, 111, 424, 825, 1054,  936, 564, 197,  13, -19,  18, },
+	{ -18, -10, 107, 418, 819, 1053,  941, 570, 202,  14, -19,  19, },
+	{ -18, -10, 104, 412, 814, 1052,  945, 577, 206,  16, -19,  17, },
+	{ -18, -11, 101, 406, 808, 1050,  949, 583, 211,  17, -19,  19, },
+	{ -18, -11,  98, 400, 802, 1049,  954, 590, 216,  19, -19,  16, },
+	{ -18, -12,  95, 394, 796, 1048,  958, 596, 220,  20, -19,  18, },
+	{ -18, -12,  92, 388, 791, 1046,  962, 603, 225,  22, -19,  16, },
+	{ -18, -13,  89, 382, 785, 1045,  966, 609, 230,  24, -19,  16, },
+	{ -18, -13,  86, 376, 779, 1043,  970, 616, 235,  25, -19,  16, },
+	{ -18, -14,  83, 370, 773, 1041,  973, 622, 240,  27, -19,  18, },
+	{ -18, -14,  80, 364, 767, 1039,  977, 629, 244,  29, -19,  18, },
+	{ -18, -15,  77, 358, 761, 1037,  981, 635, 249,  31, -19,  19, },
+	{ -18, -15,  74, 352, 755, 1035,  984, 642, 255,  33, -19,  18, },
+	{ -18, -15,  71, 347, 749, 1033,  988, 648, 260,  35, -19,  17, },
+	{ -18, -16,  69, 341, 743, 1031,  991, 654, 265,  36, -19,  19, },
+	{ -18, -16,  66, 335, 736, 1029,  995, 661, 270,  38, -19,  19, },
+	{ -18, -16,  64, 330, 730, 1026,  998, 667, 275,  41, -18,  17, },
+	{ -18, -17,  61, 324, 724, 1024, 1001, 674, 280,  43, -18,  18, },
+	{ -18, -17,  59, 318, 718, 1021, 1004, 680, 286,  45, -18,  18, },
+	{ -18, -17,  56, 313, 712, 1019, 1007, 686, 291,  47, -18,  18, },
+	{ -18, -17,  54, 307, 705, 1016, 1010, 693, 296,  49, -18,  19, },
+	{ -18, -18,  51, 302, 699, 1013, 1013, 699, 302,  51, -18,  20, },
+	{ -18, -18,  49, 296, 693, 1010, 1016, 705, 307,  54, -17,  19, },
+	{ -18, -18,  47, 291, 686, 1007, 1019, 712, 313,  56, -17,  18, },
+	{ -18, -18,  45, 286, 680, 1004, 1021, 718, 318,  59, -17,  18, },
+	{ -18, -18,  43, 280, 674, 1001, 1024, 724, 324,  61, -17,  18, },
+	{ -18, -18,  41, 275, 667,  998, 1026, 730, 330,  64, -16,  17, },
+	{ -18, -19,  38, 270, 661,  995, 1029, 736, 335,  66, -16,  19, },
+	{ -19, -19,  36, 265, 654,  991, 1031, 743, 341,  69, -16,  20, },
+	{ -19, -19,  35, 260, 648,  988, 1033, 749, 347,  71, -15,  18, },
+	{ -19, -19,  33, 255, 642,  984, 1035, 755, 352,  74, -15,  19, },
+	{ -19, -19,  31, 249, 635,  981, 1037, 761, 358,  77, -15,  20, },
+	{ -19, -19,  29, 244, 629,  977, 1039, 767, 364,  80, -14,  19, },
+	{ -19, -19,  27, 240, 622,  973, 1041, 773, 370,  83, -14,  19, },
+	{ -19, -19,  25, 235, 616,  970, 1043, 779, 376,  86, -13,  17, },
+	{ -19, -19,  24, 230, 609,  966, 1045, 785, 382,  89, -13,  17, },
+	{ -19, -19,  22, 225, 603,  962, 1046, 791, 388,  92, -12,  17, },
+	{ -19, -19,  20, 220, 596,  958, 1048, 796, 394,  95, -12,  19, },
+	{ -20, -19,  19, 216, 590,  954, 1049, 802, 400,  98, -11,  18, },
+	{ -20, -19,  17, 211, 583,  949, 1050, 808, 406, 101, -11,  21, },
+	{ -20, -19,  16, 206, 577,  945, 1052, 814, 412, 104, -10,  19, },
+	{ -20, -19,  14, 202, 570,  941, 1053, 819, 418, 107, -10,  21, },
+	{ -20, -19,  13, 197, 564,  936, 1054, 825, 424, 111,  -9,  20, },
+	{ -20, -19,  12, 193, 557,  932, 1055, 831, 430, 114,  -8,  19, },
+	{ -21, -19,  10, 188, 551,  927, 1056, 836, 436, 118,  -8,  22, },
+	{ -21, -19,   9, 184, 544,  923, 1056, 842, 443, 121,  -7,  21, },
+	{ -21, -19,   8, 180, 538,  918, 1057, 847, 449, 125,  -6,  20, },
+	{ -21, -19,   7, 175, 531,  913, 1058, 853, 455, 128,  -5,  21, },
+	{ -21, -19,   5, 171, 525,  909, 1058, 858, 461, 132,  -5,  22, },
+	{ -21, -19,   4, 167, 519,  904, 1059, 863, 468, 136,  -4,  20, },
+	{ -22, -19,   3, 163, 512,  899, 1059, 869, 474, 139,  -3,  22, },
+	{ -22, -19,   2, 159, 506,  894, 1059, 874, 480, 143,  -2,  22, },
+	{ -22, -19,   1, 155, 499,  889, 1059, 879, 487, 147,  -1,  22, }
+};
+
+#define XV_HSCALER_CTRL_WIDTH_HWREG_HFLTCOEFF			(16)
+#define XV_HSCALER_CTRL_DEPTH_HWREG_HFLTCOEFF			(384)
+#define XV_HSCALER_CTRL_ADDR_HWREG_PHASESH_V_BASE		(0x2000)
+#define XV_HSCALER_CTRL_ADDR_HWREG_PHASESH_V_HIGH		(0x3fff)
+#define XV_HSCALER_CTRL_WIDTH_HWREG_PHASESH_V			(18)
+#define XV_HSCALER_CTRL_DEPTH_HWREG_PHASESH_V			(1920)
+#define XV_HSCALER_CTRL_ADDR_HWREG_PHASEH_FIX			(0x4000)
+
+/* H-scaler masks */
+#define XV_HSCALER_PHASESH_V_OUTPUT_WR_EN			BIT(8)
+
+/* V-scaler registers */
+#define XV_VSCALER_CTRL_ADDR_AP_CTRL			(0x000)
+#define XV_VSCALER_CTRL_ADDR_GIE			(0x004)
+#define XV_VSCALER_CTRL_ADDR_IER			(0x008)
+#define XV_VSCALER_CTRL_ADDR_ISR			(0x00c)
+#define XV_VSCALER_CTRL_ADDR_HWREG_HEIGHTIN_DATA	(0x010)
+#define XV_VSCALER_CTRL_ADDR_HWREG_WIDTH_DATA		(0x018)
+#define XV_VSCALER_CTRL_ADDR_HWREG_HEIGHTOUT_DATA	(0x020)
+#define XV_VSCALER_CTRL_ADDR_HWREG_LINERATE_DATA	(0x028)
+#define XV_VSCALER_CTRL_ADDR_HWREG_COLORMODE_DATA	(0x030)
+#define XV_VSCALER_CTRL_ADDR_HWREG_VFLTCOEFF_BASE	(0x800)
+#define XV_VSCALER_CTRL_ADDR_HWREG_VFLTCOEFF_HIGH	(0xbff)
+
+#define XV_VSCALER_CTRL_WIDTH_HWREG_VFLTCOEFF		(16)
+#define XV_VSCALER_CTRL_DEPTH_HWREG_VFLTCOEFF		(384)
+
+/* These bits are for xscaler feature flags */
+#define XSCALER_CLK_PROP	BIT(0)
+#define XSCALER_HPHASE_FIX	BIT(1)
+
+/**
+ * struct xscaler_feature - dt or IP property structure
+ * @flags: Bitmask of properties enabled in IP or dt
+ */
+struct xscaler_feature {
+	u32 flags;
+};
+
+/**
+ * struct xscaler_device - Xilinx Scaler device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: Scaler sub-device media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: Xilinx Video IP format retrieved from the DT
+ * @num_hori_taps: number of horizontal taps
+ * @num_vert_taps: number of vertical taps
+ * @max_num_phases: maximum number of phases
+ * @pix_per_clk: Pixels per Clock cycle the IP operates upon
+ * @max_pixels: The maximum number of pixels that the H-scaler examines
+ * @max_lines: The maximum number of lines that the V-scaler examines
+ * @H_phases: The phases needed to program the H-scaler for different taps
+ * @hscaler_coeff: The complete array of H-scaler coefficients
+ * @vscaler_coeff: The complete array of V-scaler coefficients
+ * @is_polyphase: Track if scaling algorithm is polyphase or not
+ * @rst_gpio: GPIO reset line to bring VPSS Scaler out of reset
+ * @cfg: Pointer to scaler config structure
+ * @aclk_axis: AXI4-Stream video interface clock
+ * @aclk_ctrl: AXI4-Lite control interface clock
+ */
+struct xscaler_device {
+	struct xvip_device xvip;
+
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct xvip_video_format *vip_formats[2];
+
+	u32 num_hori_taps;
+	u32 num_vert_taps;
+	u32 max_num_phases;
+	u32 pix_per_clk;
+	u32 max_pixels;
+	u32 max_lines;
+	u64 H_phases[XV_HSCALER_MAX_LINE_WIDTH];
+	short hscaler_coeff[XV_HSCALER_MAX_H_PHASES][XV_HSCALER_MAX_H_TAPS];
+	short vscaler_coeff[XV_VSCALER_MAX_V_PHASES][XV_VSCALER_MAX_V_TAPS];
+	bool is_polyphase;
+
+	struct gpio_desc *rst_gpio;
+	const struct xscaler_feature *cfg;
+	struct clk *aclk_axis;
+	struct clk *aclk_ctrl;
+};
+
+static const struct xscaler_feature xlnx_scaler_v2_2 = {
+	.flags = XSCALER_CLK_PROP | XSCALER_HPHASE_FIX,
+};
+
+static const struct xscaler_feature xlnx_scaler_v1_0 = {
+	.flags = XSCALER_CLK_PROP,
+};
+
+static const struct xscaler_feature xlnx_scaler = {
+	.flags = 0,
+};
+
+static const struct of_device_id xscaler_of_id_table[] = {
+	{ .compatible = "xlnx,v-vpss-scaler",
+		.data = &xlnx_scaler},
+	{ .compatible = "xlnx,v-vpss-scaler-1.0",
+		.data = &xlnx_scaler_v1_0},
+	{ .compatible = "xlnx,v-vpss-scaler-2.2",
+		.data = &xlnx_scaler_v2_2},
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, xscaler_of_id_table);
+
+static inline struct xscaler_device *to_scaler(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xscaler_device, xvip.subdev);
+}
+
+static void
+xv_hscaler_calculate_phases(struct xscaler_device *xscaler,
+			    u32 width_in, u32 width_out, u32 pixel_rate)
+{
+	unsigned int loop_width;
+	unsigned int x, s;
+	int offset = 0;
+	int xwrite_pos = 0;
+	bool output_write_en;
+	bool get_new_pix;
+	u64 phaseH;
+	u64 array_idx = 0;
+	int nr_rds = 0;
+	int nr_rds_clck;
+	unsigned int nphases = xscaler->max_num_phases;
+	unsigned int nppc = xscaler->pix_per_clk;
+	unsigned int shift = XHSC_STEP_PRECISION_SHIFT - ilog2(nphases);
+
+	loop_width = max_t(u32, width_in, width_out);
+	loop_width = ALIGN(loop_width + nppc - 1, nppc);
+
+	for (x = 0; x < loop_width; x++) {
+		nr_rds_clck = 0;
+		for (s = 0; s < nppc; s++) {
+			phaseH = (offset >> shift) & (nphases - 1);
+			get_new_pix = false;
+			output_write_en = false;
+			if ((offset >> XHSC_STEP_PRECISION_SHIFT) != 0) {
+				/* read a new input sample */
+				get_new_pix = true;
+				offset -= (1 << XHSC_STEP_PRECISION_SHIFT);
+				array_idx++;
+			}
+
+			if (((offset >> XHSC_STEP_PRECISION_SHIFT) == 0) &&
+			    (xwrite_pos < width_out)) {
+				/* produce a new output sample */
+				offset += pixel_rate;
+				output_write_en = true;
+				xwrite_pos++;
+			}
+
+			if (nppc == XSCALER_PPC_4) {
+				xscaler->H_phases[x] |=
+					((u64)phaseH <<
+					 (s * XHSC_HPHASE_MUL_4PPC));
+				xscaler->H_phases[x] |=
+					((u64)array_idx <<
+					 (XHSC_HPHASE_SHIFT_BY_6 +
+					  (s * XHSC_HPHASE_MUL_4PPC)));
+				if (output_write_en)
+					xscaler->H_phases[x] |=
+						((u64)1 <<
+						 (XHSC_HPHASE_MULTIPLIER + s *
+						  XHSC_HPHASE_MUL_4PPC));
+			} else {
+				xscaler->H_phases[x] |=
+					(phaseH <<
+					 (s * XHSC_HPHASE_MULTIPLIER));
+				xscaler->H_phases[x] |=
+					(array_idx <<
+					 (XHSC_HPHASE_SHIFT_BY_6 +
+					  (s * XHSC_HPHASE_MULTIPLIER)));
+
+				if (output_write_en)
+					xscaler->H_phases[x] |=
+						(XV_HSCALER_PHASESH_V_OUTPUT_WR_EN <<
+						 (s * XHSC_HPHASE_MULTIPLIER));
+			}
+
+			if (get_new_pix)
+				nr_rds_clck++;
+		}
+		if (array_idx >= nppc)
+			array_idx &= (nppc - 1);
+
+		nr_rds += nr_rds_clck;
+		if (nr_rds >= nppc)
+			nr_rds -= nppc;
+	}
+}
+
+static void
+xv_hscaler_load_ext_coeff(struct xscaler_device *xscaler,
+			  const short *coeff, u32 ntaps)
+{
+	unsigned int i, j, pad, offset;
+	u32 nphases = xscaler->max_num_phases;
+
+	/* Determine if coefficient needs padding (effective vs. max taps) */
+	pad = XV_HSCALER_MAX_H_TAPS - ntaps;
+	offset = pad >> 1;
+	dev_dbg(xscaler->xvip.dev,
+		"%s : Pad = %d Offset = %d Nphases = %d ntaps = %d",
+			__func__, pad, offset, nphases, ntaps);
+
+	/* Load coefficients into scaler coefficient table */
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps; ++j)
+			xscaler->hscaler_coeff[i][j + offset] =
+						coeff[i * ntaps + j];
+	}
+
+	if (pad) { /* effective taps < max_taps */
+		for (i = 0; i < nphases; i++) {
+			/* pad left */
+			for (j = 0; j < offset; j++)
+				xscaler->hscaler_coeff[i][j] = 0;
+			/* pad right */
+			j = ntaps + offset;
+			for (; j < XV_HSCALER_MAX_H_TAPS; j++)
+				xscaler->hscaler_coeff[i][j] = 0;
+		}
+	}
+}
+
+static const short *xv_select_coeff(struct xscaler_device *xscaler,
+				    u32 in, u32 out, u32 *ntaps)
+{
+	const short *coeff = NULL;
+
+	/*
+	 * Scale Down Mode will use dynamic filter selection logic
+	 * Scale Up Mode (including 1:1) will always use 6 tap filter
+	 */
+	if (out < in) {
+		u16 scale_ratio = (in * 10) / out;
+
+		/* Since XV_HSCALER_TAPS_* is same as XV_VSCALER_TAPS_* */
+		switch (*ntaps) {
+		case XV_HSCALER_TAPS_6:
+			*ntaps = XV_HSCALER_TAPS_6;
+			if (scale_ratio > 35)
+				coeff = &XV_fixedcoeff_taps6_SR4[0][0];
+			else if (scale_ratio > 25)
+				coeff = &XV_fixedcoeff_taps6_SR3[0][0];
+			else if (scale_ratio > 15)
+				coeff = &XV_fixedcoeff_taps6_SR2[0][0];
+			else
+				coeff = &XV_fixedcoeff_taps6_SR1p2[0][0];
+			break;
+		case XV_HSCALER_TAPS_8:
+			if (scale_ratio > 35) {
+				coeff = &XV_fixedcoeff_taps8_SR4[0][0];
+				*ntaps = XV_HSCALER_TAPS_8;
+			} else if (scale_ratio > 25) {
+				coeff = &XV_fixedcoeff_taps8_SR3[0][0];
+				*ntaps = XV_HSCALER_TAPS_8;
+			} else if (scale_ratio > 15) {
+				coeff = &XV_fixedcoeff_taps8_SR2[0][0];
+				*ntaps = XV_HSCALER_TAPS_8;
+			} else {
+				coeff = &XV_fixedcoeff_taps6_SR1p2[0][0];
+				*ntaps = XV_HSCALER_TAPS_6;
+			}
+			break;
+		case XV_HSCALER_TAPS_10:
+			if (scale_ratio > 35) {
+				coeff = &XV_fixedcoeff_taps10_SR4[0][0];
+				*ntaps = XV_HSCALER_TAPS_10;
+			} else if (scale_ratio > 25) {
+				coeff = &XV_fixedcoeff_taps10_SR3[0][0];
+				*ntaps = XV_HSCALER_TAPS_10;
+			} else if (scale_ratio > 15) {
+				coeff = &XV_fixedcoeff_taps8_SR2[0][0];
+				*ntaps = XV_HSCALER_TAPS_8;
+			} else {
+				coeff = &XV_fixedcoeff_taps6_SR1p2[0][0];
+				*ntaps = XV_HSCALER_TAPS_6;
+			}
+			break;
+		case XV_HSCALER_TAPS_12:
+			if (scale_ratio > 35) {
+				coeff = &XV_fixedcoeff_taps12_SR4[0][0];
+				*ntaps = XV_HSCALER_TAPS_12;
+			} else if (scale_ratio > 25) {
+				coeff = &XV_fixedcoeff_taps10_SR3[0][0];
+				*ntaps = XV_HSCALER_TAPS_10;
+			} else if (scale_ratio > 15) {
+				coeff = &XV_fixedcoeff_taps8_SR2[0][0];
+				*ntaps = XV_HSCALER_TAPS_8;
+			} else {
+				coeff = &XV_fixedcoeff_taps6_SR1p2[0][0];
+				*ntaps = XV_HSCALER_TAPS_6;
+			}
+			break;
+		default:
+			dev_err(xscaler->xvip.dev,
+				"Unsupported number of taps = %d",
+				*ntaps);
+		}
+	} else {
+		dev_dbg(xscaler->xvip.dev, "scaler : scale up 6 tap");
+		coeff = &XV_lanczos2_taps6[0][0];
+		*ntaps = XV_HSCALER_TAPS_6;
+	}
+
+	return coeff;
+}
+
+/**
+ * xv_hscaler_select_coeff - Selection of H-Scaler coefficients of operation
+ * @xscaler: VPSS Scaler device information
+ * @width_in: Width of input video
+ * @width_out: Width of desired output video
+ *
+ * There are instances when a N-tap filter might operate in an M-tap
+ * configuration where N > M.
+ *
+ * For example :
+ * Depending on the ratio of scaling (while downscaling), a 12-tap
+ * filter may operate with 10 tap coefficients and zero-pads the remaining
+ * coefficients.
+ *
+ * While upscaling the driver will program 6-tap filter coefficients
+ * in any N-tap configurations (for N >= 6).
+ *
+ * This selection is adopted by the as it gives optimal
+ * video output determined by repeated testing of the IP
+ *
+ * Return: Will return 0 if successful. Returns -EINVAL on an unsupported
+ * H-scaler number of taps.
+ */
+static int
+xv_hscaler_select_coeff(struct xscaler_device *xscaler,
+			u32 width_in, u32 width_out)
+{
+	const short *coeff;
+	u32 ntaps = xscaler->num_hori_taps;
+
+	coeff = xv_select_coeff(xscaler, width_in, width_out, &ntaps);
+	if (!coeff)
+		return -EINVAL;
+
+	xv_hscaler_load_ext_coeff(xscaler, coeff, ntaps);
+	return 0;
+}
+
+static void xv_hscaler_set_coeff(struct xscaler_device *xscaler)
+{
+	int val, i, j, offset, rd_indx;
+	u32 ntaps = xscaler->num_hori_taps;
+	u32 nphases = xscaler->max_num_phases;
+	u32 base_addr;
+
+	offset = (XV_HSCALER_MAX_H_TAPS - ntaps) / 2;
+	base_addr = V_HSCALER_OFF + XV_HSCALER_CTRL_ADDR_HWREG_HFLTCOEFF_BASE;
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps / 2; j++) {
+			rd_indx = j * 2 + offset;
+			val = (xscaler->hscaler_coeff[i][rd_indx + 1] <<
+			       XSCALER_BITSHIFT_16) |
+			       (xscaler->hscaler_coeff[i][rd_indx] &
+			       XHSC_MASK_LOW_16BITS);
+			 xvip_write(&xscaler->xvip, base_addr +
+				    ((i * ntaps / 2 + j) * 4), val);
+		}
+	}
+}
+
+static void
+xv_vscaler_load_ext_coeff(struct xscaler_device *xscaler,
+			  const short *coeff, u32 ntaps)
+{
+	int i, j, pad, offset;
+	u32 nphases = xscaler->max_num_phases;
+
+	/* Determine if coefficient needs padding (effective vs. max taps) */
+	pad = XV_VSCALER_MAX_V_TAPS - ntaps;
+	offset = pad ? (pad >> 1) : 0;
+
+	dev_dbg(xscaler->xvip.dev,
+		"%s : Pad = %d Offset = %d Nphases = %d ntaps = %d",
+			__func__, pad, offset, nphases, ntaps);
+
+	/* Load User defined coefficients into scaler coefficient table */
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps; ++j)
+			xscaler->vscaler_coeff[i][j + offset] =
+						coeff[i * ntaps + j];
+	}
+
+	if (pad) { /* effective taps < max_taps */
+		for (i = 0; i < nphases; i++) {
+			/* pad left */
+			for (j = 0; j < offset; j++)
+				xscaler->vscaler_coeff[i][j] = 0;
+			/* pad right */
+			j = ntaps + offset;
+			for (; j < XV_VSCALER_MAX_V_TAPS; j++)
+				xscaler->vscaler_coeff[i][j] = 0;
+		}
+	}
+}
+
+static void xv_vscaler_set_coeff(struct xscaler_device *xscaler)
+{
+	u32 nphases = xscaler->max_num_phases;
+	u32 ntaps   = xscaler->num_vert_taps;
+	int val, i, j, offset, rd_indx;
+	u32 base_addr;
+
+	offset = (XV_VSCALER_MAX_V_TAPS - ntaps) / 2;
+	base_addr = V_VSCALER_OFF + XV_VSCALER_CTRL_ADDR_HWREG_VFLTCOEFF_BASE;
+
+	for (i = 0; i < nphases; i++) {
+		for (j = 0; j < ntaps / 2; j++) {
+			rd_indx = j * 2 + offset;
+			val = (xscaler->vscaler_coeff[i][rd_indx + 1] <<
+			       XSCALER_BITSHIFT_16) |
+			       (xscaler->vscaler_coeff[i][rd_indx] &
+			       XVSC_MASK_LOW_16BITS);
+			xvip_write(&xscaler->xvip,
+				   base_addr + ((i * ntaps / 2 + j) * 4), val);
+		}
+	}
+}
+
+/**
+ * xv_vscaler_select_coeff - Selection of V-Scaler coefficients of operation
+ * @xscaler: VPSS Scaler device information
+ * @height_in: Height of input video
+ * @height_out: Height of desired output video
+ *
+ * There are instances when a N-tap filter might operate in an M-tap
+ * configuration where N > M.
+ *
+ * For example :
+ * Depending on the ratio of scaling (while downscaling), a 10-tap
+ * filter may operate with 6 tap coefficients and zero-pads the remaining
+ * coefficients.
+ *
+ * While upscaling the driver will program 6-tap filter coefficients
+ * in any N-tap configurations (for N >= 6).
+ *
+ * This selection is adopted by the as it gives optimal
+ * video output determined by repeated testing of the IP
+ *
+ * Return: Will return 0 if successful. Returns -EINVAL on an unsupported
+ * V-scaler number of taps.
+ */
+static int
+xv_vscaler_select_coeff(struct xscaler_device *xscaler,
+			u32 height_in, u32 height_out)
+{
+	const short *coeff;
+	u32 ntaps = xscaler->num_vert_taps;
+
+	coeff = xv_select_coeff(xscaler, height_in, height_out, &ntaps);
+	if (!coeff)
+		return -EINVAL;
+
+	xv_vscaler_load_ext_coeff(xscaler, coeff, ntaps);
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Video Operations
+ */
+
+static inline void
+xv_procss_disable_block(struct xvip_device *xvip, u32 channel, u32 ip_block)
+{
+	xvip_clr(xvip, ((channel - 1) * XGPIO_CHAN_OFFSET) +
+		 XGPIO_DATA_OFFSET + S_AXIS_RESET_OFF,
+		 ip_block);
+}
+
+static inline void
+xv_procss_enable_block(struct xvip_device *xvip, u32 channel, u32 ip_block)
+{
+	xvip_set(xvip, ((channel - 1) * XGPIO_CHAN_OFFSET) +
+		 XGPIO_DATA_OFFSET + S_AXIS_RESET_OFF,
+		 ip_block);
+}
+
+static void xscaler_reset(struct xscaler_device *xscaler)
+{
+	xv_procss_disable_block(&xscaler->xvip, XGPIO_CH_RESET_SEL,
+				XGPIO_RESET_MASK_ALL_BLOCKS);
+	xv_procss_enable_block(&xscaler->xvip, XGPIO_CH_RESET_SEL,
+			       XGPIO_RESET_MASK_IP_AXIS);
+}
+
+static int
+xv_vscaler_setup_video_fmt(struct xscaler_device *xscaler, u32 code_in)
+{
+	u32 video_in;
+
+	switch (code_in) {
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+	case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		dev_dbg(xscaler->xvip.dev,
+			"Vscaler Input Media Format YUV 420");
+		video_in = XVIDC_CSF_YCRCB_420;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		dev_dbg(xscaler->xvip.dev,
+			"Vscaler Input Media Format YUV 422");
+		video_in = XVIDC_CSF_YCRCB_422;
+		break;
+	case MEDIA_BUS_FMT_VUY8_1X24:
+	case MEDIA_BUS_FMT_VUY10_1X30:
+		dev_dbg(xscaler->xvip.dev,
+			"Vscaler Input Media Format YUV 444");
+		video_in = XVIDC_CSF_YCRCB_444;
+		break;
+	case MEDIA_BUS_FMT_RBG888_1X24:
+	case MEDIA_BUS_FMT_RBG101010_1X30:
+		dev_dbg(xscaler->xvip.dev,
+			"Vscaler Input Media Format RGB");
+		video_in = XVIDC_CSF_RGB;
+		break;
+	default:
+		dev_err(xscaler->xvip.dev,
+			"Vscaler Unsupported Input Media Format 0x%x",
+			code_in);
+		return -EINVAL;
+	}
+	xvip_write(&xscaler->xvip, V_VSCALER_OFF +
+		   XV_VSCALER_CTRL_ADDR_HWREG_COLORMODE_DATA,
+		   video_in);
+	/*
+	 * Vscaler will upscale to YUV 422 before
+	 * Hscaler starts operation
+	 */
+	if (video_in == XVIDC_CSF_YCRCB_420)
+		return XVIDC_CSF_YCRCB_422;
+	return video_in;
+}
+
+static int xv_hscaler_setup_video_fmt(struct xscaler_device *xscaler,
+				      u32 code_out, u32 vsc_out)
+{
+	u32 video_out;
+
+	switch (vsc_out) {
+	case XVIDC_CSF_YCRCB_422:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Input Media Format is YUV 422");
+		break;
+	case XVIDC_CSF_YCRCB_444:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Input Media Format is YUV 444");
+		break;
+	case XVIDC_CSF_RGB:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Input Media Format is RGB");
+		break;
+	default:
+		dev_err(xscaler->xvip.dev,
+			"Hscaler got unsupported format from Vscaler");
+		return -EINVAL;
+	}
+
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		XV_HSCALER_CTRL_ADDR_HWREG_COLORMODE_DATA,
+		vsc_out);
+
+	switch (code_out) {
+	case MEDIA_BUS_FMT_VYYUYY8_1X24:
+	case MEDIA_BUS_FMT_VYYUYY10_4X20:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Output Media Format YUV 420\n");
+		video_out = XVIDC_CSF_YCRCB_420;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Output Media Format YUV 422\n");
+		video_out = XVIDC_CSF_YCRCB_422;
+		break;
+	case MEDIA_BUS_FMT_VUY8_1X24:
+	case MEDIA_BUS_FMT_VUY10_1X30:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Output Media Format YUV 444\n");
+		video_out = XVIDC_CSF_YCRCB_444;
+		break;
+	case MEDIA_BUS_FMT_RBG888_1X24:
+	case MEDIA_BUS_FMT_RBG101010_1X30:
+		dev_dbg(xscaler->xvip.dev,
+			"Hscaler Output Media Format RGB\n");
+		video_out = XVIDC_CSF_RGB;
+		break;
+	default:
+		dev_err(xscaler->xvip.dev,
+			"Hscaler Unsupported Output Media Format 0x%x",
+			code_out);
+		return -EINVAL;
+	}
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		   XV_HSCALER_CTRL_ADDR_HWREG_COLORMODEOUT_DATA,
+		   video_out);
+	return 0;
+}
+
+static void
+xv_hscaler_set_phases(struct xscaler_device *xscaler)
+{
+	u32 loop_width;
+	u32 index = 0, val;
+	u32 offset, i, j = 0, lsb, msb;
+	u64 phasehdata;
+
+	loop_width = xscaler->max_pixels / xscaler->pix_per_clk;
+
+	if (xscaler->cfg->flags & XSCALER_HPHASE_FIX) {
+		offset = V_HSCALER_OFF +
+			XV_HSCALER_CTRL_ADDR_HWREG_PHASEH_FIX;
+	} else {
+		offset = V_HSCALER_OFF +
+			XV_HSCALER_CTRL_ADDR_HWREG_PHASESH_V_BASE;
+	}
+
+	switch (xscaler->pix_per_clk) {
+	case XSCALER_PPC_1:
+		/*
+		 * phaseH is 64 bits but only lower 16 bits of each entry
+		 * is valid .Form a 32 bit word with 16bit LSB from 2
+		 * consecutive entries. Need 1 32b write to get 2 entries
+		 * into IP registers (i is array loc and index is
+		 * address offset)
+		 */
+		for (i = 0; i < loop_width; i += 2) {
+			lsb = lower_32_bits(xscaler->H_phases[i] &
+					    XHSC_MASK_LOW_16BITS);
+			msb = lower_32_bits(xscaler->H_phases[i + 1] &
+					    XHSC_MASK_LOW_16BITS);
+			val = (msb << 16 | lsb);
+			xvip_write(&xscaler->xvip, offset + (index * 4), val);
+			++index;
+		}
+		dev_dbg(xscaler->xvip.dev,
+			"%s : Operating in 1 PPC design", __func__);
+		return;
+	case XSCALER_PPC_2:
+		/*
+		 * PhaseH is 64bits but only lower 32b of each entry is valid
+		 * Need 1 32b write to get each entry into IP registers
+		 */
+		for (i = 0; i < loop_width; i++) {
+			val = lower_32_bits(xscaler->H_phases[i] &
+					    XHSC_MASK_LOW_32BITS);
+			xvip_write(&xscaler->xvip, offset + (i * 4), val);
+		}
+		dev_dbg(xscaler->xvip.dev,
+			"%s : Operating in 2 PPC design", __func__);
+		return;
+	case XSCALER_PPC_4:
+		/*
+		 * PhaseH is 64bits and each entry has valid 32b MSB & LSB
+		 * Need 2 32b writes to get each entry into IP registers
+		 * (index is array loc and offset is address offset)
+		 */
+		for (i = 0; i < loop_width; i++) {
+			phasehdata = xscaler->H_phases[index++];
+			lsb = (u32)(phasehdata & XHSC_MASK_LOW_32BITS);
+			msb = (u32)((phasehdata >> 32) & XHSC_MASK_LOW_32BITS);
+			xvip_write(&xscaler->xvip, offset + (j * 4), lsb);
+			xvip_write(&xscaler->xvip, offset + ((j + 1) * 4), msb);
+			j += 2;
+		}
+		dev_dbg(xscaler->xvip.dev,
+			"%s : Operating in 4 PPC design", __func__);
+		return;
+	default:
+		dev_warn(xscaler->xvip.dev, "%s : %d unsupported ppc design!!!\n",
+			 __func__, xscaler->pix_per_clk);
+	}
+}
+
+static int xscaler_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	u32 width_in, width_out;
+	u32 height_in, height_out;
+	u32 code_in, code_out;
+	u32 pixel_rate;
+	u32 line_rate;
+	int ret;
+
+	if (!enable) {
+		dev_dbg(xscaler->xvip.dev, "%s: Stream Off", __func__);
+		/* Reset the Global IP Reset through PS GPIO */
+		gpiod_set_value_cansleep(xscaler->rst_gpio,
+					 XSCALER_RESET_ASSERT);
+		gpiod_set_value_cansleep(xscaler->rst_gpio,
+					 XSCALER_RESET_DEASSERT);
+		xscaler_reset(xscaler);
+		memset(xscaler->H_phases, 0, sizeof(xscaler->H_phases));
+		return 0;
+	}
+
+	dev_dbg(xscaler->xvip.dev, "%s: Stream On", __func__);
+
+	/* Extract Sink Pad Information */
+	width_in = xscaler->formats[XVIP_PAD_SINK].width;
+	height_in = xscaler->formats[XVIP_PAD_SINK].height;
+	code_in = xscaler->formats[XVIP_PAD_SINK].code;
+
+	/* Extract Source Pad Information */
+	width_out = xscaler->formats[XVIP_PAD_SOURCE].width;
+	height_out = xscaler->formats[XVIP_PAD_SOURCE].height;
+	code_out = xscaler->formats[XVIP_PAD_SOURCE].code;
+
+	/*
+	 * V Scaler is before H Scaler
+	 * V-Scaler_setup
+	 */
+	line_rate = (height_in * STEP_PRECISION) / height_out;
+
+	if (xscaler->is_polyphase) {
+		ret = xv_vscaler_select_coeff(xscaler, height_in, height_out);
+		if (ret < 0)
+			return ret;
+		xv_vscaler_set_coeff(xscaler);
+	}
+
+	xvip_write(&xscaler->xvip, V_VSCALER_OFF +
+		   XV_VSCALER_CTRL_ADDR_HWREG_HEIGHTIN_DATA, height_in);
+	xvip_write(&xscaler->xvip, V_VSCALER_OFF +
+		   XV_VSCALER_CTRL_ADDR_HWREG_WIDTH_DATA, width_in);
+	xvip_write(&xscaler->xvip, V_VSCALER_OFF +
+		   XV_VSCALER_CTRL_ADDR_HWREG_HEIGHTOUT_DATA, height_out);
+	xvip_write(&xscaler->xvip, V_VSCALER_OFF +
+		   XV_VSCALER_CTRL_ADDR_HWREG_LINERATE_DATA, line_rate);
+	ret = xv_vscaler_setup_video_fmt(xscaler, code_in);
+	if (ret < 0)
+		return ret;
+
+	/* H-Scaler_setup */
+	pixel_rate = (width_in * STEP_PRECISION) / width_out;
+
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		   XV_HSCALER_CTRL_ADDR_HWREG_HEIGHT_DATA, height_out);
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		   XV_HSCALER_CTRL_ADDR_HWREG_WIDTHIN_DATA, width_in);
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		   XV_HSCALER_CTRL_ADDR_HWREG_WIDTHOUT_DATA, width_out);
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		   XV_HSCALER_CTRL_ADDR_HWREG_PIXELRATE_DATA, pixel_rate);
+	ret = xv_hscaler_setup_video_fmt(xscaler, code_out, ret);
+	if (ret < 0)
+		return ret;
+
+	if (xscaler->is_polyphase) {
+		ret = xv_hscaler_select_coeff(xscaler, width_in, width_out);
+		if (ret < 0)
+			return ret;
+		xv_hscaler_set_coeff(xscaler);
+	}
+
+	xv_hscaler_calculate_phases(xscaler, width_in, width_out, pixel_rate);
+	xv_hscaler_set_phases(xscaler);
+
+	/* Start Scaler sub-cores */
+	xvip_write(&xscaler->xvip, V_HSCALER_OFF +
+		   XV_HSCALER_CTRL_ADDR_AP_CTRL, XSCALER_STREAM_ON);
+	xvip_write(&xscaler->xvip, V_VSCALER_OFF +
+		   XV_VSCALER_CTRL_ADDR_AP_CTRL, XSCALER_STREAM_ON);
+	xv_procss_enable_block(&xscaler->xvip, XGPIO_CH_RESET_SEL,
+			       XGPIO_RESET_MASK_VIDEO_IN);
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Pad Operations
+ */
+
+static int xscaler_enum_frame_size(struct v4l2_subdev *subdev,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+	struct xscaler_device *xscaler = to_scaler(subdev);
+
+	format = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	fse->min_width = XSCALER_MIN_WIDTH;
+	fse->max_width = xscaler->max_pixels;
+	fse->min_height = XSCALER_MIN_HEIGHT;
+	fse->max_height = xscaler->max_lines;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__xscaler_get_pad_format(struct xscaler_device *xscaler,
+			 struct v4l2_subdev_state *sd_state,
+			 unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&xscaler->xvip.subdev,
+						    sd_state,
+						    pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &xscaler->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int xscaler_get_format(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xscaler_get_pad_format(xscaler, sd_state, fmt->pad,
+					  fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int xscaler_set_format(struct v4l2_subdev *subdev,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __xscaler_get_pad_format(xscaler, sd_state, fmt->pad,
+					  fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	*format = fmt->format;
+
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XSCALER_MIN_WIDTH, xscaler->max_pixels);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XSCALER_MIN_HEIGHT, xscaler->max_lines);
+	format->code = fmt->format.code;
+	fmt->format = *format;
+	return 0;
+}
+
+/*
+ * V4L2 Subdevice Operations
+ */
+
+static int
+xscaler_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct xscaler_device *xscaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, XVIP_PAD_SINK);
+	*format = xscaler->default_formats[XVIP_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state,
+					    XVIP_PAD_SOURCE);
+	*format = xscaler->default_formats[XVIP_PAD_SOURCE];
+
+	return 0;
+}
+
+static int
+xscaler_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops xscaler_video_ops = {
+	.s_stream = xscaler_s_stream,
+};
+
+static struct v4l2_subdev_pad_ops xscaler_pad_ops = {
+	.enum_mbus_code		= xvip_enum_mbus_code,
+	.enum_frame_size	= xscaler_enum_frame_size,
+	.get_fmt		= xscaler_get_format,
+	.set_fmt		= xscaler_set_format,
+};
+
+static struct v4l2_subdev_ops xscaler_ops = {
+	.video  = &xscaler_video_ops,
+	.pad    = &xscaler_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xscaler_internal_ops = {
+	.open	= xscaler_open,
+	.close	= xscaler_close,
+};
+
+/*
+ * Media Operations
+ */
+
+static const struct media_entity_operations xscaler_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/*
+ * Platform Device Driver
+ */
+
+static int xscaler_parse_of(struct xscaler_device *xscaler)
+{
+	struct device *dev = xscaler->xvip.dev;
+	struct device_node *node = xscaler->xvip.dev->of_node;
+	const struct xvip_video_format *vip_format;
+	struct device_node *ports;
+	struct device_node *port;
+	int ret;
+	u32 port_id, dt_ppc = 0;
+
+	if (xscaler->cfg->flags & XSCALER_CLK_PROP) {
+		xscaler->aclk_axis = devm_clk_get(dev, "aclk_axis");
+		if (IS_ERR(xscaler->aclk_axis)) {
+			ret = PTR_ERR(xscaler->aclk_axis);
+			dev_err(dev, "failed to get aclk_axis (%d)\n", ret);
+			return ret;
+		}
+		xscaler->aclk_ctrl = devm_clk_get(dev, "aclk_ctrl");
+		if (IS_ERR(xscaler->aclk_ctrl)) {
+			ret = PTR_ERR(xscaler->aclk_ctrl);
+			dev_err(dev, "failed to get aclk_ctrl (%d)\n", ret);
+			return ret;
+		}
+	} else {
+		dev_info(dev, "assuming all required clocks are enabled!\n");
+	}
+
+	ret = of_property_read_u32(node, "xlnx,max-height",
+				   &xscaler->max_lines);
+	if (ret < 0) {
+		dev_err(dev, "xlnx,max-height is missing!");
+		return -EINVAL;
+	} else if (xscaler->max_lines > XSCALER_MAX_HEIGHT ||
+		   xscaler->max_lines < XSCALER_MIN_HEIGHT) {
+		dev_err(dev, "Invalid height in dt");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,max-width",
+				   &xscaler->max_pixels);
+	if (ret < 0) {
+		dev_err(dev, "xlnx,max-width is missing!");
+		return -EINVAL;
+	} else if (xscaler->max_pixels > XSCALER_MAX_WIDTH ||
+		   xscaler->max_pixels < XSCALER_MIN_WIDTH) {
+		dev_err(dev, "Invalid width in dt");
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	/* Get the format description for each pad */
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			vip_format = xvip_of_get_format(port);
+			if (IS_ERR(vip_format)) {
+				dev_err(dev, "invalid format in DT");
+				return PTR_ERR(vip_format);
+			}
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "No reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "Invalid reg in DT");
+				return -EINVAL;
+			}
+			xscaler->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	ret = of_property_read_u32(node, "xlnx,num-hori-taps",
+				   &xscaler->num_hori_taps);
+	if (ret < 0)
+		return ret;
+
+	switch (xscaler->num_hori_taps) {
+	case XV_HSCALER_TAPS_2:
+	case XV_HSCALER_TAPS_4:
+		xscaler->is_polyphase = false;
+		break;
+	case XV_HSCALER_TAPS_6:
+	case XV_HSCALER_TAPS_8:
+	case XV_HSCALER_TAPS_10:
+	case XV_HSCALER_TAPS_12:
+		xscaler->is_polyphase = true;
+		break;
+	default:
+		dev_err(dev, "Unsupported num-hori-taps %d",
+			xscaler->num_hori_taps);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,num-vert-taps",
+				   &xscaler->num_vert_taps);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * For Bilinear and Bicubic case
+	 * number of vertical and horizontal taps must match
+	 */
+	switch (xscaler->num_vert_taps) {
+	case XV_HSCALER_TAPS_2:
+	case XV_VSCALER_TAPS_4:
+		if (xscaler->num_vert_taps != xscaler->num_hori_taps) {
+			dev_err(dev,
+				"H-scaler taps %d mismatches V-scaler taps %d",
+				 xscaler->num_hori_taps,
+				 xscaler->num_vert_taps);
+			return -EINVAL;
+		}
+		break;
+	case XV_VSCALER_TAPS_6:
+	case XV_VSCALER_TAPS_8:
+	case XV_VSCALER_TAPS_10:
+	case XV_VSCALER_TAPS_12:
+		xscaler->is_polyphase = true;
+		break;
+	default:
+		dev_err(dev, "Unsupported num-vert-taps %d",
+			xscaler->num_vert_taps);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "xlnx,pix-per-clk", &dt_ppc);
+	if (ret < 0)
+		return ret;
+
+	/* Driver only supports 1 PPC and 2 PPC */
+	if (dt_ppc != XSCALER_PPC_1 && dt_ppc != XSCALER_PPC_2 &&
+	    dt_ppc != XSCALER_PPC_4) {
+		dev_err(xscaler->xvip.dev,
+			"Unsupported xlnx,pix-per-clk(%d) value in DT", dt_ppc);
+		return -EINVAL;
+	}
+	xscaler->pix_per_clk = dt_ppc;
+
+	/* Reset GPIO */
+	xscaler->rst_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(xscaler->rst_gpio)) {
+		if (PTR_ERR(xscaler->rst_gpio) != -EPROBE_DEFER)
+			dev_err(dev, "Reset GPIO not setup in DT");
+		return PTR_ERR(xscaler->rst_gpio);
+	}
+
+	return 0;
+}
+
+static int xscaler_probe(struct platform_device *pdev)
+{
+	struct xscaler_device *xscaler;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	int ret;
+	const struct of_device_id *match;
+	struct device_node *node = pdev->dev.of_node;
+	struct resource *res;
+
+	xscaler = devm_kzalloc(&pdev->dev, sizeof(*xscaler), GFP_KERNEL);
+	if (!xscaler)
+		return -ENOMEM;
+
+	xscaler->xvip.dev = &pdev->dev;
+
+	match = of_match_node(xscaler_of_id_table, node);
+	if (!match)
+		return -ENODEV;
+
+	if (!strcmp(xscaler_of_id_table[0].compatible, match->compatible)) {
+		dev_warn(&pdev->dev,
+			 "%s - compatible string is getting deprecated!\n",
+			 match->compatible);
+	}
+
+	xscaler->cfg = match->data;
+
+	ret = xscaler_parse_of(xscaler);
+	if (ret < 0)
+		return ret;
+
+	/* Initialize coefficient parameters */
+	xscaler->max_num_phases = XSCALER_MAX_PHASES;
+
+	if (xscaler->cfg->flags & XSCALER_CLK_PROP) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		xscaler->xvip.iomem = devm_ioremap_resource(xscaler->xvip.dev,
+							    res);
+		if (IS_ERR(xscaler->xvip.iomem))
+			return PTR_ERR(xscaler->xvip.iomem);
+
+		ret = clk_prepare_enable(xscaler->aclk_axis);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable aclk_axis (%d)\n",
+				ret);
+			goto res_cleanup;
+		}
+
+		ret = clk_prepare_enable(xscaler->aclk_ctrl);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable aclk_ctrl (%d)\n",
+				ret);
+			goto axis_clk_cleanup;
+		}
+	} else {
+		ret = xvip_init_resources(&xscaler->xvip);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Reset the Global IP Reset through a PS GPIO */
+	gpiod_set_value_cansleep(xscaler->rst_gpio, XSCALER_RESET_DEASSERT);
+	/* Reset internal GPIO within the IP */
+	xscaler_reset(xscaler);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xscaler->xvip.subdev;
+	v4l2_subdev_init(subdev, &xscaler_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xscaler_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xscaler);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &xscaler->default_formats[XVIP_PAD_SINK];
+	default_format->code = xscaler->vip_formats[XVIP_PAD_SINK]->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	default_format->width = XSCALER_DEF_IN_WIDTH;
+	default_format->height = XSCALER_DEF_IN_HEIGHT;
+	xscaler->formats[XVIP_PAD_SINK] = *default_format;
+
+	default_format = &xscaler->default_formats[XVIP_PAD_SOURCE];
+	*default_format = xscaler->default_formats[XVIP_PAD_SINK];
+	default_format->code = xscaler->vip_formats[XVIP_PAD_SOURCE]->code;
+	default_format->width = XSCALER_DEF_OUT_WIDTH;
+	default_format->height = XSCALER_DEF_OUT_HEIGHT;
+	xscaler->formats[XVIP_PAD_SOURCE] = *default_format;
+
+	xscaler->pads[XVIP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xscaler->pads[XVIP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xscaler_media_ops;
+
+	ret = media_entity_pads_init(&subdev->entity, 2, xscaler->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, xscaler);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev");
+		goto error;
+	}
+	dev_info(xscaler->xvip.dev, "Num Hori Taps %d",
+		 xscaler->num_hori_taps);
+	dev_info(xscaler->xvip.dev, "Num Vert Taps %d",
+		 xscaler->num_vert_taps);
+	dev_info(&pdev->dev, "VPSS Scaler Probe Successful");
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xscaler->aclk_ctrl);
+axis_clk_cleanup:
+	clk_disable_unprepare(xscaler->aclk_axis);
+res_cleanup:
+	xvip_cleanup_resources(&xscaler->xvip);
+	return ret;
+}
+
+static int xscaler_remove(struct platform_device *pdev)
+{
+	struct xscaler_device *xscaler = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xscaler->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	clk_disable_unprepare(xscaler->aclk_ctrl);
+	clk_disable_unprepare(xscaler->aclk_axis);
+	xvip_cleanup_resources(&xscaler->xvip);
+
+	return 0;
+}
+
+static struct platform_driver xscaler_driver = {
+	.driver			= {
+		.name		= "xilinx-vpss-scaler",
+		.of_match_table	= xscaler_of_id_table,
+	},
+	.probe			= xscaler_probe,
+	.remove			= xscaler_remove,
+};
+
+module_platform_driver(xscaler_driver);
+MODULE_DESCRIPTION("Xilinx Scaler VPSS Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-vtc.c b/drivers/media/platform/xilinx/xilinx-vtc.c
index 0ae0208d7..f71db1c34 100644
--- a/drivers/media/platform/xilinx/xilinx-vtc.c
+++ b/drivers/media/platform/xilinx/xilinx-vtc.c
@@ -141,6 +141,9 @@
 
 #define XVTC_GENERATOR_GLOBAL_DELAY		0x0104
 
+/* Value of 1 = .01% */
+#define XVTC_CLK_MAX_PCT_ERR			1
+
 /**
  * struct xvtc_device - Xilinx Video Timing Controller device structure
  * @xvip: Xilinx Video IP device
@@ -175,10 +178,25 @@ int xvtc_generator_start(struct xvtc_device *xvtc,
 			 const struct xvtc_config *config)
 {
 	int ret;
+	unsigned long s_rate;
+	unsigned long g_rate;
+	unsigned long clk_err;
 
 	if (!xvtc->has_generator)
 		return -ENXIO;
 
+	s_rate = (unsigned long)config->fps * config->hsize * config->vsize;
+	ret = clk_set_rate(xvtc->xvip.clk, s_rate);
+	if (ret < 0)
+		return ret;
+
+	/* Verify that the clock is within a reasonable tolerance. */
+	g_rate = clk_get_rate(xvtc->xvip.clk);
+	clk_err = (abs(g_rate - s_rate) * 10000) / (s_rate);
+	if (clk_err > XVTC_CLK_MAX_PCT_ERR)
+		dev_warn(xvtc->xvip.dev, "Failed to set clk rate: %lu, actual rate: %lu\n",
+				s_rate, g_rate);
+
 	ret = clk_prepare_enable(xvtc->xvip.clk);
 	if (ret < 0)
 		return ret;
diff --git a/drivers/media/platform/xilinx/xilinx-vtc.h b/drivers/media/platform/xilinx/xilinx-vtc.h
index 855845911..0f360ed55 100644
--- a/drivers/media/platform/xilinx/xilinx-vtc.h
+++ b/drivers/media/platform/xilinx/xilinx-vtc.h
@@ -27,6 +27,7 @@ struct xvtc_config {
 	unsigned int vsync_start;
 	unsigned int vsync_end;
 	unsigned int vsize;
+	unsigned int fps;
 };
 
 struct xvtc_device *xvtc_of_get(struct device_node *np);
diff --git a/include/dt-bindings/media/xilinx-vip.h b/include/dt-bindings/media/xilinx-vip.h
index 94ed3edfc..beb50a748 100644
--- a/include/dt-bindings/media/xilinx-vip.h
+++ b/include/dt-bindings/media/xilinx-vip.h
@@ -32,5 +32,11 @@
 #define XVIP_VF_CUSTOM2			13
 #define XVIP_VF_CUSTOM3			14
 #define XVIP_VF_CUSTOM4			15
+#define XVIP_VF_VUY_422			16
+#define XVIP_VF_BGRX			17
+#define XVIP_VF_YUVX			18
+#define XVIP_VF_XBGR			19
+#define XVIP_VF_Y_GREY			20
+#define XVIP_VF_XRGB			21
 
 #endif /* __DT_BINDINGS_MEDIA_XILINX_VIP_H__ */
diff --git a/include/uapi/linux/xilinx-dprxss.h b/include/uapi/linux/xilinx-dprxss.h
new file mode 100644
index 000000000..3713735e1
--- /dev/null
+++ b/include/uapi/linux/xilinx-dprxss.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+
+#ifndef __XILINX_DPRXSS_H__
+#define __XILINX_DPRXSS_H__
+
+#include <linux/types.h>
+
+/**
+ * struct xdprxss_hdcp1x_keys_ioctl - Hdcp1x Keys structure
+ * @size: size of the keys
+ * @keys: Pointer to the keys buffer
+ */
+struct xdprxss_hdcp1x_keys_ioctl {
+	__u32 size;
+	void const *keys;
+};
+
+struct xdprxss_hdcp2x_keys_ioctl {
+	__u32 size_lc128;
+	__u32 size_private;
+	void const *key_lc128;
+	void const *key_private;
+};
+
+/* This ioctl is used to set the hdcp1x keys into IP */
+#define XILINX_DPRXSS_HDCP_KEY_WRITE \
+	_IOW('X', BASE_VIDIOC_PRIVATE + 0, struct xdprxss_hdcp1x_keys_ioctl)
+
+#define XILINX_DPRXSS_HDCP2X_KEY_WRITE \
+	_IOW('X', BASE_VIDIOC_PRIVATE + 1, struct xdprxss_hdcp2x_keys_ioctl)
+
+#endif
diff --git a/include/uapi/linux/xilinx-hdmirxss.h b/include/uapi/linux/xilinx-hdmirxss.h
new file mode 100644
index 000000000..37677c735
--- /dev/null
+++ b/include/uapi/linux/xilinx-hdmirxss.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+
+#ifndef __XILINX_HDMIRXSS_H__
+#define __XILINX_HDMIRXSS_H__
+
+#include <linux/types.h>
+
+/**
+ * struct xhdmirxss_hdcp1x_keys_ioctl - HDCP 1x Keys structure
+ * @size: size of the keys
+ * @keys: Pointer to the keys buffer
+ */
+struct xhdmirxss_hdcp1x_keys_ioctl {
+	__u32 size;
+	void const *keys;
+};
+
+/* This ioctl is used to set the HDCP1x keys into IP */
+#define XILINX_HDMIRXSS_HDCP_KEY_WRITE \
+	_IOW('X', BASE_VIDIOC_PRIVATE + 1, struct xhdmirxss_hdcp1x_keys_ioctl)
+
+#endif
