--- /dev/null
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/usb/ehci-xilinx.txt	2023-07-05 08:33:04.907651500 +0900
@@ -0,0 +1,21 @@
+Xilinx USB EHCI controller
+
+Required properties:
+- compatible: must be "xlnx,xps-usb-host-1.00.a"
+- reg: physical base address of the controller and length of memory mapped
+  region.
+- interrupts: The EHCI interrupt
+
+Optional properties:
+- xlnx,ext-vbus-valid: Use external VBUS
+- xlnx,support-usb-fs: Support for Full Speed USB
+- xlnx,use-phy-bus-pwr: Use phy bus power in USB
+
+Example:
+
+	xps_usb_host_0: usb@82400000 {
+		compatible = "xlnx,xps-usb-host-1.00.a";
+		interrupt-parent = <&xps_intc_0>;
+		interrupts = < 0 2 >;
+		reg = < 0x82400000 0x200 >;
+	} ;
--- linux-6.1.0/drivers/usb/host/xhci-hub.c	2023-07-05 08:37:35.792875900 +0900
+++ linux-xlnx-2023.1/drivers/usb/host/xhci-hub.c	2023-07-05 08:33:32.891815100 +0900
@@ -1942,6 +1942,13 @@
 		}
 	}
 
+	/* After resuming back from suspend, the controller may not initiate
+	 * LFPS.U3_exit signalling if not given a delay after updating the
+	 * link from U3->U0. So, lets wait for at least 1ms
+	 */
+	if (next_state == XDEV_U0)
+		mdelay(1);
+
 	/* poll for U0 link state complete, both USB2 and USB3 */
 	for_each_set_bit(port_index, &bus_state->bus_suspended, BITS_PER_LONG) {
 		sret = xhci_handshake(ports[port_index]->addr, PORT_PLC,
--- linux-6.1.0/drivers/usb/host/xhci-plat.c	2023-07-05 08:37:35.792875900 +0900
+++ linux-xlnx-2023.1/drivers/usb/host/xhci-plat.c	2023-07-05 08:33:32.891815100 +0900
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/usb/of.h>
+#include <linux/usb/otg.h>
 
 #include "xhci.h"
 #include "xhci-plat.h"
@@ -30,6 +31,8 @@
 static int xhci_plat_setup(struct usb_hcd *hcd);
 static int xhci_plat_start(struct usb_hcd *hcd);
 
+static host_wakeup_t host_wakeup_fn;
+
 static const struct xhci_driver_overrides xhci_plat_overrides __initconst = {
 	.extra_priv_size = sizeof(struct xhci_plat_priv),
 	.reset = xhci_plat_setup,
@@ -86,6 +89,17 @@
 	xhci->quirks |= XHCI_PLAT | priv->quirks;
 }
 
+static void host_wakeup_register(host_wakeup_t func)
+{
+	host_wakeup_fn = func;
+}
+
+static void host_wakeup_capable(struct device *dev, bool wakeup)
+{
+	if (host_wakeup_fn)
+		host_wakeup_fn(dev, wakeup);
+}
+
 /* called during probe() after chip reset completes */
 static int xhci_plat_setup(struct usb_hcd *hcd)
 {
@@ -173,6 +187,35 @@
 MODULE_DEVICE_TABLE(of, usb_xhci_of_match);
 #endif
 
+static int usb_otg_set_host(struct device *dev, struct usb_hcd *hcd, bool yes)
+{
+	int ret = 0;
+
+	hcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB3);
+	if (!IS_ERR_OR_NULL(hcd->usb_phy) && hcd->usb_phy->otg) {
+		if (yes) {
+			if (otg_set_host(hcd->usb_phy->otg, &hcd->self)) {
+				usb_put_phy(hcd->usb_phy);
+				goto disable_phy;
+			}
+		} else {
+			ret = otg_set_host(hcd->usb_phy->otg, NULL);
+			usb_put_phy(hcd->usb_phy);
+			goto disable_phy;
+		}
+
+	} else {
+		goto disable_phy;
+	}
+
+	return 0;
+
+disable_phy:
+	hcd->usb_phy = NULL;
+
+	return ret;
+}
+
 static int xhci_plat_probe(struct platform_device *pdev)
 {
 	const struct xhci_plat_priv *priv_match;
@@ -223,6 +266,9 @@
 	if (ret)
 		return ret;
 
+	/* Set the controller as wakeup capable */
+	device_set_wakeup_capable(&pdev->dev, true);
+
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 	pm_runtime_get_noresume(&pdev->dev);
@@ -283,6 +329,7 @@
 	}
 
 	device_set_wakeup_capable(&pdev->dev, true);
+	host_wakeup_register(dwc3_host_wakeup_capable);
 
 	xhci->main_hcd = hcd;
 
@@ -301,6 +348,9 @@
 		if (device_property_read_bool(tmpdev, "quirk-broken-port-ped"))
 			xhci->quirks |= XHCI_BROKEN_PORT_PED;
 
+		if (device_property_read_bool(tmpdev, "xhci-reset-on-resume"))
+			xhci->quirks |= XHCI_RESET_ON_RESUME;
+
 		device_property_read_u32(tmpdev, "imod-interval-ns",
 					 &xhci->imod_interval);
 	}
@@ -350,6 +400,10 @@
 			goto put_usb3_hcd;
 	}
 
+	ret = usb_otg_set_host(&pdev->dev, hcd, true);
+	if (ret)
+		goto dealloc_usb2_hcd;
+
 	device_enable_async_suspend(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
@@ -405,6 +459,9 @@
 
 	usb_phy_shutdown(hcd->usb_phy);
 
+	host_wakeup_register(NULL);
+	usb_otg_set_host(&dev->dev, hcd, false);
+
 	usb_remove_hcd(hcd);
 
 	if (shared_hcd)
@@ -433,6 +490,17 @@
 	ret = xhci_priv_suspend_quirk(hcd);
 	if (ret)
 		return ret;
+
+	/* Inform dwc3 driver about the device wakeup capability */
+	if (device_may_wakeup(&hcd->self.root_hub->dev)) {
+		host_wakeup_capable(dev, true);
+		enable_irq_wake(hcd->irq);
+		xhci->quirks &= ~XHCI_RESET_ON_RESUME;
+	} else {
+		host_wakeup_capable(dev, false);
+		xhci->quirks |= XHCI_RESET_ON_RESUME;
+	}
+
 	/*
 	 * xhci_suspend() needs `do_wakeup` to know whether host is allowed
 	 * to do wakeup during suspend.
@@ -493,6 +561,9 @@
 	struct usb_hcd  *hcd = dev_get_drvdata(dev);
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 
+	if (device_may_wakeup(&hcd->self.root_hub->dev))
+		disable_irq_wake(hcd->irq);
+
 	return xhci_resume(xhci, 0);
 }
 
--- linux-6.1.0/drivers/usb/host/xhci.c	2023-07-05 08:37:35.808497400 +0900
+++ linux-xlnx-2023.1/drivers/usb/host/xhci.c	2023-07-05 08:33:32.891815100 +0900
@@ -187,7 +187,11 @@
 
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init, "// Reset the HC");
 	command = readl(&xhci->op_regs->command);
+#ifdef CONFIG_USB_DWC3_OTG
+	command |= CMD_LRESET;
+#else
 	command |= CMD_RESET;
+#endif
 	writel(command, &xhci->op_regs->command);
 
 	/* Existing Intel xHCI controllers require a delay of 1 mS,
@@ -200,7 +204,13 @@
 	if (xhci->quirks & XHCI_INTEL_HOST)
 		udelay(1000);
 
-	ret = xhci_handshake(&xhci->op_regs->command, CMD_RESET, 0, timeout_us);
+	ret = xhci_handshake(&xhci->op_regs->command,
+#ifdef CONFIG_USB_DWC3_OTG
+			CMD_LRESET,
+#else
+			CMD_RESET,
+#endif
+			0, timeout_us);
 	if (ret)
 		return ret;
 
--- linux-6.1.0/drivers/usb/host/xhci.h	2023-07-05 08:37:35.808497400 +0900
+++ linux-xlnx-2023.1/drivers/usb/host/xhci.h	2023-07-05 08:33:32.891815100 +0900
@@ -2106,6 +2106,8 @@
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
+typedef void (*host_wakeup_t)(struct device *dev, bool wakeup);
+void dwc3_host_wakeup_capable(struct device *dev, bool wakeup);
 int xhci_handshake(void __iomem *ptr, u32 mask, u32 done, u64 timeout_us);
 void xhci_quiesce(struct xhci_hcd *xhci);
 int xhci_halt(struct xhci_hcd *xhci);
