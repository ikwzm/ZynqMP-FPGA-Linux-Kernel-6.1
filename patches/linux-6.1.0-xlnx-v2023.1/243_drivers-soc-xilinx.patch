--- /dev/null
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/soc/xilinx/xlnx,ai-engine.yaml	2023-07-05 08:33:04.634581500 +0900
@@ -0,0 +1,199 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/soc/xilinx/xlnx,ai-engine.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx AI Engine
+
+maintainers:
+  - Wendy Liang <wendy.liang@xilinx.com>
+
+description: |+
+  The Xilinx AI Engine is a tile processor with many cores (up to 400) that
+  can run in parallel. The data routing between cores is configured through
+  internal switches, and shim tiles interface with external interconnect, such
+  as memory or PL. One AI engine device can have multiple apertures, each
+  has its own address space and interrupt. At runtime application can create
+  multiple partitions within an aperture which are groups of columns of AI
+  engine tiles. Each AI engine partition is the minimum resetable unit for an
+  AI engine application.
+
+properties:
+  compatible:
+    enum:
+      - xlnx,ai-engine-v2.0
+      - xlnx,ai-engine-v1.0 # deprecated
+
+  reg:
+    deprecated: true
+    description: |
+      Physical base address and length of the device registers.
+      The AI engine address space assigned to Linux is defined by Xilinx
+      platform design tool.
+
+  '#address-cells':
+    enum: [2]
+    description: |
+      size of cell to describe AI engine range of tiles address.
+      It is the location of the starting tile of the range.
+      As the AI engine tiles are 2D array, the location of a tile
+      is presented as (column, row), the address cell is 2.
+
+  '#size-cells':
+    enum: [2]
+    description: |
+      size of cell to describe AI engine range of tiles size.
+      As the AI engine tiles are 2D array, the size cell is 2.
+
+  interrupts:
+    deprecated: true
+    maxItems: 3
+
+  interrupt-names:
+    deprecated: true
+    description: |
+      Should be "interrupt1", "interrupt2" or "interrupt3".
+
+  ranges: true
+
+  xlnx,aie-gen:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: |
+      hardware generation of AI engine device. E.g. the current values supported
+      are 1 and 2, it will be presented as <0x1> or <0x2>
+
+  xlnx,shim-rows:
+    $ref: /schemas/types.yaml#/definitions/uint8-array
+    description: |
+      start row and the number of rows of SHIM tiles of the AI engine device
+
+  xlnx,core-rows:
+    $ref: /schemas/types.yaml#/definitions/uint8-array
+    description: |
+      start row and the number of rows of core tiles of the AI engine device
+
+  xlnx,mem-rows:
+    $ref: /schemas/types.yaml#/definitions/uint8-array
+    description: |
+      start row and the number of rows of memory tiles of the AI engine device
+
+required:
+  - compatible
+  - '#address-cells'
+  - '#size-cells'
+  - ranges
+  - power-domains
+  - xlnx,aie-gen
+  - xlnx,shim-rows
+  - xlnx,core-rows
+  - xlnx,mem-rows
+
+patternProperties:
+  "^aperture@[0-9]+$":
+    type: object
+    description: |
+      AI engine aperture which is a group of column based tiles of the
+      AI engine device. Each AI engine apertures isolated from the
+      other AI engine apertures. An AI engine aperture is defined by
+      Xilinx platform design tools.
+
+    properties:
+      reg:
+        description: |
+          Physical base address and length of the aperture registers.
+          The AI engine address space assigned to Linux is defined by Xilinx
+          platform design tool.
+
+      xlnx,columns:
+        $ref: /schemas/types.yaml#/definitions/uint32-array
+        description:
+          It describes the location of the aperture. It specifies the start
+          column and the number of columns. E.g. an aperture starts from
+          column 0 and there are 50 columns, it will be presented as <0 50>.
+
+      interrupts:
+        maxItems: 3
+
+      interrupt-names:
+        description: |
+          Should be "interrupt1", "interrupt2" or "interrupt3".
+
+      xlnx,node-id:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        description: |
+          AI engine aperture node ID, which is defined by Xilinx platform design
+          tool to identify the AI engine aperture in the firmware.
+
+    required:
+      - reg
+      - xlnx,columns
+      - xlnx,node-id
+
+  "^partition[0-9]@[0-9]+$":
+    deprecated: true
+    type: object
+    description: |
+      AI engine partition which is a group of column based tiles of the AI
+      engine device. Each AI engine partition is isolated from the other
+      AI engine partitions. An AI engine partition is defined by Xilinx
+      platform design tools.
+      AI engine partition driver will create a FPGA bridge when probes the
+      AI engine partition. The AI engine SHIM row of the partition is the
+      bridge to connect AI engine partition, FPGA and PS.
+
+    properties:
+      reg:
+        description: |
+          It describes the group of tiles of the AI engine partition. It needs
+          to include the SHIM row. The format is defined by the parent AI engine
+          device node's '#address-cells' and '#size-cells' properties. e.g. a v1
+          AI engine device has 2D tiles array, the first row is SHIM row. A
+          partition which has 50 columns and 8 rows of core tiles and 1 row of
+          SHIM tiles will be presented as <0 0 50 9>.
+
+      label:
+        maxItems: 1
+
+      xlnx,partition-id:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        description: |
+          AI engine partition ID, which is defined by Xilinx platform design
+          tool to identify the AI engine partition in the system.
+
+    required:
+      - reg
+      - xlnx,partition-id
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/power/xlnx-versal-power.h>
+    bus {
+      #address-cells = <2>;
+      #size-cells = <2>;
+      ai_engine: ai-engine {
+        compatible = "xlnx,ai-engine-v2.0";
+        xlnx,aie-gen = /bits/ 8 <0x1>;
+        xlnx,shim-rows = /bits/ 8 <0 1>;
+        xlnx,core-rows = /bits/ 8 <1 8>;
+        xlnx,mem-rows = /bits/ 8 <0 0>;
+        power-domains = <&versal_firmware PM_DEV_AI>;
+        #address-cells = <2>;
+        #size-cells = <2>;
+        ranges;
+
+        aperture0: aperture@0 {
+          /* 50 columns and 8 core tile rows + 1 SHIM row */
+          reg = <0x200 0x0 0x1 0x0>;
+          xlnx,columns = <0 50>;
+          xlnx,node-id = <1>;
+          interrupt-parent = <&gic>;
+          interrupts = <0x0 0x94 0x4>,
+                       <0x0 0x95 0x4>,
+                       <0x0 0x96 0x4>;
+          interrupt-names = "interrupt1", "interrupt2", "interrupt3";
+        };
+      };
+    };
--- /dev/null
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/soc/xilinx/xlnx,ai_engine.txt	2023-07-05 08:33:04.634581500 +0900
@@ -0,0 +1,28 @@
+Xilinx AI Engine
+----------------
+
+The Xilinx AI Engine is a tile processor with many cores (up to 400) that
+can run in parallel. The data routing between cores is configured through
+internal switches, and shim tiles interface with external interconnect, such
+as memory or PL.
+
+Required properties:
+
+- compatible: Must be "xlnx,ai_engine".
+- reg: Physical base address and length of the registers set for the device.
+- interrupt-parent: the phandle to the interrupt controller.
+- interrupts: the interrupt numbers.
+- interrupt-names: Should be "interrupt0", "interrupt1", "interrupt2" or
+  "interrupt3".
+
+Example:
+
+	ai_engine@20000000000 {
+		compatible = "xlnx,ai_engine";
+		reg = <0x200 0x0 0x1 0x0>;
+		interrupt-parent = <&gic>;
+		interrupts = <0x0 0x94 0x1>,
+			     <0x0 0x95 0x1>,
+			     <0x0 0x96 0x1>;
+		interrupt-names = "interrupt1", "interrupt2", "interrupt3";
+	};
--- linux-6.1.0/Documentation/devicetree/bindings/soc/xilinx/xlnx,vcu.txt	2023-07-05 08:37:06.703762200 +0900
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/soc/xilinx/xlnx,vcu.txt	1970-01-01 09:00:00.000000000 +0900
@@ -1,26 +0,0 @@
-LogicoreIP designed compatible with Xilinx ZYNQ family.
--------------------------------------------------------
-
-General concept
----------------
-
-LogicoreIP design to provide the isolation between processing system
-and programmable logic. Also provides the list of register set to configure
-the frequency.
-
-Required properties:
-- compatible: shall be one of:
-	"xlnx,vcu"
-	"xlnx,vcu-logicoreip-1.0"
-- reg : The base offset and size of the VCU_PL_SLCR register space.
-- clocks: phandle for aclk and pll_ref clocksource
-- clock-names: The identification string, "aclk", is always required for
-   the axi clock. "pll_ref" is required for pll.
-Example:
-
-	xlnx_vcu: vcu@a0040000 {
-		compatible = "xlnx,vcu-logicoreip-1.0";
-		reg = <0x0 0xa0040000 0x0 0x1000>;
-		clocks = <&si570_1>, <&clkc 71>;
-		clock-names = "pll_ref", "aclk";
-	};
--- linux-6.1.0/drivers/soc/xilinx/xlnx_event_manager.c	2023-07-05 08:37:34.188561300 +0900
+++ linux-xlnx-2023.1/drivers/soc/xilinx/xlnx_event_manager.c	2023-07-05 08:33:31.087638500 +0900
@@ -35,7 +35,6 @@
 
 #define MAX_BITS	(32U) /* Number of bits available for error mask */
 
-#define FIRMWARE_VERSION_MASK			(0xFFFFU)
 #define REGISTER_NOTIFIER_FIRMWARE_VERSION	(2U)
 
 static DEFINE_HASHTABLE(reg_driver_map, REGISTERED_DRIVER_MAX_ORDER);
@@ -116,8 +115,10 @@
 		INIT_LIST_HEAD(&eve_data->cb_list_head);
 
 		cb_data = kmalloc(sizeof(*cb_data), GFP_KERNEL);
-		if (!cb_data)
+		if (!cb_data) {
+			kfree(eve_data);
 			return -ENOMEM;
+		}
 		cb_data->eve_cb = cb_fun;
 		cb_data->agent_data = data;
 
@@ -473,13 +474,13 @@
 		}
 	}
 	if (!is_callback_found)
-		pr_warn("Didn't find any registered callback for 0x%x 0x%x\n",
+		pr_warn("Unhandled SGI node 0x%x event 0x%x. Expected with Xen hypervisor\n",
 			payload[1], payload[2]);
 }
 
 static void xlnx_get_event_callback_data(u32 *buf)
 {
-	zynqmp_pm_invoke_fn(GET_CALLBACK_DATA, 0, 0, 0, 0, buf);
+	zynqmp_pm_invoke_fn(GET_CALLBACK_DATA, 0, 0, 0, 0, 0, buf);
 }
 
 static irqreturn_t xlnx_event_handler(int irq, void *dev_id)
@@ -551,7 +552,7 @@
 static int xlnx_event_init_sgi(struct platform_device *pdev)
 {
 	int ret = 0;
-	int cpu = smp_processor_id();
+	int cpu;
 	/*
 	 * IRQ related structures are used for the following:
 	 * for each SGI interrupt ensure its mapped by GIC IRQ domain
@@ -588,9 +589,12 @@
 	sgi_fwspec.param[0] = sgi_num;
 	virq_sgi = irq_create_fwspec_mapping(&sgi_fwspec);
 
+	cpu = get_cpu();
 	per_cpu(cpu_number1, cpu) = cpu;
 	ret = request_percpu_irq(virq_sgi, xlnx_event_handler, "xlnx_event_mgmt",
 				 &cpu_number1);
+	put_cpu();
+
 	WARN_ON(ret);
 	if (ret) {
 		irq_dispose_mapping(virq_sgi);
@@ -649,7 +653,12 @@
 
 	ret = zynqmp_pm_register_sgi(sgi_num, 0);
 	if (ret) {
-		dev_err(&pdev->dev, "SGI %d Registration over TF-A failed with %d\n", sgi_num, ret);
+		if (ret == -ENOTSUPP)
+			dev_info(&pdev->dev, "PM firmware event notification not supported\n");
+		else
+			dev_err(&pdev->dev, "SGI %d registration failed, err %d\n",
+				sgi_num, ret);
+
 		xlnx_event_cleanup_sgi(pdev);
 		return ret;
 	}
--- linux-6.1.0/drivers/soc/xilinx/zynqmp_pm_domains.c	2023-07-05 08:37:34.188561300 +0900
+++ linux-xlnx-2023.1/drivers/soc/xilinx/zynqmp_pm_domains.c	2023-07-05 08:33:31.087638500 +0900
@@ -227,7 +227,7 @@
 			goto done;
 	}
 
-	/**
+	/*
 	 * Add index in empty node_id of power domain list as no existing
 	 * power domain found for current index.
 	 */
--- linux-6.1.0/drivers/soc/xilinx/zynqmp_power.c	2023-07-05 08:37:34.188561300 +0900
+++ linux-xlnx-2023.1/drivers/soc/xilinx/zynqmp_power.c	2023-07-05 08:33:31.087638500 +0900
@@ -50,7 +50,7 @@
 
 static void zynqmp_pm_get_callback_data(u32 *buf)
 {
-	zynqmp_pm_invoke_fn(GET_CALLBACK_DATA, 0, 0, 0, 0, buf);
+	zynqmp_pm_invoke_fn(GET_CALLBACK_DATA, 0, 0, 0, 0, 0, buf);
 }
 
 static void suspend_event_callback(const u32 *payload, void *data)
@@ -82,9 +82,11 @@
 			pm_suspend(PM_SUSPEND_MEM);
 			break;
 		default:
-			pr_err("%s Unsupported InitSuspendCb reason "
-				"code %d\n", __func__, payload[1]);
+			pr_err("%s Unsupported InitSuspendCb reason code %d\n",
+			       __func__, payload[1]);
 		}
+	} else {
+		pr_err("%s() Unsupported Callback %d\n", __func__, payload[0]);
 	}
 
 	return IRQ_HANDLED;
@@ -251,8 +253,8 @@
 						dev_name(&pdev->dev),
 						&pdev->dev);
 		if (ret) {
-			dev_err(&pdev->dev, "devm_request_threaded_irq '%d' "
-					    "failed with %d\n", irq, ret);
+			dev_err(&pdev->dev, "devm_request_threaded_irq '%d' failed with %d\n",
+				irq, ret);
 			return ret;
 		}
 	} else {
