--- linux-6.1.0/Documentation/devicetree/bindings/serial/xlnx,opb-uartlite.yaml	2023-07-05 08:37:06.656897200 +0900
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/serial/xlnx,opb-uartlite.yaml	2023-07-05 08:33:04.587717600 +0900
@@ -15,6 +15,7 @@
       enum:
         - xlnx,xps-uartlite-1.00.a
         - xlnx,opb-uartlite-1.00.b
+        - xlnx,axi-uartlite-rs485
 
   reg:
     maxItems: 1
--- linux-6.1.0/drivers/tty/serial/Kconfig	2023-07-05 08:37:35.457823700 +0900
+++ linux-xlnx-2023.1/drivers/tty/serial/Kconfig	2023-07-05 08:33:32.547139200 +0900
@@ -535,7 +535,7 @@
 	int "Maximum number of uartlite serial ports"
 	depends on SERIAL_UARTLITE
 	range 1 256
-	default 1
+	default 16
 	help
 	  Set this to the number of uartlites in your system, or the number
 	  you think you might implement.
--- linux-6.1.0/drivers/tty/serial/xilinx_uartps.c	2023-07-05 08:37:35.520308600 +0900
+++ linux-xlnx-2023.1/drivers/tty/serial/xilinx_uartps.c	2023-07-05 08:33:32.594003100 +0900
@@ -34,12 +34,12 @@
 #define TX_TIMEOUT		500000
 
 /* Rx Trigger level */
-static int rx_trigger_level = 56;
+static uint rx_trigger_level = 56;
 module_param(rx_trigger_level, uint, 0444);
 MODULE_PARM_DESC(rx_trigger_level, "Rx trigger level, 1-63 bytes");
 
 /* Rx Timeout */
-static int rx_timeout = 10;
+static uint rx_timeout = 10;
 module_param(rx_timeout, uint, 0444);
 MODULE_PARM_DESC(rx_timeout, "Rx timeout, 1-255");
 
@@ -229,6 +229,13 @@
 
 	is_rxbs_support = cdns_uart->quirks & CDNS_UART_RXBS_SUPPORT;
 
+	/*
+	 * RXEMPTY will never be set if RX is disabled as read bytes
+	 * will not be removed from the FIFO
+	 */
+	if (readl(port->membase + CDNS_UART_CR) & CDNS_UART_CR_RX_DIS)
+		return;
+
 	while ((readl(port->membase + CDNS_UART_SR) &
 		CDNS_UART_SR_RXEMPTY) != CDNS_UART_SR_RXEMPTY) {
 		if (is_rxbs_support)
@@ -1089,13 +1096,17 @@
 static void cdns_uart_pm(struct uart_port *port, unsigned int state,
 		   unsigned int oldstate)
 {
+	int ret;
+
 	switch (state) {
 	case UART_PM_STATE_OFF:
 		pm_runtime_mark_last_busy(port->dev);
 		pm_runtime_put_autosuspend(port->dev);
 		break;
 	default:
-		pm_runtime_get_sync(port->dev);
+		ret = pm_runtime_get_sync(port->dev);
+		if (ret < 0)
+			dev_err(port->dev, "Failed to enable clocks\n");
 		break;
 	}
 }
