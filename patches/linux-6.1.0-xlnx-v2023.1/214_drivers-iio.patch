--- /dev/null
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/iio/adc/ti,ina260.yaml	2023-07-05 08:33:03.546923400 +0900
@@ -0,0 +1,57 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/iio/adc/ti,ina260.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Texas Instruments INA260 power monitor
+
+maintainers:
+  - Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
+
+description: |
+  The INA260 is a digital-output, current, power and voltage monitor
+  with an I2C and SMBUS compatible interface with an integrated shunt
+  resistor. It features up to 16 programmable addresses on I2C compatible
+  interface. Datasheet - https://www.ti.com/lit/ds/symlink/ina260.pdf?ts=1608607288391
+
+properties:
+  compatible:
+    enum:
+      - ti,ina260
+
+  reg:
+    description: |
+      The 7-bits long I2c address of the device
+
+  "#io-channel-cells":
+    const: 1
+
+  interrupts:
+    description: |
+      IRQ line for the device
+
+  label:
+    description: |
+      A symbolic name for the device
+
+required:
+  - compatible
+  - reg
+  - "#io-channel-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      ina260@40 {
+        compatible = "ti,ina260";
+        reg = <0x40>;
+        #io-channel-cells = <1>;
+      };
+    };
+...
--- /dev/null
+++ linux-xlnx-2023.1/Documentation/devicetree/bindings/iio/adc/xlnx,versal-sysmon.yaml	2023-07-05 08:33:03.562545200 +0900
@@ -0,0 +1,154 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# Copyright 2019 - 2020 Xilinx Inc.
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/iio/adc/xlnx,versal-sysmon.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Versal Sysmon Linux Driver
+
+maintainers:
+  - Salih Erim <salih.erim@amd.com>
+
+description: |
+  Sysmon Driver uses Linux IIO framework which was used to abstract the supply
+  voltages and temperatures across the chip as Voltage and Temperature
+  Channels in the framework. Since there are only 160 supply voltage registers
+  and 184 measurement points, there is no constant mapping of supply voltage
+  registers and the measurement points. User has to select the voltages to
+  monitor in design tool. Depending on the selection, a voltage supply gets
+  mapped to one of the supply registers. So, this mapping information is
+  provided to the driver via a device tree. Depending on the number of supplies
+  enabled in the design, the device tree will contain the information of name
+  of the supply enabled and the supply register it maps to.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,versal-sysmon
+
+  reg:
+    description: Sysmon Registers
+    maxItems: 1
+
+  interrupts:
+    description: interrupt line for Sysmon
+    maxItems: 1
+
+  '#address-cells':
+    const: 1
+
+  '#size-cells':
+    const: 0
+
+  xlnx,numchannels:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: |
+      Number of supply channels enabled in the design.
+      Possible values 0 - 160. Based on this value, child supply nodes will
+      be created
+
+  xlnx,nodeid:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description: |
+      PLM specified sysmon node id.
+
+  xlnx,hbm:
+    description: |
+      Exists if node refers to a HBM SLR.
+    type: boolean
+
+patternProperties:
+  "^supply@([0-9]{1,2}|1[0-5][0-9])$":
+    type: object
+    description: |
+      Represents the supplies configured in the design.
+
+    properties:
+      reg:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 159
+        description:
+          The supply number associated with the voltage.
+
+      xlnx,name:
+        $ref: /schemas/types.yaml#/definitions/string
+        description:
+          Name of the supply enabled
+
+      xlnx,bipolar:
+        $ref: /schemas/types.yaml#/definitions/flag
+        description:
+          If the supply has a bipolar type and the output will be signed
+
+    required:
+      - reg
+      - xlnx,name
+
+required:
+  - compatible
+  - reg
+  - xlnx,numchannels
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/power/xlnx-versal-regnode.h>
+    bus {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
+        sysmon@f1270000 {
+            compatible = "xlnx,versal-sysmon";
+            reg = <0 0xf1270000 0 0x4000>;
+            interrupts = <0 0x90 0x4>;
+            xlnx,numchannels = /bits/8 <8>;
+            xlnx,nodeid = <PM_REGNODE_SYSMON_ROOT_0>;
+            #address-cells = <1>;
+            #size-cells = <0>;
+            supply@0 {
+                    reg = <0>;
+                    xlnx,name = "vccint";
+            };
+
+            supply@31 {
+                    reg = <31>;
+                    xlnx,name = "vccsoc";
+            };
+
+            supply@32 {
+                    reg = <32>;
+                    xlnx,bipolar;
+                    xlnx,name = "vccram";
+            };
+
+            supply@63 {
+                    reg = <63>;
+                    xlnx,bipolar;
+                    xlnx,name = "vccaux";
+            };
+
+            supply@64 {
+                    reg = <64>;
+                    xlnx,name = "vccbram";
+            };
+
+            supply@95 {
+                    reg = <95>;
+                    xlnx,name = "gt_avaux";
+            };
+
+            supply@96 {
+                    reg = <96>;
+                    xlnx,name = "gt_vccaux";
+            };
+
+            supply@159 {
+                    reg = <159>;
+                    xlnx,name = "vccint_ir";
+            };
+        };
+    };
--- linux-6.1.0/drivers/iio/adc/Kconfig	2023-07-05 08:37:25.055034400 +0900
+++ linux-xlnx-2023.1/drivers/iio/adc/Kconfig	2023-07-05 08:33:21.958993100 +0900
@@ -509,6 +509,18 @@
 	  Say yes here to build support for TI INA2xx family of Power Monitors.
 	  This driver is mutually exclusive with the HWMON version.
 
+config INA260_ADC
+	tristate "Texas Instruments INA260 Power Monitors IIO driver"
+	depends on I2C && !SENSORS_INA2XX
+	select REGMAP_I2C
+	select IIO_BUFFER
+	select IIO_KFIFO_BUF
+	help
+	  Say yes here to build support for TI INA260 power monitor.
+	  This driver can also be built as a module. It supports software buffer
+	  mode and raw reads of ina260 iio channels. Up to 4 channels are
+	  supported including timestamp.
+
 config INGENIC_ADC
 	tristate "Ingenic JZ47xx SoCs ADC driver"
 	depends on MIPS || COMPILE_TEST
@@ -1338,4 +1350,15 @@
 	  The driver can also be built as a module. If so, the module will be called
 	  xilinx-ams.
 
+config VERSAL_SYSMON
+	tristate "Xilinx Sysmon driver for Versal"
+	depends on HAS_IOMEM
+	help
+	  Say yes here to have support for the Xilinx Sysmon.
+	  The driver will enable users to monitor temperature and voltage on the
+	  Xilinx Versal platform.
+	  The HW also supports I2C access but it is not supported by the driver.
+
+	  The driver can also be build as a module. If so, the module will be called
+	  versal-sysmon.
 endmenu
--- linux-6.1.0/drivers/iio/adc/Makefile	2023-07-05 08:37:25.055034400 +0900
+++ linux-xlnx-2023.1/drivers/iio/adc/Makefile	2023-07-05 08:33:21.958993100 +0900
@@ -49,6 +49,7 @@
 obj-$(CONFIG_IMX7D_ADC) += imx7d_adc.o
 obj-$(CONFIG_IMX8QXP_ADC) += imx8qxp-adc.o
 obj-$(CONFIG_INA2XX_ADC) += ina2xx-adc.o
+obj-$(CONFIG_INA260_ADC) += ina260-adc.o
 obj-$(CONFIG_INGENIC_ADC) += ingenic-adc.o
 obj-$(CONFIG_INTEL_MRFLD_ADC) += intel_mrfld_adc.o
 obj-$(CONFIG_LP8788_ADC) += lp8788_adc.o
@@ -120,3 +121,4 @@
 obj-$(CONFIG_XILINX_XADC) += xilinx-xadc.o
 obj-$(CONFIG_XILINX_AMS) += xilinx-ams.o
 obj-$(CONFIG_SD_ADC_MODULATOR) += sd_adc_modulator.o
+obj-$(CONFIG_VERSAL_SYSMON) += versal-sysmon.o
--- /dev/null
+++ linux-xlnx-2023.1/drivers/iio/adc/ina260-adc.c	2023-07-05 08:33:21.990235400 +0900
@@ -0,0 +1,557 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * INA260 power monitor driver
+ * Based on drivers/iio/adc/ina2xx-adc.c
+ *
+ * Copyright (C) 2021 Xilinx, Inc.
+ */
+
+#include <linux/i2c.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/sysfs.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/sched/task.h>
+#include <linux/util_macros.h>
+
+/* INA260 registers definition */
+#define INA260_CONFIG		0x00
+#define INA260_CURRENT		0x01
+#define INA260_VOLTAGE		0x02
+#define INA260_POWER		0x03
+#define INA260_MASK_ENABLE	0x06
+#define INA260_ALERT_LIMIT	0x07
+#define INA260_MANF_ID		0xFE
+#define INA260_DIE_ID		0xFF
+
+#define INA260_CONFIG_DEFAULT	0x6327
+
+#define INA260_CURRENT_LSB	1250
+#define INA260_VOLTAGE_LSB	1250
+#define INA260_POWER_LSB	10
+
+/* Bits */
+#define INA260_CVRF		BIT(3)
+
+#define INA260_MODE_MASK	GENMASK(2, 0)
+#define INA260_VOLT_MASK	GENMASK(8, 6)
+#define INA260_SHIFT_VOLT(val)	((val) << 6)
+#define INA260_CURR_MASK	GENMASK(5, 3)
+#define INA260_SHIFT_CURR(val)	((val) << 3)
+#define INA260_AVG_MASK		GENMASK(11, 9)
+#define INA260_SHIFT_AVG(val)	((val) << 9)
+
+#define SAMPLING_PERIOD(x) ({		\
+	typeof(x) _x = (x);		\
+	(_x->config->volt_conv_time	\
+	+ _x->config->curr_conv_time)	\
+	* _x->config->avgs; })
+
+static bool ina260_is_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return (reg == INA260_CONFIG) || (reg == INA260_MASK_ENABLE) ||
+		(reg == INA260_ALERT_LIMIT);
+}
+
+static bool ina260_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return (reg != INA260_CONFIG);
+}
+
+static inline bool is_signed_reg(unsigned int reg)
+{
+	return (reg == INA260_CURRENT);
+}
+
+static const struct regmap_config ina260_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.max_register = 8,
+	.writeable_reg = ina260_is_writeable_reg,
+	.volatile_reg = ina260_is_volatile_reg,
+};
+
+enum ina260_ids {ina260 = 0};
+
+/**
+ * struct ina260_config - For configurable parameters
+ * @config_default: Default configuration
+ * @volt_conv_time: Bus voltage conversion time
+ * @curr_conv_time: Shunt current conversion time
+ * @avgs: Number of samples collected and averaged
+ */
+struct ina260_config {
+	u16 config_default;
+	int volt_conv_time;
+	int curr_conv_time;
+	int avgs;
+};
+
+/**
+ * struct ina260_chip - For device specific data
+ * @regmap: Regmap pointer to device registers
+ * @task: Pointer to task created by buffer mode
+ * @lock: Mutex to enable use of multiple user apps
+ * @chip_id: Id to determine chip
+ * @config: Pointer to config structure
+ */
+struct ina260_chip {
+	struct regmap *regmap;
+	struct task_struct *task;
+	struct mutex lock; /* Lock for device writes */
+	enum ina260_ids chip_id;
+	struct ina260_config *config;
+};
+
+static struct ina260_config ina260_config[] = {
+	[ina260] = {
+		.config_default = INA260_CONFIG_DEFAULT,
+		.volt_conv_time = 1100,
+		.curr_conv_time = 1100,
+		.avgs = 4,
+	},
+};
+
+static int ina260_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val, int *val2, long mask)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int regval;
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		if (iio_buffer_enabled(indio_dev))
+			return -EBUSY;
+
+		ret = regmap_read(chip->regmap, chan->address, &regval);
+		if (ret)
+			return ret;
+
+		if (is_signed_reg(chan->address))
+			*val = (s16)regval;
+		else
+			*val = regval;
+		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->address) {
+		case INA260_CURRENT:
+			*val = INA260_CURRENT_LSB;
+			*val2 = 1000;
+			return IIO_VAL_FRACTIONAL;
+
+		case INA260_VOLTAGE:
+			*val = INA260_VOLTAGE_LSB;
+			*val2 = 1000;
+			return IIO_VAL_FRACTIONAL;
+
+		case INA260_POWER:
+			*val = INA260_POWER_LSB;
+			return IIO_VAL_INT;
+		}
+		return -EINVAL;
+
+	case IIO_CHAN_INFO_INT_TIME:
+		*val = 0;
+		if (chan->address == INA260_VOLTAGE)
+			*val2 = chip->config->volt_conv_time;
+		else
+			*val2 = chip->config->curr_conv_time;
+
+		return IIO_VAL_INT_PLUS_MICRO;
+
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = DIV_ROUND_CLOSEST(1000000, SAMPLING_PERIOD(chip));
+		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*val = chip->config->avgs;
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const int ina260_avg_tab[] = { 1, 4, 16, 64, 128, 256, 512, 1024 };
+
+/* Conversion times in uS */
+static const int ina260_conv_time_tab[] = { 140, 204, 332, 588, 1100, 2116, 4156, 8244 };
+
+static int ina260_write_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int val, int val2, long mask)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int config;
+	int ret, bits;
+
+	if (iio_buffer_enabled(indio_dev))
+		return -EBUSY;
+
+	mutex_lock(&chip->lock);
+
+	ret = regmap_read(chip->regmap, INA260_CONFIG, &config);
+	if (ret)
+		goto err;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_INT_TIME:
+		if (val2 > 8244 || val2 < 140) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		bits = find_closest(val2, ina260_conv_time_tab,
+				    ARRAY_SIZE(ina260_conv_time_tab));
+
+		if (chan->address == INA260_VOLTAGE) {
+			chip->config->volt_conv_time = ina260_conv_time_tab[bits];
+			config &= ~INA260_VOLT_MASK;
+			config |= INA260_SHIFT_VOLT(bits) & INA260_VOLT_MASK;
+		} else {
+			chip->config->curr_conv_time = ina260_conv_time_tab[bits];
+			config &= ~INA260_CURR_MASK;
+			config |= INA260_SHIFT_CURR(bits) & INA260_CURR_MASK;
+		}
+		break;
+
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		bits = find_closest(val, ina260_avg_tab, ARRAY_SIZE(ina260_avg_tab));
+		chip->config->avgs = ina260_avg_tab[bits];
+		config &= ~INA260_AVG_MASK;
+		config |= INA260_SHIFT_AVG(bits) & INA260_AVG_MASK;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+	if (!ret)
+		ret = regmap_write(chip->regmap, INA260_CONFIG, config);
+err:
+	mutex_unlock(&chip->lock);
+
+	return ret;
+}
+
+static int ina260_debug_reg(struct iio_dev *indio_dev,
+			    unsigned int reg, unsigned int writeval, unsigned int *readval)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+
+	if (!readval)
+		return regmap_write(chip->regmap, reg, writeval);
+
+	return regmap_read(chip->regmap, reg, readval);
+}
+
+#define INA260_CHAN_VOLTAGE(_index, _address) { \
+	.type = IIO_VOLTAGE, \
+	.address = (_address), \
+	.indexed = 1, \
+	.channel = (_index), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+	BIT(IIO_CHAN_INFO_SCALE) | \
+	BIT(IIO_CHAN_INFO_INT_TIME), \
+	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+	BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \
+	.scan_index = (_index), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = 16, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	} \
+}
+
+#define INA260_CHAN_CURRENT(_index, _address) { \
+	.type = IIO_CURRENT, \
+	.address = (_address), \
+	.indexed = 1, \
+	.channel = (_index), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+	BIT(IIO_CHAN_INFO_SCALE) | \
+	BIT(IIO_CHAN_INFO_INT_TIME), \
+	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+	BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \
+	.scan_index = (_index), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 16, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	} \
+}
+
+#define INA260_CHAN_POWER(_index, _address) { \
+	.type = IIO_POWER, \
+	.address = (_address), \
+	.indexed = 1, \
+	.channel = (_index), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+	BIT(IIO_CHAN_INFO_SCALE), \
+	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+	BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \
+	.scan_index = (_index), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = 16, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	} \
+}
+
+static const struct iio_chan_spec ina260_channels[] = {
+	INA260_CHAN_CURRENT(0, INA260_CURRENT),
+	INA260_CHAN_VOLTAGE(1, INA260_VOLTAGE),
+	INA260_CHAN_POWER(2, INA260_POWER),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+/* Possible integration times for current and voltage */
+static IIO_CONST_ATTR_NAMED(ina260_integration_time_available,
+			    integration_time_available,
+			    "0.000140 0.000204 0.000332 0.000588 0.001100 0.002116 0.004156 0.008244");
+
+static struct attribute *ina260_attributes[] = {
+	&iio_const_attr_ina260_integration_time_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ina260_attribute_group = {
+	.attrs = ina260_attributes,
+};
+
+static const struct iio_info ina260_info = {
+	.attrs = &ina260_attribute_group,
+	.read_raw = ina260_read_raw,
+	.write_raw = ina260_write_raw,
+	.debugfs_reg_access = ina260_debug_reg,
+};
+
+static int ina260_conversion_ready(struct iio_dev *indio_dev)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int alert;
+	int ret;
+
+	ret = regmap_read(chip->regmap, INA260_MASK_ENABLE, &alert);
+	if (ret < 0)
+		return ret;
+
+	return (alert & INA260_CVRF);
+}
+
+static int ina260_work_buffer(struct iio_dev *indio_dev)
+{
+	/* data buffer needs space for channel data and timestap */
+	unsigned short data[3 + sizeof(s64) / sizeof(short)];
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	int bit, ret, i = 0;
+	s64 time;
+
+	time = iio_get_time_ns(indio_dev);
+
+	/*
+	 * Read current, voltage and power from device
+	 */
+	for_each_set_bit(bit, indio_dev->active_scan_mask,
+			 indio_dev->masklength) {
+		unsigned int val;
+
+		ret = regmap_read(chip->regmap, INA260_CURRENT + bit, &val);
+		if (ret < 0)
+			return ret;
+
+		data[i++] = val;
+	}
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data, time);
+
+	return 0;
+}
+
+static int ina260_capture_thread(void *data)
+{
+	struct iio_dev *indio_dev = data;
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	int sampling_us = SAMPLING_PERIOD(chip);
+	struct timespec64 next, now, delta;
+	s64 delay_us;
+	int ret;
+
+	ktime_get_ts64(&next);
+
+	do {
+		while (1) {
+			/* Check if conversion is ready */
+			ret = ina260_conversion_ready(indio_dev);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * If the conversion was not yet finished,
+			 * reset the reference timestamp.
+			 */
+			if (ret == 0)
+				ktime_get_ts64(&next);
+			else
+				break;
+		}
+		/* Read the data from sensor and push it to buffers */
+		ret = ina260_work_buffer(indio_dev);
+		if (ret < 0)
+			return ret;
+
+		ktime_get_ts64(&now);
+		/*
+		 * Advance the timestamp for the next poll by one sampling
+		 * interval, and sleep for the remainder (next - now)
+		 * In case "next" has already passed, the interval is added
+		 * multiple times, i.e. samples are dropped.
+		 */
+		do {
+			timespec64_add_ns(&next, 1000 * sampling_us);
+			delta = timespec64_sub(next, now);
+			delay_us = div_s64(timespec64_to_ns(&delta), 1000);
+		} while (delay_us <= 0);
+
+		usleep_range(delay_us, (delay_us * 3) >> 1);
+
+	} while (!kthread_should_stop());
+
+	return 0;
+}
+
+static int ina260_buffer_enable(struct iio_dev *indio_dev)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int sampling_us = SAMPLING_PERIOD(chip);
+	struct task_struct *task;
+
+	task = kthread_create(ina260_capture_thread, (void *)indio_dev,
+			      "%s:%d-%uus", indio_dev->name, iio_device_id(indio_dev),
+			      sampling_us);
+
+	if (IS_ERR(task))
+		return PTR_ERR(task);
+
+	get_task_struct(task);
+	wake_up_process(task);
+	chip->task = task;
+
+	return 0;
+}
+
+static int ina260_buffer_disable(struct iio_dev *indio_dev)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+
+	if (chip->task) {
+		kthread_stop(chip->task);
+		put_task_struct(chip->task);
+		chip->task = NULL;
+	}
+
+	return 0;
+}
+
+static const struct iio_buffer_setup_ops ina260_setup_ops = {
+	.postenable = &ina260_buffer_enable,
+	.predisable = &ina260_buffer_disable,
+};
+
+static int ina260_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct iio_dev *indio_dev;
+	struct ina260_chip *chip;
+	enum ina260_ids type = 0;
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	chip = iio_priv(indio_dev);
+	i2c_set_clientdata(client, indio_dev);
+
+	chip->regmap = devm_regmap_init_i2c(client, &ina260_regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		dev_err(&client->dev, "failed to allocate register map\n");
+		return PTR_ERR(chip->regmap);
+	}
+
+	mutex_init(&chip->lock);
+
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->dev.of_node = client->dev.of_node;
+
+	chip->config = &ina260_config[type];
+	ret = regmap_write(chip->regmap, INA260_CONFIG,
+			   chip->config->config_default);
+	if (ret) {
+		dev_err(&client->dev, "Error configuring the device\n");
+		return ret;
+	}
+	indio_dev->channels = ina260_channels;
+	indio_dev->num_channels = ARRAY_SIZE(ina260_channels);
+	indio_dev->info = &ina260_info;
+	indio_dev->name = id->name;
+
+	ret = devm_iio_kfifo_buffer_setup(&indio_dev->dev, indio_dev,
+					  &ina260_setup_ops);
+	if (ret)
+		return ret;
+
+	return iio_device_register(indio_dev);
+}
+
+static void ina260_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	int ret;
+
+	iio_device_unregister(indio_dev);
+	/* Power down */
+	ret = regmap_update_bits(chip->regmap, INA260_CONFIG, INA260_MODE_MASK, 0);
+	if (ret)
+		dev_warn(&client->dev, "Failed to power down device (%pe)\n",
+			 ERR_PTR(ret));
+}
+
+static const struct i2c_device_id ina260_id[] = {
+	{"ina260", ina260},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ina260_id);
+
+static const struct of_device_id ina260_of_match[] = {
+	{
+		.compatible = "ti,ina260",
+		.data = (void *)ina260
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ina260_of_match);
+
+static struct i2c_driver ina260_driver = {
+	.driver = {
+		.name = "ina260-adc",
+		.of_match_table = ina260_of_match,
+	},
+	.probe = ina260_probe,
+	.remove = ina260_remove,
+	.id_table = ina260_id,
+};
+module_i2c_driver(ina260_driver);
+
+MODULE_AUTHOR("Raviteja Narayanam <raviteja.narayanam@xilinx.com>");
+MODULE_DESCRIPTION("Texas Instruments INA 260 ADC driver");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ linux-xlnx-2023.1/drivers/iio/adc/versal-sysmon.c	2023-07-05 08:33:22.021478500 +0900
@@ -0,0 +1,1293 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx SYSMON for Versal
+ *
+ * Copyright (C) 2019 - 2022, Xilinx, Inc.
+ * Copyright (C) 2022 - 2023, Advanced Micro Devices, Inc.
+ *
+ * Description:
+ * This driver is developed for SYSMON on Versal. The driver supports INDIO Mode
+ * and supports voltage and temperature monitoring via IIO sysfs interface and
+ * in kernel event monitoring for some modules.
+ */
+
+#include <linux/bits.h>
+#include <dt-bindings/power/xlnx-versal-regnode.h>
+#include <linux/firmware/xlnx-zynqmp.h>
+#include <linux/moduleparam.h>
+#include "versal-sysmon.h"
+
+#define SYSMON_EVENT_WORK_DELAY_MS	1000
+#define SYSMON_UNMASK_WORK_DELAY_MS	500
+
+#define SYSMON_FRACTIONAL_DENOM		128
+#define SYSMON_HBM_FRACTIONAL_DENOM	1
+
+#define SYSMON_HBM_TEMP_SHIFT	16U
+#define SYSMON_HBM_TEMP_MASK	GENMASK(6, 0)
+
+static bool secure_mode;
+module_param(secure_mode, bool, 0444);
+MODULE_PARM_DESC(secure_mode,
+		 "Allow sysmon to access register space using EEMI, when direct register access is restricted (default: Direct Access mode)");
+
+static LIST_HEAD(sysmon_list_head);
+
+/* This structure describes temperature events */
+static const struct iio_event_spec sysmon_temp_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate =
+			BIT(IIO_EV_INFO_ENABLE) | BIT(IIO_EV_INFO_HYSTERESIS),
+	},
+};
+
+/* This structure describes voltage events */
+static const struct iio_event_spec sysmon_supply_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+/* Temperature channel attributes */
+static const struct iio_chan_spec temp_channels[] = {
+	SYSMON_CHAN_TEMP(TEMP_MAX, "temp"),
+	SYSMON_CHAN_TEMP(TEMP_MIN, "min"),
+	SYSMON_CHAN_TEMP(TEMP_MAX_MAX, "max_max"),
+	SYSMON_CHAN_TEMP(TEMP_MIN_MIN, "min_min"),
+};
+
+/* Temperature event attributes */
+static const struct iio_chan_spec temp_events[] = {
+	SYSMON_CHAN_TEMP_EVENT(TEMP_EVENT, "temp", sysmon_temp_events),
+	SYSMON_CHAN_TEMP_EVENT(OT_EVENT, "ot", sysmon_temp_events),
+};
+
+/* HBM temperature channel attributes */
+static const struct iio_chan_spec temp_hbm_channels[] = {
+	SYSMON_CHAN_TEMP(TEMP_HBM, "temp_hbm"),
+};
+
+static inline void sysmon_direct_read_reg(struct sysmon *sysmon, u32 offset, u32 *data)
+{
+	*data = readl(sysmon->base + offset);
+}
+
+static inline void sysmon_direct_write_reg(struct sysmon *sysmon, u32 offset, u32 data)
+{
+	writel(data, sysmon->base + offset);
+}
+
+static inline void sysmon_direct_update_reg(struct sysmon *sysmon, u32 offset,
+					    u32 mask, u32 data)
+{
+	u32 val;
+
+	sysmon_direct_read_reg(sysmon, offset, &val);
+	sysmon_direct_write_reg(sysmon, offset, (val & ~mask) | (mask & data));
+}
+
+static struct sysmon_ops direct_access = {
+	.read_reg = sysmon_direct_read_reg,
+	.write_reg = sysmon_direct_write_reg,
+	.update_reg = sysmon_direct_update_reg,
+};
+
+static inline void sysmon_secure_read_reg(struct sysmon *sysmon, u32 offset, u32 *data)
+{
+	zynqmp_pm_sec_read_reg(sysmon->pm_info, offset, data);
+}
+
+static inline void sysmon_secure_write_reg(struct sysmon *sysmon, u32 offset, u32 data)
+{
+	zynqmp_pm_sec_mask_write_reg(sysmon->pm_info, offset, GENMASK(31, 0), data);
+}
+
+static inline void sysmon_secure_update_reg(struct sysmon *sysmon, u32 offset,
+					    u32 mask, u32 data)
+{
+	u32 val;
+
+	zynqmp_pm_sec_read_reg(sysmon->pm_info, offset, &val);
+	zynqmp_pm_sec_mask_write_reg(sysmon->pm_info, offset, GENMASK(31, 0),
+				     (val & ~mask) | (mask & data));
+}
+
+static struct sysmon_ops secure_access = {
+	.read_reg = sysmon_secure_read_reg,
+	.write_reg = sysmon_secure_write_reg,
+	.update_reg = sysmon_secure_update_reg,
+};
+
+static void sysmon_read_reg(struct sysmon *sysmon, u32 offset, u32 *data)
+{
+	sysmon->ops->read_reg(sysmon, offset, data);
+}
+
+static void sysmon_write_reg(struct sysmon *sysmon, u32 offset, u32 data)
+{
+	sysmon->ops->write_reg(sysmon, offset, data);
+}
+
+static void sysmon_update_reg(struct sysmon *sysmon, u32 offset, u32 mask, u32 data)
+{
+	sysmon->ops->update_reg(sysmon, offset, mask, data);
+}
+
+static u32 sysmon_temp_offset(int address)
+{
+	switch (address) {
+	case TEMP_MAX:
+		return SYSMON_TEMP_MAX;
+	case TEMP_MIN:
+		return SYSMON_TEMP_MIN;
+	case TEMP_MAX_MAX:
+		return SYSMON_TEMP_MAX_MAX;
+	case TEMP_MIN_MIN:
+		return SYSMON_TEMP_MIN_MIN;
+	case TEMP_HBM:
+		return SYSMON_TEMP_HBM;
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static u32 sysmon_temp_thresh_offset(int address, enum iio_event_direction dir)
+{
+	switch (address) {
+	case TEMP_EVENT:
+		return (dir == IIO_EV_DIR_RISING) ? SYSMON_TEMP_TH_UP :
+						    SYSMON_TEMP_TH_LOW;
+	case OT_EVENT:
+		return (dir == IIO_EV_DIR_RISING) ? SYSMON_OT_TH_UP :
+						    SYSMON_OT_TH_LOW;
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static u32 sysmon_supply_offset(int address)
+{
+	return (address * 4) + SYSMON_SUPPLY_BASE;
+}
+
+static u32 sysmon_supply_thresh_offset(int address,
+				       enum iio_event_direction dir)
+{
+	if (dir == IIO_EV_DIR_RISING)
+		return (address * 4) + SYSMON_SUPPLY_TH_UP;
+	else if (dir == IIO_EV_DIR_FALLING)
+		return (address * 4) + SYSMON_SUPPLY_TH_LOW;
+
+	return -EINVAL;
+}
+
+/**
+ * sysmon_hbm_to_celsius() - The raw register value to degrees C.
+ * @raw_data: Raw register value
+ * @val: The numerator of the fraction needed by IIO_VAL_PROCESSED
+ * @val2: Denominator of the fraction needed by IIO_VAL_PROCESSED
+ *
+ * The function returns a fraction which returns celsius
+ */
+static void sysmon_hbm_to_celsius(int raw_data, int *val, int *val2)
+{
+	*val = (raw_data >> SYSMON_HBM_TEMP_SHIFT) & SYSMON_HBM_TEMP_MASK;
+	*val2 = SYSMON_HBM_FRACTIONAL_DENOM;
+}
+
+/**
+ * sysmon_q8p7_to_celsius() - converts fixed point Q8.7 format to a fraction.
+ * @raw_data: Raw ADC value
+ * @val: The numerator of the fraction needed by IIO_VAL_PROCESSED
+ * @val2: Denominator of the fraction needed by IIO_VAL_PROCESSED
+ *
+ * The function returns a fraction which returns celsius
+ */
+static void sysmon_q8p7_to_celsius(int raw_data, int *val, int *val2)
+{
+	*val = (raw_data & 0x8000) ? -(twoscomp(raw_data)) : raw_data;
+	*val2 = SYSMON_FRACTIONAL_DENOM;
+}
+
+/**
+ * sysmon_celsius_to_q8p7() - converts value from IIO Framework to ADC Raw data
+ * @raw_data: Raw ADC value
+ * @val: The numerator of the fraction provided by the IIO Framework
+ * @val2: Denominator of the fraction provided by the IIO Framework
+ *
+ * The function takes in exponent and mantissa as val and val2 respectively
+ * of temperature value in Deg Celsius and returns raw adc value for the
+ * given temperature.
+ */
+static void sysmon_celsius_to_q8p7(u32 *raw_data, int val, int val2)
+{
+	int scale = 1 << 7;
+
+	/* The value is scaled by 10^6 in the IIO framework
+	 * dividing by 1000 twice to avoid overflow
+	 */
+	val2 = val2 / 1000;
+	*raw_data = (val * scale) + ((val2 * scale) / 1000);
+}
+
+static void sysmon_supply_rawtoprocessed(int raw_data, int *val, int *val2)
+{
+	int mantissa, format, exponent;
+
+	mantissa = raw_data & SYSMON_MANTISSA_MASK;
+	exponent = (raw_data & SYSMON_MODE_MASK) >> SYSMON_MODE_SHIFT;
+	format = (raw_data & SYSMON_FMT_MASK) >> SYSMON_FMT_SHIFT;
+
+	*val2 = 1 << (16 - exponent);
+	*val = mantissa;
+	if (format && (mantissa >> SYSMON_MANTISSA_SIGN_SHIFT))
+		*val = (~(mantissa) & SYSMON_MANTISSA_MASK) * -1;
+}
+
+static void sysmon_supply_processedtoraw(int val, int val2, u32 reg_val,
+					 u32 *raw_data)
+{
+	int exponent = (reg_val & SYSMON_MODE_MASK) >> SYSMON_MODE_SHIFT;
+	int format = (reg_val & SYSMON_FMT_MASK) >> SYSMON_FMT_SHIFT;
+	int scale = 1 << (16 - exponent);
+	int tmp;
+
+	/**
+	 * The value is scaled by 10^6 in the IIO framework
+	 * dividing by 1000 twice to avoid overflow
+	 */
+	val2 = val2 / 1000;
+	tmp = (val * scale) + ((val2 * scale) / 1000);
+
+	/* Set out of bound values to saturation levels */
+	if (format) {
+		if (tmp > SYSMON_UPPER_SATURATION_SIGNED)
+			tmp = 0x7fff;
+		else if (tmp < SYSMON_LOWER_SATURATION_SIGNED)
+			tmp = 0x8000;
+
+	} else {
+		if (tmp > SYSMON_UPPER_SATURATION)
+			tmp = 0xffff;
+		else if (tmp < SYSMON_LOWER_SATURATION)
+			tmp = 0x0000;
+	}
+
+	*raw_data = tmp & 0xffff;
+}
+
+/**
+ * sysmon_find_extreme_temp() - Finds extreme temperature
+ * value read from each device.
+ * @offset: Register offset address of temperature channels
+ *
+ * The function takes offset address of temperature channels
+ * returns extreme value (highest/lowest) of that channel
+ *
+ * @return: - The highest/lowest temperature found from
+ * current or historic min/max temperature of all devices.
+ */
+static int sysmon_find_extreme_temp(int offset)
+{
+	struct sysmon *sysmon;
+	u32 regval;
+	u32 extreme_val = SYSMON_LOWER_SATURATION_SIGNED;
+	bool is_min_channel = false, skip_hbm = true;
+
+	if (offset == SYSMON_TEMP_MIN || offset == SYSMON_TEMP_MIN_MIN) {
+		is_min_channel = true;
+		extreme_val = SYSMON_UPPER_SATURATION_SIGNED;
+	} else if (offset == SYSMON_TEMP_HBM) {
+		skip_hbm = false;
+	}
+
+	list_for_each_entry(sysmon, &sysmon_list_head, list) {
+		if (skip_hbm && sysmon->hbm_slr)
+			continue;
+		if (!skip_hbm && !sysmon->hbm_slr)
+			continue;
+		sysmon_read_reg(sysmon, offset, &regval);
+		if (sysmon->hbm_slr)
+			return regval;
+
+		if (!is_min_channel) {
+			/* Find the highest value */
+			if (compare(regval, extreme_val))
+				extreme_val = regval;
+		} else {
+			/* Find the lowest value */
+			if (compare(extreme_val, regval))
+				extreme_val = regval;
+		}
+	}
+
+	return extreme_val;
+}
+
+static int sysmon_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan, int *val,
+			   int *val2, long mask)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 offset, regval;
+	u32 ret = -EINVAL;
+
+	mutex_lock(&sysmon->mutex);
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		switch (chan->type) {
+		case IIO_TEMP:
+			offset = sysmon_temp_offset(chan->address);
+			*val = sysmon_find_extreme_temp(offset);
+			*val2 = 0;
+			ret = IIO_VAL_INT;
+			break;
+
+		case IIO_VOLTAGE:
+			offset = sysmon_supply_offset(chan->address);
+			sysmon_read_reg(sysmon, offset, &regval);
+			*val = (int)regval;
+			*val2 = 0;
+			ret = IIO_VAL_INT;
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	case IIO_CHAN_INFO_PROCESSED:
+		switch (chan->type) {
+		case IIO_TEMP:
+			/* In Deg C */
+			offset = sysmon_temp_offset(chan->address);
+			regval = sysmon_find_extreme_temp(offset);
+			if (!sysmon->hbm_slr)
+				sysmon_q8p7_to_celsius(regval, val, val2);
+			else
+				sysmon_hbm_to_celsius(regval, val, val2);
+
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+
+		case IIO_VOLTAGE:
+			/* In Volts */
+			offset = sysmon_supply_offset(chan->address);
+			sysmon_read_reg(sysmon, offset, &regval);
+			sysmon_supply_rawtoprocessed(regval, val, val2);
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+
+static int sysmon_get_event_mask(unsigned long address)
+{
+	if (address == TEMP_EVENT)
+		return BIT(SYSMON_BIT_TEMP);
+	else if (address == OT_EVENT)
+		return BIT(SYSMON_BIT_OT);
+
+	/* return supply */
+	return BIT(address / 32);
+}
+
+static int sysmon_read_alarm_config(struct sysmon *sysmon,
+				    unsigned long address)
+{
+	u32 reg_val;
+	u32 alarm_reg_num = ALARM_REG(address);
+	u32 shift = ALARM_SHIFT(address);
+	u32 offset = SYSMON_ALARM_REG + (4 * alarm_reg_num);
+
+	sysmon_read_reg(sysmon, offset, &reg_val);
+
+	return reg_val & BIT(shift);
+}
+
+static void sysmon_write_alarm_config(struct sysmon *sysmon,
+				      unsigned long address, u32 val)
+{
+	u32 alarm_reg_num = ALARM_REG(address);
+	u32 shift = ALARM_SHIFT(address);
+	u32 offset = SYSMON_ALARM_REG + (4 * alarm_reg_num);
+
+	sysmon_update_reg(sysmon, offset, BIT(shift), (val << shift));
+}
+
+static int sysmon_read_event_config(struct iio_dev *indio_dev,
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 config_value, imr;
+	u32 alarm_event_mask = sysmon_get_event_mask(chan->address);
+
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+
+	/* Getting the unmasked interrupts */
+	imr = ~imr;
+
+	if (chan->type == IIO_VOLTAGE) {
+		config_value = sysmon_read_alarm_config(sysmon, chan->address);
+
+		return (config_value && (imr & alarm_event_mask));
+	}
+
+	return (imr & sysmon_get_event_mask(chan->address)) ? 1 : 0;
+}
+
+static int sysmon_write_event_config(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan,
+				     enum iio_event_type type,
+				     enum iio_event_direction dir, int state)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 alarm_reg_num = ALARM_REG(chan->address);
+	u32 offset = SYSMON_ALARM_REG + (4 * alarm_reg_num);
+	u32 shift = ALARM_SHIFT(chan->address);
+	u32 ier = sysmon_get_event_mask(chan->address);
+	u32 alarm_config;
+	unsigned long flags;
+
+	mutex_lock(&sysmon->mutex);
+	spin_lock_irqsave(&sysmon->lock, flags);
+
+	if (chan->type == IIO_VOLTAGE) {
+		sysmon_write_alarm_config(sysmon, chan->address, state);
+
+		sysmon_read_reg(sysmon, offset, &alarm_config);
+
+		if (alarm_config & BIT(shift))
+			sysmon_write_reg(sysmon, SYSMON_IER, ier);
+		else
+			sysmon_write_reg(sysmon, SYSMON_IDR, ier);
+	} else if (chan->type == IIO_TEMP) {
+		if (state) {
+			sysmon_write_reg(sysmon, SYSMON_IER, ier);
+			sysmon->temp_mask &= ~ier;
+		} else {
+			sysmon_write_reg(sysmon, SYSMON_IDR, ier);
+			sysmon->temp_mask |= ier;
+		}
+	}
+
+	spin_unlock_irqrestore(&sysmon->lock, flags);
+	mutex_unlock(&sysmon->mutex);
+
+	return 0;
+}
+
+static int sysmon_read_event_value(struct iio_dev *indio_dev,
+				   const struct iio_chan_spec *chan,
+				   enum iio_event_type type,
+				   enum iio_event_direction dir,
+				   enum iio_event_info info, int *val,
+				   int *val2)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 offset, reg_val;
+	u32 mask, shift;
+	u32 ret = -EINVAL;
+
+	mutex_lock(&sysmon->mutex);
+	if (chan->type == IIO_TEMP) {
+		if (info == IIO_EV_INFO_VALUE) {
+			offset = sysmon_temp_thresh_offset(chan->address, dir);
+			sysmon_read_reg(sysmon, offset, &reg_val);
+			sysmon_q8p7_to_celsius(reg_val, val, val2);
+			ret = IIO_VAL_FRACTIONAL;
+		} else if (info == IIO_EV_INFO_HYSTERESIS) {
+			mask = (chan->address == OT_EVENT) ? 0x1 : 0x2;
+			shift = mask - 1;
+			sysmon_read_reg(sysmon, SYSMON_TEMP_EV_CFG, &reg_val);
+			*val = (reg_val & mask) >> shift;
+			*val2 = 0;
+			ret = IIO_VAL_INT;
+		}
+	} else if (chan->type == IIO_VOLTAGE) {
+		offset = sysmon_supply_thresh_offset(chan->address, dir);
+		sysmon_read_reg(sysmon, offset, &reg_val);
+		sysmon_supply_rawtoprocessed(reg_val, val, val2);
+		ret = IIO_VAL_FRACTIONAL;
+	}
+
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+
+static int sysmon_write_event_value(struct iio_dev *indio_dev,
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir,
+				    enum iio_event_info info, int val, int val2)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 offset, raw_val, reg_val;
+	u32 mask, shift;
+
+	mutex_lock(&sysmon->mutex);
+	if (chan->type == IIO_TEMP) {
+		if (info == IIO_EV_INFO_VALUE) {
+			offset = sysmon_temp_thresh_offset(chan->address, dir);
+			sysmon_celsius_to_q8p7(&reg_val, val, val2);
+			sysmon_write_reg(sysmon, offset, reg_val);
+		} else if (info == IIO_EV_INFO_HYSTERESIS) {
+			/* calculating the mask value for OT and TEMP Alarms */
+			mask = (chan->address == OT_EVENT) ? 1 : 2;
+			shift = mask - 1;
+			sysmon_update_reg(sysmon, SYSMON_TEMP_EV_CFG, mask,
+					  (val << shift));
+		}
+	} else if (chan->type == IIO_VOLTAGE) {
+		offset = sysmon_supply_thresh_offset(chan->address, dir);
+		sysmon_read_reg(sysmon, offset, &reg_val);
+		sysmon_supply_processedtoraw(val, val2, reg_val, &raw_val);
+		sysmon_write_reg(sysmon, offset, raw_val);
+	}
+
+	mutex_unlock(&sysmon->mutex);
+	return 0;
+}
+
+static const struct iio_info iio_dev_info = {
+	.read_raw = sysmon_read_raw,
+	.read_event_config = sysmon_read_event_config,
+	.write_event_config = sysmon_write_event_config,
+	.read_event_value = sysmon_read_event_value,
+	.write_event_value = sysmon_write_event_value,
+};
+
+/* sysmon instance for in kernel exported functions */
+static struct sysmon *g_sysmon;
+
+/**
+ * sysmon_register_temp_ops - register temperature based event handler for a
+ *			      given region.
+ * @cb: callback function pointer.
+ * @data: private data to be passed to the callback.
+ * @region_id: id of the region for which the callback is to be set.
+ * @return: 0 for success and negative number in case of failure.
+ */
+int sysmon_register_temp_ops(void (*cb)(void *data, struct regional_node *node),
+			     void *data, enum sysmon_region region_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	struct region_info *region;
+	int ret = 0, found = 0;
+
+	if (!cb || !sysmon)
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&sysmon->mutex);
+	if (ret) {
+		dev_err(sysmon->dev, "Failed to acquire a lock. Process was interrupted by fatal signals");
+		return ret;
+	}
+
+	if (list_empty(&sysmon->region_list)) {
+		dev_err(sysmon->dev, "Failed to set a callback. HW node info missing in the device tree/ Not supported for this device");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		if (region->id == region_id) {
+			found = 1;
+			if (region->cb) {
+				dev_err(sysmon->dev, "Error callback already set. Unregister the existing callback to set a new one.");
+				ret = -EINVAL;
+				goto exit;
+			}
+			region->cb = cb;
+			region->data = data;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(sysmon->dev, "Error invalid region. Please select the correct region");
+		ret = -EINVAL;
+	}
+
+exit:
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+EXPORT_SYMBOL(sysmon_register_temp_ops);
+
+/**
+ * sysmon_unregister_temp_ops - Unregister the callback for temperature
+ *				notification.
+ * @region_id: id of the region for which the callback is to be set.
+ * @return: 0 for success and negative number in case of failure.
+ */
+int sysmon_unregister_temp_ops(enum sysmon_region region_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	struct region_info *region;
+	int ret = 0, found = 0;
+
+	if (!sysmon)
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&sysmon->mutex);
+	if (ret) {
+		dev_err(sysmon->dev, "Failed to acquire a lock. Process was interrupted by fatal signals");
+		return ret;
+	}
+
+	if (list_empty(&sysmon->region_list)) {
+		dev_err(sysmon->dev, "Failed to set a callback. HW node info missing in the device tree/ Not supported for this device");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		if (region->id == region_id) {
+			found = 1;
+			region->cb = NULL;
+			region->data = NULL;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(sysmon->dev, "Error no such region. Please select the correct region");
+		ret = -EINVAL;
+	}
+
+exit:
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+EXPORT_SYMBOL(sysmon_unregister_temp_ops);
+
+/**
+ * sysmon_nodes_by_region - returns the nodes list for a particular region.
+ * @region_id: id for the region for which nodes are requested.
+ * @return: Pointer to the linked list or NULL if region is not present.
+ */
+struct list_head *sysmon_nodes_by_region(enum sysmon_region region_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	struct region_info *region;
+
+	if (!sysmon)
+		return NULL;
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		if (region->id == region_id)
+			return &region->node_list;
+	}
+
+	dev_err(sysmon->dev, "Error invalid region. Please select the correct region");
+
+	return NULL;
+}
+EXPORT_SYMBOL(sysmon_nodes_by_region);
+
+/**
+ * sysmon_get_node_value - returns value of the sensor at a node.
+ * @sat_id: id of the node.
+ * @return: -EINVAL if not initialized or returns raw value of the sensor.
+ */
+int sysmon_get_node_value(int sat_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	u32 raw;
+
+	if (!sysmon)
+		return -EINVAL;
+
+	sysmon_read_reg(sysmon, SYSMON_NODE_OFFSET, &raw);
+
+	return raw;
+}
+EXPORT_SYMBOL(sysmon_get_node_value);
+
+static void sysmon_push_event(struct iio_dev *indio_dev, u32 address)
+{
+	u32 i;
+	const struct iio_chan_spec *chan;
+
+	for (i = 0; i < indio_dev->num_channels; i++) {
+		if (indio_dev->channels[i].address == address) {
+			chan = &indio_dev->channels[i];
+			iio_push_event(indio_dev,
+				       IIO_UNMOD_EVENT_CODE(chan->type,
+							    chan->channel,
+							    IIO_EV_TYPE_THRESH,
+							    IIO_EV_DIR_EITHER),
+				       iio_get_time_ns(indio_dev));
+		}
+	}
+}
+
+static void sysmon_region_event_handler(struct sysmon *sysmon)
+{
+	struct region_info *region;
+	struct regional_node *node, *eventnode;
+	u32 regval, event = 0;
+	u16 thresh_up, val;
+
+	sysmon_read_reg(sysmon, SYSMON_TEMP_TH_UP, &regval);
+	thresh_up = (u16)regval;
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		list_for_each_entry(node, &region->node_list,
+				    regional_node_list) {
+			val = sysmon_get_node_value(node->sat_id);
+
+			/* Find the highest value */
+			if (compare(val, thresh_up)) {
+				eventnode = node;
+				eventnode->temp = val;
+				thresh_up = val;
+				event = 1;
+			}
+		}
+		if (event && region->cb)
+			region->cb(region->data, eventnode);
+	}
+}
+
+static void sysmon_handle_event(struct iio_dev *indio_dev, u32 event)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	unsigned long alarm_flag_reg;
+	u32 address, bit, reg_val;
+	u32 alarm_flag_offset = SYSMON_ALARM_FLAG + (event * 4);
+	u32 alarm_reg_offset = SYSMON_ALARM_REG + (event * 4);
+
+	switch (event) {
+	case SYSMON_BIT_TEMP:
+		address = TEMP_EVENT;
+		sysmon_push_event(indio_dev, address);
+		sysmon_write_reg(sysmon, SYSMON_IDR, BIT(SYSMON_BIT_TEMP));
+		sysmon->masked_temp |= BIT(SYSMON_BIT_TEMP);
+		sysmon_region_event_handler(sysmon);
+		break;
+
+	case SYSMON_BIT_OT:
+		address = OT_EVENT;
+		sysmon_push_event(indio_dev, address);
+		sysmon_write_reg(sysmon, SYSMON_IDR, BIT(SYSMON_BIT_OT));
+		sysmon->masked_temp |= BIT(SYSMON_BIT_OT);
+		sysmon_region_event_handler(sysmon);
+		break;
+
+	case SYSMON_BIT_ALARM4:
+	case SYSMON_BIT_ALARM3:
+	case SYSMON_BIT_ALARM2:
+	case SYSMON_BIT_ALARM1:
+	case SYSMON_BIT_ALARM0:
+		/* Read enabled alarms */
+		sysmon_read_reg(sysmon, alarm_flag_offset, &reg_val);
+		alarm_flag_reg = (unsigned long)reg_val;
+
+		for_each_set_bit(bit, &alarm_flag_reg, 32) {
+			address = bit + (32 * event);
+			sysmon_push_event(indio_dev, address);
+			/* disable alarm */
+			sysmon_update_reg(sysmon, alarm_reg_offset, BIT(bit),
+					  0);
+		}
+		/* clear alarms */
+		sysmon_write_reg(sysmon, alarm_flag_offset, alarm_flag_reg);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void sysmon_handle_events(struct iio_dev *indio_dev,
+				 unsigned long events)
+{
+	unsigned int bit;
+
+	for_each_set_bit(bit, &events, SYSMON_NO_OF_EVENTS)
+		sysmon_handle_event(indio_dev, bit);
+}
+
+static void sysmon_unmask_temp(struct sysmon *sysmon, unsigned int isr)
+{
+	unsigned int unmask, status;
+
+	status = isr & SYSMON_TEMP_MASK;
+
+	/* clear bits that are not active any more */
+	unmask = (sysmon->masked_temp ^ status) & sysmon->masked_temp;
+	sysmon->masked_temp &= status;
+
+	/* clear status of disabled alarm */
+	unmask &= ~sysmon->temp_mask;
+
+	sysmon_write_reg(sysmon, SYSMON_IER, unmask);
+}
+
+/*
+ * The Versal threshold interrupts are level sensitive. Since we can't make the
+ * threshold condition go way from within the interrupt handler, this means as
+ * soon as a threshold condition is present we would enter the interrupt handler
+ * again and again. To work around this we mask all active thresholds interrupts
+ * in the interrupt handler and start a timer. In this timer we poll the
+ * interrupt status and only if the interrupt is inactive we unmask it again.
+ */
+static void sysmon_unmask_worker(struct work_struct *work)
+{
+	struct sysmon *sysmon = container_of(work, struct sysmon,
+					     sysmon_unmask_work.work);
+	unsigned int isr;
+
+	spin_lock_irq(&sysmon->lock);
+
+	/* Read the current interrupt status */
+	sysmon_read_reg(sysmon, SYSMON_ISR, &isr);
+
+	/* Clear interrupts */
+	sysmon_write_reg(sysmon, SYSMON_ISR, isr);
+
+	sysmon_unmask_temp(sysmon, isr);
+
+	spin_unlock_irq(&sysmon->lock);
+
+	/* if still pending some alarm re-trigger the timer */
+	if (sysmon->masked_temp)
+		schedule_delayed_work(&sysmon->sysmon_unmask_work,
+				      msecs_to_jiffies(SYSMON_UNMASK_WORK_DELAY_MS));
+	else
+		/*
+		 * Reset the temp_max_max and temp_min_min values to reset the
+		 * previously reached high/low values during an alarm.
+		 * This will enable the user to see the high/low values attained
+		 * during an event
+		 */
+		sysmon_write_reg(sysmon, SYSMON_STATUS_RESET, 1);
+}
+
+static irqreturn_t sysmon_iio_irq(int irq, void *data)
+{
+	u32 isr, imr;
+	struct iio_dev *indio_dev = data;
+	struct sysmon *sysmon = iio_priv(indio_dev);
+
+	spin_lock(&sysmon->lock);
+
+	sysmon_read_reg(sysmon, SYSMON_ISR, &isr);
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+
+	/* only process alarm that are not masked */
+	isr &= ~imr;
+
+	/* clear interrupt */
+	sysmon_write_reg(sysmon, SYSMON_ISR, isr);
+
+	if (isr) {
+		sysmon_handle_events(indio_dev, isr);
+
+		schedule_delayed_work(&sysmon->sysmon_unmask_work,
+				      msecs_to_jiffies(SYSMON_UNMASK_WORK_DELAY_MS));
+	}
+
+	spin_unlock(&sysmon->lock);
+
+	return IRQ_HANDLED;
+}
+
+static void sysmon_events_worker(struct work_struct *work)
+{
+	u32 isr, imr;
+	struct sysmon *sysmon = container_of(work, struct sysmon,
+					     sysmon_events_work.work);
+
+	spin_lock(&sysmon->lock);
+
+	sysmon_read_reg(sysmon, SYSMON_ISR, &isr);
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+
+	/* only process alarm that are not masked */
+	isr &= ~imr;
+
+	/* clear interrupt */
+	sysmon_write_reg(sysmon, SYSMON_ISR, isr);
+
+	if (isr) {
+		sysmon_handle_events(sysmon->indio_dev, isr);
+		schedule_delayed_work(&sysmon->sysmon_unmask_work,
+				      msecs_to_jiffies(SYSMON_UNMASK_WORK_DELAY_MS));
+	}
+	spin_unlock(&sysmon->lock);
+
+	schedule_delayed_work(&sysmon->sysmon_events_work,
+			      msecs_to_jiffies(SYSMON_EVENT_WORK_DELAY_MS));
+}
+
+static int get_hw_node_properties(struct platform_device *pdev,
+				  struct list_head *region_list)
+{
+	struct region_info *region = NULL;
+	struct regional_node *nodes;
+	struct device_node *np = pdev->dev.of_node;
+	int size;
+	u32 id, satid, x, y, i, offset, prev = 0;
+
+	/* get hw-node-info */
+	if (!of_get_property(np, "hw-node", &size))
+		return 0;
+
+	if (size % 16) {
+		dev_info(&pdev->dev, "HW-Node properties not correct");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < (size / 16); i++) {
+		offset = i * 4;
+		of_property_read_u32_index(np, "hw-node", offset, &id);
+		of_property_read_u32_index(np, "hw-node", offset + 1, &satid);
+		of_property_read_u32_index(np, "hw-node", offset + 2, &x);
+		of_property_read_u32_index(np, "hw-node", offset + 3, &y);
+
+		if (list_empty(region_list) || prev != id) {
+			region = devm_kzalloc(&pdev->dev, sizeof(*region),
+					      GFP_KERNEL);
+			if (!region)
+				return -ENOMEM;
+
+			region->id = (enum sysmon_region)id;
+			INIT_LIST_HEAD(&region->node_list);
+			list_add(&region->list, region_list);
+		}
+
+		prev = id;
+		nodes = devm_kzalloc(&pdev->dev, sizeof(*nodes), GFP_KERNEL);
+		if (!nodes)
+			return -ENOMEM;
+		nodes->sat_id = satid;
+		nodes->x = x;
+		nodes->y = y;
+		list_add(&nodes->regional_node_list, &region->node_list);
+	}
+
+	return 0;
+}
+
+static int sysmon_parse_dt(struct iio_dev *indio_dev,
+			   struct platform_device *pdev)
+{
+	struct sysmon *sysmon;
+	struct iio_chan_spec *sysmon_channels;
+	struct device_node *child_node = NULL, *np = pdev->dev.of_node;
+	int ret, i = 0;
+	u8 num_supply_chan = 0;
+	u32 reg = 0, num_temp_chan = 0;
+	const char *name;
+	u32 chan_size = sizeof(struct iio_chan_spec);
+	u32 temp_chan_size;
+
+	sysmon = iio_priv(indio_dev);
+	ret = of_property_read_u8(np, "xlnx,numchannels", &num_supply_chan);
+	if (ret < 0)
+		return ret;
+
+	INIT_LIST_HEAD(&sysmon->region_list);
+
+	if (sysmon->irq > 0)
+		get_hw_node_properties(pdev, &sysmon->region_list);
+
+	/* Initialize buffer for channel specification */
+	if (sysmon->master_slr) {
+		temp_chan_size = (sizeof(temp_channels) + sizeof(temp_events));
+		num_temp_chan = ARRAY_SIZE(temp_channels);
+	} else if (sysmon->hbm_slr) {
+		temp_chan_size = (sizeof(temp_hbm_channels));
+		num_temp_chan = ARRAY_SIZE(temp_hbm_channels);
+	} else {
+		temp_chan_size = sizeof(temp_events);
+		num_temp_chan = 0;
+	}
+
+	sysmon_channels = devm_kzalloc(&pdev->dev,
+				       (chan_size * num_supply_chan) +
+				       temp_chan_size, GFP_KERNEL);
+
+	for_each_child_of_node(np, child_node) {
+		ret = of_property_read_u32(child_node, "reg", &reg);
+		if (ret < 0) {
+			of_node_put(child_node);
+			return ret;
+		}
+
+		ret = of_property_read_string(child_node, "xlnx,name", &name);
+		if (ret < 0) {
+			of_node_put(child_node);
+			return ret;
+		}
+
+		sysmon_channels[i].type = IIO_VOLTAGE;
+		sysmon_channels[i].indexed = 1;
+		sysmon_channels[i].address = reg;
+		sysmon_channels[i].channel = reg;
+		sysmon_channels[i].info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_PROCESSED);
+
+		sysmon_channels[i].event_spec = sysmon_supply_events;
+		sysmon_channels[i].num_event_specs = ARRAY_SIZE(sysmon_supply_events);
+
+		sysmon_channels[i].scan_index = i;
+		sysmon_channels[i].scan_type.realbits = 19;
+		sysmon_channels[i].scan_type.storagebits = 32;
+
+		sysmon_channels[i].scan_type.endianness = IIO_CPU;
+		sysmon_channels[i].extend_name = name;
+
+		if (of_property_read_bool(child_node, "xlnx,bipolar"))
+			sysmon_channels[i].scan_type.sign = 's';
+		else
+			sysmon_channels[i].scan_type.sign = 'u';
+
+		i++;
+	}
+
+	/* Append static temperature channels to the channel list */
+	indio_dev->num_channels = num_supply_chan;
+
+	if (sysmon->master_slr) {
+		memcpy(sysmon_channels + num_supply_chan, temp_channels,
+		       sizeof(temp_channels));
+		indio_dev->num_channels += ARRAY_SIZE(temp_channels);
+	}
+
+	if (sysmon->hbm_slr) {
+		memcpy(sysmon_channels + num_supply_chan, temp_hbm_channels,
+		       sizeof(temp_hbm_channels));
+		indio_dev->num_channels += num_temp_chan;
+	} else {
+		memcpy(sysmon_channels + num_supply_chan + num_temp_chan,
+		       temp_events, sizeof(temp_events));
+		indio_dev->num_channels += ARRAY_SIZE(temp_events);
+	}
+
+	indio_dev->channels = sysmon_channels;
+
+	return 0;
+}
+
+static void sysmon_init_interrupt(struct sysmon *sysmon)
+{
+	u32 imr;
+
+	/* Read default Interrupt Mask */
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+	sysmon->temp_mask = imr & SYSMON_TEMP_MASK;
+}
+
+static int sysmon_probe(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev;
+	struct sysmon *sysmon, *temp_sysmon;
+	struct resource *mem;
+	bool exist = false;
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*sysmon));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	sysmon = iio_priv(indio_dev);
+
+	sysmon->dev = &pdev->dev;
+	sysmon->indio_dev = indio_dev;
+
+	mutex_init(&sysmon->mutex);
+	spin_lock_init(&sysmon->lock);
+
+	indio_dev->dev.parent = &pdev->dev;
+	indio_dev->dev.of_node = pdev->dev.of_node;
+	indio_dev->name = "xlnx,versal-sysmon";
+	indio_dev->info = &iio_dev_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sysmon->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(sysmon->base))
+		return PTR_ERR(sysmon->base);
+
+	if (secure_mode) {
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "xlnx,nodeid", &sysmon->pm_info);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to read SLR node id\n");
+			return ret;
+		}
+
+		ret = zynqmp_pm_feature(PM_IOCTL);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Feature check failed with %d\n", ret);
+			return ret;
+		}
+		if ((ret & FIRMWARE_VERSION_MASK) < PM_API_VERSION_2) {
+			dev_err(&pdev->dev, "IOCTL firmware version error. Expected: v%d - Found: v%d\n",
+				PM_API_VERSION_2, ret & FIRMWARE_VERSION_MASK);
+			return -EOPNOTSUPP;
+		}
+		sysmon->ops = &secure_access;
+	} else {
+		sysmon->ops = &direct_access;
+	}
+
+	INIT_LIST_HEAD(&sysmon->list);
+
+	mutex_lock(&sysmon->mutex);
+	if (list_empty(&sysmon_list_head)) {
+		sysmon->master_slr = true;
+	} else {
+		list_for_each_entry(temp_sysmon, &sysmon_list_head, list) {
+			if (temp_sysmon->master_slr)
+				exist = true;
+		}
+		if (exist)
+			sysmon->master_slr = false;
+		else
+			sysmon->master_slr = true;
+	}
+	mutex_unlock(&sysmon->mutex);
+
+	sysmon->hbm_slr = of_property_read_bool(pdev->dev.of_node, "xlnx,hbm");
+
+	if (!sysmon->hbm_slr) {
+		sysmon_write_reg(sysmon, SYSMON_NPI_LOCK, NPI_UNLOCK);
+		sysmon_write_reg(sysmon, SYSMON_IDR, 0xffffffff);
+		sysmon_write_reg(sysmon, SYSMON_ISR, 0xffffffff);
+
+		sysmon->irq = platform_get_irq_optional(pdev, 0);
+	}
+
+	ret = sysmon_parse_dt(indio_dev, pdev);
+	if (ret)
+		return ret;
+
+	INIT_DELAYED_WORK(&sysmon->sysmon_unmask_work,
+			  sysmon_unmask_worker);
+	if (!sysmon->hbm_slr) {
+		sysmon_init_interrupt(sysmon);
+
+		if (sysmon->irq == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		if (sysmon->irq > 0) {
+			g_sysmon = sysmon;
+			ret = devm_request_irq(&pdev->dev, sysmon->irq, &sysmon_iio_irq,
+					       0, "sysmon-irq", indio_dev);
+			if (ret < 0)
+				return ret;
+		} else {
+			INIT_DELAYED_WORK(&sysmon->sysmon_events_work,
+					  sysmon_events_worker);
+			schedule_delayed_work(&sysmon->sysmon_events_work,
+					      msecs_to_jiffies(SYSMON_EVENT_WORK_DELAY_MS));
+		}
+	}
+
+	platform_set_drvdata(pdev, indio_dev);
+
+	ret = iio_device_register(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&sysmon->mutex);
+	list_add(&sysmon->list, &sysmon_list_head);
+	mutex_unlock(&sysmon->mutex);
+
+	dev_info(&pdev->dev, "Successfully registered Versal Sysmon");
+
+	return 0;
+}
+
+static int sysmon_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct sysmon *sysmon = iio_priv(indio_dev);
+
+	/* cancel SSIT based events */
+	if (sysmon->irq < 0)
+		cancel_delayed_work_sync(&sysmon->sysmon_events_work);
+
+	cancel_delayed_work_sync(&sysmon->sysmon_unmask_work);
+
+	mutex_lock(&sysmon->mutex);
+	list_del(&sysmon->list);
+	mutex_unlock(&sysmon->mutex);
+	/* Unregister the device */
+	iio_device_unregister(indio_dev);
+	return 0;
+}
+
+static int sysmon_resume(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct sysmon *sysmon = iio_priv(indio_dev);
+
+	sysmon_write_reg(sysmon, SYSMON_NPI_LOCK, NPI_UNLOCK);
+
+	return 0;
+}
+
+static const struct of_device_id sysmon_of_match_table[] = {
+	{ .compatible = "xlnx,versal-sysmon" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sysmon_of_match_table);
+
+static struct platform_driver sysmon_driver = {
+	.probe = sysmon_probe,
+	.remove = sysmon_remove,
+	.resume = sysmon_resume,
+	.driver = {
+		.name = "sysmon",
+		.of_match_table = sysmon_of_match_table,
+	},
+};
+module_platform_driver(sysmon_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Xilinx Versal SysMon Driver");
+MODULE_AUTHOR("Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>");
--- /dev/null
+++ linux-xlnx-2023.1/drivers/iio/adc/versal-sysmon.h	2023-07-05 08:33:22.021478500 +0900
@@ -0,0 +1,194 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx SYSMON for Versal
+ *
+ * Copyright (C) 2019 - 2022, Xilinx, Inc.
+ * Copyright (C) 2022 - 2023, Advanced Micro Devices, Inc.
+ *
+ * Description:
+ * This driver is developed for SYSMON on Versal. The driver supports INDIO Mode
+ * and supports voltage and temperature monitoring via IIO sysfs interface.
+ */
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/adc/versal-sysmon-events.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+
+/* Channel IDs for Temp Channels */
+/* TEMP_MAX gives the current temperature for Production
+ * silicon.
+ * TEMP_MAX gives the current maximum temperature for ES1
+ * silicon.
+ */
+#define TEMP_MAX	160
+
+/* TEMP_MIN is not applicable for Production silicon.
+ * TEMP_MIN gives the current minimum temperature for ES1 silicon.
+ */
+#define TEMP_MIN	161
+
+#define TEMP_MAX_MAX	162
+#define TEMP_MIN_MIN	163
+#define TEMP_EVENT	164
+#define OT_EVENT	165
+#define TEMP_HBM	166
+
+/* Register Unlock Code */
+#define NPI_UNLOCK	0xF9E8D7C6
+
+/* Register Offsets */
+#define SYSMON_NPI_LOCK		0x000C
+#define SYSMON_ISR		0x0044
+#define SYSMON_TEMP_MASK	0x300
+#define SYSMON_IMR		0x0048
+#define SYSMON_IER		0x004C
+#define SYSMON_IDR		0x0050
+#define SYSMON_ALARM_FLAG	0x1018
+#define SYSMON_TEMP_MAX		0x1030
+#define SYSMON_TEMP_MIN		0x1034
+#define SYSMON_SUPPLY_BASE	0x1040
+#define SYSMON_ALARM_REG	0x1940
+#define SYSMON_TEMP_TH_LOW	0x1970
+#define SYSMON_TEMP_TH_UP	0x1974
+#define SYSMON_OT_TH_LOW	0x1978
+#define SYSMON_OT_TH_UP		0x197C
+#define SYSMON_SUPPLY_TH_LOW	0x1980
+#define SYSMON_SUPPLY_TH_UP	0x1C80
+#define SYSMON_TEMP_MAX_MAX	0x1F90
+#define SYSMON_TEMP_MIN_MIN	0x1F8C
+#define SYSMON_TEMP_HBM	0x0000
+#define SYSMON_TEMP_EV_CFG	0x1F84
+#define SYSMON_NODE_OFFSET	0x1FAC
+#define SYSMON_STATUS_RESET	0x1F94
+
+#define SYSMON_NO_OF_EVENTS	32
+
+/* Supply Voltage Conversion macros */
+#define SYSMON_MANTISSA_MASK		0xFFFF
+#define SYSMON_FMT_MASK			0x10000
+#define SYSMON_FMT_SHIFT		16
+#define SYSMON_MODE_MASK		0x60000
+#define SYSMON_MODE_SHIFT		17
+#define SYSMON_MANTISSA_SIGN_SHIFT	15
+#define SYSMON_UPPER_SATURATION_SIGNED	32767
+#define SYSMON_LOWER_SATURATION_SIGNED	-32768
+#define SYSMON_UPPER_SATURATION		65535
+#define SYSMON_LOWER_SATURATION		0
+
+#define SYSMON_CHAN_TEMP_EVENT(_address, _ext, _events) { \
+	.type = IIO_TEMP, \
+	.indexed = 1, \
+	.address = _address, \
+	.channel = _address, \
+	.event_spec = _events, \
+	.num_event_specs = ARRAY_SIZE(_events), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 15, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	}, \
+	.extend_name = _ext, \
+	}
+
+#define SYSMON_CHAN_TEMP(_address, _ext) { \
+	.type = IIO_TEMP, \
+	.indexed = 1, \
+	.address = _address, \
+	.channel = _address, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_PROCESSED), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 15, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	}, \
+	.extend_name = _ext, \
+}
+
+#define twoscomp(val) ((((val) ^ 0xFFFF) + 1) & 0x0000FFFF)
+#define ALARM_REG(address) ((address) / 32)
+#define ALARM_SHIFT(address) ((address) % 32)
+
+#define compare(val, thresh) (((val) & 0x8000) || ((thresh) & 0x8000) ? \
+			      ((val) < (thresh)) : ((val) > (thresh)))  \
+
+enum sysmon_alarm_bit {
+	SYSMON_BIT_ALARM0 = 0,
+	SYSMON_BIT_ALARM1 = 1,
+	SYSMON_BIT_ALARM2 = 2,
+	SYSMON_BIT_ALARM3 = 3,
+	SYSMON_BIT_ALARM4 = 4,
+	SYSMON_BIT_ALARM5 = 5,
+	SYSMON_BIT_ALARM6 = 6,
+	SYSMON_BIT_ALARM7 = 7,
+	SYSMON_BIT_OT = 8,
+	SYSMON_BIT_TEMP = 9,
+};
+
+/**
+ * struct sysmon - Driver data for Sysmon
+ * @base: physical base address of device
+ * @dev: pointer to device struct
+ * @indio_dev: pointer to the iio device
+ * @mutex: to handle multiple user interaction
+ * @lock: to help manage interrupt registers correctly
+ * @irq: interrupt number of the sysmon
+ * @region_list: list of the regions of sysmon
+ * @list: list of sysmon instances
+ * @masked_temp: currently masked due to alarm
+ * @temp_mask: temperature based interrupt configuration
+ * @sysmon_unmask_work: re-enables event once the event condition disappears
+ * @sysmon_events_work: poll for events on SSIT slices
+ * @ops: read write operations for sysmon registers
+ * @pm_info: plm address of sysmon
+ * @master_slr: to keep master sysmon info
+ * @hbm_slr: flag if HBM slr is present
+ *
+ * This structure contains necessary state for Sysmon driver to operate
+ */
+struct sysmon {
+	void __iomem *base;
+	struct device *dev;
+	struct iio_dev *indio_dev;
+	/* kernel doc above */
+	struct mutex mutex;
+	/* kernel doc above*/
+	spinlock_t lock;
+	int irq;
+	struct list_head region_list;
+	struct list_head list;
+	unsigned int masked_temp;
+	unsigned int temp_mask;
+	struct delayed_work sysmon_unmask_work;
+	struct delayed_work sysmon_events_work;
+	struct sysmon_ops *ops;
+	u32 pm_info;
+	bool master_slr;
+	bool hbm_slr;
+};
+
+struct sysmon_ops {
+	void (*read_reg)(struct sysmon *sysmon, u32 offset, u32 *data);
+	void (*write_reg)(struct sysmon *sysmon, u32 offset, u32 data);
+	void (*update_reg)(struct sysmon *sysmon, u32 offset,
+			   u32 mask, u32 data);
+};
+
+int sysmon_register_temp_ops(void (*cb)(void *data, struct regional_node *node),
+			     void *data, enum sysmon_region region_id);
+int sysmon_unregister_temp_ops(enum sysmon_region region_id);
+struct list_head *sysmon_nodes_by_region(enum sysmon_region region_id);
+int sysmon_get_node_value(int sat_id);
--- linux-6.1.0/drivers/iio/adc/xilinx-ams.c	2023-07-05 08:37:25.118590300 +0900
+++ linux-xlnx-2023.1/drivers/iio/adc/xilinx-ams.c	2023-07-05 08:33:22.021478500 +0900
@@ -161,6 +161,7 @@
 
 #define AMS_TEMP_SCALE			509314
 #define AMS_TEMP_SCALE_DIV_BIT		16
+#define AMS_TEMP_SCALE_DIV		BIT(AMS_TEMP_SCALE_DIV_BIT)
 #define AMS_TEMP_OFFSET			-((280230LL << 16) / 509314)
 
 enum ams_alarm_bit {
@@ -227,6 +228,7 @@
 	.indexed = 1, \
 	.address = (_addr), \
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_PROCESSED) | \
 		BIT(IIO_CHAN_INFO_SCALE) | \
 		BIT(IIO_CHAN_INFO_OFFSET), \
 	.event_spec = ams_temp_events, \
@@ -679,9 +681,20 @@
 			int *val, int *val2, long mask)
 {
 	struct ams *ams = iio_priv(indio_dev);
-	int ret;
+	int ret, regval;
 
 	switch (mask) {
+	case IIO_CHAN_INFO_PROCESSED:
+		mutex_lock(&ams->lock);
+		if (chan->scan_index >= AMS_PS_SEQ_MAX)
+			regval = readl(ams->pl_base + chan->address);
+		else
+			regval = readl(ams->ps_base + chan->address);
+
+		*val = ((regval + AMS_TEMP_OFFSET) * AMS_TEMP_SCALE) / AMS_TEMP_SCALE_DIV;
+		mutex_unlock(&ams->lock);
+		return IIO_VAL_INT;
+
 	case IIO_CHAN_INFO_RAW:
 		mutex_lock(&ams->lock);
 		if (chan->scan_index >= AMS_CTRL_SEQ_BASE) {
@@ -1329,7 +1342,7 @@
 
 	dev_channels = devm_krealloc(dev, ams_channels, dev_size, GFP_KERNEL);
 	if (!dev_channels)
-		ret = -ENOMEM;
+		return -ENOMEM;
 
 	indio_dev->channels = dev_channels;
 	indio_dev->num_channels = num_channels;
--- linux-6.1.0/drivers/iio/imu/adis16400.c	2023-07-05 08:37:25.222862700 +0900
+++ linux-xlnx-2023.1/drivers/iio/imu/adis16400.c	2023-07-05 08:33:22.133857400 +0900
@@ -466,7 +466,7 @@
 
 		dev_info(&indio_dev->dev, "%s: prod_id 0x%04x at CS%d (irq %d)\n",
 			indio_dev->name, prod_id,
-			st->adis.spi->chip_select, st->adis.spi->irq);
+			spi_get_chipselect(st->adis.spi, 0), st->adis.spi->irq);
 	}
 	/* use high spi speed if possible */
 	if (st->variant->flags & ADIS16400_HAS_SLOW_MODE) {
--- /dev/null
+++ linux-xlnx-2023.1/include/linux/iio/adc/versal-sysmon-events.h	2023-07-05 08:33:35.816398200 +0900
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx SYSMON hardware info
+ *
+ * Copyright (C) 2019 - 2021 Xilinx, Inc.
+ *
+ */
+#ifndef _VERSAL_SYSMON_H_
+#define _VERSAL_SYSMON_H_
+
+#include <linux/types.h>
+#include <linux/iio/types.h>
+
+/* Sysmon region ids */
+enum sysmon_region {
+	SYSMON_AIE = 0,
+	SYSMON_PMC = 1,
+	SYSMON_XPIO = 2,
+	SYSMON_VNOC = 3,
+	SYSMON_CC = 4,
+};
+
+/**
+ * struct regional_node - regional node properties
+ * @sat_id: node_id
+ * @x: x co-ordinate of the node
+ * @y: y co-ordinate of the node
+ * @temp: raw sensor value
+ * @regional_node_list: list of nodes in the region
+ */
+struct regional_node {
+	int sat_id;
+	int x;
+	int y;
+	u16 temp;
+	struct list_head regional_node_list;
+};
+
+/**
+ * struct region_info - information about a regions sensors
+ * @id: region id
+ * @cb: callback to be called when there is a region specific event
+ * @data: pointer to the callback data
+ * @node_list: head to the regional_nodes list
+ * @list: list of regions
+ */
+struct region_info {
+	enum sysmon_region id;
+	void (*cb)(void *data, struct regional_node *node);
+	void *data;
+	struct list_head node_list;
+	struct list_head list;
+};
+
+#endif
